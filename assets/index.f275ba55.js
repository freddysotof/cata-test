function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$6 = Symbol.for("react.element"), n$7 = Symbol.for("react.portal"), p$8 = Symbol.for("react.fragment"), q$7 = Symbol.for("react.strict_mode"), r$5 = Symbol.for("react.profiler"), t$7 = Symbol.for("react.provider"), u$5 = Symbol.for("react.context"), v$6 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$4 = Symbol.iterator;
function A$4(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$4 && a2[z$4] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$3 = {};
function E$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B$3;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$3.prototype;
function G$2(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e2 || B$3;
}
var H$3 = G$2.prototype = new F$2();
H$3.constructor = G$2;
C$2(H$3, E$3.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$3 = { key: true, ref: true, __self: true, __source: true };
function M$3(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$6, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$3(a2, b2) {
  return { $$typeof: l$6, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$3(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$6;
}
function escape(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$3 = /\/+/g;
function Q$3(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape("" + a2.key) : b2.toString(36);
}
function R$3(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$6:
          case n$7:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$3(h2, 0) : d2, I$3(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$3, "$&/") + "/"), R$3(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$3(c2) && (c2 = N$3(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$3, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$3(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$3(k2, g2);
      h2 += R$3(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$4(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$3(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$3(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$3(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$2(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$1 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$1, ReactCurrentOwner: K$1 };
react_production_min.Children = { map: S$3, forEach: function(a2, b2, e2) {
  S$3(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$3(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$3(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$8;
react_production_min.Profiler = r$5;
react_production_min.PureComponent = G$2;
react_production_min.StrictMode = q$7;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$6, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$5, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$7, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a2) {
  var b2 = M$3.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$6, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$2 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$1.transition;
  V$1.transition = {};
  try {
    a2();
  } finally {
    V$1.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$2.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$2.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$2.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$2.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$2.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$2.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$2.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$2.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$2.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.2.0";
(function(module) {
  {
    module.exports = react_production_min;
  }
})(react);
const React = /* @__PURE__ */ getDefaultExportFromCjs(react.exports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [react.exports]);
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
(function(module) {
  {
    module.exports = scheduler_production_min;
  }
})(scheduler);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, ca = scheduler.exports;
function p$7(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$5(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$3 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$3[a2] = new v$5(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$3[b2] = new v$5(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$3[a2] = new v$5(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$3[b2] = new v$5(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$3[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$3.xlinkHref = new v$5("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$3[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$3.hasOwnProperty(b2) ? z$3[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$3 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$7(91));
  return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$7(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$7(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$7(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$7(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$7(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$7(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$7(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$7(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$7(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$7(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$7(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$7(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$7(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$7(190));
  }
  if (3 !== c2.tag)
    throw Error(p$7(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$1 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$3(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$3({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$3({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$3({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$3({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$3({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$3({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$3({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$3({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$3({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$3({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$3({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie)
    return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2))
    return a2;
}
function ve(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2])
    return Xe[a2];
  if (!We[a2])
    return a2;
  var b2 = We[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye)
      return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$2(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve;
        else if (me(h3))
          if (we)
            na = Fe;
          else {
            na = De;
            var xa = Ce;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable)
            Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2))
        d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$7(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$7(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$1(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$7(168));
  G$1(H$2, b2);
  G$1(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$7(108, Ra(a2) || "Unknown", e2));
  return A$3({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$1(H$2, a2);
  G$1(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$7(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$2), G$1(H$2, a2)) : E$2(Wf);
  G$1(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$1;
    try {
      var c2 = eg;
      for (C$1 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$2) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$7(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$2 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$7(418));
      a2.flags = a2.flags & -4097 | 2;
      I$2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$2)
    return Fg(a2), I$2 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$7(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$7(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$3({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$2(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$7(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$3({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$7(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$3({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$7(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$7(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$7(284));
    if (!c2._owner)
      throw Error(p$7(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$7(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$7(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$7(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$7(174));
  return a2;
}
function Ih(a2, b2) {
  G$1(Gh, b2);
  G$1(Fh, a2);
  G$1(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$2(Eh);
  G$1(Eh, b2);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$1(Fh, a2), G$1(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$2 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$2 = null, P$2 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$2() {
  throw Error(p$7(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$2 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$7(301));
      f2 += 1;
      P$2 = O$2 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai;
  b2 = null !== O$2 && null !== O$2.next;
  Rh = 0;
  P$2 = O$2 = N$2 = null;
  Sh = false;
  if (b2)
    throw Error(p$7(300));
  return a2;
}
function bi() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$2 ? N$2.memoizedState = P$2 = a2 : P$2 = P$2.next = a2;
  return P$2;
}
function di() {
  if (null === O$2) {
    var a2 = N$2.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$2.next;
  var b2 = null === P$2 ? N$2.memoizedState : P$2.next;
  if (null !== b2)
    P$2 = b2, O$2 = a2;
  else {
    if (null === a2)
      throw Error(p$7(310));
    O$2 = a2;
    a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null };
    null === P$2 ? N$2.memoizedState = P$2 = a2 : P$2 = P$2.next = a2;
  }
  return P$2;
}
function ei(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$7(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$2, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$2.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$2.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi(a2) {
  var b2 = di(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$7(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi() {
}
function ii(a2, b2) {
  var c2 = N$2, d2 = di(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$2 && P$2.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li(9, mi.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$2)
      throw Error(p$7(349));
    0 !== (Rh & 30) || ni(c2, b2, e2);
  }
  return e2;
}
function ni(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi(b2) && pi(a2);
}
function ki(a2, b2, c2) {
  return c2(function() {
    oi(b2) && pi(a2);
  });
}
function oi(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri.bind(null, N$2, a2);
  return [b2.memoizedState, a2];
}
function li(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si() {
  return di().memoizedState;
}
function ti(a2, b2, c2, d2) {
  var e2 = ci();
  N$2.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui(a2, b2, c2, d2) {
  var e2 = di();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$2) {
    var g2 = O$2.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li(b2, c2, f2, d2);
      return;
    }
  }
  N$2.flags |= a2;
  e2.memoizedState = li(1 | b2, c2, f2, d2);
}
function vi(a2, b2) {
  return ti(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui(2048, 8, a2, b2);
}
function wi(a2, b2) {
  return ui(4, 2, a2, b2);
}
function xi(a2, b2) {
  return ui(4, 4, a2, b2);
}
function yi(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui(4, 4, yi.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei(a2, b2) {
  var c2 = C$1;
  C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$1 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$2();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$2(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$2 || null !== b2 && b2 === N$2;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti(
    4194308,
    4,
    yi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$2, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei.bind(null, a2[1]);
  ci().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$2, e2 = ci();
  if (I$2) {
    if (void 0 === c2)
      throw Error(p$7(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$2)
      throw Error(p$7(349));
    0 !== (Rh & 30) || ni(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi(ki.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li(9, mi.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci(), b2 = R$2.identifierPrefix;
  if (I$2) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi,
  useLayoutEffect: xi,
  useMemo: Ci,
  useReducer: fi,
  useRef: si,
  useState: function() {
    return fi(ei);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di();
    return Di(b2, O$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi(ei)[0], b2 = di().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi,
  useSyncExternalStore: ii,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
  return gi(ei);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di();
  return null === O$2 ? b2.memoizedState = a2 : Di(b2, O$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi(ei)[0], b2 = di().memoizedState;
  return [a2, b2];
}, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$1(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$1(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$1(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$1(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$2.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$1(M$2, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$7(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$7(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$2;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$7(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$2.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$1(M$2, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$7(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$1(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$1(M$2, M$2.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$1(M$2, M$2.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$1(M$2, M$2.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$1(M$2, M$2.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$3({}, e2, { value: void 0 });
        d2 = A$3({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$2)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$2(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$2);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$2(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$7(166));
          S$2(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$2("cancel", d2);
              D$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$2(lf[e2], d2);
              break;
            case "source":
              D$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d2
              );
              D$2("load", d2);
              break;
            case "details":
              D$2("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$2("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$2("cancel", a2);
                D$2("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$2(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$2("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a2
                );
                D$2("load", a2);
                e2 = d2;
                break;
              case "details":
                D$2("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$2("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$3({}, d2, { value: void 0 });
                D$2("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$2("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$2(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$7(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$2(b2);
      return null;
    case 13:
      E$2(M$2);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$7(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$7(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$2(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$2.current & 1) ? 0 === T$1 && (T$1 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$2(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$2(b2), null;
    case 10:
      return Rg(b2.type._context), S$2(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 19:
      E$2(M$2);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$2(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$1(M$2, M$2.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$2() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2)
              return S$2(b2), null;
          } else
            2 * B$2() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$2.current, G$1(M$2, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$2(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$2(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$7(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$2(M$2);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$7(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$2(M$2), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$1 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V = b2; null !== V; )
    if (b2 = V, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V = a2;
    else
      for (; null !== V; ) {
        b2 = V;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$7(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V = a2;
          break;
        }
        V = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$1 || Mj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Yj;
      X$1 = null;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Yj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Yj;
      X$1 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$1 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$1 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Zj(a2, b2, c2), U$1 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$1 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$1 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$1)
          throw Error(p$7(160));
        ak(f2, g2, e2);
        X$1 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$7(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$2()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, dk(b2, a2), U$1 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V = m2; null !== V; ) {
              r2 = V;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$7(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$7(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V; ) {
    var e2 = V, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Kj;
        var l2 = U$1;
        Kj = g2;
        if ((U$1 = k2) && !l2)
          for (V = e2; null !== V; )
            g2 = V, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V = k2) : kk(e2);
        for (; null !== f2; )
          V = f2, jk(f2), f2 = f2.sibling;
        V = e2;
        Kj = h2;
        U$1 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$1 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$1)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$7(163));
          }
        U$1 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function hk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    if (b2 === a2) {
      V = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V = c2;
      break;
    }
    V = b2.return;
  }
}
function kk(a2) {
  for (; null !== V; ) {
    var b2 = V;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V = h2;
      break;
    }
    V = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K = 0, R$2 = null, Y = null, Z$1 = 0, gj = 0, fj = Uf(0), T$1 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return 0 !== (K & 6) ? B$2() : -1 !== Bk ? Bk : Bk = B$2();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K & 2) && 0 !== Z$1)
    return Z$1 & -Z$1;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$1;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$7(185));
  Ac(a2, c2, d2);
  if (0 === (K & 2) || a2 !== R$2)
    a2 === R$2 && (0 === (K & 2) && (rk |= c2), 4 === T$1 && Dk(a2, Z$1)), Ek(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Hj = B$2() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$2 ? Z$1 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K & 6))
    throw Error(p$7(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$2 ? Z$1 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Kk();
    if (R$2 !== a2 || Z$1 !== b2)
      vk = null, Hj = B$2() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (R$2 = null, Z$1 = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$7(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$2(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$2();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$2() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$7(329));
      }
    }
  }
  Ek(a2, B$2());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K & 6))
    throw Error(p$7(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$2()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$2()), c2;
  if (6 === c2)
    throw Error(p$7(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$2());
  return null;
}
function Rk(a2, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a2(b2);
  } finally {
    K = c2, 0 === K && (Hj = B$2() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
  var b2 = K;
  K |= 1;
  var c2 = pk.transition, d2 = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a2)
      return a2();
  } finally {
    C$1 = d2, pk.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y)
    for (c2 = Y.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$2);
          break;
        case 19:
          E$2(M$2);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$2 = a2;
  Y = a2 = wh(a2.current, null);
  Z$1 = gj = b2;
  T$1 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y;
    try {
      Qg();
      Ph.current = ai;
      if (Sh) {
        for (var d2 = N$2.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$2 = O$2 = N$2 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        qk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$1;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$7(426));
          }
        } else if (I$2 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai;
  return null === a2 ? ai : a2;
}
function uj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1)
    T$1 = 4;
  null === R$2 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$2, Z$1);
}
function Jk(a2, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Kk();
  if (R$2 !== a2 || Z$1 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K = c2;
  nk.current = d2;
  if (null !== Y)
    throw Error(p$7(261));
  R$2 = null;
  Z$1 = 0;
  return T$1;
}
function Uk() {
  for (; null !== Y; )
    Vk(Y);
}
function Mk() {
  for (; null !== Y && !cc(); )
    Vk(Y);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$1 = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$1, e2 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$1 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K & 6))
    throw Error(p$7(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$7(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$2 && (Y = R$2 = null, Z$1 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K;
    K |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K = h2;
    C$1 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$2());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K & 6))
          throw Error(p$7(331));
        var e2 = K;
        K |= 4;
        for (V = a2.current; null !== V; ) {
          var f2 = V, g2 = f2.child;
          if (0 !== (V.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V = l2; null !== V; ) {
                  var m2 = V;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V = q2;
                  else
                    for (; null !== V; ) {
                      m2 = V;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V = r2;
                        break;
                      }
                      V = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V = g2;
          else
            b:
              for (; null !== V; ) {
                f2 = V;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V = x2;
                  break b;
                }
                V = f2.return;
              }
        }
        var w2 = a2.current;
        for (V = w2; null !== V; ) {
          g2 = V;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V = u2;
          else
            b:
              for (g2 = w2; null !== V; ) {
                h2 = V;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V = F2;
                  break b;
                }
                V = h2.return;
              }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$1 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$2();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$2();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$2 === a2 && (Z$1 & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z$1 & 130023424) === Z$1 && 500 > B$2() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$2();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$7(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$2 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$7(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$7(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$7(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$7(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$2 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$1(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$7(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$7(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$7(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$7(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$7(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$2();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$2(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$7(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$2()), 0 === (K & 6) && (Hj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a2, b2) {
  var c2 = C$1;
  try {
    return C$1 = a2, b2();
  } finally {
    C$1 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$7(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$7(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$7(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$7(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$7(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$7(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$7(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$7(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$7(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$7(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$7(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
(function(module) {
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
  {
    checkDCE();
    module.exports = reactDom_production_min;
  }
})(reactDom);
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDom.exports);
const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactDOM
}, [reactDom.exports]);
var m$6 = reactDom.exports;
{
  client.createRoot = m$6.createRoot;
  client.hydrateRoot = m$6.hydrateRoot;
}
/**
 * @remix-run/router v1.0.4
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$2({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path2) {
  let parsedPath = {};
  if (path2) {
    let hashIndex = path2.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path2.substr(hashIndex);
      path2 = path2.substr(0, hashIndex);
    }
    let searchIndex = path2.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path2.substr(searchIndex);
      path2 = path2.substr(0, searchIndex);
    }
    if (path2) {
      parsedPath.pathname = path2;
    }
  }
  return parsedPath;
}
function createURL(location) {
  let base = typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.origin !== "null" ? window.location.origin : "unknown://unknown";
  let href = typeof location === "string" ? location : createPath(location);
  return new URL(href, base);
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  function handlePop() {
    action = Action.Pop;
    if (listener) {
      listener({
        action,
        location: history.location
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url2 = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url2);
    } catch (error) {
      window2.location.assign(url2);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location
      });
    }
  }
  function replace2(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url2 = history.createHref(location);
    globalHistory.replaceState(historyState, "", url2);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location
      });
    }
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    encodeLocation(to) {
      let url2 = createURL(typeof to === "string" ? to : createPath(to));
      return {
        pathname: url2.pathname,
        search: url2.search,
        hash: url2.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(
      branches[i2],
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route, index2) => {
    let meta = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path2 = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path2 + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path2);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path: path2,
      score: computeScore(path2, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path2, index2) {
  let segments = path2.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? a2[a2.length - 1] - b2[b2.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern4, pathname) {
  if (typeof pattern4 === "string") {
    pattern4 = {
      path: pattern4,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern4.path, pattern4.caseSensitive, pattern4.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern: pattern4
  };
}
function compilePath(path2, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning$4(path2 === "*" || !path2.endsWith("*") || path2.endsWith("/*"), 'Route path "' + path2 + '" will be treated as if it were ' + ('"' + path2.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path2.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path2.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path2.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path2 === "*" || path2 === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path2 !== "" && path2 !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning$4(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning$4(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant(value, message2) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message2);
  }
}
function warning$4(cond, message2) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message2);
    try {
      throw new Error(message2);
    } catch (e2) {
    }
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path2) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path2) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index2) => index2 === 0 || match.route.path && match.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$2({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (isPathRelative || toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path2 = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path2.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path2.pathname += "/";
  }
  return path2;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
class ErrorResponse {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
function isRouteErrorResponse(e2) {
  return e2 instanceof ErrorResponse;
}
const validActionMethodsArr = ["post", "put", "patch", "delete"];
["get", ...validActionMethodsArr];
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$4 = react.exports, k$5 = Symbol.for("react.element"), l$5 = Symbol.for("react.fragment"), m$5 = Object.prototype.hasOwnProperty, n$6 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$6 = { key: true, ref: true, __self: true, __source: true };
function q$6(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$5.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$5, type: c2, key: e2, ref: h2, props: d2, _owner: n$6.current };
}
reactJsxRuntime_production_min.Fragment = l$5;
reactJsxRuntime_production_min.jsx = q$6;
reactJsxRuntime_production_min.jsxs = q$6;
(function(module) {
  {
    module.exports = reactJsxRuntime_production_min;
  }
})(jsxRuntime);
const Fragment = jsxRuntime.exports.Fragment;
const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
/**
 * React Router v6.4.4
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
const is = typeof Object.is === "function" ? Object.is : isPolyfill;
const {
  useState,
  useEffect,
  useLayoutEffect: useLayoutEffect$1,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe, getSnapshot, getServerSnapshot) {
  const value = getSnapshot();
  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  });
  useLayoutEffect$1(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe, value, getSnapshot]);
  useEffect(() => {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe(handleStoreChange);
  }, [subscribe]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is(prevValue, nextValue);
  } catch (error) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
const canUseDOM$2 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM$2;
const shim$1 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 ? ((module) => module.useSyncExternalStore)(React$1) : shim$1;
const DataStaticRouterContext = /* @__PURE__ */ react.exports.createContext(null);
const DataRouterContext = /* @__PURE__ */ react.exports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ react.exports.createContext(null);
const NavigationContext = /* @__PURE__ */ react.exports.createContext(null);
const LocationContext = /* @__PURE__ */ react.exports.createContext(null);
const RouteContext = /* @__PURE__ */ react.exports.createContext({
  outlet: null,
  matches: []
});
const RouteErrorContext = /* @__PURE__ */ react.exports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return react.exports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return react.exports.useContext(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  let activeRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = react.exports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path2 = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (basename !== "/") {
      path2.pathname = path2.pathname === "/" ? basename : joinPaths([basename, path2.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path2, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = react.exports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  return react.exports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let dataRouterStateContext = react.exports.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = react.exports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      navigator2.encodeLocation ? navigator2.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterStateContext || void 0);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ jsx(LocationContext.Provider, {
      value: {
        location: _extends$1({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      },
      children: renderedMatches
    });
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error = useRouteError();
  let message2 = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("h2", {
      children: "Unhandled Thrown Error!"
    }), /* @__PURE__ */ jsx("h3", {
      style: {
        fontStyle: "italic"
      },
      children: message2
    }), stack ? /* @__PURE__ */ jsx("pre", {
      style: preStyles,
      children: stack
    }) : null, /* @__PURE__ */ jsx("p", {
      children: "\u{1F4BF} Hey developer \u{1F44B}"
    }), /* @__PURE__ */ jsxs("p", {
      children: ["You can provide a way better UX than this when your app throws errors by providing your own\xA0", /* @__PURE__ */ jsx("code", {
        style: codeStyles,
        children: "errorElement"
      }), " props on\xA0", /* @__PURE__ */ jsx("code", {
        style: codeStyles,
        children: "<Route>"
      })]
    })]
  });
}
class RenderErrorBoundary extends react.exports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ jsx(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataStaticRouterContext = react.exports.useContext(DataStaticRouterContext);
  if (dataStaticRouterContext && match.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ jsx(RouteContext.Provider, {
    value: routeContext,
    children
  });
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index2) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;
    let errorElement = dataRouterState ? match.route.errorElement || /* @__PURE__ */ jsx(DefaultErrorElement, {}) : null;
    let getChildren = () => /* @__PURE__ */ jsx(RenderedRoute, {
      match,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index2 + 1))
      },
      children: error ? errorElement : match.route.element !== void 0 ? match.route.element : outlet
    });
    return dataRouterState && (match.route.errorElement || index2 === 0) ? /* @__PURE__ */ jsx(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error,
      children: getChildren()
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = react.exports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteError() {
  var _state$errors;
  let error = react.exports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let route = react.exports.useContext(RouteContext);
  let thisRoute = route.matches[route.matches.length - 1];
  if (error) {
    return error;
  }
  !route ? invariant(false) : void 0;
  !thisRoute.route.id ? invariant(false) : void 0;
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
}
function Navigate(_ref3) {
  let {
    to,
    replace: replace2,
    state,
    relative
  } = _ref3;
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterState = react.exports.useContext(DataRouterStateContext);
  let navigate = useNavigate();
  react.exports.useEffect(() => {
    if (dataRouterState && dataRouterState.navigation.state !== "idle") {
      return;
    }
    navigate(to, {
      replace: replace2,
      state,
      relative
    });
  });
  return null;
}
function Route(_props) {
  invariant(false);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = react.exports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = react.exports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ jsx(NavigationContext.Provider, {
    value: navigationContext,
    children: /* @__PURE__ */ jsx(LocationContext.Provider, {
      children,
      value: {
        location,
        navigationType
      }
    })
  });
}
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = react.exports.useContext(DataRouterContext);
  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  react.exports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ react.exports.isValidElement(element)) {
      return;
    }
    if (element.type === react.exports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let treePath = [...parentPath, index2];
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.4.4
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event);
}
const _excluded$u = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2$6 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    window: window2
  } = _ref;
  let historyRef = react.exports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = react.exports.useState({
    action: history.action,
    location: history.location
  });
  react.exports.useLayoutEffect(() => history.listen(setState), [history]);
  return /* @__PURE__ */ jsx(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
const Link$2 = /* @__PURE__ */ react.exports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose$1(_ref4, _excluded$u);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ jsx("a", {
    ...rest,
    href,
    onClick: reloadDocument ? onClick : handleClick,
    ref,
    target
  });
});
const NavLink = /* @__PURE__ */ react.exports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose$1(_ref5, _excluded2$6);
  let path2 = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = react.exports.useContext(DataRouterStateContext);
  let {
    navigator: navigator2
  } = react.exports.useContext(NavigationContext);
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path2).pathname : path2.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive2 = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive2 ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive: isActive2,
      isPending
    });
  } else {
    className = [classNameProp, isActive2 ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp({
    isActive: isActive2,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ jsx(Link$2, {
    ...rest,
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to,
    children: typeof children === "function" ? children({
      isActive: isActive2,
      isPending
    }) : children
  });
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path2 = useResolvedPath(to, {
    relative
  });
  return react.exports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path2);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path2, replaceProp, state, target, to, preventScrollReset, relative]);
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$3 = react.exports;
function h$5(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$4 = "function" === typeof Object.is ? Object.is : h$5, l$4 = e$3.useState, m$4 = e$3.useEffect, n$5 = e$3.useLayoutEffect, p$5 = e$3.useDebugValue;
function q$5(a2, b2) {
  var d2 = b2(), f2 = l$4({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$5(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$4(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$4(function() {
    r$4(c2) && g2({ inst: c2 });
    return a2(function() {
      r$4(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$5(d2);
  return d2;
}
function r$4(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$4(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$6(a2, b2) {
  return b2();
}
var u$4 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$6 : q$5;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$3.useSyncExternalStore ? e$3.useSyncExternalStore : u$4;
(function(module) {
  {
    module.exports = useSyncExternalStoreShim_production_min;
  }
})(shim);
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$4 = react.exports, n$4 = shim.exports;
function p$4(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$4 = "function" === typeof Object.is ? Object.is : p$4, r$3 = n$4.useSyncExternalStore, t$5 = h$4.useRef, u$3 = h$4.useEffect, v$4 = h$4.useMemo, w$2 = h$4.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$5(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$4(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$4(d3, a4))
        return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$3(a2, c2[0], c2[1]);
  u$3(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$2(d2);
  return d2;
};
(function(module) {
  {
    module.exports = withSelector_production_min;
  }
})(withSelector);
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ReactReduxContext = /* @__PURE__ */ react.exports.createContext(null);
function useReduxContext() {
  const contextValue = react.exports.useContext(ReactReduxContext);
  return contextValue;
}
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn2) => {
  useSyncExternalStoreWithSelector = fn2;
};
const refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : () => react.exports.useContext(context);
  return function useSelector2(selector, equalityFn = refEquality) {
    const {
      store: store2,
      subscription,
      getServerState
    } = useReduxContext$1();
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store2.getState, getServerState || store2.getState, selector, equalityFn);
    react.exports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var reactIs$2 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$3 = "function" === typeof Symbol && Symbol.for, c$2 = b$3 ? Symbol.for("react.element") : 60103, d$3 = b$3 ? Symbol.for("react.portal") : 60106, e$2 = b$3 ? Symbol.for("react.fragment") : 60107, f$3 = b$3 ? Symbol.for("react.strict_mode") : 60108, g$3 = b$3 ? Symbol.for("react.profiler") : 60114, h$3 = b$3 ? Symbol.for("react.provider") : 60109, k$3 = b$3 ? Symbol.for("react.context") : 60110, l$3 = b$3 ? Symbol.for("react.async_mode") : 60111, m$3 = b$3 ? Symbol.for("react.concurrent_mode") : 60111, n$3 = b$3 ? Symbol.for("react.forward_ref") : 60112, p$3 = b$3 ? Symbol.for("react.suspense") : 60113, q$3 = b$3 ? Symbol.for("react.suspense_list") : 60120, r$2 = b$3 ? Symbol.for("react.memo") : 60115, t$4 = b$3 ? Symbol.for("react.lazy") : 60116, v$3 = b$3 ? Symbol.for("react.block") : 60121, w$1 = b$3 ? Symbol.for("react.fundamental") : 60117, x$1 = b$3 ? Symbol.for("react.responder") : 60118, y$2 = b$3 ? Symbol.for("react.scope") : 60119;
function z$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$2:
        switch (a2 = a2.type, a2) {
          case l$3:
          case m$3:
          case e$2:
          case g$3:
          case f$3:
          case p$3:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$3:
              case n$3:
              case t$4:
              case r$2:
              case h$3:
                return a2;
              default:
                return u2;
            }
        }
      case d$3:
        return u2;
    }
  }
}
function A$2(a2) {
  return z$2(a2) === m$3;
}
reactIs_production_min$1.AsyncMode = l$3;
reactIs_production_min$1.ConcurrentMode = m$3;
reactIs_production_min$1.ContextConsumer = k$3;
reactIs_production_min$1.ContextProvider = h$3;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$3;
reactIs_production_min$1.Fragment = e$2;
reactIs_production_min$1.Lazy = t$4;
reactIs_production_min$1.Memo = r$2;
reactIs_production_min$1.Portal = d$3;
reactIs_production_min$1.Profiler = g$3;
reactIs_production_min$1.StrictMode = f$3;
reactIs_production_min$1.Suspense = p$3;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A$2(a2) || z$2(a2) === l$3;
};
reactIs_production_min$1.isConcurrentMode = A$2;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z$2(a2) === k$3;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z$2(a2) === h$3;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z$2(a2) === n$3;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z$2(a2) === e$2;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z$2(a2) === t$4;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z$2(a2) === r$2;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z$2(a2) === d$3;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z$2(a2) === g$3;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z$2(a2) === f$3;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z$2(a2) === p$3;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$3 || a2 === g$3 || a2 === f$3 || a2 === p$3 || a2 === q$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$4 || a2.$$typeof === r$2 || a2.$$typeof === h$3 || a2.$$typeof === k$3 || a2.$$typeof === n$3 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$2 || a2.$$typeof === v$3);
};
reactIs_production_min$1.typeOf = z$2;
(function(module) {
  {
    module.exports = reactIs_production_min$1;
  }
})(reactIs$2);
var reactIs$1 = reactIs$2.exports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var reactIs = { exports: {} };
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$2 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$2 = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f$2 = Symbol.for("react.profiler"), g$2 = Symbol.for("react.provider"), h$2 = Symbol.for("react.context"), k$2 = Symbol.for("react.server_context"), l$2 = Symbol.for("react.forward_ref"), m$2 = Symbol.for("react.suspense"), n$2 = Symbol.for("react.suspense_list"), p$2 = Symbol.for("react.memo"), q$2 = Symbol.for("react.lazy"), t$3 = Symbol.for("react.offscreen"), u$2;
u$2 = Symbol.for("react.module.reference");
function v$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b$2:
        switch (a2 = a2.type, a2) {
          case d$2:
          case f$2:
          case e$1:
          case m$2:
          case n$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case h$2:
              case l$2:
              case q$2:
              case p$2:
              case g$2:
                return a2;
              default:
                return r2;
            }
        }
      case c$1:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h$2;
reactIs_production_min.ContextProvider = g$2;
reactIs_production_min.Element = b$2;
reactIs_production_min.ForwardRef = l$2;
reactIs_production_min.Fragment = d$2;
reactIs_production_min.Lazy = q$2;
reactIs_production_min.Memo = p$2;
reactIs_production_min.Portal = c$1;
reactIs_production_min.Profiler = f$2;
reactIs_production_min.StrictMode = e$1;
reactIs_production_min.Suspense = m$2;
reactIs_production_min.SuspenseList = n$2;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return v$2(a2) === h$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return v$2(a2) === g$2;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$2;
};
reactIs_production_min.isForwardRef = function(a2) {
  return v$2(a2) === l$2;
};
reactIs_production_min.isFragment = function(a2) {
  return v$2(a2) === d$2;
};
reactIs_production_min.isLazy = function(a2) {
  return v$2(a2) === q$2;
};
reactIs_production_min.isMemo = function(a2) {
  return v$2(a2) === p$2;
};
reactIs_production_min.isPortal = function(a2) {
  return v$2(a2) === c$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return v$2(a2) === f$2;
};
reactIs_production_min.isStrictMode = function(a2) {
  return v$2(a2) === e$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return v$2(a2) === m$2;
};
reactIs_production_min.isSuspenseList = function(a2) {
  return v$2(a2) === n$2;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$2 || a2 === f$2 || a2 === e$1 || a2 === m$2 || a2 === n$2 || a2 === t$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$2 || a2.$$typeof === p$2 || a2.$$typeof === g$2 || a2.$$typeof === h$2 || a2.$$typeof === l$2 || a2.$$typeof === u$2 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v$2;
(function(module) {
  {
    module.exports = reactIs_production_min;
  }
})(reactIs);
function createListenerCollection() {
  const batch2 = getBatch();
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      batch2(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store2, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe);
  }
  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect$1 = canUseDOM$1 ? react.exports.useLayoutEffect : react.exports.useEffect;
function Provider$1({
  store: store2,
  context,
  children,
  serverState
}) {
  const contextValue = react.exports.useMemo(() => {
    const subscription = createSubscription(store2);
    return {
      store: store2,
      subscription,
      getServerState: serverState ? () => serverState : void 0
    };
  }, [store2, serverState]);
  const previousState = react.exports.useMemo(() => store2.getState(), [store2]);
  useIsomorphicLayoutEffect$1(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context2 = context || ReactReduxContext;
  return /* @__PURE__ */ jsx(Context2.Provider, {
    value: contextValue,
    children
  });
}
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : () => react.exports.useContext(context);
  return function useStore2() {
    const {
      store: store2
    } = useReduxContext$1();
    return store2;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore$1 = context === ReactReduxContext ? useStore : createStoreHook(context);
  return function useDispatch2() {
    const store2 = useStore$1();
    return store2.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelector.exports.useSyncExternalStoreWithSelector);
setBatch(reactDom.exports.unstable_batchedUpdates);
function n$1(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
    t2[e2 - 1] = arguments[e2];
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r$1(n2) {
  return !!n2 && !!n2[Q$1];
}
function t$2(n2) {
  var r2;
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3)
      return true;
    var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z;
  }(n2) || Array.isArray(n2) || !!n2[L$1] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L$1]) || s(n2) || v$1(n2));
}
function i$1(n2, r2, t2) {
  void 0 === t2 && (t2 = false), 0 === o$2(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
    t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
  }) : n2.forEach(function(t3, e2) {
    return r2(e2, t3, n2);
  });
}
function o$2(n2) {
  var r2 = n2[Q$1];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v$1(n2) ? 3 : 0;
}
function u$1(n2, r2) {
  return 2 === o$2(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return 2 === o$2(n2) ? n2.get(r2) : n2[r2];
}
function f$1(n2, r2, t2) {
  var e2 = o$2(n2);
  2 === e2 ? n2.set(r2, t2) : 3 === e2 ? (n2.delete(r2), n2.add(t2)) : n2[r2] = t2;
}
function c(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X && n2 instanceof Map;
}
function v$1(n2) {
  return q$1 && n2 instanceof Set;
}
function p$1(n2) {
  return n2.o || n2.t;
}
function l$1(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q$1];
  for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
    var i2 = t2[e2], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d$1(n2, e2) {
  return void 0 === e2 && (e2 = false), y$1(n2) || r$1(n2) || !t$2(n2) ? n2 : (o$2(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h$1), Object.freeze(n2), e2 && i$1(n2, function(n3, r2) {
    return d$1(r2, true);
  }, true), n2);
}
function h$1() {
  n$1(2);
}
function y$1(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b$1(r2) {
  var t2 = tn[r2];
  return t2 || n$1(18, r2), t2;
}
function m$1(n2, r2) {
  tn[n2] || (tn[n2] = r2);
}
function _$1() {
  return U;
}
function j(n2, r2) {
  r2 && (b$1("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function O$1(n2) {
  g$1(n2), n2.p.forEach(S$1), n2.p = null;
}
function g$1(n2) {
  n2 === U && (U = n2.l);
}
function w(n2) {
  return U = { p: [], l: U, h: n2, m: true, _: 0 };
}
function S$1(n2) {
  var r2 = n2[Q$1];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.O = true;
}
function P$1(r2, e2) {
  e2._ = e2.p.length;
  var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e2.h.g || b$1("ES5").S(e2, r2, o2), o2 ? (i2[Q$1].P && (O$1(e2), n$1(4)), t$2(r2) && (r2 = M$1(e2, r2), e2.l || x(e2, r2)), e2.u && b$1("Patches").M(i2[Q$1].t, r2, e2.u, e2.s)) : r2 = M$1(e2, i2, []), O$1(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H$1 ? r2 : void 0;
}
function M$1(n2, r2, t2) {
  if (y$1(r2))
    return r2;
  var e2 = r2[Q$1];
  if (!e2)
    return i$1(r2, function(i2, o3) {
      return A$1(n2, e2, r2, i2, o3, t2);
    }, true), r2;
  if (e2.A !== n2)
    return r2;
  if (!e2.P)
    return x(n2, e2.t, true), e2.t;
  if (!e2.I) {
    e2.I = true, e2.A._--;
    var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l$1(e2.k) : e2.o;
    i$1(3 === e2.i ? new Set(o2) : o2, function(r3, i2) {
      return A$1(n2, e2, o2, r3, i2, t2);
    }), x(n2, o2, false), t2 && n2.u && b$1("Patches").R(e2, t2, n2.u, n2.s);
  }
  return e2.o;
}
function A$1(e2, i2, o2, a2, c2, s2) {
  if (r$1(c2)) {
    var v2 = M$1(e2, c2, s2 && i2 && 3 !== i2.i && !u$1(i2.D, a2) ? s2.concat(a2) : void 0);
    if (f$1(o2, a2, v2), !r$1(v2))
      return;
    e2.m = false;
  }
  if (t$2(c2) && !y$1(c2)) {
    if (!e2.h.F && e2._ < 1)
      return;
    M$1(e2, c2), i2 && i2.A.l || x(e2, c2);
  }
}
function x(n2, r2, t2) {
  void 0 === t2 && (t2 = false), n2.h.F && n2.m && d$1(r2, t2);
}
function z$1(n2, r2) {
  var t2 = n2[Q$1];
  return (t2 ? p$1(t2) : n2)[r2];
}
function I$1(n2, r2) {
  if (r2 in n2)
    for (var t2 = Object.getPrototypeOf(n2); t2; ) {
      var e2 = Object.getOwnPropertyDescriptor(t2, r2);
      if (e2)
        return e2;
      t2 = Object.getPrototypeOf(t2);
    }
}
function k$1(n2) {
  n2.P || (n2.P = true, n2.l && k$1(n2.l));
}
function E$1(n2) {
  n2.o || (n2.o = l$1(n2.t));
}
function R$1(n2, r2, t2) {
  var e2 = s(r2) ? b$1("MapSet").N(r2, t2) : v$1(r2) ? b$1("MapSet").T(r2, t2) : n2.g ? function(n3, r3) {
    var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _$1(), P: false, I: false, D: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en;
    t3 && (i2 = [e3], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e3.k = f2, e3.j = a2, f2;
  }(r2, t2) : b$1("ES5").J(r2, t2);
  return (t2 ? t2.A : _$1()).p.push(e2), e2;
}
function D$1(e2) {
  return r$1(e2) || n$1(22, e2), function n2(r2) {
    if (!t$2(r2))
      return r2;
    var e3, u2 = r2[Q$1], c2 = o$2(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b$1("ES5").K(u2)))
        return u2.t;
      u2.I = true, e3 = F$1(r2, c2), u2.I = false;
    } else
      e3 = F$1(r2, c2);
    return i$1(e3, function(r3, t2) {
      u2 && a(u2.t, r3) === t2 || f$1(e3, r3, n2(t2));
    }), 3 === c2 ? new Set(e3) : e3;
  }(e2);
}
function F$1(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l$1(n2);
}
function N$1() {
  function t2(n2, r2) {
    var t3 = s2[n2];
    return t3 ? t3.enumerable = r2 : s2[n2] = t3 = { configurable: true, enumerable: r2, get: function() {
      var r3 = this[Q$1];
      return en.get(r3, n2);
    }, set: function(r3) {
      var t4 = this[Q$1];
      en.set(t4, n2, r3);
    } }, t3;
  }
  function e2(n2) {
    for (var r2 = n2.length - 1; r2 >= 0; r2--) {
      var t3 = n2[r2][Q$1];
      if (!t3.P)
        switch (t3.i) {
          case 5:
            a2(t3) && k$1(t3);
            break;
          case 4:
            o2(t3) && k$1(t3);
        }
    }
  }
  function o2(n2) {
    for (var r2 = n2.t, t3 = n2.k, e3 = nn(t3), i2 = e3.length - 1; i2 >= 0; i2--) {
      var o3 = e3[i2];
      if (o3 !== Q$1) {
        var a3 = r2[o3];
        if (void 0 === a3 && !u$1(r2, o3))
          return true;
        var f2 = t3[o3], s3 = f2 && f2[Q$1];
        if (s3 ? s3.t !== a3 : !c(f2, a3))
          return true;
      }
    }
    var v2 = !!r2[Q$1];
    return e3.length !== nn(r2).length + (v2 ? 0 : 1);
  }
  function a2(n2) {
    var r2 = n2.k;
    if (r2.length !== n2.t.length)
      return true;
    var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
    if (t3 && !t3.get)
      return true;
    for (var e3 = 0; e3 < r2.length; e3++)
      if (!r2.hasOwnProperty(e3))
        return true;
    return false;
  }
  var s2 = {};
  m$1("ES5", { J: function(n2, r2) {
    var e3 = Array.isArray(n2), i2 = function(n3, r3) {
      if (n3) {
        for (var e4 = Array(r3.length), i3 = 0; i3 < r3.length; i3++)
          Object.defineProperty(e4, "" + i3, t2(i3, true));
        return e4;
      }
      var o4 = rn(r3);
      delete o4[Q$1];
      for (var u2 = nn(o4), a3 = 0; a3 < u2.length; a3++) {
        var f2 = u2[a3];
        o4[f2] = t2(f2, n3 || !!o4[f2].enumerable);
      }
      return Object.create(Object.getPrototypeOf(r3), o4);
    }(e3, n2), o3 = { i: e3 ? 5 : 4, A: r2 ? r2.A : _$1(), P: false, I: false, D: {}, l: r2, t: n2, k: i2, o: null, O: false, C: false };
    return Object.defineProperty(i2, Q$1, { value: o3, writable: true }), i2;
  }, S: function(n2, t3, o3) {
    o3 ? r$1(t3) && t3[Q$1].A === n2 && e2(n2.p) : (n2.u && function n3(r2) {
      if (r2 && "object" == typeof r2) {
        var t4 = r2[Q$1];
        if (t4) {
          var e3 = t4.t, o4 = t4.k, f2 = t4.D, c2 = t4.i;
          if (4 === c2)
            i$1(o4, function(r3) {
              r3 !== Q$1 && (void 0 !== e3[r3] || u$1(e3, r3) ? f2[r3] || n3(o4[r3]) : (f2[r3] = true, k$1(t4)));
            }), i$1(e3, function(n4) {
              void 0 !== o4[n4] || u$1(o4, n4) || (f2[n4] = false, k$1(t4));
            });
          else if (5 === c2) {
            if (a2(t4) && (k$1(t4), f2.length = true), o4.length < e3.length)
              for (var s3 = o4.length; s3 < e3.length; s3++)
                f2[s3] = false;
            else
              for (var v2 = e3.length; v2 < o4.length; v2++)
                f2[v2] = true;
            for (var p2 = Math.min(o4.length, e3.length), l2 = 0; l2 < p2; l2++)
              o4.hasOwnProperty(l2) || (f2[l2] = true), void 0 === f2[l2] && n3(o4[l2]);
          }
        }
      }
    }(n2.p[0]), e2(n2.p));
  }, K: function(n2) {
    return 4 === n2.i ? o2(n2) : a2(n2);
  } });
}
var G, U, W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X = "undefined" != typeof Map, q$1 = "undefined" != typeof Set, B$1 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H$1 = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G), L$1 = W ? Symbol.for("immer-draftable") : "__$immer_draftable", Q$1 = W ? Symbol.for("immer-state") : "__$immer_state", Z = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  }), r2;
}, tn = {}, en = { get: function(n2, r2) {
  if (r2 === Q$1)
    return n2;
  var e2 = p$1(n2);
  if (!u$1(e2, r2))
    return function(n3, r3, t2) {
      var e3, i3 = I$1(r3, t2);
      return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
    }(n2, e2, r2);
  var i2 = e2[r2];
  return n2.I || !t$2(i2) ? i2 : i2 === z$1(n2.t, r2) ? (E$1(n2), n2.o[r2] = R$1(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p$1(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p$1(n2));
}, set: function(n2, r2, t2) {
  var e2 = I$1(p$1(n2), r2);
  if (null == e2 ? void 0 : e2.set)
    return e2.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z$1(p$1(n2), r2), o2 = null == i2 ? void 0 : i2[Q$1];
    if (o2 && o2.t === t2)
      return n2.o[r2] = t2, n2.D[r2] = false, true;
    if (c(t2, i2) && (void 0 !== t2 || u$1(n2.t, r2)))
      return true;
    E$1(n2), k$1(n2);
  }
  return n2.o[r2] === t2 && "number" != typeof t2 && (void 0 !== t2 || r2 in n2.o) || (n2.o[r2] = t2, n2.D[r2] = true, true);
}, deleteProperty: function(n2, r2) {
  return void 0 !== z$1(n2.t, r2) || r2 in n2.t ? (n2.D[r2] = false, E$1(n2), k$1(n2)) : delete n2.D[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p$1(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
}, defineProperty: function() {
  n$1(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n$1(12);
} }, on = {};
i$1(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t2) {
  return on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e2) {
  return en.set.call(this, r2[0], t2, e2, r2[0]);
};
var un = function() {
  function e2(r2) {
    var e3 = this;
    this.g = B$1, this.F = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e3;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
            e4[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n$1(6), void 0 !== o2 && "function" != typeof o2 && n$1(7), t$2(r3)) {
        var c2 = w(e3), s2 = R$1(e3, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? O$1(c2) : g$1(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j(c2, o2), P$1(n2, c2);
        }, function(n2) {
          throw O$1(c2), n2;
        }) : (j(c2, o2), P$1(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H$1 && (f2 = void 0), e3.F && d$1(f2, true), o2) {
          var p2 = [], l2 = [];
          b$1("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n$1(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2)
        return function(r4) {
          for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            i4[o3 - 1] = arguments[o3];
          return e3.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
        t2 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t2, i3];
      }) : [o2, t2, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e2.prototype;
  return i2.createDraft = function(e3) {
    t$2(e3) || n$1(8), r$1(e3) && (e3 = D$1(e3));
    var i3 = w(this), o2 = R$1(this, e3, void 0);
    return o2[Q$1].C = true, g$1(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e3 = r2 && r2[Q$1];
    var i3 = e3.A;
    return j(i3, t2), P$1(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.F = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B$1 && n$1(20), this.g = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e3;
    for (e3 = t2.length - 1; e3 >= 0; e3--) {
      var i3 = t2[e3];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e3 > -1 && (t2 = t2.slice(e3 + 1));
    var o2 = b$1("Patches").$;
    return r$1(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
      return o2(n3, t2);
    });
  }, e2;
}(), an = new un(), fn = an.produce;
an.produceWithPatches.bind(an);
an.setAutoFreeze.bind(an);
an.setUseProxies.bind(an);
an.applyPatches.bind(an);
an.createDraft.bind(an);
an.finishDraft.bind(an);
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function _toPrimitive(input, hint) {
  if (_typeof$1(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof$1(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$1(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$2(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$2(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer = reducers[key];
    var initialState2 = reducer(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(formatProdErrorMessage(12));
    }
    if (typeof reducer(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage(13));
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i2 = 0; i2 < reducerKeys.length; i2++) {
    var key = reducerKeys[i2];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage(14));
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store2 = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store2.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store2.dispatch);
      return _objectSpread2$1(_objectSpread2$1({}, store2), {}, {
        dispatch: _dispatch
      });
    };
  };
}
function createThunkMiddleware(extraArgument) {
  var middleware = function middleware2(_ref) {
    var dispatch = _ref.dispatch, getState = _ref.getState;
    return function(next2) {
      return function(action) {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next2(action);
      };
    };
  };
  return middleware;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
const thunkMiddleware = thunk;
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __generator = globalThis && globalThis.__generator || function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2) {
  for (var i2 = 0, il2 = from2.length, j2 = to.length; i2 < il2; i2++, j2++)
    to[j2] = from2[i2];
  return to;
};
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = function(obj, key, value) {
  return key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues = function(a2, b2) {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var _i = 0, _c = __getOwnPropSymbols(b2); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = function(a2, b2) {
  return __defProps(a2, __getOwnPropDescs(b2));
};
var __async = function(__this, __arguments, generator2) {
  return new Promise(function(resolve, reject) {
    var fulfilled = function(value) {
      try {
        step(generator2.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = function(value) {
      try {
        step(generator2.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = function(x2) {
      return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    };
    step((generator2 = generator2.apply(__this, __arguments)).next());
  });
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose;
  return compose.apply(null, arguments);
};
function isPlainObject$1(value) {
  if (typeof value !== "object" || value === null)
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  var baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
var MiddlewareArray = function(_super) {
  __extends(MiddlewareArray2, _super);
  function MiddlewareArray2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var _this = _super.apply(this, args) || this;
    Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
    return _this;
  }
  Object.defineProperty(MiddlewareArray2, Symbol.species, {
    get: function() {
      return MiddlewareArray2;
    },
    enumerable: false,
    configurable: true
  });
  MiddlewareArray2.prototype.concat = function() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      arr[_i] = arguments[_i];
    }
    return _super.prototype.concat.apply(this, arr);
  };
  MiddlewareArray2.prototype.prepend = function() {
    var arr = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      arr[_i] = arguments[_i];
    }
    if (arr.length === 1 && Array.isArray(arr[0])) {
      return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr[0].concat(this))))();
    }
    return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray([void 0], arr.concat(this))))();
  };
  return MiddlewareArray2;
}(Array);
function freezeDraftable(val) {
  return t$2(val) ? fn(val, function() {
  }) : val;
}
function isBoolean$1(x2) {
  return typeof x2 === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  var _c = options.thunk, thunk2 = _c === void 0 ? true : _c;
  options.immutableCheck;
  options.serializableCheck;
  var middlewareArray = new MiddlewareArray();
  if (thunk2) {
    if (isBoolean$1(thunk2)) {
      middlewareArray.push(thunkMiddleware);
    } else {
      middlewareArray.push(thunkMiddleware.withExtraArgument(thunk2.extraArgument));
    }
  }
  return middlewareArray;
}
var IS_PRODUCTION = true;
function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  var _c = options || {}, _d = _c.reducer, reducer = _d === void 0 ? void 0 : _d, _e = _c.middleware, middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
  var rootReducer;
  if (typeof reducer === "function") {
    rootReducer = reducer;
  } else if (isPlainObject$1(reducer)) {
    rootReducer = combineReducers(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  var finalMiddleware = middleware;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
  }
  var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
  var finalCompose = compose;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  var storeEnhancers = [middlewareEnhancer];
  if (Array.isArray(enhancers)) {
    storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(storeEnhancers);
  }
  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function createAction(type4, prepareAction) {
  function actionCreator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues(__spreadValues({
        type: type4,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type: type4, payload: args[0] };
  }
  actionCreator.toString = function() {
    return "" + type4;
  };
  actionCreator.type = type4;
  actionCreator.match = function(action) {
    return action.type === type4;
  };
  return actionCreator;
}
function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function(typeOrActionCreator, reducer) {
      var type4 = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (type4 in actionsMap) {
        throw new Error("addCase cannot be called with two reducers for the same action type");
      }
      actionsMap[type4] = reducer;
      return builder;
    },
    addMatcher: function(matcher, reducer) {
      actionMatchers.push({ matcher, reducer });
      return builder;
    },
    addDefaultCase: function(reducer) {
      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
function createReducer(initialState2, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }
  var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
  var getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = function() {
      return freezeDraftable(initialState2());
    };
  } else {
    var frozenInitialState_1 = freezeDraftable(initialState2);
    getInitialState = function() {
      return frozenInitialState_1;
    };
  }
  function reducer(state, action) {
    if (state === void 0) {
      state = getInitialState();
    }
    var caseReducers = __spreadArray([
      actionsMap[action.type]
    ], finalActionMatchers.filter(function(_c2) {
      var matcher = _c2.matcher;
      return matcher(action);
    }).map(function(_c2) {
      var reducer2 = _c2.reducer;
      return reducer2;
    }));
    if (caseReducers.filter(function(cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce(function(previousState, caseReducer) {
      if (caseReducer) {
        if (r$1(previousState)) {
          var draft = previousState;
          var result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!t$2(previousState)) {
          var result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return fn(previousState, function(draft2) {
            return caseReducer(draft2, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer.getInitialState = getInitialState;
  return reducer;
}
function getType2(slice2, actionKey) {
  return slice2 + "/" + actionKey;
}
function createSlice(options) {
  var name2 = options.name;
  if (!name2) {
    throw new Error("`name` is a required option for createSlice");
  }
  if (typeof process !== "undefined" && false) {
    if (options.initialState === void 0) {
      console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    }
  }
  var initialState2 = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
  var reducers = options.reducers || {};
  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function(reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type4 = getType2(name2, reducerName);
    var caseReducer;
    var prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type4] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type4, prepareCallback) : createAction(type4);
  });
  function buildReducer() {
    var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e = _c[1], actionMatchers = _e === void 0 ? [] : _e, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
    var finalCaseReducers = __spreadValues(__spreadValues({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState2, function(builder) {
      for (var key in finalCaseReducers) {
        builder.addCase(key, finalCaseReducers[key]);
      }
      for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
        var m2 = actionMatchers_1[_i];
        builder.addMatcher(m2.matcher, m2.reducer);
      }
      if (defaultCaseReducer) {
        builder.addDefaultCase(defaultCaseReducer);
      }
    });
  }
  var _reducer;
  return {
    name: name2,
    reducer: function(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState: function() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function(size) {
  if (size === void 0) {
    size = 21;
  }
  var id2 = "";
  var i2 = size;
  while (i2--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
var commonProperties = [
  "name",
  "message",
  "stack",
  "code"
];
var RejectWithValue = function() {
  function RejectWithValue2(payload, meta) {
    this.payload = payload;
    this.meta = meta;
  }
  return RejectWithValue2;
}();
var FulfillWithMeta = function() {
  function FulfillWithMeta2(payload, meta) {
    this.payload = payload;
    this.meta = meta;
  }
  return FulfillWithMeta2;
}();
var miniSerializeError = function(value) {
  if (typeof value === "object" && value !== null) {
    var simpleError = {};
    for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
      var property = commonProperties_1[_i];
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return { message: String(value) };
};
(function() {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
      return {
        payload,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "fulfilled"
        })
      };
    });
    var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
      return {
        payload: void 0,
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "pending"
        })
      };
    });
    var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
      return {
        payload,
        error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
        meta: __spreadProps(__spreadValues({}, meta || {}), {
          arg,
          requestId,
          rejectedWithValue: !!payload,
          requestStatus: "rejected",
          aborted: (error == null ? void 0 : error.name) === "AbortError",
          condition: (error == null ? void 0 : error.name) === "ConditionError"
        })
      };
    });
    var AC = typeof AbortController !== "undefined" ? AbortController : function() {
      function class_1() {
        this.signal = {
          aborted: false,
          addEventListener: function() {
          },
          dispatchEvent: function() {
            return false;
          },
          onabort: function() {
          },
          removeEventListener: function() {
          },
          reason: void 0,
          throwIfAborted: function() {
          }
        };
      }
      class_1.prototype.abort = function() {
      };
      return class_1;
    }();
    function actionCreator(arg) {
      return function(dispatch, getState, extra) {
        var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
        var abortController = new AC();
        var abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        var promise2 = function() {
          return __async(this, null, function() {
            var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
            return __generator(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _c.trys.push([0, 4, , 5]);
                  conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState, extra });
                  if (!isThenable(conditionResult))
                    return [3, 2];
                  return [4, conditionResult];
                case 1:
                  conditionResult = _c.sent();
                  _c.label = 2;
                case 2:
                  if (conditionResult === false || abortController.signal.aborted) {
                    throw {
                      name: "ConditionError",
                      message: "Aborted due to condition callback returning false."
                    };
                  }
                  abortedPromise = new Promise(function(_2, reject) {
                    return abortController.signal.addEventListener("abort", function() {
                      return reject({
                        name: "AbortError",
                        message: abortReason || "Aborted"
                      });
                    });
                  });
                  dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId, arg }, { getState, extra })));
                  return [4, Promise.race([
                    abortedPromise,
                    Promise.resolve(payloadCreator(arg, {
                      dispatch,
                      getState,
                      extra,
                      requestId,
                      signal: abortController.signal,
                      abort,
                      rejectWithValue: function(value, meta) {
                        return new RejectWithValue(value, meta);
                      },
                      fulfillWithValue: function(value, meta) {
                        return new FulfillWithMeta(value, meta);
                      }
                    })).then(function(result) {
                      if (result instanceof RejectWithValue) {
                        throw result;
                      }
                      if (result instanceof FulfillWithMeta) {
                        return fulfilled(result.payload, requestId, arg, result.meta);
                      }
                      return fulfilled(result, requestId, arg);
                    })
                  ])];
                case 3:
                  finalAction = _c.sent();
                  return [3, 5];
                case 4:
                  err_1 = _c.sent();
                  finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                  return [3, 5];
                case 5:
                  skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                  if (!skipDispatch) {
                    dispatch(finalAction);
                  }
                  return [2, finalAction];
              }
            });
          });
        }();
        return Object.assign(promise2, {
          abort,
          requestId,
          arg,
          unwrap: function() {
            return promise2.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = function() {
    return createAsyncThunk2;
  };
  return createAsyncThunk2;
})();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var alm = "listenerMiddleware";
createAction(alm + "/add");
createAction(alm + "/removeAll");
createAction(alm + "/remove");
var promise;
typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
  return (promise || (promise = Promise.resolve())).then(cb2).catch(function(err) {
    return setTimeout(function() {
      throw err;
    }, 0);
  });
};
N$1();
function bind(fn2, thisArg) {
  return function wrap2() {
    return fn2.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type4) => {
  type4 = type4.toLowerCase();
  return (thing) => kindOf(thing) === type4;
};
const typeOfTest = (type4) => (thing) => typeof thing === type4;
const { isArray: isArray$4 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer$3(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$3(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$3 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$5 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$5(val) && isFunction$3(val.pipe);
const isFormData = (thing) => {
  const pattern4 = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern4 || isFunction$3(thing.toString) && thing.toString() === pattern4);
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim$1 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$4(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys2[i2];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i2 = keys2.length;
  let _key;
  while (i2-- > 0) {
    _key = keys2[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = typeof self === "undefined" ? typeof global === "undefined" ? globalThis : global : self;
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge$1() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge$1(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge$1({}, val);
    } else if (isArray$4(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction$3(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray$4 = (thing) => {
  if (!thing)
    return null;
  if (isArray$4(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray$3 = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn2) => {
  const generator2 = obj && obj[Symbol.iterator];
  const iterator = generator2.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[_-\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$9 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction$3(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction$3(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray$4(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop$2 = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject$5(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray$4(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const utils$1 = {
  isArray: isArray$4,
  isArrayBuffer,
  isBuffer: isBuffer$3,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject: isObject$5,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$3,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$3,
  isFileList,
  forEach,
  merge: merge$1,
  extend,
  trim: trim$1,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$4,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$9,
  hasOwnProp: hasOwnProperty$9,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  toJSONObject
};
function AxiosError(message2, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message2;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var browser = typeof self == "object" ? self.FormData : window.FormData;
const FormData$2 = browser;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2)
    return key;
  return path2.concat(key).map(function each2(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function isSpecCompliant(thing) {
  return thing && utils$1.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
}
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData$2 || FormData)();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && isSpecCompliant(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]") && (arr = utils$1.toArray(value)))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el2, index2) {
          !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each2(el2, key) {
      const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$1.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$2(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$2);
  } : encode$2;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode$1(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode$1;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn2) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = FormData;
const isStandardBrowserEnv = (() => {
  let product2;
  if (typeof navigator !== "undefined" && ((product2 = navigator.product) === "ReactNative" || product2 === "NativeScript" || product2 === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i2;
  const len = keys2.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys2[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index2) {
    let name2 = path2[index2++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path2.length;
    name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$1.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path2, value, target[name2], index2);
    if (result && utils$1.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils$1.forEach(["delete", "get", "head"], function forEachMethodNoData(method4) {
  defaults.headers[method4] = {};
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method4) {
  defaults.headers[method4] = utils$1.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i2 = line2.indexOf(":");
    key = line2.substring(0, i2).trim().toLowerCase();
    val = line2.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value, header, filter3) {
  if (utils$1.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$1.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
utils$1.freezeMethods(AxiosHeaders.prototype);
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn2) {
    data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message2, config, request) {
  AxiosError.call(this, message2 == null ? "canceled" : message2, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
const httpAdapter = null;
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
  return {
    write: function write(name2, value, expires, path2, domain, secure) {
      const cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils$1.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$1.isString(path2)) {
        cookie.push("path=" + path2);
      }
      if (utils$1.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove2(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? function standardBrowserEnv2() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url2) {
    let href = url2;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function parseProtocol(url2) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match && match[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils$1.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters2[i2];
      if (adapter = utils$1.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils$1.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils$1.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils$1.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge3 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge3(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge3 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.2.1";
const validators$2 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type4, i2) => {
  validators$2[type4] = function validator2(thing) {
    return typeof thing === type4 || "a" + (i2 < 1 ? "n " : " ") + type4;
  };
});
const deprecatedWarnings = {};
validators$2.transitional = function transitional(validator2, version2, message2) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i2 = keys2.length;
  while (i2-- > 0) {
    const opt = keys2[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$2
};
const validators$1 = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators$1.transitional(validators$1.boolean),
        forcedJSONParsing: validators$1.transitional(validators$1.boolean),
        clarifyTimeoutError: validators$1.transitional(validators$1.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator.assertOptions(paramsSerializer, {
        encode: validators$1.function,
        serialize: validators$1.function
      }, true);
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method4) => {
        delete headers[method4];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config);
      while (i2 < len) {
        promise2 = promise2.then(chain[i2++], chain[i2++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise2 = promise2.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise2;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method4) {
  Axios.prototype[method4] = function(url2, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method4,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData2(method4) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method4,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data
      }));
    };
  }
  Axios.prototype[method4] = generateHTTPMethod();
  Axios.prototype[method4 + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message2, config, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message2, config, request);
      resolvePromise(token2.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
function createInstance(defaultConfig2) {
  const context = new Axios$1(defaultConfig2);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig2, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.default = axios;
const axios$1 = axios;
const axiosAuthApi = axios$1.create({
  baseURL: "https://dev.bona.com.do:9797/api/v1"
});
axiosAuthApi.interceptors.response.use(
  (response) => {
    const { status, statusText } = response;
    const { Messages, Data, IsSuccessStatusCode } = response.data;
    return {
      status,
      statusText,
      data: Data,
      messages: Messages,
      isSuccessStatusCode: IsSuccessStatusCode
    };
  },
  (error) => {
    let status, statusText, Errors = null, IsSuccessStatusCode = false;
    if (error.response) {
      ({ status, statusText } = error);
      ({ Errors, IsSuccessStatusCode } = error.response.data);
    } else {
      status = error.code;
      statusText = error.message;
      Errors = [{ Message: error.message, StatusError: error.code }];
      IsSuccessStatusCode = false;
    }
    throw {
      isSuccessStatusCode: IsSuccessStatusCode,
      statusText,
      statusCode: status,
      details: Errors.map((error2) => {
        return {
          message: error2.Message,
          statusError: error2.StatusError,
          description: error2.Description,
          stackTrace: error2.StackTrace
        };
      })
    };
  }
);
const authSlice = createSlice({
  name: "auth",
  initialState: {
    status: "checking",
    id: null,
    email: null,
    displayName: null,
    username: null,
    errorMessage: null
  },
  reducers: {
    onLogin: (state, { payload }) => {
      state.status = "authenticated";
      state.id = payload.id;
      state.email = payload.email;
      state.displayName = payload.displayName;
      state.username = payload.username;
      state.errorMessage = null;
    },
    onLogout: (state, { payload }) => {
      var _a;
      state.status = "not-authenticated";
      state.id = null;
      state.email = null;
      state.displayName = null;
      state.username = null;
      state.errorMessage = (_a = payload == null ? void 0 : payload.errorMessage) != null ? _a : null;
    },
    onCheckingCredentials: (state) => {
      state.errorMessage = null;
      state.status = "checking";
    },
    onSetDisplayName: (state, { payload }) => {
      state.displayName = payload;
    }
  }
});
const {
  onLogin,
  onLogout,
  onCheckingCredentials,
  onSetDisplayName
} = authSlice.actions;
//! https://react-redux.js.org/tutorials/quick-start
const uiSlice = createSlice({
  name: "ui",
  initialState: {
    approvalModal: {
      isApprovalModalOpen: false,
      okText: "",
      cancelText: "",
      title: "",
      onOk: () => {
      },
      onCancel: () => {
      },
      showTextArea: false
    }
  },
  reducers: {
    onOpenApprovalModal: (state, { payload }) => {
      state.approvalModal.isApprovalModalOpen = true;
      state.approvalModal.okText = payload.okText;
      state.approvalModal.cancelText = payload.cancelText;
      state.approvalModal.title = payload.title;
      state.approvalModal.onOk = payload.onOk;
      state.approvalModal.onCancel = payload.onCancel;
      state.approvalModal.showTextArea = payload.showTextArea;
    },
    onCloseApprovalModal: (state) => {
      state.approvalModal.isApprovalModalOpen = false;
    }
  }
});
//! https://react-redux.js.org/tutorials/quick-start
const store = configureStore({
  reducer: {
    auth: authSlice.reducer,
    ui: uiSlice.reducer
  },
  middleware: (getDefaultMiddleware2) => getDefaultMiddleware2({
    serializableCheck: false
  }).concat()
});
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t2 in e2)
        e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const u = (t2) => "number" == typeof t2 && !isNaN(t2), d = (t2) => "string" == typeof t2, p = (t2) => "function" == typeof t2, m = (t2) => d(t2) || p(t2) ? t2 : null, f = (t2) => react.exports.isValidElement(t2) || d(t2) || p(t2) || u(t2);
function g(t2, e2, n2) {
  void 0 === n2 && (n2 = 300);
  const {
    scrollHeight: o2,
    style: s2
  } = t2;
  requestAnimationFrame(() => {
    s2.minHeight = "initial", s2.height = o2 + "px", s2.transition = `all ${n2}ms`, requestAnimationFrame(() => {
      s2.height = "0", s2.padding = "0", s2.margin = "0", setTimeout(e2, n2);
    });
  });
}
function h(e2) {
  let {
    enter: a2,
    exit: r2,
    appendPosition: i2 = false,
    collapse: l2 = true,
    collapseDuration: c2 = 300
  } = e2;
  return function(e3) {
    let {
      children: u2,
      position: d2,
      preventExitTransition: p2,
      done: m2,
      nodeRef: f2,
      isIn: h2
    } = e3;
    const y2 = i2 ? `${a2}--${d2}` : a2, v2 = i2 ? `${r2}--${d2}` : r2, T2 = react.exports.useRef(0);
    return react.exports.useLayoutEffect(() => {
      const t2 = f2.current, e4 = y2.split(" "), n2 = (o2) => {
        o2.target === f2.current && (t2.dispatchEvent(new Event("d")), t2.removeEventListener("animationend", n2), t2.removeEventListener("animationcancel", n2), 0 === T2.current && "animationcancel" !== o2.type && t2.classList.remove(...e4));
      };
      t2.classList.add(...e4), t2.addEventListener("animationend", n2), t2.addEventListener("animationcancel", n2);
    }, []), react.exports.useEffect(() => {
      const t2 = f2.current, e4 = () => {
        t2.removeEventListener("animationend", e4), l2 ? g(t2, m2, c2) : m2();
      };
      h2 || (p2 ? e4() : (T2.current = 1, t2.className += ` ${v2}`, t2.addEventListener("animationend", e4)));
    }, [h2]), React.createElement(React.Fragment, null, u2);
  };
}
function y(t2, e2) {
  return {
    content: t2.content,
    containerId: t2.props.containerId,
    id: t2.props.toastId,
    theme: t2.props.theme,
    type: t2.props.type,
    data: t2.props.data || {},
    isLoading: t2.props.isLoading,
    icon: t2.props.icon,
    status: e2
  };
}
const v = {
  list: /* @__PURE__ */ new Map(),
  emitQueue: /* @__PURE__ */ new Map(),
  on(t2, e2) {
    return this.list.has(t2) || this.list.set(t2, []), this.list.get(t2).push(e2), this;
  },
  off(t2, e2) {
    if (e2) {
      const n2 = this.list.get(t2).filter((t3) => t3 !== e2);
      return this.list.set(t2, n2), this;
    }
    return this.list.delete(t2), this;
  },
  cancelEmit(t2) {
    const e2 = this.emitQueue.get(t2);
    return e2 && (e2.forEach(clearTimeout), this.emitQueue.delete(t2)), this;
  },
  emit(t2) {
    this.list.has(t2) && this.list.get(t2).forEach((e2) => {
      const n2 = setTimeout(() => {
        e2(...[].slice.call(arguments, 1));
      }, 0);
      this.emitQueue.has(t2) || this.emitQueue.set(t2, []), this.emitQueue.get(t2).push(n2);
    });
  }
}, T = (e2) => {
  let {
    theme: n2,
    type: o2,
    ...s2
  } = e2;
  return /* @__PURE__ */ jsx("svg", {
    viewBox: "0 0 24 24",
    width: "100%",
    height: "100%",
    fill: "colored" === n2 ? "currentColor" : `var(--toastify-icon-color-${o2})`,
    ...s2
  });
}, E = {
  info: function(e2) {
    return /* @__PURE__ */ jsx(T, {
      ...e2,
      children: /* @__PURE__ */ jsx("path", {
        d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z"
      })
    });
  },
  warning: function(e2) {
    return /* @__PURE__ */ jsx(T, {
      ...e2,
      children: /* @__PURE__ */ jsx("path", {
        d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z"
      })
    });
  },
  success: function(e2) {
    return /* @__PURE__ */ jsx(T, {
      ...e2,
      children: /* @__PURE__ */ jsx("path", {
        d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z"
      })
    });
  },
  error: function(e2) {
    return /* @__PURE__ */ jsx(T, {
      ...e2,
      children: /* @__PURE__ */ jsx("path", {
        d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z"
      })
    });
  },
  spinner: function() {
    return /* @__PURE__ */ jsx("div", {
      className: "Toastify__spinner"
    });
  }
};
function C(t2) {
  const [, o2] = react.exports.useReducer((t3) => t3 + 1, 0), [l2, c2] = react.exports.useState([]), g2 = react.exports.useRef(null), h2 = react.exports.useRef(/* @__PURE__ */ new Map()).current, T2 = (t3) => -1 !== l2.indexOf(t3), C2 = react.exports.useRef({
    toastKey: 1,
    displayedToast: 0,
    count: 0,
    queue: [],
    props: t2,
    containerId: null,
    isToastActive: T2,
    getToast: (t3) => h2.get(t3)
  }).current;
  function I2(t3) {
    let {
      containerId: e2
    } = t3;
    const {
      limit: n2
    } = C2.props;
    !n2 || e2 && C2.containerId !== e2 || (C2.count -= C2.queue.length, C2.queue = []);
  }
  function b2(t3) {
    c2((e2) => null == t3 ? [] : e2.filter((e3) => e3 !== t3));
  }
  function _2() {
    const {
      toastContent: t3,
      toastProps: e2,
      staleId: n2
    } = C2.queue.shift();
    O2(t3, e2, n2);
  }
  function L2(t3, n2) {
    let {
      delay: s2,
      staleId: r2,
      ...i2
    } = n2;
    if (!f(t3) || function(t4) {
      return !g2.current || C2.props.enableMultiContainer && t4.containerId !== C2.props.containerId || h2.has(t4.toastId) && null == t4.updateId;
    }(i2))
      return;
    const {
      toastId: l3,
      updateId: c3,
      data: T3
    } = i2, {
      props: I3
    } = C2, L3 = () => b2(l3), N2 = null == c3;
    N2 && C2.count++;
    const M2 = {
      ...I3,
      style: I3.toastStyle,
      key: C2.toastKey++,
      ...i2,
      toastId: l3,
      updateId: c3,
      data: T3,
      closeToast: L3,
      isIn: false,
      className: m(i2.className || I3.toastClassName),
      bodyClassName: m(i2.bodyClassName || I3.bodyClassName),
      progressClassName: m(i2.progressClassName || I3.progressClassName),
      autoClose: !i2.isLoading && (R2 = i2.autoClose, w2 = I3.autoClose, false === R2 || u(R2) && R2 > 0 ? R2 : w2),
      deleteToast() {
        const t4 = y(h2.get(l3), "removed");
        h2.delete(l3), v.emit(4, t4);
        const e2 = C2.queue.length;
        if (C2.count = null == l3 ? C2.count - C2.displayedToast : C2.count - 1, C2.count < 0 && (C2.count = 0), e2 > 0) {
          const t5 = null == l3 ? C2.props.limit : 1;
          if (1 === e2 || 1 === t5)
            C2.displayedToast++, _2();
          else {
            const n3 = t5 > e2 ? e2 : t5;
            C2.displayedToast = n3;
            for (let t6 = 0; t6 < n3; t6++)
              _2();
          }
        } else
          o2();
      }
    };
    var R2, w2;
    M2.iconOut = function(t4) {
      let {
        theme: n3,
        type: o3,
        isLoading: s3,
        icon: r3
      } = t4, i3 = null;
      const l4 = {
        theme: n3,
        type: o3
      };
      return false === r3 || (p(r3) ? i3 = r3(l4) : react.exports.isValidElement(r3) ? i3 = react.exports.cloneElement(r3, l4) : d(r3) || u(r3) ? i3 = r3 : s3 ? i3 = E.spinner() : ((t5) => t5 in E)(o3) && (i3 = E[o3](l4))), i3;
    }(M2), p(i2.onOpen) && (M2.onOpen = i2.onOpen), p(i2.onClose) && (M2.onClose = i2.onClose), M2.closeButton = I3.closeButton, false === i2.closeButton || f(i2.closeButton) ? M2.closeButton = i2.closeButton : true === i2.closeButton && (M2.closeButton = !f(I3.closeButton) || I3.closeButton);
    let x2 = t3;
    react.exports.isValidElement(t3) && !d(t3.type) ? x2 = react.exports.cloneElement(t3, {
      closeToast: L3,
      toastProps: M2,
      data: T3
    }) : p(t3) && (x2 = t3({
      closeToast: L3,
      toastProps: M2,
      data: T3
    })), I3.limit && I3.limit > 0 && C2.count > I3.limit && N2 ? C2.queue.push({
      toastContent: x2,
      toastProps: M2,
      staleId: r2
    }) : u(s2) ? setTimeout(() => {
      O2(x2, M2, r2);
    }, s2) : O2(x2, M2, r2);
  }
  function O2(t3, e2, n2) {
    const {
      toastId: o3
    } = e2;
    n2 && h2.delete(n2);
    const s2 = {
      content: t3,
      props: e2
    };
    h2.set(o3, s2), c2((t4) => [...t4, o3].filter((t5) => t5 !== n2)), v.emit(4, y(s2, null == s2.props.updateId ? "added" : "updated"));
  }
  return react.exports.useEffect(() => (C2.containerId = t2.containerId, v.cancelEmit(3).on(0, L2).on(1, (t3) => g2.current && b2(t3)).on(5, I2).emit(2, C2), () => {
    h2.clear(), v.emit(3, C2);
  }), []), react.exports.useEffect(() => {
    C2.props = t2, C2.isToastActive = T2, C2.displayedToast = l2.length;
  }), {
    getToastToRender: function(e2) {
      const n2 = /* @__PURE__ */ new Map(), o3 = Array.from(h2.values());
      return t2.newestOnTop && o3.reverse(), o3.forEach((t3) => {
        const {
          position: e3
        } = t3.props;
        n2.has(e3) || n2.set(e3, []), n2.get(e3).push(t3);
      }), Array.from(n2, (t3) => e2(t3[0], t3[1]));
    },
    containerRef: g2,
    isToastActive: T2
  };
}
function I(t2) {
  return t2.targetTouches && t2.targetTouches.length >= 1 ? t2.targetTouches[0].clientX : t2.clientX;
}
function b(t2) {
  return t2.targetTouches && t2.targetTouches.length >= 1 ? t2.targetTouches[0].clientY : t2.clientY;
}
function _(t2) {
  const [o2, a2] = react.exports.useState(false), [r2, l2] = react.exports.useState(false), c2 = react.exports.useRef(null), u2 = react.exports.useRef({
    start: 0,
    x: 0,
    y: 0,
    delta: 0,
    removalDistance: 0,
    canCloseOnClick: true,
    canDrag: false,
    boundingRect: null,
    didMove: false
  }).current, d2 = react.exports.useRef(t2), {
    autoClose: m2,
    pauseOnHover: f2,
    closeToast: g2,
    onClick: h2,
    closeOnClick: y2
  } = t2;
  function v2(e2) {
    if (t2.draggable) {
      "touchstart" === e2.nativeEvent.type && e2.nativeEvent.preventDefault(), u2.didMove = false, document.addEventListener("mousemove", _2), document.addEventListener("mouseup", L2), document.addEventListener("touchmove", _2), document.addEventListener("touchend", L2);
      const n2 = c2.current;
      u2.canCloseOnClick = true, u2.canDrag = true, u2.boundingRect = n2.getBoundingClientRect(), n2.style.transition = "", u2.x = I(e2.nativeEvent), u2.y = b(e2.nativeEvent), "x" === t2.draggableDirection ? (u2.start = u2.x, u2.removalDistance = n2.offsetWidth * (t2.draggablePercent / 100)) : (u2.start = u2.y, u2.removalDistance = n2.offsetHeight * (80 === t2.draggablePercent ? 1.5 * t2.draggablePercent : t2.draggablePercent / 100));
    }
  }
  function T2(e2) {
    if (u2.boundingRect) {
      const {
        top: n2,
        bottom: o3,
        left: s2,
        right: a3
      } = u2.boundingRect;
      "touchend" !== e2.nativeEvent.type && t2.pauseOnHover && u2.x >= s2 && u2.x <= a3 && u2.y >= n2 && u2.y <= o3 ? C2() : E2();
    }
  }
  function E2() {
    a2(true);
  }
  function C2() {
    a2(false);
  }
  function _2(e2) {
    const n2 = c2.current;
    u2.canDrag && n2 && (u2.didMove = true, o2 && C2(), u2.x = I(e2), u2.y = b(e2), u2.delta = "x" === t2.draggableDirection ? u2.x - u2.start : u2.y - u2.start, u2.start !== u2.x && (u2.canCloseOnClick = false), n2.style.transform = `translate${t2.draggableDirection}(${u2.delta}px)`, n2.style.opacity = "" + (1 - Math.abs(u2.delta / u2.removalDistance)));
  }
  function L2() {
    document.removeEventListener("mousemove", _2), document.removeEventListener("mouseup", L2), document.removeEventListener("touchmove", _2), document.removeEventListener("touchend", L2);
    const e2 = c2.current;
    if (u2.canDrag && u2.didMove && e2) {
      if (u2.canDrag = false, Math.abs(u2.delta) > u2.removalDistance)
        return l2(true), void t2.closeToast();
      e2.style.transition = "transform 0.2s, opacity 0.2s", e2.style.transform = `translate${t2.draggableDirection}(0)`, e2.style.opacity = "1";
    }
  }
  react.exports.useEffect(() => {
    d2.current = t2;
  }), react.exports.useEffect(() => (c2.current && c2.current.addEventListener("d", E2, {
    once: true
  }), p(t2.onOpen) && t2.onOpen(react.exports.isValidElement(t2.children) && t2.children.props), () => {
    const t3 = d2.current;
    p(t3.onClose) && t3.onClose(react.exports.isValidElement(t3.children) && t3.children.props);
  }), []), react.exports.useEffect(() => (t2.pauseOnFocusLoss && (document.hasFocus() || C2(), window.addEventListener("focus", E2), window.addEventListener("blur", C2)), () => {
    t2.pauseOnFocusLoss && (window.removeEventListener("focus", E2), window.removeEventListener("blur", C2));
  }), [t2.pauseOnFocusLoss]);
  const O2 = {
    onMouseDown: v2,
    onTouchStart: v2,
    onMouseUp: T2,
    onTouchEnd: T2
  };
  return m2 && f2 && (O2.onMouseEnter = C2, O2.onMouseLeave = E2), y2 && (O2.onClick = (t3) => {
    h2 && h2(t3), u2.canCloseOnClick && g2();
  }), {
    playToast: E2,
    pauseToast: C2,
    isRunning: o2,
    preventExitTransition: r2,
    toastRef: c2,
    eventHandlers: O2
  };
}
function L(e2) {
  let {
    closeToast: n2,
    theme: o2,
    ariaLabel: s2 = "close"
  } = e2;
  return /* @__PURE__ */ jsx("button", {
    className: `Toastify__close-button Toastify__close-button--${o2}`,
    type: "button",
    onClick: (t2) => {
      t2.stopPropagation(), n2(t2);
    },
    "aria-label": s2,
    children: /* @__PURE__ */ jsx("svg", {
      "aria-hidden": "true",
      viewBox: "0 0 14 16",
      children: /* @__PURE__ */ jsx("path", {
        fillRule: "evenodd",
        d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
      })
    })
  });
}
function O(e2) {
  let {
    delay: n2,
    isRunning: o2,
    closeToast: s2,
    type: a2 = "default",
    hide: r2,
    className: i2,
    style: l2,
    controlledProgress: u2,
    progress: d2,
    rtl: m2,
    isIn: f2,
    theme: g2
  } = e2;
  const h2 = r2 || u2 && 0 === d2, y2 = {
    ...l2,
    animationDuration: `${n2}ms`,
    animationPlayState: o2 ? "running" : "paused",
    opacity: h2 ? 0 : 1
  };
  u2 && (y2.transform = `scaleX(${d2})`);
  const v2 = clsx("Toastify__progress-bar", u2 ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", `Toastify__progress-bar-theme--${g2}`, `Toastify__progress-bar--${a2}`, {
    "Toastify__progress-bar--rtl": m2
  }), T2 = p(i2) ? i2({
    rtl: m2,
    type: a2,
    defaultClassName: v2
  }) : clsx(v2, i2);
  return React.createElement("div", {
    role: "progressbar",
    "aria-hidden": h2 ? "true" : "false",
    "aria-label": "notification timer",
    className: T2,
    style: y2,
    [u2 && d2 >= 1 ? "onTransitionEnd" : "onAnimationEnd"]: u2 && d2 < 1 ? null : () => {
      f2 && s2();
    }
  });
}
const N = (n2) => {
  const {
    isRunning: o2,
    preventExitTransition: s2,
    toastRef: r2,
    eventHandlers: i2
  } = _(n2), {
    closeButton: l2,
    children: u2,
    autoClose: d2,
    onClick: m2,
    type: f2,
    hideProgressBar: g2,
    closeToast: h2,
    transition: y2,
    position: v2,
    className: T2,
    style: E2,
    bodyClassName: C2,
    bodyStyle: I2,
    progressClassName: b2,
    progressStyle: N2,
    updateId: M2,
    role: R2,
    progress: w2,
    rtl: x2,
    toastId: $,
    deleteToast: k2,
    isIn: P2,
    isLoading: B2,
    iconOut: D2,
    closeOnClick: A2,
    theme: z2
  } = n2, F2 = clsx("Toastify__toast", `Toastify__toast-theme--${z2}`, `Toastify__toast--${f2}`, {
    "Toastify__toast--rtl": x2
  }, {
    "Toastify__toast--close-on-click": A2
  }), H2 = p(T2) ? T2({
    rtl: x2,
    position: v2,
    type: f2,
    defaultClassName: F2
  }) : clsx(F2, T2), S2 = !!w2 || !d2, q2 = {
    closeToast: h2,
    type: f2,
    theme: z2
  };
  let Q2 = null;
  return false === l2 || (Q2 = p(l2) ? l2(q2) : react.exports.isValidElement(l2) ? react.exports.cloneElement(l2, q2) : L(q2)), React.createElement(y2, {
    isIn: P2,
    done: k2,
    position: v2,
    preventExitTransition: s2,
    nodeRef: r2
  }, /* @__PURE__ */ jsxs("div", {
    id: $,
    onClick: m2,
    className: H2,
    ...i2,
    style: E2,
    ref: r2,
    children: [/* @__PURE__ */ jsxs("div", {
      ...P2 && {
        role: R2
      },
      className: p(C2) ? C2({
        type: f2
      }) : clsx("Toastify__toast-body", C2),
      style: I2,
      children: [null != D2 && /* @__PURE__ */ jsx("div", {
        className: clsx("Toastify__toast-icon", {
          "Toastify--animate-icon Toastify__zoom-enter": !B2
        }),
        children: D2
      }), /* @__PURE__ */ jsx("div", {
        children: u2
      })]
    }), Q2, /* @__PURE__ */ jsx(O, {
      ...M2 && !S2 ? {
        key: `pb-${M2}`
      } : {},
      rtl: x2,
      theme: z2,
      delay: d2,
      isRunning: o2,
      isIn: P2,
      closeToast: h2,
      hide: g2,
      type: f2,
      style: N2,
      className: b2,
      controlledProgress: S2,
      progress: w2 || 0
    })]
  }));
}, M = function(t2, e2) {
  return void 0 === e2 && (e2 = false), {
    enter: `Toastify--animate Toastify__${t2}-enter`,
    exit: `Toastify--animate Toastify__${t2}-exit`,
    appendPosition: e2
  };
}, R = h(M("bounce", true));
h(M("slide", true));
h(M("zoom"));
h(M("flip"));
const k = react.exports.forwardRef((e2, n2) => {
  const {
    getToastToRender: o2,
    containerRef: a2,
    isToastActive: r2
  } = C(e2), {
    className: i2,
    style: l2,
    rtl: u2,
    containerId: d2
  } = e2;
  function f2(t2) {
    const e3 = clsx("Toastify__toast-container", `Toastify__toast-container--${t2}`, {
      "Toastify__toast-container--rtl": u2
    });
    return p(i2) ? i2({
      position: t2,
      rtl: u2,
      defaultClassName: e3
    }) : clsx(e3, m(i2));
  }
  return react.exports.useEffect(() => {
    n2 && (n2.current = a2.current);
  }, []), /* @__PURE__ */ jsx("div", {
    ref: a2,
    className: "Toastify",
    id: d2,
    children: o2((e3, n3) => {
      const o3 = n3.length ? {
        ...l2
      } : {
        ...l2,
        pointerEvents: "none"
      };
      return /* @__PURE__ */ jsx("div", {
        className: f2(e3),
        style: o3,
        children: n3.map((e4, o4) => {
          let {
            content: s2,
            props: a3
          } = e4;
          return /* @__PURE__ */ react.exports.createElement(N, {
            ...a3,
            isIn: r2(a3.toastId),
            style: {
              ...a3.style,
              "--nth": o4 + 1,
              "--len": n3.length
            },
            key: `toast-${a3.key}`
          }, s2);
        })
      }, `container-${e3}`);
    })
  });
});
k.displayName = "ToastContainer", k.defaultProps = {
  position: "top-right",
  transition: R,
  autoClose: 5e3,
  closeButton: L,
  pauseOnHover: true,
  pauseOnFocusLoss: true,
  closeOnClick: true,
  draggable: true,
  draggablePercent: 80,
  draggableDirection: "x",
  role: "alert",
  theme: "light"
};
let P, B = /* @__PURE__ */ new Map(), D = [], A = 1;
function z() {
  return "" + A++;
}
function F(t2) {
  return t2 && (d(t2.toastId) || u(t2.toastId)) ? t2.toastId : z();
}
function H(t2, e2) {
  return B.size > 0 ? v.emit(0, t2, e2) : D.push({
    content: t2,
    options: e2
  }), e2.toastId;
}
function S(t2, e2) {
  return {
    ...e2,
    type: e2 && e2.type || t2,
    toastId: F(e2)
  };
}
function q(t2) {
  return (e2, n2) => H(e2, S(t2, n2));
}
function Q(t2, e2) {
  return H(t2, S("default", e2));
}
Q.loading = (t2, e2) => H(t2, S("default", {
  isLoading: true,
  autoClose: false,
  closeOnClick: false,
  closeButton: false,
  draggable: false,
  ...e2
})), Q.promise = function(t2, e2, n2) {
  let o2, {
    pending: s2,
    error: a2,
    success: r2
  } = e2;
  s2 && (o2 = d(s2) ? Q.loading(s2, n2) : Q.loading(s2.render, {
    ...n2,
    ...s2
  }));
  const i2 = {
    isLoading: null,
    autoClose: null,
    closeOnClick: null,
    closeButton: null,
    draggable: null,
    delay: 100
  }, l2 = (t3, e3, s3) => {
    if (null == e3)
      return void Q.dismiss(o2);
    const a3 = {
      type: t3,
      ...i2,
      ...n2,
      data: s3
    }, r3 = d(e3) ? {
      render: e3
    } : e3;
    return o2 ? Q.update(o2, {
      ...a3,
      ...r3
    }) : Q(r3.render, {
      ...a3,
      ...r3
    }), s3;
  }, c2 = p(t2) ? t2() : t2;
  return c2.then((t3) => l2("success", r2, t3)).catch((t3) => l2("error", a2, t3)), c2;
}, Q.success = q("success"), Q.info = q("info"), Q.error = q("error"), Q.warning = q("warning"), Q.warn = Q.warning, Q.dark = (t2, e2) => H(t2, S("default", {
  theme: "dark",
  ...e2
})), Q.dismiss = (t2) => {
  B.size > 0 ? v.emit(1, t2) : D = D.filter((e2) => null != t2 && e2.options.toastId !== t2);
}, Q.clearWaitingQueue = function(t2) {
  return void 0 === t2 && (t2 = {}), v.emit(5, t2);
}, Q.isActive = (t2) => {
  let e2 = false;
  return B.forEach((n2) => {
    n2.isToastActive && n2.isToastActive(t2) && (e2 = true);
  }), e2;
}, Q.update = function(t2, e2) {
  void 0 === e2 && (e2 = {}), setTimeout(() => {
    const n2 = function(t3, e3) {
      let {
        containerId: n3
      } = e3;
      const o2 = B.get(n3 || P);
      return o2 && o2.getToast(t3);
    }(t2, e2);
    if (n2) {
      const {
        props: o2,
        content: s2
      } = n2, a2 = {
        ...o2,
        ...e2,
        toastId: e2.toastId || t2,
        updateId: z()
      };
      a2.toastId !== t2 && (a2.staleId = t2);
      const r2 = a2.render || s2;
      delete a2.render, H(r2, a2);
    }
  }, 0);
}, Q.done = (t2) => {
  Q.update(t2, {
    progress: 1
  });
}, Q.onChange = (t2) => (v.on(4, t2), () => {
  v.off(4, t2);
}), Q.POSITION = {
  TOP_LEFT: "top-left",
  TOP_RIGHT: "top-right",
  TOP_CENTER: "top-center",
  BOTTOM_LEFT: "bottom-left",
  BOTTOM_RIGHT: "bottom-right",
  BOTTOM_CENTER: "bottom-center"
}, Q.TYPE = {
  INFO: "info",
  SUCCESS: "success",
  WARNING: "warning",
  ERROR: "error",
  DEFAULT: "default"
}, v.on(2, (t2) => {
  P = t2.containerId || t2, B.set(P, t2), D.forEach((t3) => {
    v.emit(0, t3.content, t3.options);
  }), D = [];
}).on(3, (t2) => {
  B.delete(t2.containerId || t2), 0 === B.size && v.off(0).off(1).off(5);
});
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$1(o2);
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof$1(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        var arg = arguments[i2];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
const classNames = classnames.exports;
function toArray$3(children) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var ret = [];
  React.Children.forEach(children, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray$3(child));
    } else if (reactIs$2.exports.isFragment(child) && child.props) {
      ret = ret.concat(toArray$3(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
var warned = {};
function warning$3(valid, message2) {
}
function call(method4, valid, message2) {
  if (!valid && !warned[message2]) {
    method4(false, message2);
    warned[message2] = true;
  }
}
function warningOnce(valid, message2) {
  call(warning$3, valid, message2);
}
function useMemo(getValue2, condition, shouldUpdate) {
  var cacheRef = react.exports.useRef({});
  if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue2();
    cacheRef.current.condition = condition;
  }
  return cacheRef.current.value;
}
function fillRef(ref, node2) {
  if (typeof ref === "function") {
    ref(node2);
  } else if (_typeof$1(ref) === "object" && ref && "current" in ref) {
    ref.current = node2;
  }
}
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node2) {
    refs.forEach(function(ref) {
      fillRef(ref, node2);
    });
  };
}
function useComposeRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }
  return useMemo(function() {
    return composeRef.apply(void 0, refs);
  }, refs, function(prev2, next2) {
    return prev2.length === next2.length && prev2.every(function(ref, i2) {
      return ref === next2[i2];
    });
  });
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type4 = reactIs$2.exports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type4 === "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
    return false;
  }
  if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
    return false;
  }
  return true;
}
function findDOMNode(node2) {
  if (node2 instanceof HTMLElement) {
    return node2;
  }
  if (node2 instanceof React.Component) {
    return ReactDOM.findDOMNode(node2);
  }
  return null;
}
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return function() {
    function class_1() {
      this.__entries__ = [];
    }
    Object.defineProperty(class_1.prototype, "size", {
      get: function() {
        return this.__entries__.length;
      },
      enumerable: true,
      configurable: true
    });
    class_1.prototype.get = function(key) {
      var index2 = getIndex(this.__entries__, key);
      var entry = this.__entries__[index2];
      return entry && entry[1];
    };
    class_1.prototype.set = function(key, value) {
      var index2 = getIndex(this.__entries__, key);
      if (~index2) {
        this.__entries__[index2][1] = value;
      } else {
        this.__entries__.push([key, value]);
      }
    };
    class_1.prototype.delete = function(key) {
      var entries = this.__entries__;
      var index2 = getIndex(entries, key);
      if (~index2) {
        entries.splice(index2, 1);
      }
    };
    class_1.prototype.has = function(key) {
      return !!~getIndex(this.__entries__, key);
    };
    class_1.prototype.clear = function() {
      this.__entries__.splice(0);
    };
    class_1.prototype.forEach = function(callback, ctx) {
      if (ctx === void 0) {
        ctx = null;
      }
      for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
        var entry = _a[_i];
        callback.call(ctx, entry[1], entry[0]);
      }
    };
    return class_1;
  }();
}();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle$1(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = function() {
  function ResizeObserverController2() {
    this.connected_ = false;
    this.mutationEventsAdded_ = false;
    this.mutationsObserver_ = null;
    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
  }
  ResizeObserverController2.prototype.addObserver = function(observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    }
    if (!this.connected_) {
      this.connect_();
    }
  };
  ResizeObserverController2.prototype.removeObserver = function(observer) {
    var observers2 = this.observers_;
    var index2 = observers2.indexOf(observer);
    if (~index2) {
      observers2.splice(index2, 1);
    }
    if (!observers2.length && this.connected_) {
      this.disconnect_();
    }
  };
  ResizeObserverController2.prototype.refresh = function() {
    var changesDetected = this.updateObservers_();
    if (changesDetected) {
      this.refresh();
    }
  };
  ResizeObserverController2.prototype.updateObservers_ = function() {
    var activeObservers = this.observers_.filter(function(observer) {
      return observer.gatherActive(), observer.hasActive();
    });
    activeObservers.forEach(function(observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  ResizeObserverController2.prototype.connect_ = function() {
    if (!isBrowser || this.connected_) {
      return;
    }
    document.addEventListener("transitionend", this.onTransitionEnd_);
    window.addEventListener("resize", this.refresh);
    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener("DOMSubtreeModified", this.refresh);
      this.mutationEventsAdded_ = true;
    }
    this.connected_ = true;
  };
  ResizeObserverController2.prototype.disconnect_ = function() {
    if (!isBrowser || !this.connected_) {
      return;
    }
    document.removeEventListener("transitionend", this.onTransitionEnd_);
    window.removeEventListener("resize", this.refresh);
    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }
    if (this.mutationEventsAdded_) {
      document.removeEventListener("DOMSubtreeModified", this.refresh);
    }
    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
    var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
    var isReflowProperty = transitionKeys.some(function(key) {
      return !!~propertyName.indexOf(key);
    });
    if (isReflowProperty) {
      this.refresh();
    }
  };
  ResizeObserverController2.getInstance = function() {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController2();
    }
    return this.instance_;
  };
  ResizeObserverController2.instance_ = null;
  return ResizeObserverController2;
}();
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position2) {
    var value = styles["border-" + position2 + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position2 = positions_1[_i];
    var value = styles["padding-" + position2];
    paddings[position2] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x2 = _a.x, y2 = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = function() {
  function ResizeObservation2(target) {
    this.broadcastWidth = 0;
    this.broadcastHeight = 0;
    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  ResizeObservation2.prototype.isActive = function() {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  ResizeObservation2.prototype.broadcastRect = function() {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };
  return ResizeObservation2;
}();
var ResizeObserverEntry = function() {
  function ResizeObserverEntry2(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit);
    defineConfigurable(this, { target, contentRect });
  }
  return ResizeObserverEntry2;
}();
var ResizeObserverSPI = function() {
  function ResizeObserverSPI2(callback, controller, callbackCtx) {
    this.activeObservations_ = [];
    this.observations_ = new MapShim();
    if (typeof callback !== "function") {
      throw new TypeError("The callback provided as parameter 1 is not a function.");
    }
    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  ResizeObserverSPI2.prototype.observe = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (observations.has(target)) {
      return;
    }
    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this);
    this.controller_.refresh();
  };
  ResizeObserverSPI2.prototype.unobserve = function(target) {
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    if (typeof Element === "undefined" || !(Element instanceof Object)) {
      return;
    }
    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }
    var observations = this.observations_;
    if (!observations.has(target)) {
      return;
    }
    observations.delete(target);
    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  ResizeObserverSPI2.prototype.disconnect = function() {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  ResizeObserverSPI2.prototype.gatherActive = function() {
    var _this = this;
    this.clearActive();
    this.observations_.forEach(function(observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  ResizeObserverSPI2.prototype.broadcastActive = function() {
    if (!this.hasActive()) {
      return;
    }
    var ctx = this.callbackCtx_;
    var entries = this.activeObservations_.map(function(observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  ResizeObserverSPI2.prototype.clearActive = function() {
    this.activeObservations_.splice(0);
  };
  ResizeObserverSPI2.prototype.hasActive = function() {
    return this.activeObservations_.length > 0;
  };
  return ResizeObserverSPI2;
}();
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver$2 = function() {
  function ResizeObserver2(callback) {
    if (!(this instanceof ResizeObserver2)) {
      throw new TypeError("Cannot call a class as a function.");
    }
    if (!arguments.length) {
      throw new TypeError("1 argument required, but only 0 present.");
    }
    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }
  return ResizeObserver2;
}();
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method4) {
  ResizeObserver$2.prototype[method4] = function() {
    var _a;
    return (_a = observers.get(this))[method4].apply(_a, arguments);
  };
});
var index$1 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver$2;
}();
var elementListeners = /* @__PURE__ */ new Map();
function onResize(entities) {
  entities.forEach(function(entity) {
    var _elementListeners$get;
    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
      return listener(target);
    });
  });
}
var resizeObserver = new index$1(onResize);
function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, /* @__PURE__ */ new Set());
    resizeObserver.observe(element);
  }
  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);
    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
  _inherits(DomWrapper2, _React$Component);
  var _super = _createSuper(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(react.exports.Component);
var CollectionContext = /* @__PURE__ */ react.exports.createContext(null);
function Collection(_ref) {
  var children = _ref.children, onBatchResize = _ref.onBatchResize;
  var resizeIdRef = react.exports.useRef(0);
  var resizeInfosRef = react.exports.useRef([]);
  var onCollectionResize = react.exports.useContext(CollectionContext);
  var onResize2 = react.exports.useCallback(function(size, element, data) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size,
      element,
      data
    });
    Promise.resolve().then(function() {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    });
    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return /* @__PURE__ */ jsx(CollectionContext.Provider, {
    value: onResize2,
    children
  });
}
function SingleObserver(props, ref) {
  var children = props.children, disabled = props.disabled;
  var elementRef = react.exports.useRef(null);
  var wrapperRef = react.exports.useRef(null);
  var onCollectionResize = react.exports.useContext(CollectionContext);
  var isRenderProps = typeof children === "function";
  var mergedChildren = isRenderProps ? children(elementRef) : children;
  var sizeRef = react.exports.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  });
  var canRef = !isRenderProps && /* @__PURE__ */ react.exports.isValidElement(mergedChildren) && supportRef(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = react.exports.useMemo(function() {
    return composeRef(originRef, elementRef);
  }, [originRef, elementRef]);
  var getDom = function getDom2() {
    return findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
  };
  react.exports.useImperativeHandle(ref, function() {
    return getDom();
  });
  var propsRef = react.exports.useRef(props);
  propsRef.current = props;
  var onInternalResize = react.exports.useCallback(function(target) {
    var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth,
        offsetHeight
      };
      sizeRef.current = size;
      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
      var sizeInfo = _objectSpread2$1(_objectSpread2$1({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      });
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);
      if (onResize2) {
        Promise.resolve().then(function() {
          onResize2(sizeInfo, target);
        });
      }
    }
  }, []);
  react.exports.useEffect(function() {
    var currentElement = getDom();
    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }
    return function() {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]);
  return /* @__PURE__ */ jsx(DomWrapper$1, {
    ref: wrapperRef,
    children: canRef ? /* @__PURE__ */ react.exports.cloneElement(mergedChildren, {
      ref: mergedRef
    }) : mergedChildren
  });
}
var RefSingleObserver = /* @__PURE__ */ react.exports.forwardRef(SingleObserver);
var INTERNAL_PREFIX_KEY = "rc-observer-key";
function ResizeObserver$1(props, ref) {
  var children = props.children;
  var childNodes = typeof children === "function" ? [children] : toArray$3(children);
  return childNodes.map(function(child, index2) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
    return /* @__PURE__ */ react.exports.createElement(RefSingleObserver, {
      ...props,
      key,
      ref: index2 === 0 ? ref : void 0
    }, child);
  });
}
var RefResizeObserver = /* @__PURE__ */ react.exports.forwardRef(ResizeObserver$1);
RefResizeObserver.Collection = Collection;
function omit(obj, fields) {
  var clone2 = _objectSpread2$1({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone2[key];
    });
  }
  return clone2;
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= k2 >>> 24;
    h2 = (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function isEqual$1(obj1, obj2) {
  var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var refSet = /* @__PURE__ */ new Set();
  function deepEqual2(a2, b2) {
    var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    var circular = refSet.has(a2);
    warningOnce(!circular, "Warning: There may be circular references");
    if (circular) {
      return false;
    }
    if (a2 === b2) {
      return true;
    }
    if (shallow && level > 1) {
      return false;
    }
    refSet.add(a2);
    var newLevel = level + 1;
    if (Array.isArray(a2)) {
      if (!Array.isArray(b2) || a2.length !== b2.length) {
        return false;
      }
      for (var i2 = 0; i2 < a2.length; i2++) {
        if (!deepEqual2(a2[i2], b2[i2], newLevel)) {
          return false;
        }
      }
      return true;
    }
    if (a2 && b2 && _typeof$1(a2) === "object" && _typeof$1(b2) === "object") {
      var keys2 = Object.keys(a2);
      if (keys2.length !== Object.keys(b2).length) {
        return false;
      }
      return keys2.every(function(key) {
        return deepEqual2(a2[key], b2[key], newLevel);
      });
    }
    return false;
  }
  return deepEqual2(obj1, obj2);
}
var Entity = /* @__PURE__ */ function() {
  function Entity2() {
    _classCallCheck(this, Entity2);
    _defineProperty$1(this, "cache", /* @__PURE__ */ new Map());
  }
  _createClass(Entity2, [{
    key: "get",
    value: function get2(keys2) {
      return this.cache.get(keys2.join("%")) || null;
    }
  }, {
    key: "update",
    value: function update2(keys2, valueFn) {
      var path2 = keys2.join("%");
      var prevValue = this.cache.get(path2);
      var nextValue = valueFn(prevValue);
      if (nextValue === null) {
        this.cache.delete(path2);
      } else {
        this.cache.set(path2, nextValue);
      }
    }
  }]);
  return Entity2;
}();
var ATTR_TOKEN = "data-token-hash";
var ATTR_MARK = "data-css-hash";
var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
var CSS_IN_JS_INSTANCE_ID = Math.random().toString(12).slice(2);
function createCache() {
  if (typeof document !== "undefined" && document.head && document.body) {
    var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
    var firstChild = document.head.firstChild;
    Array.from(styles).forEach(function(style2) {
      style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || CSS_IN_JS_INSTANCE_ID;
      document.head.insertBefore(style2, firstChild);
    });
    var styleHash = {};
    Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
      var hash = style2.getAttribute(ATTR_MARK);
      if (styleHash[hash]) {
        if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
          var _style$parentNode;
          (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
        }
      } else {
        styleHash[hash] = true;
      }
    });
  }
  return new Entity();
}
var StyleContext = /* @__PURE__ */ react.exports.createContext({
  hashPriority: "low",
  cache: createCache(),
  defaultCache: true
});
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i2) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i2) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
  var _React$useContext = react.exports.useContext(StyleContext), globalCache = _React$useContext.cache;
  var fullPath = [prefix].concat(_toConsumableArray(keyPath));
  react.exports.useMemo(
    function() {
      globalCache.update(fullPath, function(prevCache) {
        var _ref = prevCache || [], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
        var tmpCache = cache;
        var mergedCache = tmpCache || cacheFn();
        return [times + 1, mergedCache];
      });
    },
    [fullPath.join("_")]
  );
  react.exports.useEffect(function() {
    return function() {
      globalCache.update(fullPath, function(prevCache) {
        var _ref3 = prevCache || [], _ref4 = _slicedToArray(_ref3, 2), _ref4$ = _ref4[0], times = _ref4$ === void 0 ? 0 : _ref4$, cache = _ref4[1];
        var nextCount = times - 1;
        if (nextCount === 0) {
          onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
          return null;
        }
        return [times - 1, cache];
      });
    };
  }, fullPath);
  return globalCache.get(fullPath)[1];
}
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function contains(root2, n2) {
  if (!root2) {
    return false;
  }
  if (root2.contains) {
    return root2.contains(n2);
  }
  var node2 = n2;
  while (node2) {
    if (node2 === root2) {
      return true;
    }
    node2 = node2.parentNode;
  }
  return false;
}
var APPEND_ORDER = "data-rc-order";
var MARK_KEY = "rc-util-key";
var containerCache = /* @__PURE__ */ new Map();
function getMark() {
  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
  if (mark) {
    return mark.startsWith("data-") ? mark : "data-".concat(mark);
  }
  return MARK_KEY;
}
function getContainer(option) {
  if (option.attachTo) {
    return option.attachTo;
  }
  var head = document.querySelector("head");
  return head || document.body;
}
function getOrder(prepend) {
  if (prepend === "queue") {
    return "prependQueue";
  }
  return prepend ? "prepend" : "append";
}
function findStyles(container) {
  return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
    return node2.tagName === "STYLE";
  });
}
function injectCSS(css2) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!canUseDom()) {
    return null;
  }
  var csp = option.csp, prepend = option.prepend;
  var styleNode = document.createElement("style");
  styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
  if (csp !== null && csp !== void 0 && csp.nonce) {
    styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
  }
  styleNode.innerHTML = css2;
  var container = getContainer(option);
  var firstChild = container.firstChild;
  if (prepend) {
    if (prepend === "queue") {
      var existStyle = findStyles(container).filter(function(node2) {
        return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
      });
      if (existStyle.length) {
        container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
        return styleNode;
      }
    }
    container.insertBefore(styleNode, firstChild);
  } else {
    container.appendChild(styleNode);
  }
  return styleNode;
}
function findExistNode(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var container = getContainer(option);
  return findStyles(container).find(function(node2) {
    return node2.getAttribute(getMark(option)) === key;
  });
}
function removeCSS(key) {
  var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var existNode = findExistNode(key, option);
  if (existNode) {
    var container = getContainer(option);
    container.removeChild(existNode);
  }
}
function syncRealContainer(container, option) {
  var cachedRealContainer = containerCache.get(container);
  if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
    var placeholderStyle = injectCSS("", option);
    var parentNode = placeholderStyle.parentNode;
    containerCache.set(container, parentNode);
    container.removeChild(placeholderStyle);
  }
}
function updateCSS(css2, key) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var container = getContainer(option);
  syncRealContainer(container, option);
  var existNode = findExistNode(key, option);
  if (existNode) {
    var _option$csp, _option$csp2;
    if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
      var _option$csp3;
      existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
    }
    if (existNode.innerHTML !== css2) {
      existNode.innerHTML = css2;
    }
    return existNode;
  }
  var newNode = injectCSS(css2, option);
  newNode.setAttribute(getMark(option), key);
  return newNode;
}
function flattenToken(token2) {
  var str = "";
  Object.keys(token2).forEach(function(key) {
    var value = token2[key];
    str += key;
    if (value && _typeof$1(value) === "object") {
      str += flattenToken(value);
    } else {
      str += value;
    }
  });
  return str;
}
function token2key(token2, salt) {
  return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
}
var layerKey = "layer-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
var layerWidth = "903px";
function supportSelector(styleStr, handleElement) {
  if (canUseDom()) {
    var _ele$parentNode;
    updateCSS(styleStr, layerKey);
    var _ele = document.createElement("div");
    _ele.style.position = "fixed";
    _ele.style.left = "0";
    _ele.style.top = "0";
    handleElement === null || handleElement === void 0 ? void 0 : handleElement(_ele);
    document.body.appendChild(_ele);
    var support = getComputedStyle(_ele).width === layerWidth;
    (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 ? void 0 : _ele$parentNode.removeChild(_ele);
    removeCSS(layerKey);
    return support;
  }
  return false;
}
var canLayer = void 0;
function supportLayer() {
  if (canLayer === void 0) {
    canLayer = supportSelector("@layer ".concat(layerKey, " { .").concat(layerKey, " { width: ").concat(layerWidth, "!important; } }"), function(ele) {
      ele.className = layerKey;
    });
  }
  return canLayer;
}
var EMPTY_OVERRIDE = {};
var hashPrefix = "css";
var tokenKeys = /* @__PURE__ */ new Map();
function recordCleanToken(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
}
function removeStyleTags(key) {
  if (typeof document !== "undefined") {
    var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
    styles.forEach(function(style2) {
      if (style2[CSS_IN_JS_INSTANCE] === CSS_IN_JS_INSTANCE_ID) {
        var _style$parentNode;
        (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
      }
    });
  }
}
function cleanTokenStyle(tokenKey) {
  tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
  var tokenKeyList = Array.from(tokenKeys.keys());
  var cleanableKeyList = tokenKeyList.filter(function(key) {
    var count = tokenKeys.get(key) || 0;
    return count <= 0;
  });
  if (cleanableKeyList.length < tokenKeyList.length) {
    cleanableKeyList.forEach(function(key) {
      removeStyleTags(key);
      tokenKeys.delete(key);
    });
  }
}
function useCacheToken(theme2, tokens) {
  var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken;
  var mergedToken = react.exports.useMemo(function() {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
  }, [tokens]);
  var tokenStr = react.exports.useMemo(function() {
    return flattenToken(mergedToken);
  }, [mergedToken]);
  var overrideTokenStr = react.exports.useMemo(function() {
    return flattenToken(override);
  }, [override]);
  var cachedToken = useClientCache("token", [salt, theme2.id, tokenStr, overrideTokenStr], function() {
    var derivativeToken = theme2.getDerivativeToken(mergedToken);
    var mergedDerivativeToken = _objectSpread2$1(_objectSpread2$1({}, derivativeToken), override);
    if (formatToken2) {
      mergedDerivativeToken = formatToken2(mergedDerivativeToken);
    }
    var tokenKey = token2key(mergedDerivativeToken, salt);
    mergedDerivativeToken._tokenKey = tokenKey;
    recordCleanToken(tokenKey);
    var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
    mergedDerivativeToken._hashId = hashId;
    return [mergedDerivativeToken, hashId];
  }, function(cache) {
    cleanTokenStyle(cache[0]._tokenKey);
  });
  return cachedToken;
}
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs = Math.abs;
var from = String.fromCharCode;
function trim(value) {
  return value.trim();
}
function replace(value, pattern4, replacement) {
  return value.replace(pattern4, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append2(value, array4) {
  return array4.push(value), value;
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type4, props, children, length2) {
  return { value, root: root2, parent, type: type4, props, children, line, column, length: length2, return: "" };
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type4) {
  switch (type4) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type4) {
  return trim(slice(position - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
}
function whitespace$1(type4) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type4) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type4) {
  while (next())
    switch (character) {
      case type4:
        return position;
      case 34:
      case 39:
        if (type4 !== 34 && type4 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type4 === 41)
          delimiter(type4);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type4, index2) {
  while (next())
    if (type4 + character === 47 + 10)
      break;
    else if (type4 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type4 === 47 ? type4 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules2, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset2 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type4 = "";
  var props = rules2;
  var children = rulesets;
  var reference = rule;
  var characters2 = type4;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append2(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            if (property > 0 && strlen(characters2) - length2)
              append2(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append2(reference = ruleset(characters2, root2, parent, index2, offset2, rules2, points, type4, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset2 === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append2(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2), children), rules2, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset2 = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset2, rules2, points, type4, props, children, length2) {
  var post = offset2 - 1;
  var rule = offset2 === 0 ? rules2 : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root2, parent, offset2 === 0 ? RULESET : type4, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify$2(element, index2, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
var isClientSide = canUseDom();
var SKIP_CHECK = "_skip_check_";
function normalizeStyle(styleStr) {
  var serialized = serialize(compile(styleStr), stringify$2);
  return serialized.replace(/\{%%%\:[^;];}/g, ";");
}
function isCompoundCSSProperty(value) {
  return _typeof$1(value) === "object" && value && SKIP_CHECK in value;
}
function injectSelectorHash(key, hashId, hashPriority) {
  if (!hashId) {
    return key;
  }
  var hashClassName = ".".concat(hashId);
  var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
  var keys2 = key.split(",").map(function(k2) {
    var _firstPath$match;
    var fullPath = k2.trim().split(/\s+/);
    var firstPath = fullPath[0] || "";
    var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
    firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
    return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
  });
  return keys2.join(",");
}
var globalEffectStyleKeys = /* @__PURE__ */ new Set();
var parseStyle = function parseStyle2(interpolation) {
  var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: true,
    parentSelectors: []
  }, root2 = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
  var hashId = config.hashId, layer = config.layer;
  config.path;
  var hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
  config.linters;
  var styleStr = "";
  var effectStyle = {};
  function parseKeyframes(keyframes) {
    var animationName = keyframes.getName(hashId);
    if (!effectStyle[animationName]) {
      var _parseStyle = parseStyle2(keyframes.style, config, {
        root: false,
        parentSelectors
      }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
      effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
    }
  }
  function flattenList(list) {
    var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    list.forEach(function(item) {
      if (Array.isArray(item)) {
        flattenList(item, fullList);
      } else if (item) {
        fullList.push(item);
      }
    });
    return fullList;
  }
  var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
  flattenStyleList.forEach(function(originStyle) {
    var style2 = typeof originStyle === "string" && !root2 ? {} : originStyle;
    if (typeof style2 === "string") {
      styleStr += "".concat(style2, "\n");
    } else if (style2._keyframe) {
      parseKeyframes(style2);
    } else {
      var mergedStyle = transformers.reduce(function(prev2, trans) {
        var _trans$visit;
        return (trans === null || trans === void 0 ? void 0 : (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
      }, style2);
      Object.keys(mergedStyle).forEach(function(key) {
        var value = mergedStyle[key];
        if (_typeof$1(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
          var subInjectHash = false;
          var mergedKey = key.trim();
          var nextRoot = false;
          if ((root2 || injectHash) && hashId) {
            if (mergedKey.startsWith("@")) {
              subInjectHash = true;
            } else {
              mergedKey = injectSelectorHash(key, hashId, hashPriority);
            }
          } else if (root2 && !hashId && (mergedKey === "&" || mergedKey === "")) {
            mergedKey = "";
            nextRoot = true;
          }
          var _parseStyle3 = parseStyle2(value, config, {
            root: nextRoot,
            injectHash: subInjectHash,
            parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
          }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
          effectStyle = _objectSpread2$1(_objectSpread2$1({}, effectStyle), childEffectStyle);
          styleStr += "".concat(mergedKey).concat(_parsedStr2);
        } else {
          var _value;
          var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
          var styleName = key.replace(/[A-Z]/g, function(match) {
            return "-".concat(match.toLowerCase());
          });
          var formatValue = actualValue;
          if (!unitlessKeys[key] && typeof formatValue === "number" && formatValue !== 0) {
            formatValue = "".concat(formatValue, "px");
          }
          if (key === "animationName" && value !== null && value !== void 0 && value._keyframe) {
            parseKeyframes(value);
            formatValue = value.getName(hashId);
          }
          styleStr += "".concat(styleName, ":").concat(formatValue, ";");
        }
      });
    }
  });
  if (!root2) {
    styleStr = "{".concat(styleStr, "}");
  } else if (layer && supportLayer()) {
    var layerCells = layer.split(",");
    var layerName = layerCells[layerCells.length - 1].trim();
    styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
    if (layerCells.length > 1) {
      styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
    }
  }
  return [styleStr, effectStyle];
};
function uniqueHash(path2, styleStr) {
  return murmur2("".concat(path2.join("%")).concat(styleStr));
}
function Empty() {
  return null;
}
function useStyleRegister(info, styleFn) {
  var token2 = info.token, path2 = info.path, hashId = info.hashId, layer = info.layer;
  var _React$useContext = react.exports.useContext(StyleContext), autoClear = _React$useContext.autoClear;
  _React$useContext.mock;
  var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters;
  var tokenKey = token2._tokenKey;
  var fullPath = [tokenKey].concat(_toConsumableArray(path2));
  var isMergedClientSide = isClientSide;
  var _useGlobalCache = useClientCache(
    "style",
    fullPath,
    function() {
      var styleObj = styleFn();
      var _parseStyle5 = parseStyle(styleObj, {
        hashId,
        hashPriority,
        layer,
        path: path2.join("-"),
        transformers,
        linters
      }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
      var styleStr = normalizeStyle(parsedStyle);
      var styleId = uniqueHash(fullPath, styleStr);
      if (isMergedClientSide) {
        var style2 = updateCSS(styleStr, styleId, {
          mark: ATTR_MARK,
          prepend: "queue",
          attachTo: container
        });
        style2[CSS_IN_JS_INSTANCE] = CSS_IN_JS_INSTANCE_ID;
        style2.setAttribute(ATTR_TOKEN, tokenKey);
        Object.keys(effectStyle).forEach(function(effectKey) {
          if (!globalEffectStyleKeys.has(effectKey)) {
            globalEffectStyleKeys.add(effectKey);
            updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), {
              mark: ATTR_MARK,
              prepend: "queue",
              attachTo: container
            });
          }
        });
      }
      return [styleStr, tokenKey, styleId];
    },
    function(_ref2, fromHMR) {
      var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
      if ((fromHMR || autoClear) && isClientSide) {
        removeCSS(styleId, {
          mark: ATTR_MARK
        });
      }
    }
  ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
  return function(node2) {
    var styleNode;
    if (!ssrInline || isMergedClientSide || !defaultCache) {
      styleNode = /* @__PURE__ */ jsx(Empty, {});
    } else {
      var _ref4;
      styleNode = /* @__PURE__ */ jsx("style", {
        ...(_ref4 = {}, _defineProperty$1(_ref4, ATTR_TOKEN, cachedTokenKey), _defineProperty$1(_ref4, ATTR_MARK, cachedStyleId), _ref4),
        dangerouslySetInnerHTML: {
          __html: cachedStyleStr
        }
      });
    }
    return /* @__PURE__ */ jsxs(Fragment, {
      children: [styleNode, node2]
    });
  };
}
var Keyframe = /* @__PURE__ */ function() {
  function Keyframe2(name2, style2) {
    _classCallCheck(this, Keyframe2);
    _defineProperty$1(this, "name", void 0);
    _defineProperty$1(this, "style", void 0);
    _defineProperty$1(this, "_keyframe", true);
    this.name = name2;
    this.style = style2;
  }
  _createClass(Keyframe2, [{
    key: "getName",
    value: function getName() {
      var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
    }
  }]);
  return Keyframe2;
}();
function sameDerivativeOption(left, right) {
  if (left.length !== right.length) {
    return false;
  }
  for (var i2 = 0; i2 < left.length; i2++) {
    if (left[i2] !== right[i2]) {
      return false;
    }
  }
  return true;
}
var ThemeCache = /* @__PURE__ */ function() {
  function ThemeCache2() {
    _classCallCheck(this, ThemeCache2);
    _defineProperty$1(this, "cache", void 0);
    _defineProperty$1(this, "keys", void 0);
    _defineProperty$1(this, "cacheCallTimes", void 0);
    this.cache = /* @__PURE__ */ new Map();
    this.keys = [];
    this.cacheCallTimes = 0;
  }
  _createClass(ThemeCache2, [{
    key: "size",
    value: function size() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function internalGet(derivativeOption) {
      var _cache2, _cache3;
      var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var cache = {
        map: this.cache
      };
      derivativeOption.forEach(function(derivative2) {
        if (!cache) {
          cache = void 0;
        } else {
          var _cache, _cache$map;
          cache = (_cache = cache) === null || _cache === void 0 ? void 0 : (_cache$map = _cache.map) === null || _cache$map === void 0 ? void 0 : _cache$map.get(derivative2);
        }
      });
      if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
        cache.value[1] = this.cacheCallTimes++;
      }
      return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
    }
  }, {
    key: "get",
    value: function get2(derivativeOption) {
      var _this$internalGet;
      return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
    }
  }, {
    key: "has",
    value: function has(derivativeOption) {
      return !!this.internalGet(derivativeOption);
    }
  }, {
    key: "set",
    value: function set2(derivativeOption, value) {
      var _this = this;
      if (!this.has(derivativeOption)) {
        if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
          var _this$keys$reduce = this.keys.reduce(function(result, key) {
            var _result = _slicedToArray(result, 2), callTimes = _result[1];
            if (_this.internalGet(key)[1] < callTimes) {
              return [key, _this.internalGet(key)[1]];
            }
            return result;
          }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
          this.delete(targetKey);
        }
        this.keys.push(derivativeOption);
      }
      var cache = this.cache;
      derivativeOption.forEach(function(derivative2, index2) {
        if (index2 === derivativeOption.length - 1) {
          cache.set(derivative2, {
            value: [value, _this.cacheCallTimes++]
          });
        } else {
          var cacheValue = cache.get(derivative2);
          if (!cacheValue) {
            cache.set(derivative2, {
              map: /* @__PURE__ */ new Map()
            });
          } else if (!cacheValue.map) {
            cacheValue.map = /* @__PURE__ */ new Map();
          }
          cache = cache.get(derivative2).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function deleteByPath(currentCache, derivatives) {
      var cache = currentCache.get(derivatives[0]);
      if (derivatives.length === 1) {
        var _cache$value;
        if (!cache.map) {
          currentCache.delete(derivatives[0]);
        } else {
          currentCache.set(derivatives[0], {
            map: cache.map
          });
        }
        return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
      }
      var result = this.deleteByPath(cache.map, derivatives.slice(1));
      if ((!cache.map || cache.map.size === 0) && !cache.value) {
        currentCache.delete(derivatives[0]);
      }
      return result;
    }
  }, {
    key: "delete",
    value: function _delete(derivativeOption) {
      if (this.has(derivativeOption)) {
        this.keys = this.keys.filter(function(item) {
          return !sameDerivativeOption(item, derivativeOption);
        });
        return this.deleteByPath(this.cache, derivativeOption);
      }
      return void 0;
    }
  }]);
  return ThemeCache2;
}();
_defineProperty$1(ThemeCache, "MAX_CACHE_SIZE", 20);
_defineProperty$1(ThemeCache, "MAX_CACHE_OFFSET", 5);
var uuid$2 = 0;
var Theme = /* @__PURE__ */ function() {
  function Theme2(derivatives) {
    _classCallCheck(this, Theme2);
    _defineProperty$1(this, "derivatives", void 0);
    _defineProperty$1(this, "id", void 0);
    this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
    this.id = uuid$2;
    if (derivatives.length === 0) {
      warning$3(derivatives.length > 0);
    }
    uuid$2 += 1;
  }
  _createClass(Theme2, [{
    key: "getDerivativeToken",
    value: function getDerivativeToken(token2) {
      return this.derivatives.reduce(function(result, derivative2) {
        return derivative2(token2, result);
      }, void 0);
    }
  }]);
  return Theme2;
}();
var cacheThemes = new ThemeCache();
function createTheme(derivatives) {
  var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
  if (!cacheThemes.has(derivativeArr)) {
    cacheThemes.set(derivativeArr, new Theme(derivativeArr));
  }
  return cacheThemes.get(derivativeArr);
}
function noSplit(list) {
  list.notSplit = true;
  return list;
}
({
  inset: ["top", "right", "bottom", "left"],
  insetBlock: ["top", "bottom"],
  insetBlockStart: ["top"],
  insetBlockEnd: ["bottom"],
  insetInline: ["left", "right"],
  insetInlineStart: ["left"],
  insetInlineEnd: ["right"],
  marginBlock: ["marginTop", "marginBottom"],
  marginBlockStart: ["marginTop"],
  marginBlockEnd: ["marginBottom"],
  marginInline: ["marginLeft", "marginRight"],
  marginInlineStart: ["marginLeft"],
  marginInlineEnd: ["marginRight"],
  paddingBlock: ["paddingTop", "paddingBottom"],
  paddingBlockStart: ["paddingTop"],
  paddingBlockEnd: ["paddingBottom"],
  paddingInline: ["paddingLeft", "paddingRight"],
  paddingInlineStart: ["paddingLeft"],
  paddingInlineEnd: ["paddingRight"],
  borderBlock: noSplit(["borderTop", "borderBottom"]),
  borderBlockStart: noSplit(["borderTop"]),
  borderBlockEnd: noSplit(["borderBottom"]),
  borderInline: noSplit(["borderLeft", "borderRight"]),
  borderInlineStart: noSplit(["borderLeft"]),
  borderInlineEnd: noSplit(["borderRight"]),
  borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
  borderBlockStartWidth: ["borderTopWidth"],
  borderBlockEndWidth: ["borderBottomWidth"],
  borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
  borderInlineStartWidth: ["borderLeftWidth"],
  borderInlineEndWidth: ["borderRightWidth"],
  borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
  borderBlockStartStyle: ["borderTopStyle"],
  borderBlockEndStyle: ["borderBottomStyle"],
  borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
  borderInlineStartStyle: ["borderLeftStyle"],
  borderInlineEndStyle: ["borderRightStyle"],
  borderBlockColor: ["borderTopColor", "borderBottomColor"],
  borderBlockStartColor: ["borderTopColor"],
  borderBlockEndColor: ["borderBottomColor"],
  borderInlineColor: ["borderLeftColor", "borderRightColor"],
  borderInlineStartColor: ["borderLeftColor"],
  borderInlineEndColor: ["borderRightColor"],
  borderStartStartRadius: ["borderTopLeftRadius"],
  borderStartEndRadius: ["borderTopRightRadius"],
  borderEndStartRadius: ["borderBottomLeftRadius"],
  borderEndEndRadius: ["borderBottomRightRadius"]
});
var IconContext$1 = /* @__PURE__ */ react.exports.createContext({});
const Context$2 = IconContext$1;
var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
var warningFunc = function warningFunc2() {
  warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
};
var Context$1 = /* @__PURE__ */ react.exports.createContext({
  getFieldValue: warningFunc,
  getFieldsValue: warningFunc,
  getFieldError: warningFunc,
  getFieldWarning: warningFunc,
  getFieldsError: warningFunc,
  isFieldsTouched: warningFunc,
  isFieldTouched: warningFunc,
  isFieldValidating: warningFunc,
  isFieldsValidating: warningFunc,
  resetFields: warningFunc,
  setFields: warningFunc,
  setFieldValue: warningFunc,
  setFieldsValue: warningFunc,
  validateFields: warningFunc,
  submit: warningFunc,
  getInternalHooks: function getInternalHooks() {
    warningFunc();
    return {
      dispatch: warningFunc,
      initEntityValue: warningFunc,
      registerField: warningFunc,
      useSubscribe: warningFunc,
      setInitialValues: warningFunc,
      destroyForm: warningFunc,
      setCallbacks: warningFunc,
      registerWatch: warningFunc,
      getFields: warningFunc,
      setValidateMessages: warningFunc,
      setPreserve: warningFunc,
      getInitialValue: warningFunc
    };
  }
});
function toArray$2(value) {
  if (value === void 0 || value === null) {
    return [];
  }
  return Array.isArray(value) ? value : [value];
}
function _regeneratorRuntime() {
  _regeneratorRuntime = function _regeneratorRuntime2() {
    return exports;
  };
  var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
    obj[key] = desc.value;
  }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function define2(obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap2(innerFn, outerFn, self2, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator2 = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
    return defineProperty(generator2, "_invoke", {
      value: makeInvokeMethod(innerFn, self2, context)
    }), generator2;
  }
  function tryCatch(fn2, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn2.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap2;
  var ContinueSentinel = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function() {
    return this;
  });
  var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype2) {
    ["next", "throw", "return"].forEach(function(method4) {
      define(prototype2, method4, function(arg) {
        return this._invoke(method4, arg);
      });
    });
  }
  function AsyncIterator(generator2, PromiseImpl) {
    function invoke(method4, arg, resolve, reject) {
      var record = tryCatch(generator2[method4], generator2, arg);
      if ("throw" !== record.type) {
        var result = record.arg, value = result.value;
        return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
          invoke("next", value2, resolve, reject);
        }, function(err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function(unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function(error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function value(method4, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method4, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self2, context) {
    var state = "suspendedStart";
    return function(method4, arg) {
      if ("executing" === state)
        throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method4)
          throw arg;
        return doneResult();
      }
      for (context.method = method4, context.arg = arg; ; ) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel)
              continue;
            return delegateResult;
          }
        }
        if ("next" === context.method)
          context.sent = context._sent = context.arg;
        else if ("throw" === context.method) {
          if ("suspendedStart" === state)
            throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else
          "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self2, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
            continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method, method4 = delegate.iterator[methodName];
    if (void 0 === method4)
      return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method4, delegate.iterator, context.arg);
    if ("throw" === record.type)
      return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context2(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod)
        return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next)
        return iterable;
      if (!isNaN(iterable.length)) {
        var i2 = -1, next2 = function next3() {
          for (; ++i2 < iterable.length; )
            if (hasOwn.call(iterable, i2))
              return next3.value = iterable[i2], next3.done = false, next3;
          return next3.value = void 0, next3.done = true, next3;
        };
        return next2.next = next2;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: void 0,
      done: true
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: true
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: true
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function(genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function(arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap2(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
    return this;
  }), define(Gp, "toString", function() {
    return "[object Generator]";
  }), exports.keys = function(val) {
    var object4 = Object(val), keys2 = [];
    for (var key in object4)
      keys2.push(key);
    return keys2.reverse(), function next2() {
      for (; keys2.length; ) {
        var key2 = keys2.pop();
        if (key2 in object4)
          return next2.value = key2, next2.done = false, next2;
      }
      return next2.done = true, next2;
    };
  }, exports.values = values, Context2.prototype = {
    constructor: Context2,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
        for (var name2 in this)
          "t" === name2.charAt(0) && hasOwn.call(this, name2) && !isNaN(+name2.slice(1)) && (this[name2] = void 0);
    },
    stop: function stop() {
      this.done = true;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type)
        throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done)
        throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
      }
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2], record = entry.completion;
        if ("root" === entry.tryLoc)
          return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc)
              return handle(entry.catchLoc, true);
          } else {
            if (!hasFinally)
              throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc)
              return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type4, arg) {
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type)
        throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2];
        if (entry.finallyLoc === finallyLoc)
          return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
        var entry = this.tryEntries[i2];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName,
        nextLoc
      }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn2.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var formatRegExp = /%[sdj%]/g;
var warning$2 = function warning() {
};
if (typeof process !== "undefined" && process.env && false) {
  warning$2 = function warning3(type4, errors) {
    if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
      if (errors.every(function(e2) {
        return typeof e2 === "string";
      })) {
        console.warn(type4, errors);
      }
    }
  };
}
function convertFieldsError(errors) {
  if (!errors || !errors.length)
    return null;
  var fields = {};
  errors.forEach(function(error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}
function format$1(template) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  var i2 = 0;
  var len = args.length;
  if (typeof template === "function") {
    return template.apply(null, args);
  }
  if (typeof template === "string") {
    var str = template.replace(formatRegExp, function(x2) {
      if (x2 === "%%") {
        return "%";
      }
      if (i2 >= len) {
        return x2;
      }
      switch (x2) {
        case "%s":
          return String(args[i2++]);
        case "%d":
          return Number(args[i2++]);
        case "%j":
          try {
            return JSON.stringify(args[i2++]);
          } catch (_2) {
            return "[Circular]";
          }
          break;
        default:
          return x2;
      }
    });
    return str;
  }
  return template;
}
function isNativeStringType(type4) {
  return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
}
function isEmptyValue(value, type4) {
  if (value === void 0 || value === null) {
    return true;
  }
  if (type4 === "array" && Array.isArray(value) && !value.length) {
    return true;
  }
  if (isNativeStringType(type4) && typeof value === "string" && !value) {
    return true;
  }
  return false;
}
function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;
  function count(errors) {
    results.push.apply(results, errors || []);
    total++;
    if (total === arrLength) {
      callback(results);
    }
  }
  arr.forEach(function(a2) {
    func(a2, count);
  });
}
function asyncSerialArray(arr, func, callback) {
  var index2 = 0;
  var arrLength = arr.length;
  function next2(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }
    var original = index2;
    index2 = index2 + 1;
    if (original < arrLength) {
      func(arr[original], next2);
    } else {
      callback([]);
    }
  }
  next2([]);
}
function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function(k2) {
    ret.push.apply(ret, objArr[k2] || []);
  });
  return ret;
}
var AsyncValidationError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(AsyncValidationError2, _Error);
  function AsyncValidationError2(errors, fields) {
    var _this;
    _this = _Error.call(this, "Async Validation Error") || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }
  return AsyncValidationError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(objArr, option, func, callback, source) {
  if (option.first) {
    var _pending = new Promise(function(resolve, reject) {
      var next2 = function next3(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
      };
      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next2);
    });
    _pending["catch"](function(e2) {
      return e2;
    });
    return _pending;
  }
  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function(resolve, reject) {
    var next2 = function next3(errors) {
      results.push.apply(results, errors);
      total++;
      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
      }
    };
    if (!objArrKeys.length) {
      callback(results);
      resolve(source);
    }
    objArrKeys.forEach(function(key) {
      var arr = objArr[key];
      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next2);
      } else {
        asyncParallelArray(arr, func, next2);
      }
    });
  });
  pending["catch"](function(e2) {
    return e2;
  });
  return pending;
}
function isErrorObj(obj) {
  return !!(obj && obj.message !== void 0);
}
function getValue$5(value, path2) {
  var v2 = value;
  for (var i2 = 0; i2 < path2.length; i2++) {
    if (v2 == void 0) {
      return v2;
    }
    v2 = v2[path2[i2]];
  }
  return v2;
}
function complementError(rule, source) {
  return function(oe2) {
    var fieldValue;
    if (rule.fullFields) {
      fieldValue = getValue$5(source, rule.fullFields);
    } else {
      fieldValue = source[oe2.field || rule.fullField];
    }
    if (isErrorObj(oe2)) {
      oe2.field = oe2.field || rule.fullField;
      oe2.fieldValue = fieldValue;
      return oe2;
    }
    return {
      message: typeof oe2 === "function" ? oe2() : oe2,
      fieldValue,
      field: oe2.field || rule.fullField
    };
  };
}
function deepMerge(target, source) {
  if (source) {
    for (var s2 in source) {
      if (source.hasOwnProperty(s2)) {
        var value = source[s2];
        if (typeof value === "object" && typeof target[s2] === "object") {
          target[s2] = _extends({}, target[s2], value);
        } else {
          target[s2] = value;
        }
      }
    }
  }
  return target;
}
var required$1 = function required(rule, value, source, errors, options, type4) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
    errors.push(format$1(options.messages.required, rule.fullField));
  }
};
var whitespace = function whitespace2(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === "") {
    errors.push(format$1(options.messages.whitespace, rule.fullField));
  }
};
var urlReg;
var getUrlRegex = function() {
  if (urlReg) {
    return urlReg;
  }
  var word = "[a-fA-F\\d:]";
  var b2 = function b3(options) {
    return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
  };
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
  var v4exact = new RegExp("^" + v4 + "$");
  var v6exact = new RegExp("^" + v6 + "$");
  var ip = function ip2(options) {
    return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
  };
  ip.v4 = function(options) {
    return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
  };
  ip.v6 = function(options) {
    return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
  };
  var protocol = "(?:(?:[a-z]+:)?//)";
  var auth = "(?:\\S+(?::\\S*)?@)?";
  var ipv4 = ip.v4().source;
  var ipv6 = ip.v6().source;
  var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
  var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
  var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
  var port = "(?::\\d{2,5})?";
  var path2 = '(?:[/?#][^\\s"]*)?';
  var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path2;
  urlReg = new RegExp("(?:^" + regex + "$)", "i");
  return urlReg;
};
var pattern$2 = {
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }
    try {
      return !!new RegExp(value);
    } catch (e2) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }
    return typeof value === "number";
  },
  object: function object(value) {
    return typeof value === "object" && !types.array(value);
  },
  method: function method(value) {
    return typeof value === "function";
  },
  email: function email(value) {
    return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
  },
  url: function url(value) {
    return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
  },
  hex: function hex(value) {
    return typeof value === "string" && !!value.match(pattern$2.hex);
  }
};
var type$1 = function type(rule, value, source, errors, options) {
  if (rule.required && value === void 0) {
    required$1(rule, value, source, errors, options);
    return;
  }
  var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
  var ruleType = rule.type;
  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
  }
};
var range = function range2(rule, value, source, errors, options) {
  var len = typeof rule.len === "number";
  var min = typeof rule.min === "number";
  var max = typeof rule.max === "number";
  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === "number";
  var str = typeof value === "string";
  var arr = Array.isArray(value);
  if (num) {
    key = "number";
  } else if (str) {
    key = "string";
  } else if (arr) {
    key = "array";
  }
  if (!key) {
    return false;
  }
  if (arr) {
    val = value.length;
  }
  if (str) {
    val = value.replace(spRegexp, "_").length;
  }
  if (len) {
    if (val !== rule.len) {
      errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
};
var ENUM$1 = "enum";
var enumerable$1 = function enumerable(rule, value, source, errors, options) {
  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
  if (rule[ENUM$1].indexOf(value) === -1) {
    errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
  }
};
var pattern$1 = function pattern(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      rule.pattern.lastIndex = 0;
      if (!rule.pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === "string") {
      var _pattern = new RegExp(rule.pattern);
      if (!_pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
};
var rules = {
  required: required$1,
  whitespace,
  type: type$1,
  range,
  "enum": enumerable$1,
  pattern: pattern$1
};
var string = function string2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "string");
    if (!isEmptyValue(value, "string")) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);
      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }
  callback(errors);
};
var method2 = function method3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var number2 = function number3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (value === "") {
      value = void 0;
    }
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var _boolean = function _boolean2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var regexp2 = function regexp3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var integer2 = function integer3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var floatFn = function floatFn2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var array2 = function array3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if ((value === void 0 || value === null) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, "array");
    if (value !== void 0 && value !== null) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var object2 = function object3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var ENUM = "enum";
var enumerable2 = function enumerable3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (value !== void 0) {
      rules[ENUM](rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var pattern2 = function pattern3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "string") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "string")) {
      rules.pattern(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var date2 = function date3(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, "date") && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
    if (!isEmptyValue(value, "date")) {
      var dateObject;
      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }
      rules.type(rule, dateObject, source, errors, options);
      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }
  callback(errors);
};
var required2 = function required3(rule, value, callback, source, options) {
  var errors = [];
  var type4 = Array.isArray(value) ? "array" : typeof value;
  rules.required(rule, value, source, errors, options, type4);
  callback(errors);
};
var type2 = function type3(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options, ruleType);
    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }
  callback(errors);
};
var any = function any2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }
    rules.required(rule, value, source, errors, options);
  }
  callback(errors);
};
var validators = {
  string,
  method: method2,
  number: number2,
  "boolean": _boolean,
  regexp: regexp2,
  integer: integer2,
  "float": floatFn,
  array: array2,
  object: object2,
  "enum": enumerable2,
  pattern: pattern2,
  date: date2,
  url: type2,
  hex: type2,
  email: type2,
  required: required2,
  any
};
function newMessages() {
  return {
    "default": "Validation error on field %s",
    required: "%s is required",
    "enum": "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      "boolean": "%s is not a %s",
      integer: "%s is not an %s",
      "float": "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function clone2() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}
var messages = newMessages();
var Schema = /* @__PURE__ */ function() {
  function Schema2(descriptor) {
    this.rules = null;
    this._messages = messages;
    this.define(descriptor);
  }
  var _proto = Schema2.prototype;
  _proto.define = function define(rules2) {
    var _this = this;
    if (!rules2) {
      throw new Error("Cannot configure a schema with no rules");
    }
    if (typeof rules2 !== "object" || Array.isArray(rules2)) {
      throw new Error("Rules must be an object");
    }
    this.rules = {};
    Object.keys(rules2).forEach(function(name2) {
      var item = rules2[name2];
      _this.rules[name2] = Array.isArray(item) ? item : [item];
    });
  };
  _proto.messages = function messages2(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }
    return this._messages;
  };
  _proto.validate = function validate(source_, o2, oc2) {
    var _this2 = this;
    if (o2 === void 0) {
      o2 = {};
    }
    if (oc2 === void 0) {
      oc2 = function oc3() {
      };
    }
    var source = source_;
    var options = o2;
    var callback = oc2;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback(null, source);
      }
      return Promise.resolve(source);
    }
    function complete(results) {
      var errors = [];
      var fields = {};
      function add(e2) {
        if (Array.isArray(e2)) {
          var _errors;
          errors = (_errors = errors).concat.apply(_errors, e2);
        } else {
          errors.push(e2);
        }
      }
      for (var i2 = 0; i2 < results.length; i2++) {
        add(results[i2]);
      }
      if (!errors.length) {
        callback(null, source);
      } else {
        fields = convertFieldsError(errors);
        callback(errors, fields);
      }
    }
    if (options.messages) {
      var messages$1 = this.messages();
      if (messages$1 === messages) {
        messages$1 = newMessages();
      }
      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }
    var series = {};
    var keys2 = options.keys || Object.keys(this.rules);
    keys2.forEach(function(z2) {
      var arr = _this2.rules[z2];
      var value = source[z2];
      arr.forEach(function(r2) {
        var rule = r2;
        if (typeof rule.transform === "function") {
          if (source === source_) {
            source = _extends({}, source);
          }
          value = source[z2] = rule.transform(value);
        }
        if (typeof rule === "function") {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }
        rule.validator = _this2.getValidationMethod(rule);
        if (!rule.validator) {
          return;
        }
        rule.field = z2;
        rule.fullField = rule.fullField || z2;
        rule.type = _this2.getType(rule);
        series[z2] = series[z2] || [];
        series[z2].push({
          rule,
          value,
          source,
          field: z2
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function(data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;
      function addFullField(key, schema) {
        return _extends({}, schema, {
          fullField: rule.fullField + "." + key,
          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
        });
      }
      function cb2(e2) {
        if (e2 === void 0) {
          e2 = [];
        }
        var errorList = Array.isArray(e2) ? e2 : [e2];
        if (!options.suppressWarning && errorList.length) {
          Schema2.warning("async-validator:", errorList);
        }
        if (errorList.length && rule.message !== void 0) {
          errorList = [].concat(rule.message);
        }
        var filledErrors = errorList.map(complementError(rule, source));
        if (options.first && filledErrors.length) {
          errorFields[rule.field] = 1;
          return doIt(filledErrors);
        }
        if (!deep) {
          doIt(filledErrors);
        } else {
          if (rule.required && !data.value) {
            if (rule.message !== void 0) {
              filledErrors = [].concat(rule.message).map(complementError(rule, source));
            } else if (options.error) {
              filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
            }
            return doIt(filledErrors);
          }
          var fieldsSchema = {};
          if (rule.defaultField) {
            Object.keys(data.value).map(function(key) {
              fieldsSchema[key] = rule.defaultField;
            });
          }
          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
          var paredFieldsSchema = {};
          Object.keys(fieldsSchema).forEach(function(field) {
            var fieldSchema = fieldsSchema[field];
            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
          });
          var schema = new Schema2(paredFieldsSchema);
          schema.messages(options.messages);
          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }
          schema.validate(data.value, data.rule.options || options, function(errs) {
            var finalErrors = [];
            if (filledErrors && filledErrors.length) {
              finalErrors.push.apply(finalErrors, filledErrors);
            }
            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }
            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }
      var res;
      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb2, data.source, options);
      } else if (rule.validator) {
        try {
          res = rule.validator(rule, data.value, cb2, data.source, options);
        } catch (error) {
          console.error == null ? void 0 : console.error(error);
          if (!options.suppressValidatorError) {
            setTimeout(function() {
              throw error;
            }, 0);
          }
          cb2(error.message);
        }
        if (res === true) {
          cb2();
        } else if (res === false) {
          cb2(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
        } else if (res instanceof Array) {
          cb2(res);
        } else if (res instanceof Error) {
          cb2(res.message);
        }
      }
      if (res && res.then) {
        res.then(function() {
          return cb2();
        }, function(e2) {
          return cb2(e2);
        });
      }
    }, function(results) {
      complete(results);
    }, source);
  };
  _proto.getType = function getType(rule) {
    if (rule.type === void 0 && rule.pattern instanceof RegExp) {
      rule.type = "pattern";
    }
    if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format$1("Unknown rule type %s", rule.type));
    }
    return rule.type || "string";
  };
  _proto.getValidationMethod = function getValidationMethod(rule) {
    if (typeof rule.validator === "function") {
      return rule.validator;
    }
    var keys2 = Object.keys(rule);
    var messageIndex = keys2.indexOf("message");
    if (messageIndex !== -1) {
      keys2.splice(messageIndex, 1);
    }
    if (keys2.length === 1 && keys2[0] === "required") {
      return validators.required;
    }
    return validators[this.getType(rule)] || void 0;
  };
  return Schema2;
}();
Schema.register = function register(type4, validator2) {
  if (typeof validator2 !== "function") {
    throw new Error("Cannot register a validator by type, validator is not a function");
  }
  validators[type4] = validator2;
};
Schema.warning = warning$2;
Schema.messages = messages;
Schema.validators = validators;
var typeTemplate$2 = "'${name}' is not a valid ${type}";
var defaultValidateMessages = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: typeTemplate$2,
    method: typeTemplate$2,
    array: typeTemplate$2,
    object: typeTemplate$2,
    number: typeTemplate$2,
    date: typeTemplate$2,
    boolean: typeTemplate$2,
    integer: typeTemplate$2,
    float: typeTemplate$2,
    regexp: typeTemplate$2,
    email: typeTemplate$2,
    url: typeTemplate$2,
    hex: typeTemplate$2
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
function get(entity, path2) {
  var current = entity;
  for (var i2 = 0; i2 < path2.length; i2 += 1) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[path2[i2]];
  }
  return current;
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function internalSet(entity, paths, value, removeIfUndefined) {
  if (!paths.length) {
    return value;
  }
  var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1);
  var clone2;
  if (!entity && typeof path2 === "number") {
    clone2 = [];
  } else if (Array.isArray(entity)) {
    clone2 = _toConsumableArray(entity);
  } else {
    clone2 = _objectSpread2$1({}, entity);
  }
  if (removeIfUndefined && value === void 0 && restPath.length === 1) {
    delete clone2[path2][restPath[0]];
  } else {
    clone2[path2] = internalSet(clone2[path2], restPath, value, removeIfUndefined);
  }
  return clone2;
}
function set$1(entity, paths, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
    return entity;
  }
  return internalSet(entity, paths, value, removeIfUndefined);
}
function cloneDeep(val) {
  if (Array.isArray(val)) {
    return cloneArrayDeep(val);
  } else if (_typeof$1(val) === "object" && val !== null) {
    return cloneObjectDeep(val);
  }
  return val;
}
function cloneObjectDeep(val) {
  if (Object.getPrototypeOf(val) === Object.prototype) {
    var res = {};
    for (var key in val) {
      res[key] = cloneDeep(val[key]);
    }
    return res;
  }
  return val;
}
function cloneArrayDeep(val) {
  return val.map(function(item) {
    return cloneDeep(item);
  });
}
function getNamePath(path2) {
  return toArray$2(path2);
}
function getValue$4(store2, namePath) {
  var value = get(store2, namePath);
  return value;
}
function setValue(store2, namePath, value) {
  var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var newStore = set$1(store2, namePath, value, removeIfUndefined);
  return newStore;
}
function cloneByNamePathList(store2, namePathList) {
  var newStore = {};
  namePathList.forEach(function(namePath) {
    var value = getValue$4(store2, namePath);
    newStore = setValue(newStore, namePath, value);
  });
  return newStore;
}
function containsNamePath(namePathList, namePath) {
  return namePathList && namePathList.some(function(path2) {
    return matchNamePath(path2, namePath);
  });
}
function isObject$4(obj) {
  return _typeof$1(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
}
function internalSetValues(store2, values) {
  var newStore = Array.isArray(store2) ? _toConsumableArray(store2) : _objectSpread2$1({}, store2);
  if (!values) {
    return newStore;
  }
  Object.keys(values).forEach(function(key) {
    var prevValue = newStore[key];
    var value = values[key];
    var recursive = isObject$4(prevValue) && isObject$4(value);
    newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : cloneDeep(value);
  });
  return newStore;
}
function setValues(store2) {
  for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    restValues[_key - 1] = arguments[_key];
  }
  return restValues.reduce(function(current, newStore) {
    return internalSetValues(current, newStore);
  }, store2);
}
function matchNamePath(namePath, changedNamePath) {
  if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
    return false;
  }
  return namePath.every(function(nameUnit, i2) {
    return changedNamePath[i2] === nameUnit;
  });
}
function isSimilar(source, target) {
  if (source === target) {
    return true;
  }
  if (!source && target || source && !target) {
    return false;
  }
  if (!source || !target || _typeof$1(source) !== "object" || _typeof$1(target) !== "object") {
    return false;
  }
  var sourceKeys = Object.keys(source);
  var targetKeys = Object.keys(target);
  var keys2 = new Set([].concat(sourceKeys, targetKeys));
  return _toConsumableArray(keys2).every(function(key) {
    var sourceValue = source[key];
    var targetValue = target[key];
    if (typeof sourceValue === "function" && typeof targetValue === "function") {
      return true;
    }
    return sourceValue === targetValue;
  });
}
function defaultGetValueFromEvent(valuePropName) {
  var event = arguments.length <= 1 ? void 0 : arguments[1];
  if (event && event.target && _typeof$1(event.target) === "object" && valuePropName in event.target) {
    return event.target[valuePropName];
  }
  return event;
}
function move(array4, moveIndex, toIndex) {
  var length2 = array4.length;
  if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
    return array4;
  }
  var item = array4[moveIndex];
  var diff = moveIndex - toIndex;
  if (diff > 0) {
    return [].concat(_toConsumableArray(array4.slice(0, toIndex)), [item], _toConsumableArray(array4.slice(toIndex, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, length2)));
  }
  if (diff < 0) {
    return [].concat(_toConsumableArray(array4.slice(0, moveIndex)), _toConsumableArray(array4.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array4.slice(toIndex + 1, length2)));
  }
  return array4;
}
var AsyncValidator = Schema;
function replaceMessage(template, kv) {
  return template.replace(/\$\{\w+\}/g, function(str) {
    var key = str.slice(2, -1);
    return kv[key];
  });
}
var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
function validateRule(_x, _x2, _x3, _x4, _x5) {
  return _validateRule.apply(this, arguments);
}
function _validateRule() {
  _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name2, value, rule, options, messageVariables) {
    var cloneRule, originValidator, subRuleField, validator2, messages2, result, subResults, kv, fillVariableResult;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            cloneRule = _objectSpread2$1({}, rule);
            delete cloneRule.ruleIndex;
            if (cloneRule.validator) {
              originValidator = cloneRule.validator;
              cloneRule.validator = function() {
                try {
                  return originValidator.apply(void 0, arguments);
                } catch (error) {
                  console.error(error);
                  return Promise.reject(CODE_LOGIC_ERROR);
                }
              };
            }
            subRuleField = null;
            if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
              subRuleField = cloneRule.defaultField;
              delete cloneRule.defaultField;
            }
            validator2 = new AsyncValidator(_defineProperty$1({}, name2, [cloneRule]));
            messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
            validator2.messages(messages2);
            result = [];
            _context2.prev = 9;
            _context2.next = 12;
            return Promise.resolve(validator2.validate(_defineProperty$1({}, name2, value), _objectSpread2$1({}, options)));
          case 12:
            _context2.next = 17;
            break;
          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](9);
            if (_context2.t0.errors) {
              result = _context2.t0.errors.map(function(_ref4, index2) {
                var message2 = _ref4.message;
                var mergedMessage = message2 === CODE_LOGIC_ERROR ? messages2.default : message2;
                return /* @__PURE__ */ react.exports.isValidElement(mergedMessage) ? /* @__PURE__ */ react.exports.cloneElement(mergedMessage, {
                  key: "error_".concat(index2)
                }) : mergedMessage;
              });
            }
          case 17:
            if (!(!result.length && subRuleField)) {
              _context2.next = 22;
              break;
            }
            _context2.next = 20;
            return Promise.all(value.map(function(subValue, i2) {
              return validateRule("".concat(name2, ".").concat(i2), subValue, subRuleField, options, messageVariables);
            }));
          case 20:
            subResults = _context2.sent;
            return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
              return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
            }, []));
          case 22:
            kv = _objectSpread2$1(_objectSpread2$1({}, rule), {}, {
              name: name2,
              enum: (rule.enum || []).join(", ")
            }, messageVariables);
            fillVariableResult = result.map(function(error) {
              if (typeof error === "string") {
                return replaceMessage(error, kv);
              }
              return error;
            });
            return _context2.abrupt("return", fillVariableResult);
          case 25:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[9, 14]]);
  }));
  return _validateRule.apply(this, arguments);
}
function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
  var name2 = namePath.join(".");
  var filledRules = rules2.map(function(currentRule, ruleIndex) {
    var originValidatorFunc = currentRule.validator;
    var cloneRule = _objectSpread2$1(_objectSpread2$1({}, currentRule), {}, {
      ruleIndex
    });
    if (originValidatorFunc) {
      cloneRule.validator = function(rule, val, callback) {
        var hasPromise = false;
        var wrappedCallback = function wrappedCallback2() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          Promise.resolve().then(function() {
            warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
            if (!hasPromise) {
              callback.apply(void 0, args);
            }
          });
        };
        var promise2 = originValidatorFunc(rule, val, wrappedCallback);
        hasPromise = promise2 && typeof promise2.then === "function" && typeof promise2.catch === "function";
        warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
        if (hasPromise) {
          promise2.then(function() {
            callback();
          }).catch(function(err) {
            callback(err || " ");
          });
        }
      };
    }
    return cloneRule;
  }).sort(function(_ref, _ref2) {
    var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
    var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
    if (!!w1 === !!w2) {
      return i1 - i2;
    }
    if (w1) {
      return 1;
    }
    return -1;
  });
  var summaryPromise;
  if (validateFirst === true) {
    summaryPromise = new Promise(/* @__PURE__ */ function() {
      var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
        var i2, rule, errors;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                i2 = 0;
              case 1:
                if (!(i2 < filledRules.length)) {
                  _context.next = 12;
                  break;
                }
                rule = filledRules[i2];
                _context.next = 5;
                return validateRule(name2, value, rule, options, messageVariables);
              case 5:
                errors = _context.sent;
                if (!errors.length) {
                  _context.next = 9;
                  break;
                }
                reject([{
                  errors,
                  rule
                }]);
                return _context.abrupt("return");
              case 9:
                i2 += 1;
                _context.next = 1;
                break;
              case 12:
                resolve([]);
              case 13:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return function(_x6, _x7) {
        return _ref3.apply(this, arguments);
      };
    }());
  } else {
    var rulePromises = filledRules.map(function(rule) {
      return validateRule(name2, value, rule, options, messageVariables).then(function(errors) {
        return {
          errors,
          rule
        };
      });
    });
    summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
      return Promise.reject(errors);
    });
  }
  summaryPromise.catch(function(e2) {
    return e2;
  });
  return summaryPromise;
}
function finishOnAllFailed(_x8) {
  return _finishOnAllFailed.apply(this, arguments);
}
function _finishOnAllFailed() {
  _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
              var _ref5;
              var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
              return errors;
            }));
          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _finishOnAllFailed.apply(this, arguments);
}
function finishOnFirstFailed(_x9) {
  return _finishOnFirstFailed.apply(this, arguments);
}
function _finishOnFirstFailed() {
  _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
    var count;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            count = 0;
            return _context4.abrupt("return", new Promise(function(resolve) {
              rulePromises.forEach(function(promise2) {
                promise2.then(function(ruleError) {
                  if (ruleError.errors.length) {
                    resolve([ruleError]);
                  }
                  count += 1;
                  if (count === rulePromises.length) {
                    resolve([]);
                  }
                });
              });
            }));
          case 2:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _finishOnFirstFailed.apply(this, arguments);
}
var _excluded$t = ["name"];
var EMPTY_ERRORS = [];
function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
  if (typeof shouldUpdate === "function") {
    return shouldUpdate(prev2, next2, "source" in info ? {
      source: info.source
    } : {});
  }
  return prevValue !== nextValue;
}
var Field = /* @__PURE__ */ function(_React$Component) {
  _inherits(Field2, _React$Component);
  var _super = _createSuper(Field2);
  function Field2(props) {
    var _this;
    _classCallCheck(this, Field2);
    _this = _super.call(this, props);
    _this.state = {
      resetCount: 0
    };
    _this.cancelRegisterFunc = null;
    _this.mounted = false;
    _this.touched = false;
    _this.dirty = false;
    _this.validatePromise = null;
    _this.prevValidating = void 0;
    _this.errors = EMPTY_ERRORS;
    _this.warnings = EMPTY_ERRORS;
    _this.cancelRegister = function() {
      var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name2 = _this$props.name;
      if (_this.cancelRegisterFunc) {
        _this.cancelRegisterFunc(isListField, preserve, getNamePath(name2));
      }
      _this.cancelRegisterFunc = null;
    };
    _this.getNamePath = function() {
      var _this$props2 = _this.props, name2 = _this$props2.name, fieldContext = _this$props2.fieldContext;
      var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
      return name2 !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name2)) : [];
    };
    _this.getRules = function() {
      var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
      return rules2.map(function(rule) {
        if (typeof rule === "function") {
          return rule(fieldContext);
        }
        return rule;
      });
    };
    _this.refresh = function() {
      if (!_this.mounted)
        return;
      _this.setState(function(_ref) {
        var resetCount = _ref.resetCount;
        return {
          resetCount: resetCount + 1
        };
      });
    };
    _this.triggerMetaEvent = function(destroy2) {
      var onMetaChange = _this.props.onMetaChange;
      onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2$1(_objectSpread2$1({}, _this.getMeta()), {}, {
        destroy: destroy2
      }));
    };
    _this.onStoreChange = function(prevStore, namePathList, info) {
      var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
      var store2 = info.store;
      var namePath = _this.getNamePath();
      var prevValue = _this.getValue(prevStore);
      var curValue = _this.getValue(store2);
      var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
      if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
        _this.touched = true;
        _this.dirty = true;
        _this.validatePromise = null;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
      }
      switch (info.type) {
        case "reset":
          if (!namePathList || namePathMatch) {
            _this.touched = false;
            _this.dirty = false;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
            onReset === null || onReset === void 0 ? void 0 : onReset();
            _this.refresh();
            return;
          }
          break;
        case "remove": {
          if (shouldUpdate) {
            _this.reRender();
            return;
          }
          break;
        }
        case "setField": {
          if (namePathMatch) {
            var data = info.data;
            if ("touched" in data) {
              _this.touched = data.touched;
            }
            if ("validating" in data && !("originRCField" in data)) {
              _this.validatePromise = data.validating ? Promise.resolve([]) : null;
            }
            if ("errors" in data) {
              _this.errors = data.errors || EMPTY_ERRORS;
            }
            if ("warnings" in data) {
              _this.warnings = data.warnings || EMPTY_ERRORS;
            }
            _this.dirty = true;
            _this.triggerMetaEvent();
            _this.reRender();
            return;
          }
          if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store2, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var dependencyList = dependencies.map(getNamePath);
          if (dependencyList.some(function(dependency) {
            return containsNamePath(info.relatedFields, dependency);
          })) {
            _this.reRender();
            return;
          }
          break;
        }
        default:
          if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store2, prevValue, curValue, info)) {
            _this.reRender();
            return;
          }
          break;
      }
      if (shouldUpdate === true) {
        _this.reRender();
      }
    };
    _this.validateRules = function(options) {
      var namePath = _this.getNamePath();
      var currentValue = _this.getValue();
      var rootPromise = Promise.resolve().then(function() {
        if (!_this.mounted) {
          return [];
        }
        var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
        var _ref2 = options || {}, triggerName = _ref2.triggerName;
        var filteredRules = _this.getRules();
        if (triggerName) {
          filteredRules = filteredRules.filter(function(rule) {
            return rule;
          }).filter(function(rule) {
            var validateTrigger = rule.validateTrigger;
            if (!validateTrigger) {
              return true;
            }
            var triggerList = toArray$2(validateTrigger);
            return triggerList.includes(triggerName);
          });
        }
        var promise2 = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
        promise2.catch(function(e2) {
          return e2;
        }).then(function() {
          var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
          if (_this.validatePromise === rootPromise) {
            var _ruleErrors$forEach;
            _this.validatePromise = null;
            var nextErrors = [];
            var nextWarnings = [];
            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
              var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
              if (warningOnly) {
                nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
              } else {
                nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
              }
            });
            _this.errors = nextErrors;
            _this.warnings = nextWarnings;
            _this.triggerMetaEvent();
            _this.reRender();
          }
        });
        return promise2;
      });
      _this.validatePromise = rootPromise;
      _this.dirty = true;
      _this.errors = EMPTY_ERRORS;
      _this.warnings = EMPTY_ERRORS;
      _this.triggerMetaEvent();
      _this.reRender();
      return rootPromise;
    };
    _this.isFieldValidating = function() {
      return !!_this.validatePromise;
    };
    _this.isFieldTouched = function() {
      return _this.touched;
    };
    _this.isFieldDirty = function() {
      if (_this.dirty || _this.props.initialValue !== void 0) {
        return true;
      }
      var fieldContext = _this.props.fieldContext;
      var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
      if (getInitialValue(_this.getNamePath()) !== void 0) {
        return true;
      }
      return false;
    };
    _this.getErrors = function() {
      return _this.errors;
    };
    _this.getWarnings = function() {
      return _this.warnings;
    };
    _this.isListField = function() {
      return _this.props.isListField;
    };
    _this.isList = function() {
      return _this.props.isList;
    };
    _this.isPreserve = function() {
      return _this.props.preserve;
    };
    _this.getMeta = function() {
      _this.prevValidating = _this.isFieldValidating();
      var meta = {
        touched: _this.isFieldTouched(),
        validating: _this.prevValidating,
        errors: _this.errors,
        warnings: _this.warnings,
        name: _this.getNamePath()
      };
      return meta;
    };
    _this.getOnlyChild = function(children) {
      if (typeof children === "function") {
        var meta = _this.getMeta();
        return _objectSpread2$1(_objectSpread2$1({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
          isFunction: true
        });
      }
      var childList = toArray$3(children);
      if (childList.length !== 1 || !/* @__PURE__ */ react.exports.isValidElement(childList[0])) {
        return {
          child: childList,
          isFunction: false
        };
      }
      return {
        child: childList[0],
        isFunction: false
      };
    };
    _this.getValue = function(store2) {
      var getFieldsValue = _this.props.fieldContext.getFieldsValue;
      var namePath = _this.getNamePath();
      return getValue$4(store2 || getFieldsValue(true), namePath);
    };
    _this.getControlled = function() {
      var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
      var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
      var namePath = _this.getNamePath();
      var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
      var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
      var value = _this.getValue();
      var mergedGetValueProps = getValueProps || function(val) {
        return _defineProperty$1({}, valuePropName, val);
      };
      var originTriggerFunc = childProps[trigger];
      var control = _objectSpread2$1(_objectSpread2$1({}, childProps), mergedGetValueProps(value));
      control[trigger] = function() {
        _this.touched = true;
        _this.dirty = true;
        _this.triggerMetaEvent();
        var newValue;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (getValueFromEvent) {
          newValue = getValueFromEvent.apply(void 0, args);
        } else {
          newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
        }
        if (normalize2) {
          newValue = normalize2(newValue, value, getFieldsValue(true));
        }
        dispatch({
          type: "updateValue",
          namePath,
          value: newValue
        });
        if (originTriggerFunc) {
          originTriggerFunc.apply(void 0, args);
        }
      };
      var validateTriggerList = toArray$2(mergedValidateTrigger || []);
      validateTriggerList.forEach(function(triggerName) {
        var originTrigger = control[triggerName];
        control[triggerName] = function() {
          if (originTrigger) {
            originTrigger.apply(void 0, arguments);
          }
          var rules2 = _this.props.rules;
          if (rules2 && rules2.length) {
            dispatch({
              type: "validateField",
              namePath,
              triggerName
            });
          }
        };
      });
      return control;
    };
    if (props.fieldContext) {
      var getInternalHooks2 = props.fieldContext.getInternalHooks;
      var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
      initEntityValue(_assertThisInitialized(_this));
    }
    return _this;
  }
  _createClass(Field2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
      this.mounted = true;
      if (fieldContext) {
        var getInternalHooks2 = fieldContext.getInternalHooks;
        var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
        this.cancelRegisterFunc = registerField(this);
      }
      if (shouldUpdate === true) {
        this.reRender();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cancelRegister();
      this.triggerMetaEvent(true);
      this.mounted = false;
    }
  }, {
    key: "reRender",
    value: function reRender() {
      if (!this.mounted)
        return;
      this.forceUpdate();
    }
  }, {
    key: "render",
    value: function render2() {
      this.state.resetCount;
      var children = this.props.children;
      var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
      var returnChildNode;
      if (isFunction2) {
        returnChildNode = child;
      } else if (/* @__PURE__ */ react.exports.isValidElement(child)) {
        returnChildNode = /* @__PURE__ */ react.exports.cloneElement(child, this.getControlled(child.props));
      } else {
        warningOnce(!child, "`children` of Field is not validate ReactElement.");
        returnChildNode = child;
      }
      return /* @__PURE__ */ jsx(Fragment, {
        children: returnChildNode
      });
    }
  }]);
  return Field2;
}(react.exports.Component);
Field.contextType = Context$1;
Field.defaultProps = {
  trigger: "onChange",
  valuePropName: "value"
};
function WrapperField(_ref5) {
  var name2 = _ref5.name, restProps = _objectWithoutProperties(_ref5, _excluded$t);
  var fieldContext = react.exports.useContext(Context$1);
  var namePath = name2 !== void 0 ? getNamePath(name2) : void 0;
  var key = "keep";
  if (!restProps.isListField) {
    key = "_".concat((namePath || []).join("_"));
  }
  return /* @__PURE__ */ jsx(Field, {
    name: namePath,
    ...restProps,
    fieldContext
  }, key);
}
var ListContext = /* @__PURE__ */ react.exports.createContext(null);
var List$1 = function List(_ref) {
  var name2 = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger;
  var context = react.exports.useContext(Context$1);
  var keyRef = react.exports.useRef({
    keys: [],
    id: 0
  });
  var keyManager = keyRef.current;
  var prefixName = react.exports.useMemo(function() {
    var parentPrefixName = getNamePath(context.prefixName) || [];
    return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name2)));
  }, [context.prefixName, name2]);
  var fieldContext = react.exports.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, context), {}, {
      prefixName
    });
  }, [context, prefixName]);
  var listContext = react.exports.useMemo(function() {
    return {
      getKey: function getKey3(namePath) {
        var len = prefixName.length;
        var pathName = namePath[len];
        return [keyManager.keys[pathName], namePath.slice(len + 1)];
      }
    };
  }, [prefixName]);
  if (typeof children !== "function") {
    warningOnce(false, "Form.List only accepts function as children.");
    return null;
  }
  var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
    var source = _ref2.source;
    if (source === "internal") {
      return false;
    }
    return prevValue !== nextValue;
  };
  return /* @__PURE__ */ jsx(ListContext.Provider, {
    value: listContext,
    children: /* @__PURE__ */ jsx(Context$1.Provider, {
      value: fieldContext,
      children: /* @__PURE__ */ jsx(WrapperField, {
        name: [],
        shouldUpdate,
        rules: rules2,
        validateTrigger,
        initialValue,
        isList: true,
        children: function(_ref3, meta) {
          var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange2 = _ref3.onChange;
          var getFieldValue = context.getFieldValue;
          var getNewValue = function getNewValue2() {
            var values = getFieldValue(prefixName || []);
            return values || [];
          };
          var operations = {
            add: function add(defaultValue, index2) {
              var newValue = getNewValue();
              if (index2 >= 0 && index2 <= newValue.length) {
                keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
                onChange2([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
              } else {
                keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
                onChange2([].concat(_toConsumableArray(newValue), [defaultValue]));
              }
              keyManager.id += 1;
            },
            remove: function remove2(index2) {
              var newValue = getNewValue();
              var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
              if (indexSet.size <= 0) {
                return;
              }
              keyManager.keys = keyManager.keys.filter(function(_2, keysIndex) {
                return !indexSet.has(keysIndex);
              });
              onChange2(newValue.filter(function(_2, valueIndex) {
                return !indexSet.has(valueIndex);
              }));
            },
            move: function move$1(from2, to) {
              if (from2 === to) {
                return;
              }
              var newValue = getNewValue();
              if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
                return;
              }
              keyManager.keys = move(keyManager.keys, from2, to);
              onChange2(move(newValue, from2, to));
            }
          };
          var listValue = value || [];
          if (!Array.isArray(listValue)) {
            listValue = [];
          }
          return children(listValue.map(function(__, index2) {
            var key = keyManager.keys[index2];
            if (key === void 0) {
              keyManager.keys[index2] = keyManager.id;
              key = keyManager.keys[index2];
              keyManager.id += 1;
            }
            return {
              name: index2,
              key,
              isListField: true
            };
          }), operations, meta);
        }
      })
    })
  });
};
function allPromiseFinish(promiseList) {
  var hasError = false;
  var count = promiseList.length;
  var results = [];
  if (!promiseList.length) {
    return Promise.resolve([]);
  }
  return new Promise(function(resolve, reject) {
    promiseList.forEach(function(promise2, index2) {
      promise2.catch(function(e2) {
        hasError = true;
        return e2;
      }).then(function(result) {
        count -= 1;
        results[index2] = result;
        if (count > 0) {
          return;
        }
        if (hasError) {
          reject(results);
        }
        resolve(results);
      });
    });
  });
}
var SPLIT = "__@field_split__";
function normalize(namePath) {
  return namePath.map(function(cell) {
    return "".concat(_typeof$1(cell), ":").concat(cell);
  }).join(SPLIT);
}
var NameMap = /* @__PURE__ */ function() {
  function NameMap2() {
    _classCallCheck(this, NameMap2);
    this.kvs = /* @__PURE__ */ new Map();
  }
  _createClass(NameMap2, [{
    key: "set",
    value: function set2(key, value) {
      this.kvs.set(normalize(key), value);
    }
  }, {
    key: "get",
    value: function get2(key) {
      return this.kvs.get(normalize(key));
    }
  }, {
    key: "update",
    value: function update2(key, updater) {
      var origin = this.get(key);
      var next2 = updater(origin);
      if (!next2) {
        this.delete(key);
      } else {
        this.set(key, next2);
      }
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      this.kvs.delete(normalize(key));
    }
  }, {
    key: "map",
    value: function map(callback) {
      return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
        var cells = key.split(SPLIT);
        return callback({
          key: cells.map(function(cell) {
            var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type4 = _cell$match2[1], unit = _cell$match2[2];
            return type4 === "number" ? Number(unit) : unit;
          }),
          value
        });
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON2() {
      var json = {};
      this.map(function(_ref3) {
        var key = _ref3.key, value = _ref3.value;
        json[key.join(".")] = value;
        return null;
      });
      return json;
    }
  }]);
  return NameMap2;
}();
var _excluded$s = ["name", "errors"];
var FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {
  var _this = this;
  _classCallCheck(this, FormStore2);
  this.formHooked = false;
  this.forceRootUpdate = void 0;
  this.subscribable = true;
  this.store = {};
  this.fieldEntities = [];
  this.initialValues = {};
  this.callbacks = {};
  this.validateMessages = null;
  this.preserve = null;
  this.lastValidatePromise = null;
  this.getForm = function() {
    return {
      getFieldValue: _this.getFieldValue,
      getFieldsValue: _this.getFieldsValue,
      getFieldError: _this.getFieldError,
      getFieldWarning: _this.getFieldWarning,
      getFieldsError: _this.getFieldsError,
      isFieldsTouched: _this.isFieldsTouched,
      isFieldTouched: _this.isFieldTouched,
      isFieldValidating: _this.isFieldValidating,
      isFieldsValidating: _this.isFieldsValidating,
      resetFields: _this.resetFields,
      setFields: _this.setFields,
      setFieldValue: _this.setFieldValue,
      setFieldsValue: _this.setFieldsValue,
      validateFields: _this.validateFields,
      submit: _this.submit,
      _init: true,
      getInternalHooks: _this.getInternalHooks
    };
  };
  this.getInternalHooks = function(key) {
    if (key === HOOK_MARK) {
      _this.formHooked = true;
      return {
        dispatch: _this.dispatch,
        initEntityValue: _this.initEntityValue,
        registerField: _this.registerField,
        useSubscribe: _this.useSubscribe,
        setInitialValues: _this.setInitialValues,
        destroyForm: _this.destroyForm,
        setCallbacks: _this.setCallbacks,
        setValidateMessages: _this.setValidateMessages,
        getFields: _this.getFields,
        setPreserve: _this.setPreserve,
        getInitialValue: _this.getInitialValue,
        registerWatch: _this.registerWatch
      };
    }
    warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
    return null;
  };
  this.useSubscribe = function(subscribable) {
    _this.subscribable = subscribable;
  };
  this.prevWithoutPreserves = null;
  this.setInitialValues = function(initialValues, init) {
    _this.initialValues = initialValues || {};
    if (init) {
      var _this$prevWithoutPres;
      var nextStore = setValues({}, initialValues, _this.store);
      (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
        var namePath = _ref.key;
        nextStore = setValue(nextStore, namePath, getValue$4(initialValues, namePath));
      });
      _this.prevWithoutPreserves = null;
      _this.updateStore(nextStore);
    }
  };
  this.destroyForm = function() {
    var prevWithoutPreserves = new NameMap();
    _this.getFieldEntities(true).forEach(function(entity) {
      if (!_this.isMergedPreserve(entity.isPreserve())) {
        prevWithoutPreserves.set(entity.getNamePath(), true);
      }
    });
    _this.prevWithoutPreserves = prevWithoutPreserves;
  };
  this.getInitialValue = function(namePath) {
    var initValue = getValue$4(_this.initialValues, namePath);
    return namePath.length ? cloneDeep(initValue) : initValue;
  };
  this.setCallbacks = function(callbacks) {
    _this.callbacks = callbacks;
  };
  this.setValidateMessages = function(validateMessages) {
    _this.validateMessages = validateMessages;
  };
  this.setPreserve = function(preserve) {
    _this.preserve = preserve;
  };
  this.watchList = [];
  this.registerWatch = function(callback) {
    _this.watchList.push(callback);
    return function() {
      _this.watchList = _this.watchList.filter(function(fn2) {
        return fn2 !== callback;
      });
    };
  };
  this.notifyWatch = function() {
    var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (_this.watchList.length) {
      var values = _this.getFieldsValue();
      _this.watchList.forEach(function(callback) {
        callback(values, namePath);
      });
    }
  };
  this.timeoutId = null;
  this.warningUnhooked = function() {
  };
  this.updateStore = function(nextStore) {
    _this.store = nextStore;
  };
  this.getFieldEntities = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    if (!pure) {
      return _this.fieldEntities;
    }
    return _this.fieldEntities.filter(function(field) {
      return field.getNamePath().length;
    });
  };
  this.getFieldsMap = function() {
    var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
    var cache = new NameMap();
    _this.getFieldEntities(pure).forEach(function(field) {
      var namePath = field.getNamePath();
      cache.set(namePath, field);
    });
    return cache;
  };
  this.getFieldEntitiesForNamePathList = function(nameList) {
    if (!nameList) {
      return _this.getFieldEntities(true);
    }
    var cache = _this.getFieldsMap(true);
    return nameList.map(function(name2) {
      var namePath = getNamePath(name2);
      return cache.get(namePath) || {
        INVALIDATE_NAME_PATH: getNamePath(name2)
      };
    });
  };
  this.getFieldsValue = function(nameList, filterFunc) {
    _this.warningUnhooked();
    if (nameList === true && !filterFunc) {
      return _this.store;
    }
    var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
    var filteredNameList = [];
    fieldEntities.forEach(function(entity) {
      var _entity$isListField;
      var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
      if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
        return;
      }
      if (!filterFunc) {
        filteredNameList.push(namePath);
      } else {
        var meta = "getMeta" in entity ? entity.getMeta() : null;
        if (filterFunc(meta)) {
          filteredNameList.push(namePath);
        }
      }
    });
    return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
  };
  this.getFieldValue = function(name2) {
    _this.warningUnhooked();
    var namePath = getNamePath(name2);
    return getValue$4(_this.store, namePath);
  };
  this.getFieldsError = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
    return fieldEntities.map(function(entity, index2) {
      if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
        return {
          name: entity.getNamePath(),
          errors: entity.getErrors(),
          warnings: entity.getWarnings()
        };
      }
      return {
        name: getNamePath(nameList[index2]),
        errors: [],
        warnings: []
      };
    });
  };
  this.getFieldError = function(name2) {
    _this.warningUnhooked();
    var namePath = getNamePath(name2);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.errors;
  };
  this.getFieldWarning = function(name2) {
    _this.warningUnhooked();
    var namePath = getNamePath(name2);
    var fieldError = _this.getFieldsError([namePath])[0];
    return fieldError.warnings;
  };
  this.isFieldsTouched = function() {
    _this.warningUnhooked();
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var arg0 = args[0], arg1 = args[1];
    var namePathList;
    var isAllFieldsTouched = false;
    if (args.length === 0) {
      namePathList = null;
    } else if (args.length === 1) {
      if (Array.isArray(arg0)) {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = false;
      } else {
        namePathList = null;
        isAllFieldsTouched = arg0;
      }
    } else {
      namePathList = arg0.map(getNamePath);
      isAllFieldsTouched = arg1;
    }
    var fieldEntities = _this.getFieldEntities(true);
    var isFieldTouched = function isFieldTouched2(field) {
      return field.isFieldTouched();
    };
    if (!namePathList) {
      return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
    }
    var map = new NameMap();
    namePathList.forEach(function(shortNamePath) {
      map.set(shortNamePath, []);
    });
    fieldEntities.forEach(function(field) {
      var fieldNamePath = field.getNamePath();
      namePathList.forEach(function(shortNamePath) {
        if (shortNamePath.every(function(nameUnit, i2) {
          return fieldNamePath[i2] === nameUnit;
        })) {
          map.update(shortNamePath, function(list) {
            return [].concat(_toConsumableArray(list), [field]);
          });
        }
      });
    });
    var isNamePathListTouched = function isNamePathListTouched2(entities) {
      return entities.some(isFieldTouched);
    };
    var namePathListEntities = map.map(function(_ref2) {
      var value = _ref2.value;
      return value;
    });
    return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
  };
  this.isFieldTouched = function(name2) {
    _this.warningUnhooked();
    return _this.isFieldsTouched([name2]);
  };
  this.isFieldsValidating = function(nameList) {
    _this.warningUnhooked();
    var fieldEntities = _this.getFieldEntities();
    if (!nameList) {
      return fieldEntities.some(function(testField) {
        return testField.isFieldValidating();
      });
    }
    var namePathList = nameList.map(getNamePath);
    return fieldEntities.some(function(testField) {
      var fieldNamePath = testField.getNamePath();
      return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
    });
  };
  this.isFieldValidating = function(name2) {
    _this.warningUnhooked();
    return _this.isFieldsValidating([name2]);
  };
  this.resetWithFieldInitialValue = function() {
    var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var cache = new NameMap();
    var fieldEntities = _this.getFieldEntities(true);
    fieldEntities.forEach(function(field) {
      var initialValue = field.props.initialValue;
      var namePath = field.getNamePath();
      if (initialValue !== void 0) {
        var records = cache.get(namePath) || /* @__PURE__ */ new Set();
        records.add({
          entity: field,
          value: initialValue
        });
        cache.set(namePath, records);
      }
    });
    var resetWithFields = function resetWithFields2(entities) {
      entities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        if (initialValue !== void 0) {
          var namePath = field.getNamePath();
          var formInitialValue = _this.getInitialValue(namePath);
          if (formInitialValue !== void 0) {
            warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
          } else {
            var records = cache.get(namePath);
            if (records && records.size > 1) {
              warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            } else if (records) {
              var originValue = _this.getFieldValue(namePath);
              if (!info.skipExist || originValue === void 0) {
                _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));
              }
            }
          }
        }
      });
    };
    var requiredFieldEntities;
    if (info.entities) {
      requiredFieldEntities = info.entities;
    } else if (info.namePathList) {
      requiredFieldEntities = [];
      info.namePathList.forEach(function(namePath) {
        var records = cache.get(namePath);
        if (records) {
          var _requiredFieldEntitie;
          (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
            return r2.entity;
          })));
        }
      });
    } else {
      requiredFieldEntities = fieldEntities;
    }
    resetWithFields(requiredFieldEntities);
  };
  this.resetFields = function(nameList) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (!nameList) {
      _this.updateStore(setValues({}, _this.initialValues));
      _this.resetWithFieldInitialValue();
      _this.notifyObservers(prevStore, null, {
        type: "reset"
      });
      _this.notifyWatch();
      return;
    }
    var namePathList = nameList.map(getNamePath);
    namePathList.forEach(function(namePath) {
      var initialValue = _this.getInitialValue(namePath);
      _this.updateStore(setValue(_this.store, namePath, initialValue));
    });
    _this.resetWithFieldInitialValue({
      namePathList
    });
    _this.notifyObservers(prevStore, namePathList, {
      type: "reset"
    });
    _this.notifyWatch(namePathList);
  };
  this.setFields = function(fields) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    var namePathList = [];
    fields.forEach(function(fieldData) {
      var name2 = fieldData.name;
      fieldData.errors;
      var data = _objectWithoutProperties(fieldData, _excluded$s);
      var namePath = getNamePath(name2);
      namePathList.push(namePath);
      if ("value" in data) {
        _this.updateStore(setValue(_this.store, namePath, data.value));
      }
      _this.notifyObservers(prevStore, [namePath], {
        type: "setField",
        data: fieldData
      });
    });
    _this.notifyWatch(namePathList);
  };
  this.getFields = function() {
    var entities = _this.getFieldEntities(true);
    var fields = entities.map(function(field) {
      var namePath = field.getNamePath();
      var meta = field.getMeta();
      var fieldData = _objectSpread2$1(_objectSpread2$1({}, meta), {}, {
        name: namePath,
        value: _this.getFieldValue(namePath)
      });
      Object.defineProperty(fieldData, "originRCField", {
        value: true
      });
      return fieldData;
    });
    return fields;
  };
  this.initEntityValue = function(entity) {
    var initialValue = entity.props.initialValue;
    if (initialValue !== void 0) {
      var namePath = entity.getNamePath();
      var prevValue = getValue$4(_this.store, namePath);
      if (prevValue === void 0) {
        _this.updateStore(setValue(_this.store, namePath, initialValue));
      }
    }
  };
  this.isMergedPreserve = function(fieldPreserve) {
    var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
    return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
  };
  this.registerField = function(entity) {
    _this.fieldEntities.push(entity);
    var namePath = entity.getNamePath();
    _this.notifyWatch([namePath]);
    if (entity.props.initialValue !== void 0) {
      var prevStore = _this.store;
      _this.resetWithFieldInitialValue({
        entities: [entity],
        skipExist: true
      });
      _this.notifyObservers(prevStore, [entity.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(isListField, preserve) {
      var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      _this.fieldEntities = _this.fieldEntities.filter(function(item) {
        return item !== entity;
      });
      if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
        var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
        if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
          return !matchNamePath(field.getNamePath(), namePath);
        })) {
          var _prevStore = _this.store;
          _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));
          _this.notifyObservers(_prevStore, [namePath], {
            type: "remove"
          });
          _this.triggerDependenciesUpdate(_prevStore, namePath);
        }
      }
      _this.notifyWatch([namePath]);
    };
  };
  this.dispatch = function(action) {
    switch (action.type) {
      case "updateValue": {
        var namePath = action.namePath, value = action.value;
        _this.updateValue(namePath, value);
        break;
      }
      case "validateField": {
        var _namePath = action.namePath, triggerName = action.triggerName;
        _this.validateFields([_namePath], {
          triggerName
        });
        break;
      }
    }
  };
  this.notifyObservers = function(prevStore, namePathList, info) {
    if (_this.subscribable) {
      var mergedInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        store: _this.getFieldsValue(true)
      });
      _this.getFieldEntities().forEach(function(_ref3) {
        var onStoreChange = _ref3.onStoreChange;
        onStoreChange(prevStore, namePathList, mergedInfo);
      });
    } else {
      _this.forceRootUpdate();
    }
  };
  this.triggerDependenciesUpdate = function(prevStore, namePath) {
    var childrenFields = _this.getDependencyChildrenFields(namePath);
    if (childrenFields.length) {
      _this.validateFields(childrenFields);
    }
    _this.notifyObservers(prevStore, childrenFields, {
      type: "dependenciesUpdate",
      relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
    });
    return childrenFields;
  };
  this.updateValue = function(name2, value) {
    var namePath = getNamePath(name2);
    var prevStore = _this.store;
    _this.updateStore(setValue(_this.store, namePath, value));
    _this.notifyObservers(prevStore, [namePath], {
      type: "valueUpdate",
      source: "internal"
    });
    _this.notifyWatch([namePath]);
    var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
    var onValuesChange = _this.callbacks.onValuesChange;
    if (onValuesChange) {
      var changedValues = cloneByNamePathList(_this.store, [namePath]);
      onValuesChange(changedValues, _this.getFieldsValue());
    }
    _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
  };
  this.setFieldsValue = function(store2) {
    _this.warningUnhooked();
    var prevStore = _this.store;
    if (store2) {
      var nextStore = setValues(_this.store, store2);
      _this.updateStore(nextStore);
    }
    _this.notifyObservers(prevStore, null, {
      type: "valueUpdate",
      source: "external"
    });
    _this.notifyWatch();
  };
  this.setFieldValue = function(name2, value) {
    _this.setFields([{
      name: name2,
      value
    }]);
  };
  this.getDependencyChildrenFields = function(rootNamePath) {
    var children = /* @__PURE__ */ new Set();
    var childrenFields = [];
    var dependencies2fields = new NameMap();
    _this.getFieldEntities().forEach(function(field) {
      var dependencies = field.props.dependencies;
      (dependencies || []).forEach(function(dependency) {
        var dependencyNamePath = getNamePath(dependency);
        dependencies2fields.update(dependencyNamePath, function() {
          var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          fields.add(field);
          return fields;
        });
      });
    });
    var fillChildren = function fillChildren2(namePath) {
      var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
      fields.forEach(function(field) {
        if (!children.has(field)) {
          children.add(field);
          var fieldNamePath = field.getNamePath();
          if (field.isFieldDirty() && fieldNamePath.length) {
            childrenFields.push(fieldNamePath);
            fillChildren2(fieldNamePath);
          }
        }
      });
    };
    fillChildren(rootNamePath);
    return childrenFields;
  };
  this.triggerOnFieldsChange = function(namePathList, filedErrors) {
    var onFieldsChange = _this.callbacks.onFieldsChange;
    if (onFieldsChange) {
      var fields = _this.getFields();
      if (filedErrors) {
        var cache = new NameMap();
        filedErrors.forEach(function(_ref4) {
          var name2 = _ref4.name, errors = _ref4.errors;
          cache.set(name2, errors);
        });
        fields.forEach(function(field) {
          field.errors = cache.get(field.name) || field.errors;
        });
      }
      var changedFields = fields.filter(function(_ref5) {
        var fieldName = _ref5.name;
        return containsNamePath(namePathList, fieldName);
      });
      onFieldsChange(changedFields, fields);
    }
  };
  this.validateFields = function(nameList, options) {
    _this.warningUnhooked();
    var provideNameList = !!nameList;
    var namePathList = provideNameList ? nameList.map(getNamePath) : [];
    var promiseList = [];
    _this.getFieldEntities(true).forEach(function(field) {
      if (!provideNameList) {
        namePathList.push(field.getNamePath());
      }
      if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {
        var namePath = field.getNamePath();
        if (namePath.every(function(nameUnit, i2) {
          return nameList[i2] === nameUnit || nameList[i2] === void 0;
        })) {
          namePathList.push(namePath);
        }
      }
      if (!field.props.rules || !field.props.rules.length) {
        return;
      }
      var fieldNamePath = field.getNamePath();
      if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
        var promise2 = field.validateRules(_objectSpread2$1({
          validateMessages: _objectSpread2$1(_objectSpread2$1({}, defaultValidateMessages), _this.validateMessages)
        }, options));
        promiseList.push(promise2.then(function() {
          return {
            name: fieldNamePath,
            errors: [],
            warnings: []
          };
        }).catch(function(ruleErrors) {
          var _ruleErrors$forEach;
          var mergedErrors = [];
          var mergedWarnings = [];
          (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
            var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
            if (warningOnly) {
              mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
            } else {
              mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
            }
          });
          if (mergedErrors.length) {
            return Promise.reject({
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            });
          }
          return {
            name: fieldNamePath,
            errors: mergedErrors,
            warnings: mergedWarnings
          };
        }));
      }
    });
    var summaryPromise = allPromiseFinish(promiseList);
    _this.lastValidatePromise = summaryPromise;
    summaryPromise.catch(function(results) {
      return results;
    }).then(function(results) {
      var resultNamePathList = results.map(function(_ref7) {
        var name2 = _ref7.name;
        return name2;
      });
      _this.notifyObservers(_this.store, resultNamePathList, {
        type: "validateFinish"
      });
      _this.triggerOnFieldsChange(resultNamePathList, results);
    });
    var returnPromise = summaryPromise.then(function() {
      if (_this.lastValidatePromise === summaryPromise) {
        return Promise.resolve(_this.getFieldsValue(namePathList));
      }
      return Promise.reject([]);
    }).catch(function(results) {
      var errorList = results.filter(function(result) {
        return result && result.errors.length;
      });
      return Promise.reject({
        values: _this.getFieldsValue(namePathList),
        errorFields: errorList,
        outOfDate: _this.lastValidatePromise !== summaryPromise
      });
    });
    returnPromise.catch(function(e2) {
      return e2;
    });
    return returnPromise;
  };
  this.submit = function() {
    _this.warningUnhooked();
    _this.validateFields().then(function(values) {
      var onFinish = _this.callbacks.onFinish;
      if (onFinish) {
        try {
          onFinish(values);
        } catch (err) {
          console.error(err);
        }
      }
    }).catch(function(e2) {
      var onFinishFailed = _this.callbacks.onFinishFailed;
      if (onFinishFailed) {
        onFinishFailed(e2);
      }
    });
  };
  this.forceRootUpdate = forceRootUpdate;
});
function useForm$2(form) {
  var formRef = react.exports.useRef();
  var _React$useState = react.exports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
  if (!formRef.current) {
    if (form) {
      formRef.current = form;
    } else {
      var forceReRender = function forceReRender2() {
        forceUpdate({});
      };
      var formStore = new FormStore(forceReRender);
      formRef.current = formStore.getForm();
    }
  }
  return [formRef.current];
}
var FormContext$1 = /* @__PURE__ */ react.exports.createContext({
  triggerFormChange: function triggerFormChange() {
  },
  triggerFormFinish: function triggerFormFinish() {
  },
  registerForm: function registerForm() {
  },
  unregisterForm: function unregisterForm() {
  }
});
var FormProvider$1 = function FormProvider(_ref) {
  var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
  var formContext = react.exports.useContext(FormContext$1);
  var formsRef = react.exports.useRef({});
  return /* @__PURE__ */ jsx(FormContext$1.Provider, {
    value: _objectSpread2$1(_objectSpread2$1({}, formContext), {}, {
      validateMessages: _objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages),
      triggerFormChange: function triggerFormChange2(name2, changedFields) {
        if (onFormChange) {
          onFormChange(name2, {
            changedFields,
            forms: formsRef.current
          });
        }
        formContext.triggerFormChange(name2, changedFields);
      },
      triggerFormFinish: function triggerFormFinish2(name2, values) {
        if (onFormFinish) {
          onFormFinish(name2, {
            values,
            forms: formsRef.current
          });
        }
        formContext.triggerFormFinish(name2, values);
      },
      registerForm: function registerForm2(name2, form) {
        if (name2) {
          formsRef.current = _objectSpread2$1(_objectSpread2$1({}, formsRef.current), {}, _defineProperty$1({}, name2, form));
        }
        formContext.registerForm(name2, form);
      },
      unregisterForm: function unregisterForm2(name2) {
        var newForms = _objectSpread2$1({}, formsRef.current);
        delete newForms[name2];
        formsRef.current = newForms;
        formContext.unregisterForm(name2);
      }
    }),
    children
  });
};
var _excluded$r = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
var Form$3 = function Form(_ref, ref) {
  var name2 = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties(_ref, _excluded$r);
  var formContext = react.exports.useContext(FormContext$1);
  var _useForm = useForm$2(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
  var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
  react.exports.useImperativeHandle(ref, function() {
    return formInstance;
  });
  react.exports.useEffect(function() {
    formContext.registerForm(name2, formInstance);
    return function() {
      formContext.unregisterForm(name2);
    };
  }, [formContext, formInstance, name2]);
  setValidateMessages(_objectSpread2$1(_objectSpread2$1({}, formContext.validateMessages), validateMessages));
  setCallbacks({
    onValuesChange,
    onFieldsChange: function onFieldsChange(changedFields) {
      formContext.triggerFormChange(name2, changedFields);
      if (_onFieldsChange) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }
        _onFieldsChange.apply(void 0, [changedFields].concat(rest));
      }
    },
    onFinish: function onFinish(values2) {
      formContext.triggerFormFinish(name2, values2);
      if (_onFinish) {
        _onFinish(values2);
      }
    },
    onFinishFailed
  });
  setPreserve(preserve);
  var mountRef = react.exports.useRef(null);
  setInitialValues(initialValues, !mountRef.current);
  if (!mountRef.current) {
    mountRef.current = true;
  }
  react.exports.useEffect(
    function() {
      return destroyForm;
    },
    []
  );
  var childrenNode;
  var childrenRenderProps = typeof children === "function";
  if (childrenRenderProps) {
    var values = formInstance.getFieldsValue(true);
    childrenNode = children(values, formInstance);
  } else {
    childrenNode = children;
  }
  useSubscribe(!childrenRenderProps);
  var prevFieldsRef = react.exports.useRef();
  react.exports.useEffect(function() {
    if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
      formInstance.setFields(fields || []);
    }
    prevFieldsRef.current = fields;
  }, [fields, formInstance]);
  var formContextValue = react.exports.useMemo(function() {
    return _objectSpread2$1(_objectSpread2$1({}, formInstance), {}, {
      validateTrigger
    });
  }, [formInstance, validateTrigger]);
  var wrapperNode = /* @__PURE__ */ jsx(Context$1.Provider, {
    value: formContextValue,
    children: childrenNode
  });
  if (Component2 === false) {
    return wrapperNode;
  }
  return /* @__PURE__ */ jsx(Component2, {
    ...restProps,
    onSubmit: function onSubmit(event) {
      event.preventDefault();
      event.stopPropagation();
      formInstance.submit();
    },
    onReset: function onReset(event) {
      var _restProps$onReset;
      event.preventDefault();
      formInstance.resetFields();
      (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
    },
    children: wrapperNode
  });
};
function stringify$1(value) {
  try {
    return JSON.stringify(value);
  } catch (err) {
    return Math.random();
  }
}
function useWatch() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, form = args[1];
  var _useState = react.exports.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue2 = _useState2[1];
  var valueStr = react.exports.useMemo(function() {
    return stringify$1(value);
  }, [value]);
  var valueStrRef = react.exports.useRef(valueStr);
  valueStrRef.current = valueStr;
  var fieldContext = react.exports.useContext(Context$1);
  var formInstance = form || fieldContext;
  var isValidForm = formInstance && formInstance._init;
  var namePath = getNamePath(dependencies);
  var namePathRef = react.exports.useRef(namePath);
  namePathRef.current = namePath;
  react.exports.useEffect(
    function() {
      if (!isValidForm) {
        return;
      }
      var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks;
      var _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
      var cancelRegister = registerWatch(function(store2) {
        var newValue = getValue$4(store2, namePathRef.current);
        var nextValueStr = stringify$1(newValue);
        if (valueStrRef.current !== nextValueStr) {
          valueStrRef.current = nextValueStr;
          setValue2(newValue);
        }
      });
      var initialValue = getValue$4(getFieldsValue(), namePathRef.current);
      setValue2(initialValue);
      return cancelRegister;
    },
    [isValidForm]
  );
  return value;
}
var InternalForm$2 = /* @__PURE__ */ react.exports.forwardRef(Form$3);
var RefForm = InternalForm$2;
RefForm.FormProvider = FormProvider$1;
RefForm.Field = WrapperField;
RefForm.List = List$1;
RefForm.useForm = useForm$2;
RefForm.useWatch = useWatch;
const enUS$1 = {
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
var locale$5 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const locale$4 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
const TimePicker = locale$4;
const locale$3 = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, locale$5),
  timePickerLocale: Object.assign({}, TimePicker)
};
const enUS = locale$3;
const typeTemplate$1 = "${label} is not a valid ${type}";
const localeValues$1 = {
  locale: "en",
  Pagination: enUS$1,
  DatePicker: enUS,
  TimePicker,
  Calendar: enUS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh"
  }
};
const defaultLocale = localeValues$1;
let runtimeLocale = Object.assign({}, defaultLocale.Modal);
function changeConfirmLocale(newLocale) {
  if (newLocale) {
    runtimeLocale = Object.assign(Object.assign({}, runtimeLocale), newLocale);
  } else {
    runtimeLocale = Object.assign({}, defaultLocale.Modal);
  }
}
const LocaleContext = /* @__PURE__ */ react.exports.createContext(void 0);
const LocaleContext$1 = LocaleContext;
const ANT_MARK = "internalMark";
const LocaleProvider = (props) => {
  const {
    locale: locale2 = {},
    children,
    _ANT_MARK__
  } = props;
  react.exports.useEffect(() => {
    changeConfirmLocale(locale2 && locale2.Modal);
    return () => {
      changeConfirmLocale();
    };
  }, [locale2]);
  const getMemoizedContextValue = react.exports.useMemo(() => Object.assign(Object.assign({}, locale2), {
    exist: true
  }), [locale2]);
  return /* @__PURE__ */ jsx(LocaleContext$1.Provider, {
    value: getMemoizedContextValue,
    children
  });
};
const LocaleProvider$1 = LocaleProvider;
const version$4 = "5.2.3";
const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
function bound01(n2, max) {
  if (isOnePointZero(n2)) {
    n2 = "100%";
  }
  var isPercent = isPercentage(n2);
  n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
  if (isPercent) {
    n2 = parseInt(String(n2 * max), 10) / 100;
  }
  if (Math.abs(n2 - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
  } else {
    n2 = n2 % max / parseFloat(String(max));
  }
  return n2;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n2) {
  return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
}
function isPercentage(n2) {
  return typeof n2 === "string" && n2.indexOf("%") !== -1;
}
function boundAlpha(a2) {
  a2 = parseFloat(a2);
  if (isNaN(a2) || a2 < 0 || a2 > 1) {
    a2 = 1;
  }
  return a2;
}
function convertToPercentage(n2) {
  if (n2 <= 1) {
    return "".concat(Number(n2) * 100, "%");
  }
  return n2;
}
function pad2(c2) {
  return c2.length === 1 ? "0" + c2 : String(c2);
}
function rgbToRgb(r2, g2, b2) {
  return {
    r: bound01(r2, 255) * 255,
    g: bound01(g2, 255) * 255,
    b: bound01(b2, 255) * 255
  };
}
function rgbToHsl(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var s2 = 0;
  var l2 = (max + min) / 2;
  if (max === min) {
    s2 = 0;
    h2 = 0;
  } else {
    var d2 = max - min;
    s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, l: l2 };
}
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) {
    t2 += 1;
  }
  if (t2 > 1) {
    t2 -= 1;
  }
  if (t2 < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t2);
  }
  if (t2 < 1 / 2) {
    return q2;
  }
  if (t2 < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
  }
  return p2;
}
function hslToRgb(h2, s2, l2) {
  var r2;
  var g2;
  var b2;
  h2 = bound01(h2, 360);
  s2 = bound01(s2, 100);
  l2 = bound01(l2, 100);
  if (s2 === 0) {
    g2 = l2;
    b2 = l2;
    r2 = l2;
  } else {
    var q2 = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    var p2 = 2 * l2 - q2;
    r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    g2 = hue2rgb(p2, q2, h2);
    b2 = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHsv(r2, g2, b2) {
  r2 = bound01(r2, 255);
  g2 = bound01(g2, 255);
  b2 = bound01(b2, 255);
  var max = Math.max(r2, g2, b2);
  var min = Math.min(r2, g2, b2);
  var h2 = 0;
  var v2 = max;
  var d2 = max - min;
  var s2 = max === 0 ? 0 : d2 / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r2:
        h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
        break;
      case g2:
        h2 = (b2 - r2) / d2 + 2;
        break;
      case b2:
        h2 = (r2 - g2) / d2 + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s: s2, v: v2 };
}
function hsvToRgb(h2, s2, v2) {
  h2 = bound01(h2, 360) * 6;
  s2 = bound01(s2, 100);
  v2 = bound01(v2, 100);
  var i2 = Math.floor(h2);
  var f2 = h2 - i2;
  var p2 = v2 * (1 - s2);
  var q2 = v2 * (1 - f2 * s2);
  var t2 = v2 * (1 - (1 - f2) * s2);
  var mod = i2 % 6;
  var r2 = [v2, q2, p2, p2, t2, v2][mod];
  var g2 = [t2, v2, v2, q2, p2, p2][mod];
  var b2 = [p2, p2, t2, v2, v2, q2][mod];
  return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
}
function rgbToHex(r2, g2, b2, allow3Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16))
  ];
  if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r2, g2, b2, a2, allow4Char) {
  var hex2 = [
    pad2(Math.round(r2).toString(16)),
    pad2(Math.round(g2).toString(16)),
    pad2(Math.round(b2).toString(16)),
    pad2(convertDecimalToHex(a2))
  ];
  if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function convertDecimalToHex(d2) {
  return Math.round(parseFloat(d2) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a2 = 1;
  var s2 = null;
  var v2 = null;
  var l2 = null;
  var ok2 = false;
  var format2 = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok2 = true;
      format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s2 = convertToPercentage(color.s);
      v2 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s2, v2);
      ok2 = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s2 = convertToPercentage(color.s);
      l2 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s2, l2);
      ok2 = true;
      format2 = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a2 = color.a;
    }
  }
  a2 = boundAlpha(a2);
  return {
    ok: ok2,
    format: color.format || format2,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a2
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = function() {
  function TinyColor2(color, opts) {
    if (color === void 0) {
      color = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a;
    if (color instanceof TinyColor2) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    var rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a = opts.format) !== null && _a !== void 0 ? _a : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R2;
    var G2;
    var B2;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.isMonochrome = function() {
    var s2 = this.toHsl().s;
    return s2 === 0;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s2 = Math.round(hsv.s * 100);
    var v2 = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s2, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s2 = Math.round(hsl.s * 100);
    var l2 = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s2, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toHexShortString = function(allowShortChar) {
    if (allowShortChar === void 0) {
      allowShortChar = false;
    }
    return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r2 = Math.round(this.r);
    var g2 = Math.round(this.g);
    var b2 = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x2) {
      return "".concat(Math.round(bound01(x2, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x2) {
      return Math.round(bound01(x2, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a = Object.entries(names); _i < _a.length; _i++) {
      var _b = _a[_i], key = _b[0], value = _b[1];
      if (hex2 === value) {
        return key;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format2) {
    var formatSet = Boolean(format2);
    format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s2 = hsv.s;
    var v2 = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s: s2, v: v2 }));
      v2 = (v2 + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg2 = this.toRgb();
    var bg2 = new TinyColor2(background).toRgb();
    var alpha = fg2.a + bg2.a * (1 - fg2.a);
    return new TinyColor2({
      r: (fg2.r * fg2.a + bg2.r * bg2.a * (1 - fg2.a)) / alpha,
      g: (fg2.g * fg2.a + bg2.g * bg2.a * (1 - fg2.a)) / alpha,
      b: (fg2.b * fg2.a + bg2.b * bg2.a * (1 - fg2.a)) / alpha,
      a: alpha
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n2) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result = [this];
    var increment = 360 / n2;
    for (var i2 = 1; i2 < n2; i2++) {
      result.push(new TinyColor2({ h: (h2 + i2 * increment) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color) {
    return this.toRgbString() === new TinyColor2(color).toRgbString();
  };
  return TinyColor2;
}();
var hueStep$1 = 2;
var saturationStep$1 = 0.16;
var saturationStep2$1 = 0.05;
var brightnessStep1$1 = 0.05;
var brightnessStep2$1 = 0.15;
var lightColorCount$1 = 5;
var darkColorCount$1 = 4;
var darkColorMap$1 = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv$1(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex$1(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b2, false));
}
function mix$2(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue$1(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep$1 * i2 : Math.round(hsv.h) + hueStep$1 * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep$1 * i2 : Math.round(hsv.h) - hueStep$1 * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation$1(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep$1 * i2;
  } else if (i2 === darkColorCount$1) {
    saturation = hsv.s + saturationStep$1;
  } else {
    saturation = hsv.s + saturationStep2$1 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount$1 && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue$3(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1$1 * i2;
  } else {
    value = hsv.v - brightnessStep2$1 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate$3(color) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color);
  for (var i2 = lightColorCount$1; i2 > 0; i2 -= 1) {
    var hsv = toHsv$1(pColor);
    var colorString = toHex$1(inputToRGB({
      h: getHue$1(hsv, i2, true),
      s: getSaturation$1(hsv, i2, true),
      v: getValue$3(hsv, i2, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex$1(pColor));
  for (var _i = 1; _i <= darkColorCount$1; _i += 1) {
    var _hsv = toHsv$1(pColor);
    var _colorString = toHex$1(inputToRGB({
      h: getHue$1(_hsv, _i),
      s: getSaturation$1(_hsv, _i),
      v: getValue$3(_hsv, _i)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap$1.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex$1(mix$2(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors$1 = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes$1 = {};
var presetDarkPalettes$1 = {};
Object.keys(presetPrimaryColors$1).forEach(function(key) {
  presetPalettes$1[key] = generate$3(presetPrimaryColors$1[key]);
  presetPalettes$1[key].primary = presetPalettes$1[key][5];
  presetDarkPalettes$1[key] = generate$3(presetPrimaryColors$1[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes$1[key].primary = presetDarkPalettes$1[key][5];
});
var gold = presetPalettes$1.gold;
const genControlHeight = (token2) => {
  const {
    controlHeight
  } = token2;
  return {
    controlHeightSM: controlHeight * 0.75,
    controlHeightXS: controlHeight * 0.5,
    controlHeightLG: controlHeight * 1.25
  };
};
const genControlHeight$1 = genControlHeight;
function genSizeMapToken$1(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  return {
    sizeXXL: sizeUnit * (sizeStep + 8),
    sizeXL: sizeUnit * (sizeStep + 4),
    sizeLG: sizeUnit * (sizeStep + 2),
    sizeMD: sizeUnit * (sizeStep + 1),
    sizeMS: sizeUnit * sizeStep,
    size: sizeUnit * sizeStep,
    sizeSM: sizeUnit * (sizeStep - 1),
    sizeXS: sizeUnit * (sizeStep - 2),
    sizeXXS: sizeUnit * (sizeStep - 3)
  };
}
const defaultPresetColors = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
};
const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
  fontSize: 14,
  lineWidth: 1,
  lineType: "solid",
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  borderRadius: 6,
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  controlHeight: 32,
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  opacityImage: 1,
  wireframe: false
});
const defaultSeedToken = seedToken;
function genColorMapToken(seed, _ref) {
  let {
    generateColorPalettes: generateColorPalettes2,
    generateNeutralColorPalettes: generateNeutralColorPalettes2
  } = _ref;
  const {
    colorSuccess: colorSuccessBase,
    colorWarning: colorWarningBase,
    colorError: colorErrorBase,
    colorInfo: colorInfoBase,
    colorPrimary: colorPrimaryBase,
    colorBgBase,
    colorTextBase
  } = seed;
  const primaryColors = generateColorPalettes2(colorPrimaryBase);
  const successColors = generateColorPalettes2(colorSuccessBase);
  const warningColors = generateColorPalettes2(colorWarningBase);
  const errorColors = generateColorPalettes2(colorErrorBase);
  const infoColors = generateColorPalettes2(colorInfoBase);
  const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
  return Object.assign(Object.assign({}, neutralColors), {
    colorPrimaryBg: primaryColors[1],
    colorPrimaryBgHover: primaryColors[2],
    colorPrimaryBorder: primaryColors[3],
    colorPrimaryBorderHover: primaryColors[4],
    colorPrimaryHover: primaryColors[5],
    colorPrimary: primaryColors[6],
    colorPrimaryActive: primaryColors[7],
    colorPrimaryTextHover: primaryColors[8],
    colorPrimaryText: primaryColors[9],
    colorPrimaryTextActive: primaryColors[10],
    colorSuccessBg: successColors[1],
    colorSuccessBgHover: successColors[2],
    colorSuccessBorder: successColors[3],
    colorSuccessBorderHover: successColors[4],
    colorSuccessHover: successColors[4],
    colorSuccess: successColors[6],
    colorSuccessActive: successColors[7],
    colorSuccessTextHover: successColors[8],
    colorSuccessText: successColors[9],
    colorSuccessTextActive: successColors[10],
    colorErrorBg: errorColors[1],
    colorErrorBgHover: errorColors[2],
    colorErrorBorder: errorColors[3],
    colorErrorBorderHover: errorColors[4],
    colorErrorHover: errorColors[5],
    colorError: errorColors[6],
    colorErrorActive: errorColors[7],
    colorErrorTextHover: errorColors[8],
    colorErrorText: errorColors[9],
    colorErrorTextActive: errorColors[10],
    colorWarningBg: warningColors[1],
    colorWarningBgHover: warningColors[2],
    colorWarningBorder: warningColors[3],
    colorWarningBorderHover: warningColors[4],
    colorWarningHover: warningColors[4],
    colorWarning: warningColors[6],
    colorWarningActive: warningColors[7],
    colorWarningTextHover: warningColors[8],
    colorWarningText: warningColors[9],
    colorWarningTextActive: warningColors[10],
    colorInfoBg: infoColors[1],
    colorInfoBgHover: infoColors[2],
    colorInfoBorder: infoColors[3],
    colorInfoBorderHover: infoColors[4],
    colorInfoHover: infoColors[4],
    colorInfo: infoColors[6],
    colorInfoActive: infoColors[7],
    colorInfoTextHover: infoColors[8],
    colorInfoText: infoColors[9],
    colorInfoTextActive: infoColors[10],
    colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const genRadius = (radiusBase) => {
  let radiusLG = radiusBase;
  let radiusSM = radiusBase;
  let radiusXS = radiusBase;
  let radiusOuter = radiusBase;
  if (radiusBase < 6 && radiusBase >= 5) {
    radiusLG = radiusBase + 1;
  } else if (radiusBase < 16 && radiusBase >= 6) {
    radiusLG = radiusBase + 2;
  } else if (radiusBase >= 16) {
    radiusLG = 16;
  }
  if (radiusBase < 7 && radiusBase >= 5) {
    radiusSM = 4;
  } else if (radiusBase < 8 && radiusBase >= 7) {
    radiusSM = 5;
  } else if (radiusBase < 14 && radiusBase >= 8) {
    radiusSM = 6;
  } else if (radiusBase < 16 && radiusBase >= 14) {
    radiusSM = 7;
  } else if (radiusBase >= 16) {
    radiusSM = 8;
  }
  if (radiusBase < 6 && radiusBase >= 2) {
    radiusXS = 1;
  } else if (radiusBase >= 6) {
    radiusXS = 2;
  }
  if (radiusBase > 4 && radiusBase < 8) {
    radiusOuter = 4;
  } else if (radiusBase >= 8) {
    radiusOuter = 6;
  }
  return {
    borderRadius: radiusBase > 16 ? 16 : radiusBase,
    borderRadiusXS: radiusXS,
    borderRadiusSM: radiusSM,
    borderRadiusLG: radiusLG,
    borderRadiusOuter: radiusOuter
  };
};
const genRadius$1 = genRadius;
function genCommonMapToken(token2) {
  const {
    motionUnit,
    motionBase,
    borderRadius,
    lineWidth
  } = token2;
  return Object.assign({
    motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
    motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
    motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
    lineWidthBold: lineWidth + 1
  }, genRadius$1(borderRadius));
}
const getAlphaColor$2 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
const getSolidColor$1 = (baseColor, brightness) => {
  const instance = new TinyColor(baseColor);
  return instance.darken(brightness).toHexString();
};
const generateColorPalettes$1 = (baseColor) => {
  const colors = generate$3(baseColor);
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[4],
    6: colors[5],
    7: colors[6],
    8: colors[4],
    9: colors[5],
    10: colors[6]
  };
};
const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#fff";
  const colorTextBase = textBaseColor || "#000";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor$2(colorTextBase, 0.88),
    colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
    colorFill: getAlphaColor$2(colorTextBase, 0.15),
    colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
    colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
    colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
    colorBgLayout: getSolidColor$1(colorBgBase, 4),
    colorBgContainer: getSolidColor$1(colorBgBase, 0),
    colorBgElevated: getSolidColor$1(colorBgBase, 0),
    colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
    colorBorder: getSolidColor$1(colorBgBase, 15),
    colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
  };
};
function getFontSizes(base) {
  const fontSizes = new Array(10).fill(null).map((_2, index2) => {
    const i2 = index2 - 1;
    const baseSize = base * Math.pow(2.71828, i2 / 5);
    const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
    return Math.floor(intSize / 2) * 2;
  });
  fontSizes[1] = base;
  return fontSizes.map((size) => {
    const height = size + 8;
    return {
      size,
      lineHeight: height / size
    };
  });
}
const genFontMapToken = (fontSize) => {
  const fontSizePairs = getFontSizes(fontSize);
  const fontSizes = fontSizePairs.map((pair) => pair.size);
  const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
  return {
    fontSizeSM: fontSizes[0],
    fontSize: fontSizes[1],
    fontSizeLG: fontSizes[2],
    fontSizeXL: fontSizes[3],
    fontSizeHeading1: fontSizes[6],
    fontSizeHeading2: fontSizes[5],
    fontSizeHeading3: fontSizes[4],
    fontSizeHeading4: fontSizes[3],
    fontSizeHeading5: fontSizes[2],
    lineHeight: lineHeights[1],
    lineHeightLG: lineHeights[2],
    lineHeightSM: lineHeights[0],
    lineHeightHeading1: lineHeights[6],
    lineHeightHeading2: lineHeights[5],
    lineHeightHeading3: lineHeights[4],
    lineHeightHeading4: lineHeights[3],
    lineHeightHeading5: lineHeights[2]
  };
};
const genFontMapToken$1 = genFontMapToken;
function derivative$2(token2) {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate$3(token2[colorKey]);
    return new Array(10).fill(1).reduce((prev2, _2, i2) => {
      prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = Object.assign(Object.assign({}, prev2), cur);
    return prev2;
  }, {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
    generateColorPalettes: generateColorPalettes$1,
    generateNeutralColorPalettes: generateNeutralColorPalettes$1
  })), genFontMapToken$1(token2.fontSize)), genSizeMapToken$1(token2)), genControlHeight$1(token2)), genCommonMapToken(token2));
}
function isStableColor(color) {
  return color >= 0 && color <= 255;
}
function getAlphaColor$1(frontColor, backgroundColor) {
  const {
    r: fR,
    g: fG,
    b: fB,
    a: originAlpha
  } = new TinyColor(frontColor).toRgb();
  if (originAlpha < 1) {
    return frontColor;
  }
  const {
    r: bR,
    g: bG,
    b: bB
  } = new TinyColor(backgroundColor).toRgb();
  for (let fA = 0.01; fA <= 1; fA += 0.01) {
    const r2 = Math.round((fR - bR * (1 - fA)) / fA);
    const g2 = Math.round((fG - bG * (1 - fA)) / fA);
    const b2 = Math.round((fB - bB * (1 - fA)) / fA);
    if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
      return new TinyColor({
        r: r2,
        g: g2,
        b: b2,
        a: Math.round(fA * 100) / 100
      }).toRgbString();
    }
  }
  return new TinyColor({
    r: fR,
    g: fG,
    b: fB,
    a: 1
  }).toRgbString();
}
var __rest$P = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function formatToken(derivativeToken) {
  const {
    override
  } = derivativeToken, restToken = __rest$P(derivativeToken, ["override"]);
  const overrideTokens = Object.assign({}, override);
  Object.keys(defaultSeedToken).forEach((token2) => {
    delete overrideTokens[token2];
  });
  const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
  const screenXS = 480;
  const screenSM = 576;
  const screenMD = 768;
  const screenLG = 992;
  const screenXL = 1200;
  const screenXXL = 1600;
  const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
    colorLink: mergedToken.colorInfoText,
    colorLinkHover: mergedToken.colorInfoHover,
    colorLinkActive: mergedToken.colorInfoActive,
    colorFillContent: mergedToken.colorFillSecondary,
    colorFillContentHover: mergedToken.colorFill,
    colorFillAlter: mergedToken.colorFillQuaternary,
    colorBgContainerDisabled: mergedToken.colorFillTertiary,
    colorBorderBg: mergedToken.colorBgContainer,
    colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
    colorTextPlaceholder: mergedToken.colorTextQuaternary,
    colorTextDisabled: mergedToken.colorTextQuaternary,
    colorTextHeading: mergedToken.colorText,
    colorTextLabel: mergedToken.colorTextSecondary,
    colorTextDescription: mergedToken.colorTextTertiary,
    colorTextLightSolid: mergedToken.colorWhite,
    colorHighlight: mergedToken.colorError,
    colorBgTextHover: mergedToken.colorFillSecondary,
    colorBgTextActive: mergedToken.colorFill,
    colorIcon: mergedToken.colorTextTertiary,
    colorIconHover: mergedToken.colorText,
    colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
    colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
    fontSizeIcon: mergedToken.fontSizeSM,
    lineWidth: mergedToken.lineWidth,
    controlOutlineWidth: mergedToken.lineWidth * 2,
    controlInteractiveSize: mergedToken.controlHeight / 2,
    controlItemBgHover: mergedToken.colorFillTertiary,
    controlItemBgActive: mergedToken.colorPrimaryBg,
    controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
    controlItemBgActiveDisabled: mergedToken.colorFill,
    controlTmpOutline: mergedToken.colorFillQuaternary,
    controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
    lineType: mergedToken.lineType,
    borderRadius: mergedToken.borderRadius,
    borderRadiusXS: mergedToken.borderRadiusXS,
    borderRadiusSM: mergedToken.borderRadiusSM,
    borderRadiusLG: mergedToken.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: mergedToken.sizeXXS,
    paddingXS: mergedToken.sizeXS,
    paddingSM: mergedToken.sizeSM,
    padding: mergedToken.size,
    paddingMD: mergedToken.sizeMD,
    paddingLG: mergedToken.sizeLG,
    paddingXL: mergedToken.sizeXL,
    paddingContentHorizontalLG: mergedToken.sizeLG,
    paddingContentVerticalLG: mergedToken.sizeMS,
    paddingContentHorizontal: mergedToken.sizeMS,
    paddingContentVertical: mergedToken.sizeSM,
    paddingContentHorizontalSM: mergedToken.size,
    paddingContentVerticalSM: mergedToken.sizeXS,
    marginXXS: mergedToken.sizeXXS,
    marginXS: mergedToken.sizeXS,
    marginSM: mergedToken.sizeSM,
    margin: mergedToken.size,
    marginMD: mergedToken.sizeMD,
    marginLG: mergedToken.sizeLG,
    marginXL: mergedToken.sizeXL,
    marginXXL: mergedToken.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS,
    screenXSMin: screenXS,
    screenXSMax: screenSM - 1,
    screenSM,
    screenSMMin: screenSM,
    screenSMMax: screenMD - 1,
    screenMD,
    screenMDMin: screenMD,
    screenMDMax: screenLG - 1,
    screenLG,
    screenLGMin: screenLG,
    screenLGMax: screenXL - 1,
    screenXL,
    screenXLMin: screenXL,
    screenXLMax: screenXXL - 1,
    screenXXL,
    screenXXLMin: screenXXL,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), overrideTokens);
  return aliasToken;
}
const operationUnit = (token2) => ({
  color: token2.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${token2.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: token2.colorLinkHover
  },
  "&:active": {
    color: token2.colorLinkActive
  }
});
const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
  const unitWidth = width / 2;
  const ax = 0;
  const ay = unitWidth;
  const bx = outerRadius * 1 / Math.sqrt(2);
  const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
  const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
  const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
  const dx = 2 * unitWidth - cx;
  const dy = cy;
  const ex = 2 * unitWidth - bx;
  const ey = by;
  const fx = 2 * unitWidth - ax;
  const fy = ay;
  const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
  return {
    borderRadius: {
      _skip_check_: true,
      value: `0 0 ${innerRadius}px`
    },
    pointerEvents: "none",
    width,
    height: width,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width,
      height: width / 2,
      background: bgColor,
      clipPath: `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`,
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: shadowWidth,
      height: shadowWidth,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: true,
        value: `0 0 ${innerRadius}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow,
      zIndex: 0,
      background: "transparent"
    }
  };
};
function genPresetColor(token2, genCss) {
  return PresetColors.reduce((prev2, colorKey) => {
    const lightColor = token2[`${colorKey}-1`];
    const lightBorderColor = token2[`${colorKey}-3`];
    const darkColor = token2[`${colorKey}-6`];
    const textColor = token2[`${colorKey}-7`];
    return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
      lightColor,
      lightBorderColor,
      darkColor,
      textColor
    }));
  }, {});
}
const textEllipsis = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
};
const resetComponent = (token2) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: token2.colorText,
  fontSize: token2.fontSize,
  lineHeight: token2.lineHeight,
  listStyle: "none",
  fontFamily: token2.fontFamily
});
const resetIcon = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
});
const clearFix = () => ({
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    display: "table",
    clear: "both",
    content: '""'
  }
});
const genLinkStyle = (token2) => ({
  a: {
    color: token2.colorLink,
    textDecoration: token2.linkDecoration,
    backgroundColor: "transparent",
    outline: "none",
    cursor: "pointer",
    transition: `color ${token2.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    "&:hover": {
      color: token2.colorLinkHover
    },
    "&:active": {
      color: token2.colorLinkActive
    },
    [`&:active,
  &:hover`]: {
      textDecoration: token2.linkHoverDecoration,
      outline: 0
    },
    "&:focus": {
      textDecoration: token2.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: token2.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
});
const genCommonStyle = (token2, componentPrefixCls) => {
  const {
    fontFamily,
    fontSize
  } = token2;
  const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
  return {
    [rootPrefixSelector]: {
      fontFamily,
      fontSize,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [rootPrefixSelector]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
};
const genFocusOutline = (token2) => ({
  outline: `${token2.lineWidth * 4}px solid ${token2.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
});
const genFocusStyle = (token2) => ({
  "&:focus-visible": Object.assign({}, genFocusOutline(token2))
});
const defaultIconPrefixCls = "anticon";
const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
  if (customizePrefixCls)
    return customizePrefixCls;
  return suffixCls ? `ant-${suffixCls}` : "ant";
};
const ConfigContext = /* @__PURE__ */ react.exports.createContext({
  getPrefixCls: defaultGetPrefixCls,
  iconPrefixCls: defaultIconPrefixCls
});
function genComponentStyleHook(component, styleFn, getDefaultToken) {
  return (prefixCls) => {
    const [theme2, token2, hashId] = useToken$3();
    const {
      getPrefixCls,
      iconPrefixCls
    } = react.exports.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    useStyleRegister({
      theme: theme2,
      token: token2,
      hashId,
      path: ["Shared", rootPrefixCls]
    }, () => [{
      "&": genLinkStyle(token2)
    }]);
    return [useStyleRegister({
      theme: theme2,
      token: token2,
      hashId,
      path: [component, prefixCls, iconPrefixCls]
    }, () => {
      const {
        token: proxyToken,
        flush
      } = statisticToken(token2);
      const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(proxyToken) : getDefaultToken;
      const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), token2[component]);
      const componentCls = `.${prefixCls}`;
      const mergedToken = merge(proxyToken, {
        componentCls,
        prefixCls,
        iconCls: `.${iconPrefixCls}`,
        antCls: `.${rootPrefixCls}`
      }, mergedComponentToken);
      const styleInterpolation = styleFn(mergedToken, {
        hashId,
        prefixCls,
        rootPrefixCls,
        iconPrefixCls,
        overrideComponentToken: token2[component]
      });
      flush(component, mergedComponentToken);
      return [genCommonStyle(token2, prefixCls), styleInterpolation];
    }), hashId];
  };
}
const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
let recording = true;
function merge() {
  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
    objs[_key] = arguments[_key];
  }
  if (!enableStatistic) {
    return Object.assign.apply(Object, [{}].concat(objs));
  }
  recording = false;
  const ret = {};
  objs.forEach((obj) => {
    const keys2 = Object.keys(obj);
    keys2.forEach((key) => {
      Object.defineProperty(ret, key, {
        configurable: true,
        enumerable: true,
        get: () => obj[key]
      });
    });
  });
  recording = true;
  return ret;
}
function noop$1() {
}
function statisticToken(token2) {
  let tokenKeys2;
  let proxy = token2;
  let flush = noop$1;
  if (enableStatistic) {
    tokenKeys2 = /* @__PURE__ */ new Set();
    proxy = new Proxy(token2, {
      get(obj, prop) {
        if (recording) {
          tokenKeys2.add(prop);
        }
        return obj[prop];
      }
    });
    flush = (componentName, componentToken) => {
      ({
        global: Array.from(tokenKeys2),
        component: componentToken
      });
    };
  }
  return {
    token: proxy,
    keys: tokenKeys2,
    flush
  };
}
const defaultTheme = createTheme(derivative$2);
const defaultConfig = {
  token: defaultSeedToken,
  hashed: true
};
const DesignTokenContext = /* @__PURE__ */ React.createContext(defaultConfig);
function useToken$3() {
  const {
    token: rootDesignToken,
    hashed,
    theme: theme2,
    components
  } = React.useContext(DesignTokenContext);
  const salt = `${version$4}-${hashed || ""}`;
  const mergedTheme = theme2 || defaultTheme;
  const [token2, hashId] = useCacheToken(mergedTheme, [defaultSeedToken, rootDesignToken], {
    salt,
    override: Object.assign({
      override: rootDesignToken
    }, components),
    formatToken
  });
  return [mergedTheme, token2, hashed ? hashId : ""];
}
const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
function getStyle$1(globalPrefixCls2, theme2) {
  const variables = {};
  const formatColor = (color, updater) => {
    let clone2 = color.clone();
    clone2 = (updater === null || updater === void 0 ? void 0 : updater(clone2)) || clone2;
    return clone2.toRgbString();
  };
  const fillColor = (colorVal, type4) => {
    const baseColor = new TinyColor(colorVal);
    const colorPalettes = generate$3(baseColor.toRgbString());
    variables[`${type4}-color`] = formatColor(baseColor);
    variables[`${type4}-color-disabled`] = colorPalettes[1];
    variables[`${type4}-color-hover`] = colorPalettes[4];
    variables[`${type4}-color-active`] = colorPalettes[6];
    variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
    variables[`${type4}-color-deprecated-bg`] = colorPalettes[0];
    variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
  };
  if (theme2.primaryColor) {
    fillColor(theme2.primaryColor, "primary");
    const primaryColor = new TinyColor(theme2.primaryColor);
    const primaryColors = generate$3(primaryColor.toRgbString());
    primaryColors.forEach((color, index2) => {
      variables[`primary-${index2 + 1}`] = color;
    });
    variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
    variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
    variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
    variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
    variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
    const primaryActiveColor = new TinyColor(primaryColors[0]);
    variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
    variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
  }
  if (theme2.successColor) {
    fillColor(theme2.successColor, "success");
  }
  if (theme2.warningColor) {
    fillColor(theme2.warningColor, "warning");
  }
  if (theme2.errorColor) {
    fillColor(theme2.errorColor, "error");
  }
  if (theme2.infoColor) {
    fillColor(theme2.infoColor, "info");
  }
  const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
  return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
}
function registerTheme(globalPrefixCls2, theme2) {
  const style2 = getStyle$1(globalPrefixCls2, theme2);
  if (canUseDom()) {
    updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
  }
}
const DisabledContext = /* @__PURE__ */ react.exports.createContext(false);
const DisabledContextProvider = (_ref) => {
  let {
    children,
    disabled
  } = _ref;
  const originDisabled = react.exports.useContext(DisabledContext);
  return /* @__PURE__ */ jsx(DisabledContext.Provider, {
    value: disabled !== null && disabled !== void 0 ? disabled : originDisabled,
    children
  });
};
function useTheme$1(theme2, parentTheme) {
  const themeConfig = theme2 || {};
  const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
  const mergedTheme = useMemo(() => {
    if (!theme2) {
      return parentTheme;
    }
    const mergedComponents = Object.assign({}, parentThemeConfig.components);
    Object.keys(theme2.components || {}).forEach((componentName) => {
      mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
    });
    return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
      token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
      components: mergedComponents
    });
  }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
    const nextTheme = next2[index2];
    return !isEqual$1(prevTheme, nextTheme, true);
  }));
  return mergedTheme;
}
const SizeContext$1 = /* @__PURE__ */ react.exports.createContext(void 0);
const SizeContextProvider$1 = (_ref) => {
  let {
    children,
    size
  } = _ref;
  const originSize = react.exports.useContext(SizeContext$1);
  return /* @__PURE__ */ jsx(SizeContext$1.Provider, {
    value: size || originSize,
    children
  });
};
const SizeContext$2 = SizeContext$1;
const useStyle$o = (iconPrefixCls) => {
  const [theme2, token2] = useToken$3();
  return useStyleRegister({
    theme: theme2,
    token: token2,
    hashId: "",
    path: ["ant-design-icons", iconPrefixCls]
  }, () => [{
    [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
      [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
        display: "block"
      }
    })
  }]);
};
const useStyle$p = useStyle$o;
var __rest$O = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select"];
const defaultPrefixCls = "ant";
let globalPrefixCls;
let globalIconPrefixCls;
function getGlobalPrefixCls() {
  return globalPrefixCls || defaultPrefixCls;
}
function getGlobalIconPrefixCls() {
  return globalIconPrefixCls || defaultIconPrefixCls;
}
const setGlobalConfig = (_ref) => {
  let {
    prefixCls,
    iconPrefixCls,
    theme: theme2
  } = _ref;
  if (prefixCls !== void 0) {
    globalPrefixCls = prefixCls;
  }
  if (iconPrefixCls !== void 0) {
    globalIconPrefixCls = iconPrefixCls;
  }
  if (theme2) {
    registerTheme(getGlobalPrefixCls(), theme2);
  }
};
const globalConfig = () => ({
  getPrefixCls: (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls)
      return customizePrefixCls;
    return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
  },
  getIconPrefixCls: getGlobalIconPrefixCls,
  getRootPrefixCls: () => {
    if (globalPrefixCls) {
      return globalPrefixCls;
    }
    return getGlobalPrefixCls();
  }
});
const ProviderChildren = (props) => {
  const {
    children,
    csp: customCsp,
    autoInsertSpaceInButton,
    form,
    locale: locale2,
    componentSize,
    direction,
    space,
    virtual,
    dropdownMatchSelectWidth,
    legacyLocale,
    parentContext,
    iconPrefixCls: customIconPrefixCls,
    theme: theme2,
    componentDisabled
  } = props;
  const getPrefixCls = react.exports.useCallback((suffixCls, customizePrefixCls) => {
    const {
      prefixCls
    } = props;
    if (customizePrefixCls)
      return customizePrefixCls;
    const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
    return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
  }, [parentContext.getPrefixCls, props.prefixCls]);
  const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
  const shouldWrapSSR = iconPrefixCls !== parentContext.iconPrefixCls;
  const csp = customCsp || parentContext.csp;
  const wrapSSR = useStyle$p(iconPrefixCls);
  const mergedTheme = useTheme$1(theme2, parentContext.theme);
  const baseConfig = {
    csp,
    autoInsertSpaceInButton,
    locale: locale2 || legacyLocale,
    direction,
    space,
    virtual,
    dropdownMatchSelectWidth,
    getPrefixCls,
    iconPrefixCls,
    theme: mergedTheme
  };
  const config = Object.assign({}, parentContext);
  Object.keys(baseConfig).forEach((key) => {
    if (baseConfig[key] !== void 0) {
      config[key] = baseConfig[key];
    }
  });
  PASSED_PROPS.forEach((propName) => {
    const propValue = props[propName];
    if (propValue) {
      config[propName] = propValue;
    }
  });
  const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
    const prevKeys = Object.keys(prevConfig);
    const currentKeys = Object.keys(currentConfig);
    return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
  });
  const memoIconContextValue = react.exports.useMemo(() => ({
    prefixCls: iconPrefixCls,
    csp
  }), [iconPrefixCls, csp]);
  let childNode = shouldWrapSSR ? wrapSSR(children) : children;
  const validateMessages = react.exports.useMemo(() => {
    var _a, _b, _c;
    return setValues({}, ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
  }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
  if (Object.keys(validateMessages).length > 0) {
    childNode = /* @__PURE__ */ jsx(FormProvider$1, {
      validateMessages,
      children
    });
  }
  if (locale2) {
    childNode = /* @__PURE__ */ jsx(LocaleProvider$1, {
      locale: locale2,
      _ANT_MARK__: ANT_MARK,
      children: childNode
    });
  }
  if (iconPrefixCls || csp) {
    childNode = /* @__PURE__ */ jsx(Context$2.Provider, {
      value: memoIconContextValue,
      children: childNode
    });
  }
  if (componentSize) {
    childNode = /* @__PURE__ */ jsx(SizeContextProvider$1, {
      size: componentSize,
      children: childNode
    });
  }
  const memoTheme = react.exports.useMemo(() => {
    const _a = mergedTheme || {}, {
      algorithm,
      token: token2
    } = _a, rest = __rest$O(_a, ["algorithm", "token"]);
    const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
    return Object.assign(Object.assign({}, rest), {
      theme: themeObj,
      token: Object.assign(Object.assign({}, defaultSeedToken), token2)
    });
  }, [mergedTheme]);
  if (theme2) {
    childNode = /* @__PURE__ */ jsx(DesignTokenContext.Provider, {
      value: memoTheme,
      children: childNode
    });
  }
  if (componentDisabled !== void 0) {
    childNode = /* @__PURE__ */ jsx(DisabledContextProvider, {
      disabled: componentDisabled,
      children: childNode
    });
  }
  return /* @__PURE__ */ jsx(ConfigContext.Provider, {
    value: memoedConfig,
    children: childNode
  });
};
const ConfigProvider = (props) => {
  const context = react.exports.useContext(ConfigContext);
  const antLocale = react.exports.useContext(LocaleContext$1);
  return /* @__PURE__ */ jsx(ProviderChildren, {
    ...Object.assign({
      parentContext: context,
      legacyLocale: antLocale
    }, props)
  });
};
ConfigProvider.ConfigContext = ConfigContext;
ConfigProvider.SizeContext = SizeContext$2;
ConfigProvider.config = setGlobalConfig;
const ConfigProvider$1 = ConfigProvider;
var raf = function raf2(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf = function raf3(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf3(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id2) {
  rafIds.delete(id2);
}
var wrapperRaf = function wrapperRaf2(callback) {
  var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  rafUUID += 1;
  var id2 = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id2);
      callback();
    } else {
      var realId = raf(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id2, realId);
    }
  }
  callRef(times);
  return id2;
};
wrapperRaf.cancel = function(id2) {
  var realId = rafIds.get(id2);
  cleanup(realId);
  return caf(realId);
};
function throttleByAnimationFrame(fn2) {
  let requestId;
  const later = (args) => () => {
    requestId = null;
    fn2.apply(void 0, _toConsumableArray(args));
  };
  const throttled = function() {
    if (requestId == null) {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      requestId = wrapperRaf(later(args));
    }
  };
  throttled.cancel = () => {
    wrapperRaf.cancel(requestId);
    requestId = null;
  };
  return throttled;
}
function addEventListenerWrap(target, eventType, cb2, option) {
  var callback = ReactDOM.unstable_batchedUpdates ? function run(e2) {
    ReactDOM.unstable_batchedUpdates(cb2, e2);
  } : cb2;
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove2() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}
var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
const CheckCircleFilledSvg = CheckCircleFilled$2;
function warning$1(valid, message2) {
  warningOnce(valid, "[@ant-design/icons] ".concat(message2));
}
function isIconDefinition$1(target) {
  return _typeof$1(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$1(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs$1() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key) {
    var val = attrs[key];
    switch (key) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key] = val;
    }
    return acc;
  }, {});
}
function generate$2(node2, key, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$1({
      key
    }, normalizeAttrs$1(node2.attrs)), (node2.children || []).map(function(child, index2) {
      return generate$2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$1(_objectSpread2$1({
    key
  }, normalizeAttrs$1(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
    return generate$2(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
  }));
}
function getSecondaryColor$1(primaryColor) {
  return generate$3(primaryColor)[0];
}
function normalizeTwoToneColors$1(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles$1 = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles$1 = function useInsertStyles() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles$1;
  var _useContext = react.exports.useContext(Context$2), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
  var mergedStyleStr = styleStr;
  if (prefixCls) {
    mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
  }
  react.exports.useEffect(function() {
    updateCSS(mergedStyleStr, "@ant-design-icons", {
      prepend: true,
      csp
    });
  }, []);
};
var _excluded$q = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette$1 = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors$1(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette$1.primaryColor = primaryColor;
  twoToneColorPalette$1.secondaryColor = secondaryColor || getSecondaryColor$1(primaryColor);
  twoToneColorPalette$1.calculated = !!secondaryColor;
}
function getTwoToneColors$1() {
  return _objectSpread2$1({}, twoToneColorPalette$1);
}
var IconBase$1 = function IconBase(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$q);
  var colors = twoToneColorPalette$1;
  if (primaryColor) {
    colors = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor$1(primaryColor)
    };
  }
  useInsertStyles$1();
  warning$1(isIconDefinition$1(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition$1(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread2$1(_objectSpread2$1({}, target), {}, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate$2(target.icon, "svg-".concat(target.name), _objectSpread2$1({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps));
};
IconBase$1.displayName = "IconReact";
IconBase$1.getTwoToneColors = getTwoToneColors$1;
IconBase$1.setTwoToneColors = setTwoToneColors$1;
const ReactIcon$1 = IconBase$1;
function setTwoToneColor$1(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon$1.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor$1() {
  var colors = ReactIcon$1.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}
var _excluded$p = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor$1("#1890ff");
var Icon$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$p);
  var _React$useContext = react.exports.useContext(Context$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
  var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$1(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors$1(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ jsx("span", {
    ..._objectSpread2$1(_objectSpread2$1({
      role: "img",
      "aria-label": icon.name
    }, restProps), {}, {
      ref,
      tabIndex: iconTabIndex,
      onClick,
      className: classString
    }),
    children: /* @__PURE__ */ jsx(ReactIcon$1, {
      icon,
      primaryColor,
      secondaryColor,
      style: svgStyle
    })
  });
});
Icon$2.displayName = "AntdIcon";
Icon$2.getTwoToneColor = getTwoToneColor$1;
Icon$2.setTwoToneColor = setTwoToneColor$1;
const AntdIcon$1 = Icon$2;
var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: CheckCircleFilledSvg
    })
  });
};
CheckCircleFilled.displayName = "CheckCircleFilled";
const CheckCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CheckCircleFilled);
var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
const CloseCircleFilledSvg = CloseCircleFilled$2;
var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: CloseCircleFilledSvg
    })
  });
};
CloseCircleFilled.displayName = "CloseCircleFilled";
const CloseCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(CloseCircleFilled);
var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
const CloseOutlinedSvg = CloseOutlined$2;
var CloseOutlined = function CloseOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: CloseOutlinedSvg
    })
  });
};
CloseOutlined.displayName = "CloseOutlined";
const CloseOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CloseOutlined);
var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: ExclamationCircleFilledSvg
    })
  });
};
ExclamationCircleFilled.displayName = "ExclamationCircleFilled";
const ExclamationCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(ExclamationCircleFilled);
var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
const InfoCircleFilledSvg = InfoCircleFilled$2;
var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: InfoCircleFilledSvg
    })
  });
};
InfoCircleFilled.displayName = "InfoCircleFilled";
const InfoCircleFilled$1 = /* @__PURE__ */ react.exports.forwardRef(InfoCircleFilled);
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}
function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  };
  if (domSupport) {
    if (!("AnimationEvent" in win)) {
      delete prefixes.animationend.animation;
    }
    if (!("TransitionEvent" in win)) {
      delete prefixes.transitionend.transition;
    }
  }
  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
var style$1 = {};
if (canUseDom()) {
  var _document$createEleme = document.createElement("div");
  style$1 = _document$createEleme.style;
}
var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }
  var prefixMap = vendorPrefixes[eventName];
  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;
    for (var i2 = 0; i2 < len; i2 += 1) {
      var styleProp = stylePropList[i2];
      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style$1) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }
  return "";
}
var internalAnimationEndName = getVendorPrefixedEventName("animationend");
var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || "animationend";
var transitionEndName = internalTransitionEndName || "transitionend";
function getTransitionName$2(transitionName, transitionType) {
  if (!transitionName)
    return null;
  if (_typeof$1(transitionName) === "object") {
    var type4 = transitionType.replace(/-\w/g, function(match) {
      return match[1].toUpperCase();
    });
    return transitionName[type4];
  }
  return "".concat(transitionName, "-").concat(transitionType);
}
var STATUS_NONE = "none";
var STATUS_APPEAR = "appear";
var STATUS_ENTER = "enter";
var STATUS_LEAVE = "leave";
var STEP_NONE = "none";
var STEP_PREPARE = "prepare";
var STEP_START = "start";
var STEP_ACTIVE = "active";
var STEP_ACTIVATED = "end";
function useSafeState(defaultValue) {
  var destroyRef = react.exports.useRef(false);
  var _React$useState = react.exports.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue2 = _React$useState2[1];
  react.exports.useEffect(function() {
    destroyRef.current = false;
    return function() {
      destroyRef.current = true;
    };
  }, []);
  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }
    setValue2(updater);
  }
  return [value, safeSetState];
}
const useNextFrame = function() {
  var nextFrameRef = react.exports.useRef(null);
  function cancelNextFrame() {
    wrapperRaf.cancel(nextFrameRef.current);
  }
  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf(function() {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }
  react.exports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
};
var useIsomorphicLayoutEffect = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
var SkipStep = false;
var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
const useStepQueue = function(status, callback) {
  var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
  var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
  function startQueue() {
    setStep(STEP_PREPARE, true);
  }
  useIsomorphicLayoutEffect(function() {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index2 = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index2 + 1];
      var result = callback(step);
      if (result === SkipStep) {
        setStep(nextStep, true);
      } else {
        nextFrame(function(info) {
          function doNext() {
            if (info.isCanceled())
              return;
            setStep(nextStep, true);
          }
          if (result === true) {
            doNext();
          } else {
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  react.exports.useEffect(function() {
    return function() {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
};
const useDomMotionEvents = function(callback) {
  var cacheElementRef = react.exports.useRef();
  var callbackRef = react.exports.useRef(callback);
  callbackRef.current = callback;
  var onInternalMotionEnd = react.exports.useCallback(function(event) {
    callbackRef.current(event);
  }, []);
  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  }
  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }
    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd);
      cacheElementRef.current = element;
    }
  }
  react.exports.useEffect(function() {
    return function() {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
};
function useStatus(supportMotion, visible, getElement2, _ref) {
  var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
  var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
  var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
  var _useState5 = useSafeState(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
  var mountedRef = react.exports.useRef(false);
  var deadlineRef = react.exports.useRef(null);
  function getDomElement() {
    return getElement2();
  }
  var activeRef = react.exports.useRef(false);
  function onInternalMotionEnd(event) {
    var element = getDomElement();
    if (event && !event.deadline && event.target !== element) {
      return;
    }
    var currentActive = activeRef.current;
    var canEnd;
    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    }
    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      setStatus(STATUS_NONE, true);
      setStyle(null, true);
    }
  }
  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
  var eventHandlers = react.exports.useMemo(function() {
    var _ref2, _ref3, _ref4;
    switch (status) {
      case STATUS_APPEAR:
        return _ref2 = {}, _defineProperty$1(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty$1(_ref2, STEP_START, onAppearStart), _defineProperty$1(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty$1(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty$1(_ref3, STEP_START, onEnterStart), _defineProperty$1(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty$1(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty$1(_ref4, STEP_START, onLeaveStart), _defineProperty$1(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
      default:
        return {};
    }
  }, [status]);
  var _useStepQueue = useStepQueue(status, function(newStep) {
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];
      if (!onPrepare) {
        return SkipStep;
      }
      return onPrepare(getDomElement());
    }
    if (step in eventHandlers) {
      var _eventHandlers$step;
      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }
    if (step === STEP_ACTIVE) {
      patchMotionEvents(getDomElement());
      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(function() {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }
    return DoStep;
  }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
  var active = isActive(step);
  activeRef.current = active;
  useIsomorphicLayoutEffect(function() {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;
    if (!supportMotion) {
      return;
    }
    var nextStatus;
    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    }
    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    }
    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    }
    if (nextStatus) {
      setStatus(nextStatus);
      startStep();
    }
  }, [visible]);
  react.exports.useEffect(function() {
    if (status === STATUS_APPEAR && !motionAppear || status === STATUS_ENTER && !motionEnter || status === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  react.exports.useEffect(function() {
    return function() {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []);
  var firstMountChangeRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }
    if (asyncVisible !== void 0 && status === STATUS_NONE) {
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }
      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]);
  var mergedStyle = style2;
  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2$1({
      transition: "none"
    }, mergedStyle);
  }
  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}
var DomWrapper = /* @__PURE__ */ function(_React$Component) {
  _inherits(DomWrapper2, _React$Component);
  var _super = _createSuper(DomWrapper2);
  function DomWrapper2() {
    _classCallCheck(this, DomWrapper2);
    return _super.apply(this, arguments);
  }
  _createClass(DomWrapper2, [{
    key: "render",
    value: function render2() {
      return this.props.children;
    }
  }]);
  return DomWrapper2;
}(react.exports.Component);
function genCSSMotion(config) {
  var transitionSupport = config;
  if (_typeof$1(config) === "object") {
    transitionSupport = config.transitionSupport;
  }
  function isSupportTransition(props) {
    return !!(props.motionName && transitionSupport);
  }
  var CSSMotion2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
    var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
    var supportMotion = isSupportTransition(props);
    var nodeRef = react.exports.useRef();
    var wrapperNodeRef = react.exports.useRef();
    function getDomElement() {
      try {
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e2) {
        return null;
      }
    }
    var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
    var renderedRef = react.exports.useRef(mergedVisible);
    if (mergedVisible) {
      renderedRef.current = true;
    }
    var setNodeRef = react.exports.useCallback(function(node2) {
      nodeRef.current = node2;
      fillRef(ref, node2);
    }, [ref]);
    var motionChildren;
    var mergedProps = _objectSpread2$1(_objectSpread2$1({}, eventProps), {}, {
      visible
    });
    if (!children) {
      motionChildren = null;
    } else if (status === STATUS_NONE || !isSupportTransition(props)) {
      if (mergedVisible) {
        motionChildren = children(_objectSpread2$1({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender) {
        motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
          style: {
            display: "none"
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;
      var statusSuffix;
      if (statusStep === STEP_PREPARE) {
        statusSuffix = "prepare";
      } else if (isActive(statusStep)) {
        statusSuffix = "active";
      } else if (statusStep === STEP_START) {
        statusSuffix = "start";
      }
      motionChildren = children(_objectSpread2$1(_objectSpread2$1({}, mergedProps), {}, {
        className: classNames(getTransitionName$2(motionName, status), (_classNames = {}, _defineProperty$1(_classNames, getTransitionName$2(motionName, "".concat(status, "-").concat(statusSuffix)), statusSuffix), _defineProperty$1(_classNames, motionName, typeof motionName === "string"), _classNames)),
        style: statusStyle
      }), setNodeRef);
    }
    if (/* @__PURE__ */ react.exports.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var _motionChildren = motionChildren, originNodeRef = _motionChildren.ref;
      if (!originNodeRef) {
        motionChildren = /* @__PURE__ */ react.exports.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }
    return /* @__PURE__ */ jsx(DomWrapper, {
      ref: wrapperNodeRef,
      children: motionChildren
    });
  });
  CSSMotion2.displayName = "CSSMotion";
  return CSSMotion2;
}
const CSSMotion = genCSSMotion(supportTransition);
var STATUS_ADD = "add";
var STATUS_KEEP = "keep";
var STATUS_REMOVE = "remove";
var STATUS_REMOVED = "removed";
function wrapKeyToObject(key) {
  var keyObj;
  if (key && _typeof$1(key) === "object" && "key" in key) {
    keyObj = key;
  } else {
    keyObj = {
      key
    };
  }
  return _objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return keys2.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys);
  prevKeyObjects.forEach(function(keyObj) {
    var hit = false;
    for (var i2 = currentIndex; i2 < currentLen; i2 += 1) {
      var currentKeyObj = currentKeyObjects[i2];
      if (currentKeyObj.key === keyObj.key) {
        if (currentIndex < i2) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i2).map(function(obj) {
            return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i2;
        }
        list.push(_objectSpread2$1(_objectSpread2$1({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    }
    if (!hit) {
      list.push(_objectSpread2$1(_objectSpread2$1({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  });
  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
      return _objectSpread2$1(_objectSpread2$1({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }
  var keys2 = {};
  list.forEach(function(_ref) {
    var key = _ref.key;
    keys2[key] = (keys2[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys2).filter(function(key) {
    return keys2[key] > 1;
  });
  duplicatedKeys.forEach(function(matchKey) {
    list = list.filter(function(_ref2) {
      var key = _ref2.key, status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    });
    list.forEach(function(node2) {
      if (node2.key === matchKey) {
        node2.status = STATUS_KEEP;
      }
    });
  });
  return list;
}
var _excluded$o = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2$5 = ["status"];
var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function genCSSMotionList(transitionSupport) {
  var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
  var CSSMotionList2 = /* @__PURE__ */ function(_React$Component) {
    _inherits(CSSMotionList3, _React$Component);
    var _super = _createSuper(CSSMotionList3);
    function CSSMotionList3() {
      var _this;
      _classCallCheck(this, CSSMotionList3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        keyEntities: []
      };
      _this.removeKey = function(removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function(entity) {
          if (entity.key !== removeKey)
            return entity;
          return _objectSpread2$1(_objectSpread2$1({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });
        _this.setState({
          keyEntities: nextKeyEntities
        });
        return nextKeyEntities.filter(function(_ref) {
          var status = _ref.status;
          return status !== STATUS_REMOVED;
        }).length;
      };
      return _this;
    }
    _createClass(CSSMotionList3, [{
      key: "render",
      value: function render2() {
        var _this2 = this;
        var keyEntities = this.state.keyEntities;
        var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties(_this$props, _excluded$o);
        var Component2 = component || react.exports.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function(prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /* @__PURE__ */ jsx(Component2, {
          ...restProps,
          children: keyEntities.map(function(_ref2) {
            var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2$5);
            var visible = status === STATUS_ADD || status === STATUS_KEEP;
            return /* @__PURE__ */ react.exports.createElement(CSSMotion$1, {
              ...motionProps,
              key: eventProps.key,
              visible,
              eventProps,
              onVisibleChanged: function onVisibleChanged(changedVisible) {
                _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                  key: eventProps.key
                });
                if (!changedVisible) {
                  var restKeysCount = _this2.removeKey(eventProps.key);
                  if (restKeysCount === 0 && onAllRemoved) {
                    onAllRemoved();
                  }
                }
              }
            }, children);
          })
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys2 = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys2);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function(entity) {
            var prevEntity = keyEntities.find(function(_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            });
            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }
            return true;
          })
        };
      }
    }]);
    return CSSMotionList3;
  }(react.exports.Component);
  CSSMotionList2.defaultProps = {
    component: "div"
  };
  return CSSMotionList2;
}
const CSSMotionList = genCSSMotionList(supportTransition);
function getDataOrAriaProps(props) {
  return Object.keys(props).reduce((prev2, key) => {
    if ((key.startsWith("data-") || key.startsWith("aria-") || key === "role") && !key.startsWith("data-__")) {
      prev2[key] = props[key];
    }
    return prev2;
  }, {});
}
const {
  isValidElement
} = React$1;
function isFragment(child) {
  return child && isValidElement(child) && child.type === react.exports.Fragment;
}
function replaceElement(element, replacement, props) {
  if (!isValidElement(element)) {
    return replacement;
  }
  return /* @__PURE__ */ react.exports.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
}
function cloneElement(element, props) {
  return replaceElement(element, element, props);
}
let ErrorBoundary = /* @__PURE__ */ function(_React$Component) {
  _inherits(ErrorBoundary2, _React$Component);
  var _super = _createSuper(ErrorBoundary2);
  function ErrorBoundary2() {
    var _this;
    _classCallCheck(this, ErrorBoundary2);
    _this = _super.apply(this, arguments);
    _this.state = {
      error: void 0,
      info: {
        componentStack: ""
      }
    };
    return _this;
  }
  _createClass(ErrorBoundary2, [{
    key: "componentDidCatch",
    value: function componentDidCatch(error, info) {
      this.setState({
        error,
        info
      });
    }
  }, {
    key: "render",
    value: function render2() {
      const {
        message: message2,
        description,
        children
      } = this.props;
      const {
        error,
        info
      } = this.state;
      const componentStack = info && info.componentStack ? info.componentStack : null;
      const errorMessage = typeof message2 === "undefined" ? (error || "").toString() : message2;
      const errorDescription = typeof description === "undefined" ? componentStack : description;
      if (error) {
        return /* @__PURE__ */ jsx(Alert$1, {
          type: "error",
          message: errorMessage,
          description: /* @__PURE__ */ jsx("pre", {
            style: {
              fontSize: "0.9em",
              overflowX: "auto"
            },
            children: errorDescription
          })
        });
      }
      return children;
    }
  }]);
  return ErrorBoundary2;
}(react.exports.Component);
const ErrorBoundary$1 = ErrorBoundary;
const genAlertTypeStyle = (bgColor, borderColor, iconColor, token2, alertCls) => ({
  backgroundColor: bgColor,
  border: `${token2.lineWidth}px ${token2.lineType} ${borderColor}`,
  [`${alertCls}-icon`]: {
    color: iconColor
  }
});
const genBaseStyle$4 = (token2) => {
  const {
    componentCls,
    motionDurationSlow: duration,
    marginXS,
    marginSM,
    fontSize,
    fontSizeLG,
    lineHeight,
    borderRadiusLG: borderRadius,
    motionEaseInOutCirc,
    alertIconSizeLG,
    colorText,
    paddingContentVerticalSM,
    alertPaddingHorizontal,
    paddingMD,
    paddingContentHorizontalLG
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      display: "flex",
      alignItems: "center",
      padding: `${paddingContentVerticalSM}px ${alertPaddingHorizontal}px`,
      wordWrap: "break-word",
      borderRadius,
      [`&${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-content`]: {
        flex: 1,
        minWidth: 0
      },
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginXS,
        lineHeight: 0
      },
      [`&-description`]: {
        display: "none",
        fontSize,
        lineHeight
      },
      "&-message": {
        color: colorText
      },
      [`&${componentCls}-motion-leave`]: {
        overflow: "hidden",
        opacity: 1,
        transition: `max-height ${duration} ${motionEaseInOutCirc}, opacity ${duration} ${motionEaseInOutCirc},
        padding-top ${duration} ${motionEaseInOutCirc}, padding-bottom ${duration} ${motionEaseInOutCirc},
        margin-bottom ${duration} ${motionEaseInOutCirc}`
      },
      [`&${componentCls}-motion-leave-active`]: {
        maxHeight: 0,
        marginBottom: "0 !important",
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    }),
    [`${componentCls}-with-description`]: {
      alignItems: "flex-start",
      paddingInline: paddingContentHorizontalLG,
      paddingBlock: paddingMD,
      [`${componentCls}-icon`]: {
        marginInlineEnd: marginSM,
        fontSize: alertIconSizeLG,
        lineHeight: 0
      },
      [`${componentCls}-message`]: {
        display: "block",
        marginBottom: marginXS,
        color: colorText,
        fontSize: fontSizeLG
      },
      [`${componentCls}-description`]: {
        display: "block"
      }
    },
    [`${componentCls}-banner`]: {
      marginBottom: 0,
      border: "0 !important",
      borderRadius: 0
    }
  };
};
const genTypeStyle = (token2) => {
  const {
    componentCls,
    colorSuccess,
    colorSuccessBorder,
    colorSuccessBg,
    colorWarning,
    colorWarningBorder,
    colorWarningBg,
    colorError,
    colorErrorBorder,
    colorErrorBg,
    colorInfo,
    colorInfoBorder,
    colorInfoBg
  } = token2;
  return {
    [componentCls]: {
      "&-success": genAlertTypeStyle(colorSuccessBg, colorSuccessBorder, colorSuccess, token2, componentCls),
      "&-info": genAlertTypeStyle(colorInfoBg, colorInfoBorder, colorInfo, token2, componentCls),
      "&-warning": genAlertTypeStyle(colorWarningBg, colorWarningBorder, colorWarning, token2, componentCls),
      "&-error": Object.assign(Object.assign({}, genAlertTypeStyle(colorErrorBg, colorErrorBorder, colorError, token2, componentCls)), {
        [`${componentCls}-description > pre`]: {
          margin: 0,
          padding: 0
        }
      })
    }
  };
};
const genActionStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    motionDurationMid,
    marginXS,
    fontSizeIcon,
    colorIcon,
    colorIconHover
  } = token2;
  return {
    [componentCls]: {
      [`&-action`]: {
        marginInlineStart: marginXS
      },
      [`${componentCls}-close-icon`]: {
        marginInlineStart: marginXS,
        padding: 0,
        overflow: "hidden",
        fontSize: fontSizeIcon,
        lineHeight: `${fontSizeIcon}px`,
        backgroundColor: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        [`${iconCls}-close`]: {
          color: colorIcon,
          transition: `color ${motionDurationMid}`,
          "&:hover": {
            color: colorIconHover
          }
        }
      },
      "&-close-text": {
        color: colorIcon,
        transition: `color ${motionDurationMid}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }
  };
};
const genAlertStyle = (token2) => [genBaseStyle$4(token2), genTypeStyle(token2), genActionStyle(token2)];
const useStyle$n = genComponentStyleHook("Alert", (token2) => {
  const {
    fontSizeHeading3
  } = token2;
  const alertToken = merge(token2, {
    alertIconSizeLG: fontSizeHeading3,
    alertPaddingHorizontal: 12
  });
  return [genAlertStyle(alertToken)];
});
var __rest$N = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const iconMapFilled = {
  success: CheckCircleFilled$1,
  info: InfoCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1
};
const IconNode = (props) => {
  const {
    icon,
    prefixCls,
    type: type4
  } = props;
  const iconType = iconMapFilled[type4] || null;
  if (icon) {
    return replaceElement(
      icon,
      /* @__PURE__ */ jsx("span", {
        className: `${prefixCls}-icon`,
        children: icon
      }),
      () => ({
        className: classNames(`${prefixCls}-icon`, {
          [icon.props.className]: icon.props.className
        })
      })
    );
  }
  return /* @__PURE__ */ react.exports.createElement(iconType, {
    className: `${prefixCls}-icon`
  });
};
const CloseIcon = (props) => {
  const {
    isClosable,
    closeText,
    prefixCls,
    closeIcon,
    handleClose
  } = props;
  return isClosable ? /* @__PURE__ */ jsx("button", {
    type: "button",
    onClick: handleClose,
    className: `${prefixCls}-close-icon`,
    tabIndex: 0,
    children: closeText ? /* @__PURE__ */ jsx("span", {
      className: `${prefixCls}-close-text`,
      children: closeText
    }) : closeIcon
  }) : null;
};
const Alert = (_a) => {
  var {
    description,
    prefixCls: customizePrefixCls,
    message: message2,
    banner,
    className,
    rootClassName,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    onClick,
    afterClose,
    showIcon,
    closable,
    closeText,
    closeIcon = /* @__PURE__ */ jsx(CloseOutlined$1, {}),
    action
  } = _a, props = __rest$N(_a, ["description", "prefixCls", "message", "banner", "className", "rootClassName", "style", "onMouseEnter", "onMouseLeave", "onClick", "afterClose", "showIcon", "closable", "closeText", "closeIcon", "action"]);
  const [closed, setClosed] = react.exports.useState(false);
  const ref = react.exports.useRef();
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("alert", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$n(prefixCls);
  const handleClose = (e2) => {
    var _a2;
    setClosed(true);
    (_a2 = props.onClose) === null || _a2 === void 0 ? void 0 : _a2.call(props, e2);
  };
  const getType = () => {
    const {
      type: type5
    } = props;
    if (type5 !== void 0) {
      return type5;
    }
    return banner ? "warning" : "info";
  };
  const isClosable = closeText ? true : closable;
  const type4 = getType();
  const isShowIcon = banner && showIcon === void 0 ? true : showIcon;
  const alertCls = classNames(prefixCls, `${prefixCls}-${type4}`, {
    [`${prefixCls}-with-description`]: !!description,
    [`${prefixCls}-no-icon`]: !isShowIcon,
    [`${prefixCls}-banner`]: !!banner,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  const dataOrAriaProps = getDataOrAriaProps(props);
  return wrapSSR(
    /* @__PURE__ */ jsx(CSSMotion, {
      visible: !closed,
      motionName: `${prefixCls}-motion`,
      motionAppear: false,
      motionEnter: false,
      onLeaveStart: (node2) => ({
        maxHeight: node2.offsetHeight
      }),
      onLeaveEnd: afterClose,
      children: (_ref) => {
        let {
          className: motionClassName,
          style: motionStyle
        } = _ref;
        return /* @__PURE__ */ jsxs("div", {
          ...Object.assign({
            ref,
            "data-show": !closed,
            className: classNames(alertCls, motionClassName),
            style: Object.assign(Object.assign({}, style2), motionStyle),
            onMouseEnter,
            onMouseLeave,
            onClick,
            role: "alert"
          }, dataOrAriaProps),
          children: [isShowIcon ? /* @__PURE__ */ jsx(IconNode, {
            description,
            icon: props.icon,
            prefixCls,
            type: type4
          }) : null, /* @__PURE__ */ jsxs("div", {
            className: `${prefixCls}-content`,
            children: [message2 ? /* @__PURE__ */ jsx("div", {
              className: `${prefixCls}-message`,
              children: message2
            }) : null, description ? /* @__PURE__ */ jsx("div", {
              className: `${prefixCls}-description`,
              children: description
            }) : null]
          }), action ? /* @__PURE__ */ jsx("div", {
            className: `${prefixCls}-action`,
            children: action
          }) : null, /* @__PURE__ */ jsx(CloseIcon, {
            isClosable: !!isClosable,
            closeText,
            prefixCls,
            closeIcon,
            handleClose
          })]
        });
      }
    })
  );
};
Alert.ErrorBoundary = ErrorBoundary$1;
const Alert$1 = Alert;
let e = (e2) => "object" == typeof e2 && null != e2 && 1 === e2.nodeType, t$1 = (e2, t2) => (!t2 || "hidden" !== e2) && ("visible" !== e2 && "clip" !== e2), n = (e2, n2) => {
  if (e2.clientHeight < e2.scrollHeight || e2.clientWidth < e2.scrollWidth) {
    let l2 = getComputedStyle(e2, null);
    return t$1(l2.overflowY, n2) || t$1(l2.overflowX, n2) || ((e3) => {
      let t2 = ((e4) => {
        if (!e4.ownerDocument || !e4.ownerDocument.defaultView)
          return null;
        try {
          return e4.ownerDocument.defaultView.frameElement;
        } catch (e5) {
          return null;
        }
      })(e3);
      return !!t2 && (t2.clientHeight < e3.scrollHeight || t2.clientWidth < e3.scrollWidth);
    })(e2);
  }
  return false;
}, l = (e2, t2, n2, l2, i2, o2, r2, d2) => o2 < e2 && r2 > t2 || o2 > e2 && r2 < t2 ? 0 : o2 <= e2 && d2 <= n2 || r2 >= t2 && d2 >= n2 ? o2 - e2 - l2 : r2 > t2 && d2 < n2 || o2 < e2 && d2 > n2 ? r2 - t2 + i2 : 0, i = (e2) => {
  let t2 = e2.parentElement;
  return null == t2 ? e2.getRootNode().host || null : t2;
};
var o$1 = (t2, o2) => {
  var r2, d2, h2, f2, u2, s2;
  if ("undefined" == typeof document)
    return [];
  let { scrollMode: a2, block: c2, inline: g2, boundary: m2, skipOverflowHiddenElements: p2 } = o2, w2 = "function" == typeof m2 ? m2 : (e2) => e2 !== m2;
  if (!e(t2))
    throw new TypeError("Invalid target");
  let W2 = document.scrollingElement || document.documentElement, H2 = [], b2 = t2;
  for (; e(b2) && w2(b2); ) {
    if (b2 = i(b2), b2 === W2) {
      H2.push(b2);
      break;
    }
    null != b2 && b2 === document.body && n(b2) && !n(document.documentElement) || null != b2 && n(b2, p2) && H2.push(b2);
  }
  let v2 = null != (d2 = null == (r2 = window.visualViewport) ? void 0 : r2.width) ? d2 : innerWidth, y2 = null != (f2 = null == (h2 = window.visualViewport) ? void 0 : h2.height) ? f2 : innerHeight, E2 = null != (u2 = window.scrollX) ? u2 : pageXOffset, M2 = null != (s2 = window.scrollY) ? s2 : pageYOffset, { height: x2, width: I2, top: C2, right: R2, bottom: T2, left: V2 } = t2.getBoundingClientRect(), k2 = "start" === c2 || "nearest" === c2 ? C2 : "end" === c2 ? T2 : C2 + x2 / 2, B2 = "center" === g2 ? V2 + I2 / 2 : "end" === g2 ? R2 : V2, D2 = [];
  for (let e2 = 0; e2 < H2.length; e2++) {
    let t3 = H2[e2], { height: n2, width: i2, top: o3, right: r3, bottom: d3, left: h3 } = t3.getBoundingClientRect();
    if ("if-needed" === a2 && C2 >= 0 && V2 >= 0 && T2 <= y2 && R2 <= v2 && C2 >= o3 && T2 <= d3 && V2 >= h3 && R2 <= r3)
      return D2;
    let f3 = getComputedStyle(t3), u3 = parseInt(f3.borderLeftWidth, 10), s3 = parseInt(f3.borderTopWidth, 10), m3 = parseInt(f3.borderRightWidth, 10), p3 = parseInt(f3.borderBottomWidth, 10), w3 = 0, b3 = 0, O2 = "offsetWidth" in t3 ? t3.offsetWidth - t3.clientWidth - u3 - m3 : 0, X2 = "offsetHeight" in t3 ? t3.offsetHeight - t3.clientHeight - s3 - p3 : 0, Y2 = "offsetWidth" in t3 ? 0 === t3.offsetWidth ? 0 : i2 / t3.offsetWidth : 0, L2 = "offsetHeight" in t3 ? 0 === t3.offsetHeight ? 0 : n2 / t3.offsetHeight : 0;
    if (W2 === t3)
      w3 = "start" === c2 ? k2 : "end" === c2 ? k2 - y2 : "nearest" === c2 ? l(M2, M2 + y2, y2, s3, p3, M2 + k2, M2 + k2 + x2, x2) : k2 - y2 / 2, b3 = "start" === g2 ? B2 : "center" === g2 ? B2 - v2 / 2 : "end" === g2 ? B2 - v2 : l(E2, E2 + v2, v2, u3, m3, E2 + B2, E2 + B2 + I2, I2), w3 = Math.max(0, w3 + M2), b3 = Math.max(0, b3 + E2);
    else {
      w3 = "start" === c2 ? k2 - o3 - s3 : "end" === c2 ? k2 - d3 + p3 + X2 : "nearest" === c2 ? l(o3, d3, n2, s3, p3 + X2, k2, k2 + x2, x2) : k2 - (o3 + n2 / 2) + X2 / 2, b3 = "start" === g2 ? B2 - h3 - u3 : "center" === g2 ? B2 - (h3 + i2 / 2) + O2 / 2 : "end" === g2 ? B2 - r3 + m3 + O2 : l(h3, r3, i2, u3, m3 + O2, B2, B2 + I2, I2);
      let { scrollLeft: e3, scrollTop: f4 } = t3;
      w3 = Math.max(0, Math.min(f4 + w3 / L2, t3.scrollHeight - n2 / L2 + X2)), b3 = Math.max(0, Math.min(e3 + b3 / Y2, t3.scrollWidth - i2 / Y2 + O2)), k2 += f4 - w3, B2 += e3 - b3;
    }
    D2.push({ el: t3, top: w3, left: b3 });
  }
  return D2;
};
let t = (e2) => false === e2 ? { block: "end", inline: "nearest" } : ((e3) => e3 === Object(e3) && 0 !== Object.keys(e3).length)(e2) ? e2 : { block: "start", inline: "nearest" };
function o(o2, l2) {
  let n2 = o2.isConnected || o2.ownerDocument.documentElement.contains(o2);
  if (((e2) => "object" == typeof e2 && "function" == typeof e2.behavior)(l2))
    return l2.behavior(n2 ? o$1(o2, l2) : []);
  if (!n2)
    return;
  let r2 = t(l2), c2 = o$1(o2, r2), i2 = "scrollBehavior" in document.body.style;
  c2.forEach((e2) => {
    let { el: t2, top: o3, left: l3 } = e2;
    t2.scroll && i2 ? t2.scroll({ top: o3, left: l3, behavior: r2.behavior }) : (t2.scrollTop = o3, t2.scrollLeft = l3);
  });
}
function isWindow$1(obj) {
  return obj !== null && obj !== void 0 && obj === obj.window;
}
function getScroll$1(target, top) {
  var _a, _b;
  if (typeof window === "undefined") {
    return 0;
  }
  const method4 = top ? "scrollTop" : "scrollLeft";
  let result = 0;
  if (isWindow$1(target)) {
    result = target[top ? "pageYOffset" : "pageXOffset"];
  } else if (target instanceof Document) {
    result = target.documentElement[method4];
  } else if (target instanceof HTMLElement) {
    result = target[method4];
  } else if (target) {
    result = target[method4];
  }
  if (target && !isWindow$1(target) && typeof result !== "number") {
    result = (_b = ((_a = target.ownerDocument) !== null && _a !== void 0 ? _a : target).documentElement) === null || _b === void 0 ? void 0 : _b[method4];
  }
  return result;
}
function easeInOutCubic(t2, b2, c2, d2) {
  const cc2 = c2 - b2;
  t2 /= d2 / 2;
  if (t2 < 1) {
    return cc2 / 2 * t2 * t2 * t2 + b2;
  }
  return cc2 / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
}
function scrollTo(y2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    getContainer: getContainer2 = () => window,
    callback,
    duration = 450
  } = options;
  const container = getContainer2();
  const scrollTop = getScroll$1(container, true);
  const startTime = Date.now();
  const frameFunc = () => {
    const timestamp = Date.now();
    const time = timestamp - startTime;
    const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
    if (isWindow$1(container)) {
      container.scrollTo(window.pageXOffset, nextScrollTop);
    } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
      container.documentElement.scrollTop = nextScrollTop;
    } else {
      container.scrollTop = nextScrollTop;
    }
    if (time < duration) {
      wrapperRaf(frameFunc);
    } else if (typeof callback === "function") {
      callback();
    }
  };
  wrapperRaf(frameFunc);
}
function useEvent(callback) {
  var fnRef = react.exports.useRef();
  fnRef.current = callback;
  var memoFn = react.exports.useCallback(function() {
    var _fnRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
var useLayoutEffect = canUseDom() ? react.exports.useLayoutEffect : react.exports.useEffect;
var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
  var firstMountRef = react.exports.useRef(true);
  useLayoutEffect(function() {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps);
  useLayoutEffect(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};
function hasValue(value) {
  return value !== void 0;
}
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange2 = _ref.onChange, postState = _ref.postState;
  var _useState = useSafeState(function() {
    if (hasValue(value)) {
      return value;
    } else if (hasValue(defaultValue)) {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    } else {
      return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
    }
  }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
  var mergedValue = value !== void 0 ? value : innerValue;
  var postMergedValue = postState ? postState(mergedValue) : mergedValue;
  var onChangeFn = useEvent(onChange2);
  var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
  useLayoutUpdateEffect(function() {
    var prev2 = prevValue[0];
    if (innerValue !== prev2) {
      onChangeFn(innerValue, prev2);
    }
  }, [prevValue]);
  useLayoutUpdateEffect(function() {
    if (!hasValue(value)) {
      setInnerValue(value);
    }
  }, [value]);
  var triggerChange = useEvent(function(updater, ignoreDestroy) {
    setInnerValue(updater, ignoreDestroy);
    setPrevValue([mergedValue], ignoreDestroy);
  });
  return [postMergedValue, triggerChange];
}
const isMobile = function() {
  if (typeof navigator === "undefined" || typeof window === "undefined") {
    return false;
  }
  var agent = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
};
var KeyCode = {
  MAC_ENTER: 3,
  BACKSPACE: 8,
  TAB: 9,
  NUM_CENTER: 12,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  PAUSE: 19,
  CAPS_LOCK: 20,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  PRINT_SCREEN: 44,
  INSERT: 45,
  DELETE: 46,
  ZERO: 48,
  ONE: 49,
  TWO: 50,
  THREE: 51,
  FOUR: 52,
  FIVE: 53,
  SIX: 54,
  SEVEN: 55,
  EIGHT: 56,
  NINE: 57,
  QUESTION_MARK: 63,
  A: 65,
  B: 66,
  C: 67,
  D: 68,
  E: 69,
  F: 70,
  G: 71,
  H: 72,
  I: 73,
  J: 74,
  K: 75,
  L: 76,
  M: 77,
  N: 78,
  O: 79,
  P: 80,
  Q: 81,
  R: 82,
  S: 83,
  T: 84,
  U: 85,
  V: 86,
  W: 87,
  X: 88,
  Y: 89,
  Z: 90,
  META: 91,
  WIN_KEY_RIGHT: 92,
  CONTEXT_MENU: 93,
  NUM_ZERO: 96,
  NUM_ONE: 97,
  NUM_TWO: 98,
  NUM_THREE: 99,
  NUM_FOUR: 100,
  NUM_FIVE: 101,
  NUM_SIX: 102,
  NUM_SEVEN: 103,
  NUM_EIGHT: 104,
  NUM_NINE: 105,
  NUM_MULTIPLY: 106,
  NUM_PLUS: 107,
  NUM_MINUS: 109,
  NUM_PERIOD: 110,
  NUM_DIVISION: 111,
  F1: 112,
  F2: 113,
  F3: 114,
  F4: 115,
  F5: 116,
  F6: 117,
  F7: 118,
  F8: 119,
  F9: 120,
  F10: 121,
  F11: 122,
  F12: 123,
  NUMLOCK: 144,
  SEMICOLON: 186,
  DASH: 189,
  EQUALS: 187,
  COMMA: 188,
  PERIOD: 190,
  SLASH: 191,
  APOSTROPHE: 192,
  SINGLE_QUOTE: 222,
  OPEN_SQUARE_BRACKET: 219,
  BACKSLASH: 220,
  CLOSE_SQUARE_BRACKET: 221,
  WIN_KEY: 224,
  MAC_FF_META: 224,
  WIN_IME: 229,
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
    var keyCode = e2.keyCode;
    if (e2.altKey && !e2.ctrlKey || e2.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true;
    }
  },
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false;
    }
  }
};
var _excluded$n = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];
var UNDEFINED = void 0;
function InternalItem(props, ref) {
  var prefixCls = props.prefixCls, invalidate = props.invalidate, item = props.item, renderItem = props.renderItem, responsive = props.responsive, responsiveDisabled = props.responsiveDisabled, registerSize = props.registerSize, itemKey = props.itemKey, className = props.className, style2 = props.style, children = props.children, display = props.display, order = props.order, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, restProps = _objectWithoutProperties(props, _excluded$n);
  var mergedHidden = responsive && !display;
  function internalRegisterSize(width) {
    registerSize(itemKey, width);
  }
  react.exports.useEffect(function() {
    return function() {
      internalRegisterSize(null);
    };
  }, []);
  var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
  var overflowStyle;
  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? "hidden" : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? "none" : UNDEFINED,
      position: mergedHidden ? "absolute" : UNDEFINED
    };
  }
  var overflowProps = {};
  if (mergedHidden) {
    overflowProps["aria-hidden"] = true;
  }
  var itemNode = /* @__PURE__ */ jsx(Component2, {
    className: classNames(!invalidate && prefixCls, className),
    style: _objectSpread2$1(_objectSpread2$1({}, overflowStyle), style2),
    ...overflowProps,
    ...restProps,
    ref,
    children: childNode
  });
  if (responsive) {
    itemNode = /* @__PURE__ */ jsx(RefResizeObserver, {
      onResize: function onResize2(_ref) {
        var offsetWidth = _ref.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled,
      children: itemNode
    });
  }
  return itemNode;
}
var Item$3 = /* @__PURE__ */ react.exports.forwardRef(InternalItem);
Item$3.displayName = "Item";
function useBatchFrameState() {
  var _useState = useSafeState({}), _useState2 = _slicedToArray(_useState, 2), forceUpdate = _useState2[1];
  var statesRef = react.exports.useRef([]);
  var walkingIndex = 0;
  var beforeFrameId = 0;
  function createState(defaultValue) {
    var myIndex = walkingIndex;
    walkingIndex += 1;
    if (statesRef.current.length < myIndex + 1) {
      statesRef.current[myIndex] = defaultValue;
    }
    var value = statesRef.current[myIndex];
    function setValue2(val) {
      statesRef.current[myIndex] = typeof val === "function" ? val(statesRef.current[myIndex]) : val;
      wrapperRaf.cancel(beforeFrameId);
      beforeFrameId = wrapperRaf(function() {
        forceUpdate({}, true);
      });
    }
    return [value, setValue2];
  }
  return createState;
}
var _excluded$m = ["component"], _excluded2$4 = ["className"], _excluded3$1 = ["className"];
var InternalRawItem = function InternalRawItem2(props, ref) {
  var context = react.exports.useContext(OverflowContext);
  if (!context) {
    var _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, _restProps = _objectWithoutProperties(props, _excluded$m);
    return /* @__PURE__ */ jsx(Component2, {
      ..._restProps,
      ref
    });
  }
  var contextClassName = context.className, restContext = _objectWithoutProperties(context, _excluded2$4);
  var className = props.className, restProps = _objectWithoutProperties(props, _excluded3$1);
  return /* @__PURE__ */ jsx(OverflowContext.Provider, {
    value: null,
    children: /* @__PURE__ */ jsx(Item$3, {
      ref,
      className: classNames(contextClassName, className),
      ...restContext,
      ...restProps
    })
  });
};
var RawItem = /* @__PURE__ */ react.exports.forwardRef(InternalRawItem);
RawItem.displayName = "RawItem";
var _excluded$l = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];
var OverflowContext = /* @__PURE__ */ react.exports.createContext(null);
var RESPONSIVE = "responsive";
var INVALIDATE = "invalidate";
function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}
function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-overflow" : _props$prefixCls, _props$data = props.data, data = _props$data === void 0 ? [] : _props$data, renderItem = props.renderItem, renderRawItem = props.renderRawItem, itemKey = props.itemKey, _props$itemWidth = props.itemWidth, itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth, ssr = props.ssr, style2 = props.style, className = props.className, maxCount = props.maxCount, renderRest = props.renderRest, renderRawRest = props.renderRawRest, suffix = props.suffix, _props$component = props.component, Component2 = _props$component === void 0 ? "div" : _props$component, itemComponent = props.itemComponent, onVisibleChange = props.onVisibleChange, restProps = _objectWithoutProperties(props, _excluded$l);
  var createUseState = useBatchFrameState();
  var fullySSR = ssr === "full";
  var _createUseState = createUseState(null), _createUseState2 = _slicedToArray(_createUseState, 2), containerWidth = _createUseState2[0], setContainerWidth = _createUseState2[1];
  var mergedContainerWidth = containerWidth || 0;
  var _createUseState3 = createUseState(/* @__PURE__ */ new Map()), _createUseState4 = _slicedToArray(_createUseState3, 2), itemWidths = _createUseState4[0], setItemWidths = _createUseState4[1];
  var _createUseState5 = createUseState(0), _createUseState6 = _slicedToArray(_createUseState5, 2), prevRestWidth = _createUseState6[0], setPrevRestWidth = _createUseState6[1];
  var _createUseState7 = createUseState(0), _createUseState8 = _slicedToArray(_createUseState7, 2), restWidth = _createUseState8[0], setRestWidth = _createUseState8[1];
  var _createUseState9 = createUseState(0), _createUseState10 = _slicedToArray(_createUseState9, 2), suffixWidth = _createUseState10[0], setSuffixWidth = _createUseState10[1];
  var _useState = react.exports.useState(null), _useState2 = _slicedToArray(_useState, 2), suffixFixedStart = _useState2[0], setSuffixFixedStart = _useState2[1];
  var _useState3 = react.exports.useState(null), _useState4 = _slicedToArray(_useState3, 2), displayCount = _useState4[0], setDisplayCount = _useState4[1];
  var mergedDisplayCount = react.exports.useMemo(function() {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }
    return displayCount || 0;
  }, [displayCount, containerWidth]);
  var _useState5 = react.exports.useState(false), _useState6 = _slicedToArray(_useState5, 2), restReady = _useState6[0], setRestReady = _useState6[1];
  var itemPrefixCls = "".concat(prefixCls, "-item");
  var mergedRestWidth = Math.max(prevRestWidth, restWidth);
  var isResponsive = maxCount === RESPONSIVE;
  var shouldResponsive = data.length && isResponsive;
  var invalidate = maxCount === INVALIDATE;
  var showRest = shouldResponsive || typeof maxCount === "number" && data.length > maxCount;
  var mergedData = react.exports.useMemo(function() {
    var items = data;
    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data;
      } else {
        items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === "number") {
      items = data.slice(0, maxCount);
    }
    return items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = react.exports.useMemo(function() {
    if (shouldResponsive) {
      return data.slice(mergedDisplayCount + 1);
    }
    return data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]);
  var getKey3 = react.exports.useCallback(function(item, index2) {
    var _ref;
    if (typeof itemKey === "function") {
      return itemKey(item);
    }
    return (_ref = itemKey && (item === null || item === void 0 ? void 0 : item[itemKey])) !== null && _ref !== void 0 ? _ref : index2;
  }, [itemKey]);
  var mergedRenderItem = react.exports.useCallback(renderItem || function(item) {
    return item;
  }, [renderItem]);
  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    if (displayCount === count && (suffixFixedStartVal === void 0 || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }
    setDisplayCount(count);
    if (!notReady) {
      setRestReady(count < data.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }
    if (suffixFixedStartVal !== void 0) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  }
  function onOverflowResize(_2, element) {
    setContainerWidth(element.clientWidth);
  }
  function registerSize(key, width) {
    setItemWidths(function(origin) {
      var clone2 = new Map(origin);
      if (width === null) {
        clone2.delete(key);
      } else {
        clone2.set(key, width);
      }
      return clone2;
    });
  }
  function registerOverflowSize(_2, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }
  function registerSuffixSize(_2, width) {
    setSuffixWidth(width);
  }
  function getItemWidth(index2) {
    return itemWidths.get(getKey3(mergedData[index2], index2));
  }
  useLayoutEffect(function() {
    if (mergedContainerWidth && mergedRestWidth && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1;
      if (!len) {
        updateDisplayCount(0, null);
        return;
      }
      for (var i2 = 0; i2 < len; i2 += 1) {
        var currentItemWidth = getItemWidth(i2);
        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        }
        if (currentItemWidth === void 0) {
          updateDisplayCount(i2 - 1, void 0, true);
          break;
        }
        totalWidth += currentItemWidth;
        if (lastIndex === 0 && totalWidth <= mergedContainerWidth || i2 === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          updateDisplayCount(i2 - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }
      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey3, mergedData]);
  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};
  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: "absolute",
      left: suffixFixedStart,
      top: 0
    };
  }
  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate
  };
  var internalRenderItemNode = renderRawItem ? function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ jsx(OverflowContext.Provider, {
      value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), {}, {
        order: index2,
        item,
        itemKey: key,
        registerSize,
        display: index2 <= mergedDisplayCount
      }),
      children: renderRawItem(item, index2)
    }, key);
  } : function(item, index2) {
    var key = getKey3(item, index2);
    return /* @__PURE__ */ react.exports.createElement(Item$3, {
      ...itemSharedProps,
      order: index2,
      key,
      item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize,
      display: index2 <= mergedDisplayCount
    });
  };
  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };
  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode = /* @__PURE__ */ jsx(Item$3, {
      ...itemSharedProps,
      ...restContextProps,
      children: typeof mergedRenderRest === "function" ? mergedRenderRest(omittedItems) : mergedRenderRest
    });
  } else if (renderRawRest) {
    restNode = /* @__PURE__ */ jsx(OverflowContext.Provider, {
      value: _objectSpread2$1(_objectSpread2$1({}, itemSharedProps), restContextProps),
      children: renderRawRest(omittedItems)
    });
  }
  var overflowNode = /* @__PURE__ */ jsxs(Component2, {
    className: classNames(!invalidate && prefixCls, className),
    style: style2,
    ref,
    ...restProps,
    children: [mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /* @__PURE__ */ jsx(Item$3, {
      ...itemSharedProps,
      responsive: isResponsive,
      responsiveDisabled: !shouldResponsive,
      order: mergedDisplayCount,
      className: "".concat(itemPrefixCls, "-suffix"),
      registerSize: registerSuffixSize,
      display: true,
      style: suffixStyle,
      children: suffix
    })]
  });
  if (isResponsive) {
    overflowNode = /* @__PURE__ */ jsx(RefResizeObserver, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive,
      children: overflowNode
    });
  }
  return overflowNode;
}
var ForwardOverflow = /* @__PURE__ */ react.exports.forwardRef(Overflow);
ForwardOverflow.displayName = "Overflow";
ForwardOverflow.Item = RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE;
var Portal$1 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var didUpdate = props.didUpdate, getContainer2 = props.getContainer, children = props.children;
  var parentRef = react.exports.useRef();
  var containerRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return {};
  });
  var initRef = react.exports.useRef(false);
  if (!initRef.current && canUseDom()) {
    containerRef.current = getContainer2();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }
  react.exports.useEffect(function() {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  react.exports.useEffect(function() {
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }
    return function() {
      var _containerRef$current, _containerRef$current2;
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /* @__PURE__ */ ReactDOM.createPortal(children, containerRef.current) : null;
});
function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }
  return a1[0] === a2[0] && a1[1] === a2[1];
}
function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2$1(_objectSpread2$1({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements2 = Object.keys(builtinPlacements);
  for (var i2 = 0; i2 < placements2.length; i2 += 1) {
    var placement = placements2[i2];
    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }
  return "";
}
function getMotion$3(_ref) {
  var prefixCls = _ref.prefixCls, motion2 = _ref.motion, animation = _ref.animation, transitionName = _ref.transitionName;
  if (motion2) {
    return motion2;
  }
  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }
  if (transitionName) {
    return {
      motionName: transitionName
    };
  }
  return null;
}
function Mask(props) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, mask = props.mask, maskMotion = props.maskMotion, maskAnimation = props.maskAnimation, maskTransitionName = props.maskTransitionName;
  if (!mask) {
    return null;
  }
  var motion2 = {};
  if (maskMotion || maskTransitionName || maskAnimation) {
    motion2 = _objectSpread2$1({
      motionAppear: true
    }, getMotion$3({
      motion: maskMotion,
      prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }
  return /* @__PURE__ */ jsx(CSSMotion, {
    ...motion2,
    visible,
    removeOnLeave: true,
    children: function(_ref) {
      var className = _ref.className;
      return /* @__PURE__ */ jsx("div", {
        style: {
          zIndex
        },
        className: classNames("".concat(prefixCls, "-mask"), className)
      });
    }
  });
}
const isVisible = function(element) {
  if (!element) {
    return false;
  }
  if (element instanceof HTMLElement && element.offsetParent) {
    return true;
  }
  if (element instanceof SVGGraphicsElement && element.getBBox) {
    var _element$getBBox = element.getBBox(), width = _element$getBBox.width, height = _element$getBBox.height;
    if (width || height) {
      return true;
    }
  }
  if (element instanceof HTMLElement && element.getBoundingClientRect) {
    var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
    if (_width || _height) {
      return true;
    }
  }
  return false;
};
function ownKeys(object4, enumerableOnly) {
  var keys2 = Object.keys(object4);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object4);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object4, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = null != arguments[i2] ? arguments[i2] : {};
    i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var vendorPrefix;
var jsCssMap = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  ms: "-ms-",
  O: "-o-"
};
function getVendorPrefix() {
  if (vendorPrefix !== void 0) {
    return vendorPrefix;
  }
  vendorPrefix = "";
  var style2 = document.createElement("p").style;
  var testProp = "Transform";
  for (var key in jsCssMap) {
    if (key + testProp in style2) {
      vendorPrefix = key;
    }
  }
  return vendorPrefix;
}
function getTransitionName$1() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : "transitionProperty";
}
function getTransformName() {
  return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : "transform";
}
function setTransitionProperty(node2, value) {
  var name2 = getTransitionName$1();
  if (name2) {
    node2.style[name2] = value;
    if (name2 !== "transitionProperty") {
      node2.style.transitionProperty = value;
    }
  }
}
function setTransform(node2, value) {
  var name2 = getTransformName();
  if (name2) {
    node2.style[name2] = value;
    if (name2 !== "transform") {
      node2.style.transform = value;
    }
  }
}
function getTransitionProperty(node2) {
  return node2.style.transitionProperty || node2.style[getTransitionName$1()];
}
function getTransformXY(node2) {
  var style2 = window.getComputedStyle(node2, null);
  var transform = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var matrix = transform.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node2, xy) {
  var style2 = window.getComputedStyle(node2, null);
  var transform = style2.getPropertyValue("transform") || style2.getPropertyValue(getTransformName());
  if (transform && transform !== "none") {
    var arr;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node2, "matrix(".concat(arr.join(","), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(",").map(function(item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node2, "matrix3d(".concat(arr.join(","), ")"));
    }
  } else {
    setTransform(node2, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}
var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX;
function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = "none";
  elem.offsetHeight;
  elem.style.display = originalStyle;
}
function css(el2, name2, v2) {
  var value = v2;
  if (_typeof(name2) === "object") {
    for (var i2 in name2) {
      if (name2.hasOwnProperty(i2)) {
        css(el2, i2, name2[i2]);
      }
    }
    return void 0;
  }
  if (typeof value !== "undefined") {
    if (typeof value === "number") {
      value = "".concat(value, "px");
    }
    el2.style[name2] = value;
    return void 0;
  }
  return getComputedStyleX(el2, name2);
}
function getClientPosition(elem) {
  var box;
  var x2;
  var y2;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  box = elem.getBoundingClientRect();
  x2 = Math.floor(box.left);
  y2 = Math.floor(box.top);
  x2 -= docElem.clientLeft || body.clientLeft || 0;
  y2 -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x2,
    top: y2
  };
}
function getScroll(w2, top) {
  var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
  var method4 = "scroll".concat(top ? "Top" : "Left");
  if (typeof ret !== "number") {
    var d2 = w2.document;
    ret = d2.documentElement[method4];
    if (typeof ret !== "number") {
      ret = d2.body[method4];
    }
  }
  return ret;
}
function getScrollLeft(w2) {
  return getScroll(w2);
}
function getScrollTop(w2) {
  return getScroll(w2, true);
}
function getOffset$1(el2) {
  var pos = getClientPosition(el2);
  var doc = el2.ownerDocument;
  var w2 = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w2);
  pos.top += getScrollTop(w2);
  return pos;
}
function isWindow(obj) {
  return obj !== null && obj !== void 0 && obj == obj.window;
}
function getDocument(node2) {
  if (isWindow(node2)) {
    return node2.document;
  }
  if (node2.nodeType === 9) {
    return node2;
  }
  return node2.ownerDocument;
}
function _getComputedStyle(elem, name2, cs) {
  var computedStyle = cs;
  var val = "";
  var d2 = getDocument(elem);
  computedStyle = computedStyle || d2.defaultView.getComputedStyle(elem, null);
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name2) || computedStyle[name2];
  }
  return val;
}
var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), "i");
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = "currentStyle";
var RUNTIME_STYLE = "runtimeStyle";
var LEFT$1 = "left";
var PX = "px";
function _getComputedStyleIE(elem, name2) {
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name2];
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name2)) {
    var style2 = elem.style;
    var left = style2[LEFT$1];
    var rsLeft = elem[RUNTIME_STYLE][LEFT$1];
    elem[RUNTIME_STYLE][LEFT$1] = elem[CURRENT_STYLE][LEFT$1];
    style2[LEFT$1] = name2 === "fontSize" ? "1em" : ret || 0;
    ret = style2.pixelLeft + PX;
    style2[LEFT$1] = left;
    elem[RUNTIME_STYLE][LEFT$1] = rsLeft;
  }
  return ret === "" ? "auto" : ret;
}
if (typeof window !== "undefined") {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}
function getOffsetDirection(dir, option) {
  if (dir === "left") {
    return option.useCssRight ? "right" : dir;
  }
  return option.useCssBottom ? "bottom" : dir;
}
function oppositeOffsetDirection(dir) {
  if (dir === "left") {
    return "right";
  } else if (dir === "right") {
    return "left";
  } else if (dir === "top") {
    return "bottom";
  } else if (dir === "bottom") {
    return "top";
  }
}
function setLeftTop(elem, offset2, option) {
  if (css(elem, "position") === "static") {
    elem.style.position = "relative";
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection("left", option);
  var verticalProperty = getOffsetDirection("top", option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);
  if (horizontalProperty !== "left") {
    presetH = 999;
  }
  if (verticalProperty !== "top") {
    presetV = 999;
  }
  var originalTransition = "";
  var originalOffset = getOffset$1(elem);
  if ("left" in offset2 || "top" in offset2) {
    originalTransition = getTransitionProperty(elem) || "";
    setTransitionProperty(elem, "none");
  }
  if ("left" in offset2) {
    elem.style[oppositeHorizontalProperty] = "";
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }
  if ("top" in offset2) {
    elem.style[oppositeVerticalProperty] = "";
    elem.style[verticalProperty] = "".concat(presetV, "px");
  }
  forceRelayout(elem);
  var old = getOffset$1(elem);
  var originalStyle = {};
  for (var key in offset2) {
    if (offset2.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === "left" ? presetH : presetV;
      var off = originalOffset[key] - old[key];
      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  forceRelayout(elem);
  if ("left" in offset2 || "top" in offset2) {
    setTransitionProperty(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset2) {
    if (offset2.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset2[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}
function setTransform$1(elem, offset2) {
  var originalOffset = getOffset$1(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };
  if ("left" in offset2) {
    resultXY.x = originalXY.x + offset2.left - originalOffset.left;
  }
  if ("top" in offset2) {
    resultXY.y = originalXY.y + offset2.top - originalOffset.top;
  }
  setTransformXY(elem, resultXY);
}
function setOffset(elem, offset2, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset$1(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset2.left.toFixed(0);
    var tTop = offset2.top.toFixed(0);
    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset2, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset2);
  } else {
    setLeftTop(elem, offset2, option);
  }
}
function each(arr, fn2) {
  for (var i2 = 0; i2 < arr.length; i2++) {
    fn2(arr[i2]);
  }
}
function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, "boxSizing") === "border-box";
}
var BOX_MODELS = ["margin", "border", "padding"];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;
function swap(elem, options, callback) {
  var old = {};
  var style2 = elem.style;
  var name2;
  for (name2 in options) {
    if (options.hasOwnProperty(name2)) {
      old[name2] = style2[name2];
      style2[name2] = options[name2];
    }
  }
  callback.call(elem);
  for (name2 in options) {
    if (options.hasOwnProperty(name2)) {
      style2[name2] = old[name2];
    }
  }
}
function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j2;
  var i2;
  for (j2 = 0; j2 < props.length; j2++) {
    prop = props[j2];
    if (prop) {
      for (i2 = 0; i2 < which.length; i2++) {
        var cssProp = void 0;
        if (prop === "border") {
          cssProp = "".concat(prop).concat(which[i2], "Width");
        } else {
          cssProp = prop + which[i2];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}
var domUtils = {
  getParent: function getParent(element) {
    var parent = element;
    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);
    return parent;
  }
};
each(["Width", "Height"], function(name2) {
  domUtils["doc".concat(name2)] = function(refWin) {
    var d2 = refWin.document;
    return Math.max(
      d2.documentElement["scroll".concat(name2)],
      d2.body["scroll".concat(name2)],
      domUtils["viewport".concat(name2)](d2)
    );
  };
  domUtils["viewport".concat(name2)] = function(win) {
    var prop = "client".concat(name2);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    return doc.compatMode === "CSS1Compat" && documentElementProp || body && body[prop] || documentElementProp;
  };
});
function getWH(elem, name2, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name2 === "width" ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name2 === "width" ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  var borderBoxValue = name2 === "width" ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === void 0 || borderBoxValue <= 0) {
    borderBoxValue = void 0;
    cssBoxValue = getComputedStyleX(elem, name2);
    if (cssBoxValue === null || cssBoxValue === void 0 || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name2] || 0;
    }
    cssBoxValue = Math.floor(parseFloat(cssBoxValue)) || 0;
  }
  if (extra === void 0) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== void 0 || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ["border", "padding"], which);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ["border"], which) : getPBMWidth(elem, ["margin"], which));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}
var cssShow = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var val;
  var elem = args[0];
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(void 0, args);
  } else {
    swap(elem, cssShow, function() {
      val = getWH.apply(void 0, args);
    });
  }
  return val;
}
each(["width", "height"], function(name2) {
  var first = name2.charAt(0).toUpperCase() + name2.slice(1);
  domUtils["outer".concat(first)] = function(el2, includeMargin) {
    return el2 && getWHIgnoreDisplay(el2, name2, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name2 === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  domUtils[name2] = function(elem, v2) {
    var val = v2;
    if (val !== void 0) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ["padding", "border"], which);
        }
        return css(elem, name2, val);
      }
      return void 0;
    }
    return elem && getWHIgnoreDisplay(elem, name2, CONTENT_INDEX);
  };
});
function mix$1(to, from2) {
  for (var i2 in from2) {
    if (from2.hasOwnProperty(i2)) {
      to[i2] = from2[i2];
    }
  }
  return to;
}
var utils = {
  getWindow: function getWindow(node2) {
    if (node2 && node2.document && node2.setTimeout) {
      return node2;
    }
    var doc = node2.ownerDocument || node2;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument,
  offset: function offset(el2, value, option) {
    if (typeof value !== "undefined") {
      setOffset(el2, value, option || {});
    } else {
      return getOffset$1(el2);
    }
  },
  isWindow,
  each,
  css,
  clone: function clone(obj) {
    var i2;
    var ret = {};
    for (i2 in obj) {
      if (obj.hasOwnProperty(i2)) {
        ret[i2] = obj[i2];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i2 in obj) {
        if (obj.hasOwnProperty(i2)) {
          ret.overflow[i2] = obj.overflow[i2];
        }
      }
    }
    return ret;
  },
  mix: mix$1,
  getWindowScrollLeft: function getWindowScrollLeft(w2) {
    return getScrollLeft(w2);
  },
  getWindowScrollTop: function getWindowScrollTop(w2) {
    return getScrollTop(w2);
  },
  merge: function merge2() {
    var ret = {};
    for (var i2 = 0; i2 < arguments.length; i2++) {
      utils.mix(ret, i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2]);
    }
    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
mix$1(utils, domUtils);
var getParent2 = utils.getParent;
function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils.css(element, "position");
  var skipStatic = positionStyle === "fixed" || positionStyle === "absolute";
  if (!skipStatic) {
    return element.nodeName.toLowerCase() === "html" ? null : getParent2(element);
  }
  for (parent = getParent2(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent2(parent)) {
    positionStyle = utils.css(parent, "position");
    if (positionStyle !== "static") {
      return parent;
    }
  }
  return null;
}
var getParent$1 = utils.getParent;
function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }
  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent = null;
  for (parent = getParent$1(element); parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {
    var positionStyle = utils.css(parent, "position");
    if (positionStyle === "fixed") {
      return true;
    }
  }
  return false;
}
function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el2 = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;
  while (el2) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || el2.clientWidth !== 0) && el2 !== body && el2 !== documentElement && utils.css(el2, "overflow") !== "visible") {
      var pos = utils.offset(el2);
      pos.left += el2.clientLeft;
      pos.top += el2.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(
        visibleRect.right,
        pos.left + el2.clientWidth
      );
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el2.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el2 === body || el2 === documentElement) {
      break;
    }
    el2 = getOffsetParent(el2);
  }
  var originalPosition = null;
  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position2 = utils.css(element, "position");
    if (position2 === "absolute") {
      element.style.position = "fixed";
    }
  }
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight;
  var bodyStyle = window.getComputedStyle(body);
  if (bodyStyle.overflowX === "hidden") {
    documentWidth = win.innerWidth;
  }
  if (bodyStyle.overflowY === "hidden") {
    documentHeight = win.innerHeight;
  }
  if (element.style) {
    element.style.position = originalPosition;
  }
  if (alwaysByViewport || isAncestorFixed(element)) {
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}
function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };
  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }
  return utils.mix(pos, size);
}
function getRegion(node2) {
  var offset2;
  var w2;
  var h2;
  if (!utils.isWindow(node2) && node2.nodeType !== 9) {
    offset2 = utils.offset(node2);
    w2 = utils.outerWidth(node2);
    h2 = utils.outerHeight(node2);
  } else {
    var win = utils.getWindow(node2);
    offset2 = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w2 = utils.viewportWidth(win);
    h2 = utils.viewportHeight(win);
  }
  offset2.width = w2;
  offset2.height = h2;
  return offset2;
}
function getAlignOffset(region, align) {
  var V2 = align.charAt(0);
  var H2 = align.charAt(1);
  var w2 = region.width;
  var h2 = region.height;
  var x2 = region.left;
  var y2 = region.top;
  if (V2 === "c") {
    y2 += h2 / 2;
  } else if (V2 === "b") {
    y2 += h2;
  }
  if (H2 === "c") {
    x2 += w2 / 2;
  } else if (H2 === "r") {
    x2 += w2;
  }
  return {
    left: x2,
    top: y2
  };
}
function getElFuturePos(elRegion, refNodeRegion, points, offset2, targetOffset2) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset2[0] - targetOffset2[0]),
    top: Math.round(elRegion.top - diff[1] + offset2[1] - targetOffset2[1])
  };
}
function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}
function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}
function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}
function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}
function flip(points, reg, map) {
  var ret = [];
  utils.each(points, function(p2) {
    ret.push(p2.replace(reg, function(m2) {
      return map[m2];
    }));
  });
  return ret;
}
function flipOffset(offset2, index2) {
  offset2[index2] = -offset2[index2];
  return offset2;
}
function convertOffset(str, offsetLen) {
  var n2;
  if (/%$/.test(str)) {
    n2 = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n2 = parseInt(str, 10);
  }
  return n2 || 0;
}
function normalizeOffset(offset2, el2) {
  offset2[0] = convertOffset(offset2[0], el2.width);
  offset2[1] = convertOffset(offset2[1], el2.height);
}
function doAlign(el2, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset2 = align.offset || [0, 0];
  var targetOffset2 = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el2;
  offset2 = [].concat(offset2);
  targetOffset2 = [].concat(targetOffset2);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport);
  var visibleRect = getVisibleRectForElement(source, alwaysByViewport);
  var elRegion = getRegion(source);
  normalizeOffset(offset2, elRegion);
  normalizeOffset(targetOffset2, tgtRegion);
  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset2, targetOffset2);
  var newElRegion = utils.merge(elRegion, elFuturePos);
  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        var newPoints = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
        var newOffset = flipOffset(offset2, 0);
        var newTargetOffset = flipOffset(targetOffset2, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset2 = newOffset;
          targetOffset2 = newTargetOffset;
        }
      }
    }
    if (overflow.adjustY) {
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        var _newPoints = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
        var _newOffset = flipOffset(offset2, 1);
        var _newTargetOffset = flipOffset(targetOffset2, 1);
        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset2 = _newOffset;
          targetOffset2 = _newTargetOffset;
        }
      }
    }
    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset2, targetOffset2);
      utils.mix(newElRegion, elFuturePos);
    }
    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect);
    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points;
      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: "r",
          r: "l"
        });
      }
      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: "b",
          b: "t"
        });
      }
      points = _newPoints2;
      offset2 = align.offset || [0, 0];
      targetOffset2 = align.targetOffset || [0, 0];
    }
    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY;
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }
  if (newElRegion.width !== elRegion.width) {
    utils.css(source, "width", utils.width(source) + newElRegion.width - elRegion.width);
  }
  if (newElRegion.height !== elRegion.height) {
    utils.css(source, "height", utils.height(source) + newElRegion.height - elRegion.height);
  }
  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points,
    offset: offset2,
    targetOffset: targetOffset2,
    overflow: newOverflowCfg
  };
}
function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}
function alignElement(el2, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el2, refNodeRegion, align, isTargetNotOutOfVisible);
}
alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;
function alignPoint(el2, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el2);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  if ("pageX" in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }
  if ("pageY" in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }
  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight;
  var points = [align.points[0], "cc"];
  return doAlign(el2, tgtRegion, _objectSpread2(_objectSpread2({}, align), {}, {
    points
  }), pointInView);
}
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$2(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$2;
var eq$1 = eq_1;
function assocIndexOf$4(array4, key) {
  var length2 = array4.length;
  while (length2--) {
    if (eq$1(array4[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var ListCache$3 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$3();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$8 = freeGlobal || freeSelf || Function("return this")();
var _root = root$8;
var root$7 = _root;
var Symbol$4 = root$7.Symbol;
var _Symbol = Symbol$4;
var Symbol$3 = _Symbol;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$3 ? Symbol$3.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e2) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$2 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag$4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$4;
function isObject$3(value) {
  var type4 = typeof value;
  return value != null && (type4 == "object" || type4 == "function");
}
var isObject_1 = isObject$3;
var baseGetTag$3 = _baseGetTag, isObject$2 = isObject_1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$2(value) {
  if (!isObject$2(value)) {
    return false;
  }
  var tag = baseGetTag$3(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$2;
var root$6 = _root;
var coreJsData$1 = root$6["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e2) {
    }
    try {
      return func + "";
    } catch (e2) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$1 = isFunction_1, isMasked = _isMasked, isObject$1 = isObject_1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern4 = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern4.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$2(object4, key) {
  return object4 == null ? void 0 : object4[key];
}
var _getValue = getValue$2;
var baseIsNative = _baseIsNative, getValue$1 = _getValue;
function getNative$6(object4, key) {
  var value = getValue$1(object4, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$6;
var getNative$5 = _getNative, root$5 = _root;
var Map$4 = getNative$5(root$5, "Map");
var _Map = Map$4;
var getNative$4 = _getNative;
var nativeCreate$4 = getNative$4(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$6.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$5.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
var Hash = _Hash, ListCache$2 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$2)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type4 = typeof value;
  return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$2(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$2.prototype.clear = mapCacheClear;
MapCache$2.prototype["delete"] = mapCacheDelete;
MapCache$2.prototype.get = mapCacheGet;
MapCache$2.prototype.has = mapCacheHas;
MapCache$2.prototype.set = mapCacheSet;
var _MapCache = MapCache$2;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$1(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$1.prototype.clear = stackClear;
Stack$1.prototype["delete"] = stackDelete;
Stack$1.prototype.get = stackGet;
Stack$1.prototype.has = stackHas;
Stack$1.prototype.set = stackSet;
var _Stack = Stack$1;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$1(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length;
  while (++index2 < length2) {
    if (predicate(array4[index2], index2, array4)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$1;
function cacheHas$1(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$1;
var SetCache = _SetCache, arraySome = _arraySome, cacheHas = _cacheHas;
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays$2(array4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array4.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array4);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array4;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack.set(array4, other);
  stack.set(other, array4);
  while (++index2 < arrLength) {
    var arrValue = array4[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array4, stack) : customizer(arrValue, othValue, index2, array4, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array4);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$4 = _root;
var Uint8Array$2 = root$4.Uint8Array;
var _Uint8Array = Uint8Array$2;
function mapToArray$1(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$1(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray$1;
var Symbol$1 = _Symbol, Uint8Array$1 = _Uint8Array, eq = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray = _setToArray;
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object4, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object4.byteLength != other.byteLength || object4.byteOffset != other.byteOffset) {
        return false;
      }
      object4 = object4.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object4.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object4), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+object4, +other);
    case errorTag$1:
      return object4.name == other.name && object4.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object4 == other + "";
    case mapTag$2:
      var convert = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object4.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object4);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack.set(object4, other);
      var result = equalArrays$1(convert(object4), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object4);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object4) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$1(array4, values) {
  var index2 = -1, length2 = values.length, offset2 = array4.length;
  while (++index2 < length2) {
    array4[offset2 + index2] = values[index2];
  }
  return array4;
}
var _arrayPush = arrayPush$1;
var isArray$3 = Array.isArray;
var isArray_1 = isArray$3;
var arrayPush = _arrayPush, isArray$2 = isArray_1;
function baseGetAllKeys$1(object4, keysFunc, symbolsFunc) {
  var result = keysFunc(object4);
  return isArray$2(object4) ? result : arrayPush(result, symbolsFunc(object4));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array4, predicate) {
  var index2 = -1, length2 = array4 == null ? 0 : array4.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array4[index2];
    if (predicate(value, index2, array4)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$6 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object4) {
  if (object4 == null) {
    return [];
  }
  object4 = Object(object4);
  return arrayFilter(nativeGetSymbols(object4), function(symbol) {
    return propertyIsEnumerable$1.call(object4, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n2, iteratee) {
  var index2 = -1, result = Array(n2);
  while (++index2 < n2) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes$1;
function isObjectLike$4(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$4;
var baseGetTag$2 = _baseGetTag, isObjectLike$3 = isObjectLike_1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$2 = isObjectLike_1;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;
var isArguments$1 = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$2(value) && hasOwnProperty$4.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$1;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
(function(module, exports) {
  var root2 = _root, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer2 = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$2, isBuffer$2.exports);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$1(value, length2) {
  var type4 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
var _isIndex = isIndex$1;
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength$2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength$2;
var baseGetTag$1 = _baseGetTag, isLength$1 = isLength_1, isObjectLike$1 = isObjectLike_1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$1(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$1;
var _nodeUtil = { exports: {} };
(function(module, exports) {
  var freeGlobal2 = _freeGlobal;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types2 = freeModule && freeModule.require && freeModule.require("util").types;
      if (types2) {
        return types2;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e2) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var baseIsTypedArray = _baseIsTypedArray, baseUnary = _baseUnary, nodeUtil = _nodeUtil.exports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments = isArguments_1, isArray$1 = isArray_1, isBuffer$1 = isBuffer$2.exports, isIndex = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$3 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$3;
  return value === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseKeys$1(object4) {
  if (!isPrototype(object4)) {
    return nativeKeys(object4);
  }
  var result = [];
  for (var key in Object(object4)) {
    if (hasOwnProperty$2.call(object4, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction = isFunction_1, isLength = isLength_1;
function isArrayLike$1(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var isArrayLike_1 = isArrayLike$1;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike = isArrayLike_1;
function keys$1(object4) {
  return isArrayLike(object4) ? arrayLikeKeys(object4) : baseKeys(object4);
}
var keys_1 = keys$1;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys = keys_1;
function getAllKeys$2(object4) {
  return baseGetAllKeys(object4, keys, getSymbols);
}
var _getAllKeys = getAllKeys$2;
var getAllKeys$1 = _getAllKeys;
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys$1(object4), objLength = objProps.length, othProps = getAllKeys$1(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object4);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object4;
  }
  var result = true;
  stack.set(object4, other);
  stack.set(other, object4);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object4[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object4, stack) : customizer(objValue, othValue, key, object4, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object4.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object4 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object4);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$3 = _getNative, root$3 = _root;
var DataView$1 = getNative$3(root$3, "DataView");
var _DataView = DataView$1;
var getNative$2 = _getNative, root$2 = _root;
var Promise$2 = getNative$2(root$2, "Promise");
var _Promise = Promise$2;
var getNative$1 = _getNative, root$1 = _root;
var Set$2 = getNative$1(root$1, "Set");
var _Set = Set$2;
var getNative = _getNative, root = _root;
var WeakMap$2 = getNative(root, "WeakMap");
var _WeakMap = WeakMap$2;
var DataView = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$1 = _Set, WeakMap$1 = _WeakMap, baseGetTag = _baseGetTag, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag$1 = baseGetTag;
if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap$1 && getTag$1(new WeakMap$1()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray = isArray_1, isBuffer = isBuffer$2.exports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep$1(object4, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object4), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object4), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object4)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object4) ? equalArrays(object4, other, bitmask, customizer, equalFunc, stack) : equalByTag(object4, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object4, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object4.value() : object4, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object4, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike = isObjectLike_1;
function baseIsEqual$1(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$1, stack);
}
var _baseIsEqual = baseIsEqual$1;
var baseIsEqual = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
function isSamePoint(prev2, next2) {
  if (prev2 === next2)
    return true;
  if (!prev2 || !next2)
    return false;
  if ("pageX" in next2 && "pageY" in next2) {
    return prev2.pageX === next2.pageX && prev2.pageY === next2.pageY;
  }
  if ("clientX" in next2 && "clientY" in next2) {
    return prev2.clientX === next2.clientX && prev2.clientY === next2.clientY;
  }
  return false;
}
function restoreFocus(activeElement, container) {
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === "function") {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;
  function onResize2(_ref) {
    var _ref2 = _slicedToArray(_ref, 1), target = _ref2[0].target;
    if (!document.documentElement.contains(target))
      return;
    var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);
    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      Promise.resolve().then(function() {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }
    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }
  var resizeObserver2 = new index$1(onResize2);
  if (element) {
    resizeObserver2.observe(element);
  }
  return function() {
    resizeObserver2.disconnect();
  };
}
const useBuffer = function(callback, buffer) {
  var calledRef = React.useRef(false);
  var timeoutRef = React.useRef(null);
  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }
  function trigger(force) {
    cancelTrigger();
    if (!calledRef.current || force === true) {
      if (callback() === false) {
        return;
      }
      calledRef.current = true;
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
      }, buffer);
    } else {
      timeoutRef.current = window.setTimeout(function() {
        calledRef.current = false;
        trigger();
      }, buffer);
    }
  }
  return [trigger, function() {
    calledRef.current = false;
    cancelTrigger();
  }];
};
function getElement(func) {
  if (typeof func !== "function")
    return null;
  return func();
}
function getPoint(point) {
  if (_typeof$1(point) !== "object" || !point)
    return null;
  return point;
}
var Align = function Align2(_ref, ref) {
  var children = _ref.children, disabled = _ref.disabled, target = _ref.target, align = _ref.align, onAlign = _ref.onAlign, monitorWindowResize = _ref.monitorWindowResize, _ref$monitorBufferTim = _ref.monitorBufferTime, monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = React.useRef({});
  var nodeRef = React.useRef();
  var childNode = React.Children.only(children);
  var forceAlignPropsRef = React.useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.align = align;
  forceAlignPropsRef.current.onAlign = onAlign;
  var _useBuffer = useBuffer(function() {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current, latestDisabled = _forceAlignPropsRef$c.disabled, latestTarget = _forceAlignPropsRef$c.target, latestAlign = _forceAlignPropsRef$c.align, latestOnAlign = _forceAlignPropsRef$c.onAlign;
    if (!latestDisabled && latestTarget) {
      var source = nodeRef.current;
      var result;
      var element = getElement(latestTarget);
      var point = getPoint(latestTarget);
      cacheRef.current.element = element;
      cacheRef.current.point = point;
      cacheRef.current.align = latestAlign;
      var _document = document, activeElement = _document.activeElement;
      if (element && isVisible(element)) {
        result = alignElement(source, element, latestAlign);
      } else if (point) {
        result = alignPoint(source, point, latestAlign);
      }
      restoreFocus(activeElement, source);
      if (latestOnAlign && result) {
        latestOnAlign(source, result);
      }
      return true;
    }
    return false;
  }, monitorBufferTime), _useBuffer2 = _slicedToArray(_useBuffer, 2), _forceAlign = _useBuffer2[0], cancelForceAlign = _useBuffer2[1];
  var resizeMonitor = React.useRef({
    cancel: function cancel() {
    }
  });
  var sourceResizeMonitor = React.useRef({
    cancel: function cancel() {
    }
  });
  React.useEffect(function() {
    var element = getElement(target);
    var point = getPoint(target);
    if (nodeRef.current !== sourceResizeMonitor.current.element) {
      sourceResizeMonitor.current.cancel();
      sourceResizeMonitor.current.element = nodeRef.current;
      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);
    }
    if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point) || !isEqual_1(cacheRef.current.align, align)) {
      _forceAlign();
      if (resizeMonitor.current.element !== element) {
        resizeMonitor.current.cancel();
        resizeMonitor.current.element = element;
        resizeMonitor.current.cancel = monitorResize(element, _forceAlign);
      }
    }
  });
  React.useEffect(function() {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]);
  var winResizeRef = React.useRef(null);
  React.useEffect(function() {
    if (monitorWindowResize) {
      if (!winResizeRef.current) {
        winResizeRef.current = addEventListenerWrap(window, "resize", _forceAlign);
      }
    } else if (winResizeRef.current) {
      winResizeRef.current.remove();
      winResizeRef.current = null;
    }
  }, [monitorWindowResize]);
  React.useEffect(function() {
    return function() {
      resizeMonitor.current.cancel();
      sourceResizeMonitor.current.cancel();
      if (winResizeRef.current)
        winResizeRef.current.remove();
      cancelForceAlign();
    };
  }, []);
  React.useImperativeHandle(ref, function() {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  });
  if (/* @__PURE__ */ React.isValidElement(childNode)) {
    childNode = /* @__PURE__ */ React.cloneElement(childNode, {
      ref: composeRef(childNode.ref, nodeRef)
    });
  }
  return childNode;
};
var RcAlign = /* @__PURE__ */ React.forwardRef(Align);
RcAlign.displayName = "Align";
var StatusQueue = ["measure", "alignPre", "align", null, "motion"];
const useVisibleStatus = function(visible, doMeasure) {
  var _useState = useSafeState(null), _useState2 = _slicedToArray(_useState, 2), status = _useState2[0], setInternalStatus = _useState2[1];
  var rafRef = react.exports.useRef();
  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }
  function cancelRaf() {
    wrapperRaf.cancel(rafRef.current);
  }
  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf(function() {
      setStatus(function(prev2) {
        switch (status) {
          case "align":
            return "motion";
          case "motion":
            return "stable";
        }
        return prev2;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  }
  react.exports.useEffect(function() {
    setStatus("measure");
  }, [visible]);
  react.exports.useEffect(function() {
    switch (status) {
      case "measure":
        doMeasure();
        break;
    }
    if (status) {
      rafRef.current = wrapperRaf(/* @__PURE__ */ _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
        var index2, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                index2 = StatusQueue.indexOf(status);
                nextStatus = StatusQueue[index2 + 1];
                if (nextStatus && index2 !== -1) {
                  setStatus(nextStatus);
                }
              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  react.exports.useEffect(function() {
    return function() {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
};
const useStretchStyle = function(stretch) {
  var _React$useState = react.exports.useState({
    width: 0,
    height: 0
  }), _React$useState2 = _slicedToArray(_React$useState, 2), targetSize = _React$useState2[0], setTargetSize = _React$useState2[1];
  function measureStretch(element) {
    var tgtWidth = element.offsetWidth, tgtHeight = element.offsetHeight;
    var _element$getBoundingC = element.getBoundingClientRect(), width = _element$getBoundingC.width, height = _element$getBoundingC.height;
    if (Math.abs(tgtWidth - width) < 1 && Math.abs(tgtHeight - height) < 1) {
      tgtWidth = width;
      tgtHeight = height;
    }
    setTargetSize({
      width: tgtWidth,
      height: tgtHeight
    });
  }
  var style2 = react.exports.useMemo(function() {
    var sizeStyle = {};
    if (stretch) {
      var width = targetSize.width, height = targetSize.height;
      if (stretch.indexOf("height") !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf("minHeight") !== -1 && height) {
        sizeStyle.minHeight = height;
      }
      if (stretch.indexOf("width") !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf("minWidth") !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }
    return sizeStyle;
  }, [stretch, targetSize]);
  return [style2, measureStretch];
};
var PopupInner = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var visible = props.visible, prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, zIndex = props.zIndex, stretch = props.stretch, destroyPopupOnHide = props.destroyPopupOnHide, forceRender = props.forceRender, align = props.align, point = props.point, getRootDomNode = props.getRootDomNode, getClassNameFromAlign = props.getClassNameFromAlign, onAlign = props.onAlign, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onMouseDown = props.onMouseDown, onTouchStart = props.onTouchStart, onClick = props.onClick;
  var alignRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var _useState = react.exports.useState(), _useState2 = _slicedToArray(_useState, 2), alignedClassName = _useState2[0], setAlignedClassName = _useState2[1];
  var _useStretchStyle = useStretchStyle(stretch), _useStretchStyle2 = _slicedToArray(_useStretchStyle, 2), stretchStyle = _useStretchStyle2[0], measureStretchStyle = _useStretchStyle2[1];
  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  }
  var _useVisibleStatus = useVisibleStatus(visible, doMeasure), _useVisibleStatus2 = _slicedToArray(_useVisibleStatus, 2), status = _useVisibleStatus2[0], goNextStatus = _useVisibleStatus2[1];
  var _useState3 = react.exports.useState(0), _useState4 = _slicedToArray(_useState3, 2), alignTimes = _useState4[0], setAlignTimes = _useState4[1];
  var prepareResolveRef = react.exports.useRef();
  useLayoutEffect(function() {
    if (status === "alignPre") {
      setAlignTimes(0);
    }
  }, [status]);
  function getAlignTarget() {
    if (point) {
      return point;
    }
    return getRootDomNode;
  }
  function forceAlign() {
    var _alignRef$current;
    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }
  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);
    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    }
    setAlignTimes(function(val) {
      return val + 1;
    });
    if (status === "align") {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  }
  useLayoutEffect(function() {
    if (status === "align") {
      if (alignTimes < 3) {
        forceAlign();
      } else {
        goNextStatus(function() {
          var _prepareResolveRef$cu;
          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]);
  var motion2 = _objectSpread2$1({}, getMotion$3(props));
  ["onAppearEnd", "onEnterEnd", "onLeaveEnd"].forEach(function(eventName) {
    var originHandler = motion2[eventName];
    motion2[eventName] = function(element, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);
    };
  });
  function onShowPrepare() {
    return new Promise(function(resolve) {
      prepareResolveRef.current = resolve;
    });
  }
  react.exports.useEffect(function() {
    if (!motion2.motionName && status === "motion") {
      goNextStatus();
    }
  }, [motion2.motionName, status]);
  react.exports.useImperativeHandle(ref, function() {
    return {
      forceAlign,
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, stretchStyle), {}, {
    zIndex,
    opacity: status === "motion" || status === "stable" || !visible ? void 0 : 0,
    pointerEvents: !visible && status !== "stable" ? "none" : void 0
  }, style2);
  var alignDisabled = true;
  if (align !== null && align !== void 0 && align.points && (status === "align" || status === "stable")) {
    alignDisabled = false;
  }
  var childNode = children;
  if (react.exports.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-content"),
      children
    });
  }
  return /* @__PURE__ */ jsx(CSSMotion, {
    visible,
    ref: elementRef,
    leavedClassName: "".concat(prefixCls, "-hidden"),
    ...motion2,
    onAppearPrepare: onShowPrepare,
    onEnterPrepare: onShowPrepare,
    removeOnLeave: destroyPopupOnHide,
    forceRender,
    children: function(_ref, motionRef) {
      var motionClassName = _ref.className, motionStyle = _ref.style;
      var mergedClassName = classNames(prefixCls, className, alignedClassName, motionClassName);
      return /* @__PURE__ */ jsx(RcAlign, {
        target: getAlignTarget(),
        ref: alignRef,
        monitorWindowResize: true,
        disabled: alignDisabled,
        align,
        onAlign: onInternalAlign,
        children: /* @__PURE__ */ jsx("div", {
          ref: motionRef,
          className: mergedClassName,
          onMouseEnter,
          onMouseLeave,
          onMouseDownCapture: onMouseDown,
          onTouchStartCapture: onTouchStart,
          onClick,
          style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle),
          children: childNode
        })
      }, "popup");
    }
  });
});
PopupInner.displayName = "PopupInner";
var MobilePopupInner = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, visible = props.visible, zIndex = props.zIndex, children = props.children, _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName, popupStyle = _props$mobile.popupStyle, _props$mobile$popupMo = _props$mobile.popupMotion, popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo, popupRender = _props$mobile.popupRender, onClick = props.onClick;
  var elementRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return {
      forceAlign: function forceAlign() {
      },
      getElement: function getElement2() {
        return elementRef.current;
      }
    };
  });
  var mergedStyle = _objectSpread2$1({
    zIndex
  }, popupStyle);
  var childNode = children;
  if (react.exports.Children.count(children) > 1) {
    childNode = /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-content"),
      children
    });
  }
  if (popupRender) {
    childNode = popupRender(childNode);
  }
  return /* @__PURE__ */ jsx(CSSMotion, {
    visible,
    ref: elementRef,
    removeOnLeave: true,
    ...popupMotion,
    children: function(_ref, motionRef) {
      var motionClassName = _ref.className, motionStyle = _ref.style;
      var mergedClassName = classNames(prefixCls, popupClassName, motionClassName);
      return /* @__PURE__ */ jsx("div", {
        ref: motionRef,
        className: mergedClassName,
        onClick,
        style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), mergedStyle),
        children: childNode
      });
    }
  });
});
MobilePopupInner.displayName = "MobilePopupInner";
var _excluded$k = ["visible", "mobile"];
var Popup$1 = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var visible = _ref.visible, mobile = _ref.mobile, props = _objectWithoutProperties(_ref, _excluded$k);
  var _useState = react.exports.useState(visible), _useState2 = _slicedToArray(_useState, 2), innerVisible = _useState2[0], serInnerVisible = _useState2[1];
  var _useState3 = react.exports.useState(false), _useState4 = _slicedToArray(_useState3, 2), inMobile = _useState4[0], setInMobile = _useState4[1];
  var cloneProps = _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    visible: innerVisible
  });
  react.exports.useEffect(function() {
    serInnerVisible(visible);
    if (visible && mobile) {
      setInMobile(isMobile());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ? /* @__PURE__ */ jsx(MobilePopupInner, {
    ...cloneProps,
    mobile,
    ref
  }) : /* @__PURE__ */ jsx(PopupInner, {
    ...cloneProps,
    ref
  });
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx(Mask, {
      ...cloneProps
    }), popupNode]
  });
});
Popup$1.displayName = "Popup";
var TriggerContext = /* @__PURE__ */ react.exports.createContext(null);
function noop() {
}
function returnEmptyString() {
  return "";
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
function generateTrigger(PortalComponent) {
  var Trigger2 = /* @__PURE__ */ function(_React$Component) {
    _inherits(Trigger3, _React$Component);
    var _super = _createSuper(Trigger3);
    function Trigger3(props) {
      var _this;
      _classCallCheck(this, Trigger3);
      _this = _super.call(this, props);
      _defineProperty$1(_assertThisInitialized(_this), "popupRef", /* @__PURE__ */ react.exports.createRef());
      _defineProperty$1(_assertThisInitialized(_this), "triggerRef", /* @__PURE__ */ react.exports.createRef());
      _defineProperty$1(_assertThisInitialized(_this), "portalContainer", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "attachId", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "clickOutsideHandler", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "touchOutsideHandler", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "contextMenuOutsideHandler1", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "contextMenuOutsideHandler2", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "mouseDownTimeout", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "focusTime", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "preClickTime", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "preTouchTime", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "delayTimer", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "hasPopupMouseDown", void 0);
      _defineProperty$1(_assertThisInitialized(_this), "onMouseEnter", function(e2) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;
        _this.fireEvents("onMouseEnter", e2);
        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e2);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onMouseMove", function(e2) {
        _this.fireEvents("onMouseMove", e2);
        _this.setPoint(e2);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onMouseLeave", function(e2) {
        _this.fireEvents("onMouseLeave", e2);
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseEnter", function() {
        _this.clearDelayTimer();
      });
      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseLeave", function(e2) {
        var _this$popupRef$curren;
        if (e2.relatedTarget && !e2.relatedTarget.setTimeout && contains((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e2.relatedTarget)) {
          return;
        }
        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onFocus", function(e2) {
        _this.fireEvents("onFocus", e2);
        _this.clearDelayTimer();
        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();
          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onMouseDown", function(e2) {
        _this.fireEvents("onMouseDown", e2);
        _this.preClickTime = Date.now();
      });
      _defineProperty$1(_assertThisInitialized(_this), "onTouchStart", function(e2) {
        _this.fireEvents("onTouchStart", e2);
        _this.preTouchTime = Date.now();
      });
      _defineProperty$1(_assertThisInitialized(_this), "onBlur", function(e2) {
        _this.fireEvents("onBlur", e2);
        _this.clearDelayTimer();
        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onContextMenu", function(e2) {
        e2.preventDefault();
        _this.fireEvents("onContextMenu", e2);
        _this.setPopupVisible(true, e2);
      });
      _defineProperty$1(_assertThisInitialized(_this), "onContextMenuClose", function() {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onClick", function(event) {
        _this.fireEvents("onClick", event);
        if (_this.focusTime) {
          var preTime;
          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }
          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }
          _this.focusTime = 0;
        }
        _this.preClickTime = 0;
        _this.preTouchTime = 0;
        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        var nextVisible = !_this.state.popupVisible;
        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onPopupMouseDown", function() {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function() {
          _this.hasPopupMouseDown = false;
        }, 0);
        if (_this.context) {
          var _this$context;
          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "onDocumentClick", function(event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }
        var target = event.target;
        var root2 = _this.getRootDomNode();
        var popupNode = _this.getPopupDomNode();
        if ((!contains(root2, target) || _this.isContextMenuOnly()) && !contains(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "getRootDomNode", function() {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;
        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }
        try {
          var domNode = findDOMNode(_this.triggerRef.current);
          if (domNode) {
            return domNode;
          }
        } catch (err) {
        }
        return ReactDOM.findDOMNode(_assertThisInitialized(_this));
      });
      _defineProperty$1(_assertThisInitialized(_this), "getPopupClassNameFromAlign", function(align) {
        var className = [];
        var _this$props = _this.props, popupPlacement = _this$props.popupPlacement, builtinPlacements = _this$props.builtinPlacements, prefixCls = _this$props.prefixCls, alignPoint2 = _this$props.alignPoint, getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;
        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint2));
        }
        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }
        return className.join(" ");
      });
      _defineProperty$1(_assertThisInitialized(_this), "getComponent", function() {
        var _this$props2 = _this.props, prefixCls = _this$props2.prefixCls, destroyPopupOnHide = _this$props2.destroyPopupOnHide, popupClassName = _this$props2.popupClassName, onPopupAlign = _this$props2.onPopupAlign, popupMotion = _this$props2.popupMotion, popupAnimation = _this$props2.popupAnimation, popupTransitionName = _this$props2.popupTransitionName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskAnimation = _this$props2.maskAnimation, maskTransitionName = _this$props2.maskTransitionName, maskMotion = _this$props2.maskMotion, zIndex = _this$props2.zIndex, popup = _this$props2.popup, stretch = _this$props2.stretch, alignPoint2 = _this$props2.alignPoint, mobile = _this$props2.mobile, forceRender = _this$props2.forceRender, onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state, popupVisible = _this$state.popupVisible, point = _this$state.point;
        var align = _this.getPopupAlign();
        var mouseProps = {};
        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }
        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }
        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return /* @__PURE__ */ jsx(Popup$1, {
          prefixCls,
          destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint2 && point,
          className: popupClassName,
          align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign,
          ...mouseProps,
          stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask,
          zIndex,
          transitionName: popupTransitionName,
          maskAnimation,
          maskTransitionName,
          maskMotion,
          ref: _this.popupRef,
          motion: popupMotion,
          mobile,
          forceRender,
          onClick: onPopupClick,
          children: typeof popup === "function" ? popup() : popup
        });
      });
      _defineProperty$1(_assertThisInitialized(_this), "attachParent", function(popupContainer) {
        wrapperRaf.cancel(_this.attachId);
        var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument2 = _this$props3.getDocument;
        var domNode = _this.getRootDomNode();
        var mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument2(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          _this.attachId = wrapperRaf(function() {
            _this.attachParent(popupContainer);
          });
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "getContainer", function() {
        if (!_this.portalContainer) {
          var getDocument2 = _this.props.getDocument;
          var popupContainer = getDocument2(_this.getRootDomNode()).createElement("div");
          popupContainer.style.position = "absolute";
          popupContainer.style.top = "0";
          popupContainer.style.left = "0";
          popupContainer.style.width = "100%";
          _this.portalContainer = popupContainer;
        }
        _this.attachParent(_this.portalContainer);
        return _this.portalContainer;
      });
      _defineProperty$1(_assertThisInitialized(_this), "setPoint", function(point) {
        var alignPoint2 = _this.props.alignPoint;
        if (!alignPoint2 || !point)
          return;
        _this.setState({
          point: {
            pageX: point.pageX,
            pageY: point.pageY
          }
        });
      });
      _defineProperty$1(_assertThisInitialized(_this), "handlePortalUpdate", function() {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      });
      _defineProperty$1(_assertThisInitialized(_this), "triggerContextValue", {
        onPopupMouseDown: _this.onPopupMouseDown
      });
      var _popupVisible;
      if ("popupVisible" in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }
      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS.forEach(function(h2) {
        _this["fire".concat(h2)] = function(e2) {
          _this.fireEvents(h2, e2);
        };
      });
      return _this;
    }
    _createClass(Trigger3, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state;
        if (state.popupVisible) {
          var currentDocument;
          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
          }
          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick);
          }
          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, "scroll", this.onContextMenuClose);
          }
          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, "blur", this.onContextMenuClose);
          }
          return;
        }
        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement, popupAlign = props.popupAlign, builtinPlacements = props.builtinPlacements;
        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }
        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value: function setPopupVisible(popupVisible, event) {
        var alignPoint2 = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();
        if (prevPopupVisible !== popupVisible) {
          if (!("popupVisible" in this.props)) {
            this.setState({
              popupVisible,
              prevPopupVisible
            });
          }
          this.props.onPopupVisibleChange(popupVisible);
        }
        if (alignPoint2 && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;
        var delay = delayS * 1e3;
        this.clearDelayTimer();
        if (delay) {
          var point = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function() {
            _this2.setPopupVisible(visible, point);
            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }
        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }
        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }
        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;
        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }
        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;
        return action.indexOf("click") !== -1 || showAction.indexOf("click") !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === "contextMenu" || action.length === 1 && action[0] === "contextMenu";
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props, action = _this$props5.action, showAction = _this$props5.showAction;
        return action.indexOf("contextMenu") !== -1 || showAction.indexOf("contextMenu") !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props, action = _this$props6.action, hideAction = _this$props6.hideAction;
        return action.indexOf("click") !== -1 || hideAction.indexOf("click") !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props, action = _this$props7.action, showAction = _this$props7.showAction;
        return action.indexOf("hover") !== -1 || showAction.indexOf("mouseEnter") !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props, action = _this$props8.action, hideAction = _this$props8.hideAction;
        return action.indexOf("hover") !== -1 || hideAction.indexOf("mouseLeave") !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props, action = _this$props9.action, showAction = _this$props9.showAction;
        return action.indexOf("focus") !== -1 || showAction.indexOf("focus") !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props, action = _this$props10.action, hideAction = _this$props10.hideAction;
        return action.indexOf("focus") !== -1 || hideAction.indexOf("blur") !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;
          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type4, e2) {
        var childCallback = this.props.children.props[type4];
        if (childCallback) {
          childCallback(e2);
        }
        var callback = this.props[type4];
        if (callback) {
          callback(e2);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render2() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props, children = _this$props11.children, forceRender = _this$props11.forceRender, alignPoint2 = _this$props11.alignPoint, className = _this$props11.className, autoDestroy = _this$props11.autoDestroy;
        var child = react.exports.Children.only(children);
        var newChildProps = {
          key: "trigger"
        };
        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains("onContextMenu");
        }
        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains("onClick");
          newChildProps.onMouseDown = this.createTwoChains("onMouseDown");
          newChildProps.onTouchStart = this.createTwoChains("onTouchStart");
        }
        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter;
          if (alignPoint2) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains("onMouseEnter");
        }
        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains("onMouseLeave");
        }
        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains("onFocus");
          newChildProps.onBlur = this.createTwoChains("onBlur");
        }
        var childrenClassName = classNames(child && child.props && child.props.className, className);
        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }
        var cloneProps = _objectSpread2$1({}, newChildProps);
        if (supportRef(child)) {
          cloneProps.ref = composeRef(this.triggerRef, child.ref);
        }
        var trigger = /* @__PURE__ */ react.exports.cloneElement(child, cloneProps);
        var portal;
        if (popupVisible || this.popupRef.current || forceRender) {
          portal = /* @__PURE__ */ jsx(PortalComponent, {
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate,
            children: this.getComponent()
          }, "portal");
        }
        if (!popupVisible && autoDestroy) {
          portal = null;
        }
        return /* @__PURE__ */ jsxs(TriggerContext.Provider, {
          value: this.triggerContextValue,
          children: [trigger, portal]
        });
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, prevState) {
        var popupVisible = _ref.popupVisible;
        var newState = {};
        if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }
        return newState;
      }
    }]);
    return Trigger3;
  }(react.exports.Component);
  _defineProperty$1(Trigger2, "contextType", TriggerContext);
  _defineProperty$1(Trigger2, "defaultProps", {
    prefixCls: "rc-trigger-popup",
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop,
    afterPopupVisibleChange: noop,
    onPopupAlign: noop,
    popupClassName: "",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  });
  return Trigger2;
}
const Trigger = generateTrigger(Portal$1);
const useLocale = (componentName, defaultLocale$1) => {
  const fullLocale = react.exports.useContext(LocaleContext$1);
  const getLocale = react.exports.useMemo(() => {
    var _a;
    const locale2 = defaultLocale$1 || defaultLocale[componentName];
    const localeFromContext = (_a = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a !== void 0 ? _a : {};
    return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
  }, [componentName, defaultLocale$1, fullLocale]);
  const getLocaleCode = react.exports.useMemo(() => {
    const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
    if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
      return defaultLocale.locale;
    }
    return localeCode;
  }, [fullLocale]);
  return [getLocale, getLocaleCode];
};
const useLocale$1 = useLocale;
const FormContext = /* @__PURE__ */ react.exports.createContext({
  labelAlign: "right",
  vertical: false,
  itemRef: () => {
  }
});
const NoStyleItemContext = /* @__PURE__ */ react.exports.createContext(null);
const FormProvider2 = (props) => {
  const providerProps = omit(props, ["prefixCls"]);
  return /* @__PURE__ */ jsx(FormProvider$1, {
    ...Object.assign({}, providerProps)
  });
};
const FormItemPrefixContext = /* @__PURE__ */ react.exports.createContext({
  prefixCls: ""
});
const FormItemInputContext = /* @__PURE__ */ react.exports.createContext({});
const NoFormStyle = (_ref) => {
  let {
    children,
    status,
    override
  } = _ref;
  const formItemInputContext = react.exports.useContext(FormItemInputContext);
  const newFormItemInputContext = react.exports.useMemo(() => {
    const newContext = Object.assign({}, formItemInputContext);
    if (override) {
      delete newContext.isFormItemInput;
    }
    if (status) {
      delete newContext.status;
      delete newContext.hasFeedback;
      delete newContext.feedbackIcon;
    }
    return newContext;
  }, [status, override, formItemInputContext]);
  return /* @__PURE__ */ jsx(FormItemInputContext.Provider, {
    value: newFormItemInputContext,
    children
  });
};
const getCollapsedHeight = () => ({
  height: 0,
  opacity: 0
});
const getRealHeight = (node2) => {
  const {
    scrollHeight
  } = node2;
  return {
    height: scrollHeight,
    opacity: 1
  };
};
const getCurrentHeight = (node2) => ({
  height: node2 ? node2.offsetHeight : 0
});
const skipOpacityTransition = (_2, event) => (event === null || event === void 0 ? void 0 : event.deadline) === true || event.propertyName === "height";
const initCollapseMotion = function() {
  let rootCls = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant";
  return {
    motionName: `${rootCls}-motion-collapse`,
    onAppearStart: getCollapsedHeight,
    onEnterStart: getCollapsedHeight,
    onAppearActive: getRealHeight,
    onEnterActive: getRealHeight,
    onLeaveStart: getCurrentHeight,
    onLeaveActive: getCollapsedHeight,
    onAppearEnd: skipOpacityTransition,
    onEnterEnd: skipOpacityTransition,
    onLeaveEnd: skipOpacityTransition,
    motionDeadline: 500
  };
};
const getTransitionName = (rootPrefixCls, motion2, transitionName) => {
  if (transitionName !== void 0) {
    return transitionName;
  }
  return `${rootPrefixCls}-${motion2}`;
};
const initCollapseMotion$1 = initCollapseMotion;
function getStatusClassNames(prefixCls, status, hasFeedback) {
  return classNames({
    [`${prefixCls}-status-success`]: status === "success",
    [`${prefixCls}-status-warning`]: status === "warning",
    [`${prefixCls}-status-error`]: status === "error",
    [`${prefixCls}-status-validating`]: status === "validating",
    [`${prefixCls}-has-feedback`]: hasFeedback
  });
}
const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;
var CheckOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, "name": "check", "theme": "outlined" };
const CheckOutlinedSvg = CheckOutlined$2;
var CheckOutlined = function CheckOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: CheckOutlinedSvg
    })
  });
};
CheckOutlined.displayName = "CheckOutlined";
const CheckOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CheckOutlined);
var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
const LoadingOutlinedSvg = LoadingOutlined$2;
var LoadingOutlined = function LoadingOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: LoadingOutlinedSvg
    })
  });
};
LoadingOutlined.displayName = "LoadingOutlined";
const LoadingOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LoadingOutlined);
var SearchOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };
const SearchOutlinedSvg = SearchOutlined$2;
var SearchOutlined = function SearchOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: SearchOutlinedSvg
    })
  });
};
SearchOutlined.displayName = "SearchOutlined";
const SearchOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(SearchOutlined);
const genSpaceCompactStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
};
const genSpaceCompactStyle$1 = genSpaceCompactStyle;
const genSpaceStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${componentCls}-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
};
const useStyle$m = genComponentStyleHook("Space", (token2) => [genSpaceStyle(token2), genSpaceCompactStyle$1(token2)]);
var __rest$M = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const SpaceCompactItemContext = /* @__PURE__ */ react.exports.createContext(null);
const useCompactItemContext = (prefixCls, direction) => {
  const compactItemContext = react.exports.useContext(SpaceCompactItemContext);
  const compactItemClassnames = react.exports.useMemo(() => {
    if (!compactItemContext)
      return "";
    const {
      compactDirection,
      isFirstItem,
      isLastItem
    } = compactItemContext;
    const separator = compactDirection === "vertical" ? "-vertical-" : "-";
    return classNames({
      [`${prefixCls}-compact${separator}item`]: true,
      [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
      [`${prefixCls}-compact${separator}last-item`]: isLastItem,
      [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
    });
  }, [prefixCls, direction, compactItemContext]);
  return {
    compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
    compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
    compactItemClassnames
  };
};
const NoCompactStyle = (_ref) => {
  let {
    children
  } = _ref;
  return /* @__PURE__ */ jsx(SpaceCompactItemContext.Provider, {
    value: null,
    children
  });
};
const CompactItem = (_a) => {
  var {
    children
  } = _a, otherProps = __rest$M(_a, ["children"]);
  return /* @__PURE__ */ jsx(SpaceCompactItemContext.Provider, {
    value: otherProps,
    children
  });
};
const Compact = (props) => {
  const {
    getPrefixCls,
    direction: directionConfig
  } = react.exports.useContext(ConfigContext);
  const {
    size = "middle",
    direction,
    block,
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children
  } = props, restProps = __rest$M(props, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]);
  const prefixCls = getPrefixCls("space-compact", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$m(prefixCls);
  const clx = classNames(prefixCls, hashId, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-vertical`]: direction === "vertical"
  }, className, rootClassName);
  const compactItemContext = react.exports.useContext(SpaceCompactItemContext);
  const childNodes = toArray$3(children);
  const nodes = react.exports.useMemo(() => childNodes.map((child, i2) => {
    const key = child && child.key || `${prefixCls}-item-${i2}`;
    return /* @__PURE__ */ jsx(CompactItem, {
      compactSize: size,
      compactDirection: direction,
      isFirstItem: i2 === 0 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isFirstItem)),
      isLastItem: i2 === childNodes.length - 1 && (!compactItemContext || (compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.isLastItem)),
      children: child
    }, key);
  }), [size, childNodes, compactItemContext]);
  if (childNodes.length === 0) {
    return null;
  }
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      ...Object.assign({
        className: clx
      }, restProps),
      children: nodes
    })
  );
};
const Compact$1 = Compact;
function genPurePanel(Component2, defaultPrefixCls2, getDropdownCls) {
  return function PurePanel2(props) {
    const {
      prefixCls: customizePrefixCls,
      style: style2
    } = props;
    const holderRef = react.exports.useRef(null);
    const [popupHeight, setPopupHeight] = react.exports.useState(0);
    const [popupWidth, setPopupWidth] = react.exports.useState(0);
    const [open2, setOpen] = useMergedState(false, {
      value: props.open
    });
    const {
      getPrefixCls
    } = react.exports.useContext(ConfigContext);
    const prefixCls = getPrefixCls(defaultPrefixCls2 || "select", customizePrefixCls);
    react.exports.useEffect(() => {
      setOpen(true);
      if (typeof ResizeObserver !== "undefined") {
        const resizeObserver2 = new ResizeObserver((entries) => {
          const element = entries[0].target;
          setPopupHeight(element.offsetHeight + 8);
          setPopupWidth(element.offsetWidth);
        });
        const interval = setInterval(() => {
          var _a;
          const dropdownCls = getDropdownCls ? `.${getDropdownCls(prefixCls)}` : `.${prefixCls}-dropdown`;
          const popup = (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.querySelector(dropdownCls);
          if (popup) {
            clearInterval(interval);
            resizeObserver2.observe(popup);
          }
        }, 10);
        return () => {
          clearInterval(interval);
          resizeObserver2.disconnect();
        };
      }
    }, []);
    return /* @__PURE__ */ jsx(ConfigProvider$1, {
      theme: {
        token: {
          motionDurationFast: "0.01s",
          motionDurationMid: "0.01s",
          motionDurationSlow: "0.01s"
        }
      },
      children: /* @__PURE__ */ jsx("div", {
        ref: holderRef,
        style: {
          paddingBottom: popupHeight,
          position: "relative",
          width: "fit-content",
          minWidth: popupWidth
        },
        children: /* @__PURE__ */ jsx(Component2, {
          ...Object.assign({}, props, {
            style: Object.assign(Object.assign({}, style2), {
              margin: 0
            }),
            open: open2,
            visible: open2,
            getPopupContainer: () => holderRef.current
          })
        })
      })
    });
  };
}
const initMotionCommon = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
const initMotionCommonLeave = (duration) => ({
  animationDuration: duration,
  animationFillMode: "both"
});
const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
  let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return {
    [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
      animationPlayState: "paused"
    }),
    [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
      animationPlayState: "paused"
    }),
    [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
      animationName: inKeyframes,
      animationPlayState: "running"
    },
    [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
      animationName: outKeyframes,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
};
const fadeIn = new Keyframe("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
});
const fadeOut = new Keyframe("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
});
const initFadeMotion = function(token2) {
  let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-fade`;
  const sameLevelPrefix = sameLevel ? "&" : "";
  return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
    [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${sameLevelPrefix}${motionCls}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
};
const moveDownIn = new Keyframe("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveDownOut = new Keyframe("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveLeftIn = new Keyframe("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveLeftOut = new Keyframe("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveRightIn = new Keyframe("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveRightOut = new Keyframe("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveUpIn = new Keyframe("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
});
const moveUpOut = new Keyframe("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
});
const moveMotion = {
  "move-up": {
    inKeyframes: moveUpIn,
    outKeyframes: moveUpOut
  },
  "move-down": {
    inKeyframes: moveDownIn,
    outKeyframes: moveDownOut
  },
  "move-left": {
    inKeyframes: moveLeftIn,
    outKeyframes: moveLeftOut
  },
  "move-right": {
    inKeyframes: moveRightIn,
    outKeyframes: moveRightOut
  }
};
const initMoveMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = moveMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};
const slideUpIn = new Keyframe("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
const slideUpOut = new Keyframe("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
const slideDownIn = new Keyframe("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
});
const slideDownOut = new Keyframe("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
});
const slideLeftIn = new Keyframe("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
});
const slideLeftOut = new Keyframe("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
});
const slideRightIn = new Keyframe("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
});
const slideRightOut = new Keyframe("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
});
const slideMotion = {
  "slide-up": {
    inKeyframes: slideUpIn,
    outKeyframes: slideUpOut
  },
  "slide-down": {
    inKeyframes: slideDownIn,
    outKeyframes: slideDownOut
  },
  "slide-left": {
    inKeyframes: slideLeftIn,
    outKeyframes: slideLeftOut
  },
  "slide-right": {
    inKeyframes: slideRightIn,
    outKeyframes: slideRightOut
  }
};
const initSlideMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = slideMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, token2.motionDurationMid), {
    [`
      ${motionCls}-enter,
      ${motionCls}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutQuint
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInQuint
    }
  }];
};
const zoomIn = new Keyframe("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
const zoomOut = new Keyframe("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
});
const zoomBigIn = new Keyframe("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
});
const zoomBigOut = new Keyframe("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
});
const zoomUpIn = new Keyframe("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
});
const zoomUpOut = new Keyframe("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
});
const zoomLeftIn = new Keyframe("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
});
const zoomLeftOut = new Keyframe("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
});
const zoomRightIn = new Keyframe("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
});
const zoomRightOut = new Keyframe("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
});
const zoomDownIn = new Keyframe("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
});
const zoomDownOut = new Keyframe("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
});
const zoomMotion = {
  zoom: {
    inKeyframes: zoomIn,
    outKeyframes: zoomOut
  },
  "zoom-big": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-big-fast": {
    inKeyframes: zoomBigIn,
    outKeyframes: zoomBigOut
  },
  "zoom-left": {
    inKeyframes: zoomLeftIn,
    outKeyframes: zoomLeftOut
  },
  "zoom-right": {
    inKeyframes: zoomRightIn,
    outKeyframes: zoomRightOut
  },
  "zoom-up": {
    inKeyframes: zoomUpIn,
    outKeyframes: zoomUpOut
  },
  "zoom-down": {
    inKeyframes: zoomDownIn,
    outKeyframes: zoomDownOut
  }
};
const initZoomMotion = (token2, motionName) => {
  const {
    antCls
  } = token2;
  const motionCls = `${antCls}-${motionName}`;
  const {
    inKeyframes,
    outKeyframes
  } = zoomMotion[motionName];
  return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
    [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: token2.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${motionCls}-leave`]: {
      animationTimingFunction: token2.motionEaseInOutCirc
    }
  }];
};
const genCollapseMotion = (token2) => ({
  [token2.componentCls]: {
    [`${token2.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
      }
    },
    [`${token2.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${token2.motionDurationMid} ${token2.motionEaseInOut},
        opacity ${token2.motionDurationMid} ${token2.motionEaseInOut} !important`
    }
  }
});
const genCollapseMotion$1 = genCollapseMotion;
function compactItemBorder(token2, parentCls, options) {
  const {
    focusElCls,
    focus,
    borderElCls
  } = options;
  const childCombinator = borderElCls ? "> *" : "";
  const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginInlineEnd: -token2.lineWidth
    },
    "&-item": Object.assign(Object.assign({
      [hoverEffects]: {
        zIndex: 2
      }
    }, focusElCls ? {
      [`&${focusElCls}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${childCombinator}`]: {
        zIndex: 0
      }
    })
  };
}
function compactItemBorderRadius(prefixCls, parentCls, options) {
  const {
    borderElCls
  } = options;
  const childCombinator = borderElCls ? `> ${borderElCls}` : "";
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
      borderRadius: 0
    },
    [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
      [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function genCompactItemStyle(token2) {
  let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: true
  };
  const {
    componentCls
  } = token2;
  const compactCls = `${componentCls}-compact`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
  };
}
function useForceUpdate() {
  const [, forceUpdate] = react.exports.useReducer((x2) => x2 + 1, 0);
  return forceUpdate;
}
const responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"];
const getResponsiveMap = (token2) => ({
  xs: `(max-width: ${token2.screenXSMax}px)`,
  sm: `(min-width: ${token2.screenSM}px)`,
  md: `(min-width: ${token2.screenMD}px)`,
  lg: `(min-width: ${token2.screenLG}px)`,
  xl: `(min-width: ${token2.screenXL}px)`,
  xxl: `(min-width: ${token2.screenXXL}px)`
});
const validateBreakpoints = (token2) => {
  const indexableToken = token2;
  const revBreakpoints = [].concat(responsiveArray).reverse();
  revBreakpoints.forEach((breakpoint, i2) => {
    const breakpointUpper = breakpoint.toUpperCase();
    const screenMin = `screen${breakpointUpper}Min`;
    const screen = `screen${breakpointUpper}`;
    if (!(indexableToken[screenMin] <= indexableToken[screen])) {
      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);
    }
    if (i2 < revBreakpoints.length - 1) {
      const screenMax = `screen${breakpointUpper}Max`;
      if (!(indexableToken[screen] <= indexableToken[screenMax])) {
        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);
      }
      const nextBreakpointUpperMin = revBreakpoints[i2 + 1].toUpperCase();
      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;
      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {
        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);
      }
    }
  });
  return token2;
};
function useResponsiveObserver() {
  const [, token2] = useToken$3();
  const responsiveMap = getResponsiveMap(validateBreakpoints(token2));
  return React.useMemo(() => {
    const subscribers = /* @__PURE__ */ new Map();
    let subUid = -1;
    let screens = {};
    return {
      matchHandlers: {},
      dispatch(pointMap) {
        screens = pointMap;
        subscribers.forEach((func) => func(screens));
        return subscribers.size >= 1;
      },
      subscribe(func) {
        if (!subscribers.size)
          this.register();
        subUid += 1;
        subscribers.set(subUid, func);
        func(screens);
        return subUid;
      },
      unsubscribe(paramToken) {
        subscribers.delete(paramToken);
        if (!subscribers.size)
          this.unregister();
      },
      unregister() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const handler = this.matchHandlers[matchMediaQuery];
          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);
        });
        subscribers.clear();
      },
      register() {
        Object.keys(responsiveMap).forEach((screen) => {
          const matchMediaQuery = responsiveMap[screen];
          const listener = (_ref) => {
            let {
              matches
            } = _ref;
            this.dispatch(Object.assign(Object.assign({}, screens), {
              [screen]: matches
            }));
          };
          const mql = window.matchMedia(matchMediaQuery);
          mql.addListener(listener);
          this.matchHandlers[matchMediaQuery] = {
            mql,
            listener
          };
          listener(mql);
        });
      },
      responsiveMap
    };
  }, [token2]);
}
function useBreakpoint() {
  let refreshOnChange = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  const screensRef = react.exports.useRef({});
  const forceUpdate = useForceUpdate();
  const responsiveObserver = useResponsiveObserver();
  react.exports.useEffect(() => {
    const token2 = responsiveObserver.subscribe((supportScreens) => {
      screensRef.current = supportScreens;
      if (refreshOnChange) {
        forceUpdate();
      }
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  return screensRef.current;
}
const SizeContext = /* @__PURE__ */ react.exports.createContext("default");
const SizeContextProvider = (_ref) => {
  let {
    children,
    size
  } = _ref;
  const originSize = react.exports.useContext(SizeContext);
  return /* @__PURE__ */ jsx(SizeContext.Provider, {
    value: size || originSize,
    children
  });
};
const genBaseStyle$3 = (token2) => {
  const {
    antCls,
    componentCls,
    iconCls,
    avatarBg,
    avatarColor,
    avatarSizeBase,
    avatarSizeLG,
    avatarSizeSM,
    avatarFontSizeBase,
    avatarFontSizeLG,
    avatarFontSizeSM,
    borderRadius,
    borderRadiusLG,
    borderRadiusSM,
    lineWidth,
    lineType
  } = token2;
  const avatarSizeStyle = (size, fontSize, radius) => ({
    width: size,
    height: size,
    lineHeight: `${size - lineWidth * 2}px`,
    borderRadius: "50%",
    [`&${componentCls}-square`]: {
      borderRadius: radius
    },
    [`${componentCls}-string`]: {
      position: "absolute",
      left: {
        _skip_check_: true,
        value: "50%"
      },
      transformOrigin: "0 center"
    },
    [`&${componentCls}-icon`]: {
      fontSize,
      [`> ${iconCls}`]: {
        margin: 0
      }
    }
  });
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      display: "inline-block",
      overflow: "hidden",
      color: avatarColor,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: avatarBg,
      border: `${lineWidth}px ${lineType} transparent`,
      [`&-image`]: {
        background: "transparent"
      },
      [`${antCls}-image-img`]: {
        display: "block"
      }
    }), avatarSizeStyle(avatarSizeBase, avatarFontSizeBase, borderRadius)), {
      [`&-lg`]: Object.assign({}, avatarSizeStyle(avatarSizeLG, avatarFontSizeLG, borderRadiusLG)),
      [`&-sm`]: Object.assign({}, avatarSizeStyle(avatarSizeSM, avatarFontSizeSM, borderRadiusSM)),
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    })
  };
};
const genGroupStyle$3 = (token2) => {
  const {
    componentCls,
    avatarGroupBorderColor,
    avatarGroupSpace
  } = token2;
  return {
    [`${componentCls}-group`]: {
      display: "inline-flex",
      [`${componentCls}`]: {
        borderColor: avatarGroupBorderColor
      },
      [`> *:not(:first-child)`]: {
        marginInlineStart: avatarGroupSpace
      }
    }
  };
};
const useStyle$l = genComponentStyleHook("Avatar", (token2) => {
  const {
    colorTextLightSolid,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    fontSize,
    fontSizeLG,
    fontSizeXL,
    fontSizeHeading3,
    marginXS,
    colorBorderBg,
    colorTextPlaceholder
  } = token2;
  const avatarToken = merge(token2, {
    avatarBg: colorTextPlaceholder,
    avatarColor: colorTextLightSolid,
    avatarSizeBase: controlHeight,
    avatarSizeLG: controlHeightLG,
    avatarSizeSM: controlHeightSM,
    avatarFontSizeBase: Math.round((fontSizeLG + fontSizeXL) / 2),
    avatarFontSizeLG: fontSizeHeading3,
    avatarFontSizeSM: fontSize,
    avatarGroupSpace: -marginXS,
    avatarGroupBorderColor: colorBorderBg
  });
  return [genBaseStyle$3(avatarToken), genGroupStyle$3(avatarToken)];
});
var __rest$L = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const InternalAvatar = (props, ref) => {
  const groupSize = react.exports.useContext(SizeContext);
  const [scale, setScale] = react.exports.useState(1);
  const [mounted, setMounted] = react.exports.useState(false);
  const [isImgExist, setIsImgExist] = react.exports.useState(true);
  const avatarNodeRef = react.exports.useRef(null);
  const avatarChildrenRef = react.exports.useRef(null);
  const avatarNodeMergeRef = composeRef(ref, avatarNodeRef);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const setScaleParam = () => {
    if (!avatarChildrenRef.current || !avatarNodeRef.current) {
      return;
    }
    const childrenWidth = avatarChildrenRef.current.offsetWidth;
    const nodeWidth = avatarNodeRef.current.offsetWidth;
    if (childrenWidth !== 0 && nodeWidth !== 0) {
      const {
        gap = 4
      } = props;
      if (gap * 2 < nodeWidth) {
        setScale(nodeWidth - gap * 2 < childrenWidth ? (nodeWidth - gap * 2) / childrenWidth : 1);
      }
    }
  };
  react.exports.useEffect(() => {
    setMounted(true);
  }, []);
  react.exports.useEffect(() => {
    setIsImgExist(true);
    setScale(1);
  }, [props.src]);
  react.exports.useEffect(() => {
    setScaleParam();
  }, [props.gap]);
  const handleImgLoadError = () => {
    const {
      onError
    } = props;
    const errorFlag = onError ? onError() : void 0;
    if (errorFlag !== false) {
      setIsImgExist(false);
    }
  };
  const {
    prefixCls: customizePrefixCls,
    shape = "circle",
    size: customSize = "default",
    src,
    srcSet,
    icon,
    className,
    rootClassName,
    alt,
    draggable,
    children,
    crossOrigin
  } = props, others = __rest$L(props, ["prefixCls", "shape", "size", "src", "srcSet", "icon", "className", "rootClassName", "alt", "draggable", "children", "crossOrigin"]);
  const size = customSize === "default" ? groupSize : customSize;
  const needResponsive = Object.keys(typeof size === "object" ? size || {} : {}).some((key) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(key));
  const screens = useBreakpoint(needResponsive);
  const responsiveSizeStyle = react.exports.useMemo(() => {
    if (typeof size !== "object") {
      return {};
    }
    const currentBreakpoint = responsiveArray.find((screen) => screens[screen]);
    const currentSize = size[currentBreakpoint];
    return currentSize ? {
      width: currentSize,
      height: currentSize,
      lineHeight: `${currentSize}px`,
      fontSize: icon ? currentSize / 2 : 18
    } : {};
  }, [screens, size]);
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$l(prefixCls);
  const sizeCls = classNames({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const hasImageElement = /* @__PURE__ */ react.exports.isValidElement(src);
  const classString = classNames(prefixCls, sizeCls, {
    [`${prefixCls}-${shape}`]: !!shape,
    [`${prefixCls}-image`]: hasImageElement || src && isImgExist,
    [`${prefixCls}-icon`]: !!icon
  }, className, rootClassName, hashId);
  const sizeStyle = typeof size === "number" ? {
    width: size,
    height: size,
    lineHeight: `${size}px`,
    fontSize: icon ? size / 2 : 18
  } : {};
  let childrenToRender;
  if (typeof src === "string" && isImgExist) {
    childrenToRender = /* @__PURE__ */ jsx("img", {
      src,
      draggable,
      srcSet,
      onError: handleImgLoadError,
      alt,
      crossOrigin
    });
  } else if (hasImageElement) {
    childrenToRender = src;
  } else if (icon) {
    childrenToRender = icon;
  } else if (mounted || scale !== 1) {
    const transformString = `scale(${scale}) translateX(-50%)`;
    const childrenStyle = {
      msTransform: transformString,
      WebkitTransform: transformString,
      transform: transformString
    };
    const sizeChildrenStyle = typeof size === "number" ? {
      lineHeight: `${size}px`
    } : {};
    childrenToRender = /* @__PURE__ */ jsx(RefResizeObserver, {
      onResize: setScaleParam,
      children: /* @__PURE__ */ jsx("span", {
        className: `${prefixCls}-string`,
        ref: avatarChildrenRef,
        style: Object.assign(Object.assign({}, sizeChildrenStyle), childrenStyle),
        children
      })
    });
  } else {
    childrenToRender = /* @__PURE__ */ jsx("span", {
      className: `${prefixCls}-string`,
      style: {
        opacity: 0
      },
      ref: avatarChildrenRef,
      children
    });
  }
  delete others.onError;
  delete others.gap;
  return wrapSSR(
    /* @__PURE__ */ jsx("span", {
      ...Object.assign({}, others, {
        style: Object.assign(Object.assign(Object.assign({}, sizeStyle), responsiveSizeStyle), others.style),
        className: classString,
        ref: avatarNodeMergeRef
      }),
      children: childrenToRender
    })
  );
};
const Avatar$2 = /* @__PURE__ */ react.exports.forwardRef(InternalAvatar);
const InternalAvatar$1 = Avatar$2;
var autoAdjustOverflow$2 = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset$2 = [0, 0];
var placements$2 = {
  left: {
    points: ["cr", "cl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  right: {
    points: ["cl", "cr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  top: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [0, -4],
    targetOffset: targetOffset$2
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: autoAdjustOverflow$2,
    offset: [4, 0],
    targetOffset: targetOffset$2
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [0, 4],
    targetOffset: targetOffset$2
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: autoAdjustOverflow$2,
    offset: [-4, 0],
    targetOffset: targetOffset$2
  }
};
function Popup(props) {
  var showArrow = props.showArrow, arrowContent = props.arrowContent, children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
  return /* @__PURE__ */ jsxs("div", {
    className: classNames("".concat(prefixCls, "-content"), className),
    style: style2,
    children: [showArrow !== false && /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-arrow"),
      children: arrowContent
    }, "arrow"), /* @__PURE__ */ jsx("div", {
      className: "".concat(prefixCls, "-inner"),
      id: id2,
      role: "tooltip",
      style: overlayInnerStyle,
      children: typeof children === "function" ? children() : children
    })]
  });
}
var _excluded$j = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
var Tooltip$2 = function Tooltip(props, ref) {
  var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion2 = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle, arrowContent = props.arrowContent, overlay = props.overlay, id2 = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties(props, _excluded$j);
  var domRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return domRef.current;
  });
  var extraProps = _objectSpread2$1({}, restProps);
  if ("visible" in props) {
    extraProps.popupVisible = props.visible;
  }
  var getPopupElement = function getPopupElement2() {
    return /* @__PURE__ */ jsx(Popup, {
      showArrow,
      arrowContent,
      prefixCls,
      id: id2,
      overlayInnerStyle,
      children: overlay
    }, "content");
  };
  var destroyTooltip = false;
  var autoDestroy = false;
  if (typeof destroyTooltipOnHide === "boolean") {
    destroyTooltip = destroyTooltipOnHide;
  } else if (destroyTooltipOnHide && _typeof$1(destroyTooltipOnHide) === "object") {
    var keepParent = destroyTooltipOnHide.keepParent;
    destroyTooltip = keepParent === true;
    autoDestroy = keepParent === false;
  }
  return /* @__PURE__ */ jsx(Trigger, {
    popupClassName: overlayClassName,
    prefixCls,
    popup: getPopupElement,
    action: trigger,
    builtinPlacements: placements$2,
    popupPlacement: placement,
    ref: domRef,
    popupAlign: align,
    getPopupContainer: getTooltipContainer,
    onPopupVisibleChange: onVisibleChange,
    afterPopupVisibleChange: afterVisibleChange,
    popupTransitionName: transitionName,
    popupAnimation: animation,
    popupMotion: motion2,
    defaultPopupVisible: defaultVisible,
    destroyPopupOnHide: destroyTooltip,
    autoDestroy,
    mouseLeaveDelay,
    popupStyle: overlayStyle,
    mouseEnterDelay,
    ...extraProps,
    children
  });
};
const Tooltip$3 = /* @__PURE__ */ react.exports.forwardRef(Tooltip$2);
const autoAdjustOverflowEnabled = {
  adjustX: 1,
  adjustY: 1
};
const autoAdjustOverflowDisabled = {
  adjustX: 0,
  adjustY: 0
};
const targetOffset$1 = [0, 0];
function getOverflowOptions(autoAdjustOverflow2) {
  if (typeof autoAdjustOverflow2 === "boolean") {
    return autoAdjustOverflow2 ? autoAdjustOverflowEnabled : autoAdjustOverflowDisabled;
  }
  return Object.assign(Object.assign({}, autoAdjustOverflowDisabled), autoAdjustOverflow2);
}
function getArrowOffset$1(type4, arrowWidth, offset2) {
  switch (type4) {
    case "top":
    case "topLeft":
    case "topRight":
      return [0, -(arrowWidth / 2 + offset2)];
    case "bottom":
    case "bottomLeft":
    case "bottomRight":
      return [0, arrowWidth / 2 + offset2];
    case "left":
    case "leftTop":
    case "leftBottom":
      return [-(arrowWidth / 2 + offset2), 0];
    case "right":
    case "rightTop":
    case "rightBottom":
      return [arrowWidth / 2 + offset2, 0];
    default:
      return [0, 0];
  }
}
function vertexCalc(point1, point2) {
  return [point1[0] + point2[0], point1[1] + point2[1]];
}
function getPlacements(config) {
  const {
    arrowWidth,
    horizontalArrowShift = 16,
    verticalArrowShift = 8,
    autoAdjustOverflow: autoAdjustOverflow2,
    arrowPointAtCenter,
    offset: offset2
  } = config;
  const halfArrowWidth = arrowWidth / 2;
  const placementMap = {
    left: {
      points: ["cr", "cl"],
      offset: [-offset2, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [offset2, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -offset2]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, offset2]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(horizontalArrowShift + halfArrowWidth), -offset2]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-offset2, -(verticalArrowShift + halfArrowWidth)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [horizontalArrowShift + halfArrowWidth, -offset2]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [offset2, -(verticalArrowShift + halfArrowWidth)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [horizontalArrowShift + halfArrowWidth, offset2]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [offset2, verticalArrowShift + halfArrowWidth]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(horizontalArrowShift + halfArrowWidth), offset2]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-offset2, verticalArrowShift + halfArrowWidth]
    }
  };
  Object.keys(placementMap).forEach((key) => {
    placementMap[key] = arrowPointAtCenter ? Object.assign(Object.assign({}, placementMap[key]), {
      offset: vertexCalc(placementMap[key].offset, getArrowOffset$1(key, arrowWidth, offset2)),
      overflow: getOverflowOptions(autoAdjustOverflow2),
      targetOffset: targetOffset$1
    }) : Object.assign(Object.assign({}, placements$2[key]), {
      offset: vertexCalc(placements$2[key].offset, getArrowOffset$1(key, arrowWidth, offset2)),
      overflow: getOverflowOptions(autoAdjustOverflow2)
    });
    placementMap[key].ignoreShake = true;
  });
  return placementMap;
}
const MAX_VERTICAL_CONTENT_RADIUS = 8;
function getArrowOffset(options) {
  const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
  const {
    contentRadius,
    limitVerticalRadius
  } = options;
  const dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
  const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset;
  return {
    dropdownArrowOffset,
    dropdownArrowOffsetVertical
  };
}
function isInject(valid, code) {
  if (!valid)
    return {};
  return code;
}
function getArrowStyle(token2, options) {
  const {
    componentCls,
    sizePopupArrow,
    borderRadiusXS,
    borderRadiusOuter,
    boxShadowPopoverArrow
  } = token2;
  const {
    colorBg,
    contentRadius = token2.borderRadiusLG,
    limitVerticalRadius,
    arrowDistance = 0,
    arrowPlacement = {
      left: true,
      right: true,
      top: true,
      bottom: true
    }
  } = options;
  const {
    dropdownArrowOffsetVertical,
    dropdownArrowOffset
  } = getArrowOffset({
    contentRadius,
    limitVerticalRadius
  });
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
      [`${componentCls}-arrow`]: [Object.assign(Object.assign({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
        "&:before": {
          background: colorBg
        }
      })]
    }, isInject(!!arrowPlacement.top, {
      [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
        bottom: arrowDistance,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      [`&-placement-topRight ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      }
    })), isInject(!!arrowPlacement.bottom, {
      [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
        top: arrowDistance,
        transform: `translateY(-100%)`
      },
      [`&-placement-bottom ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: "50%"
        },
        transform: `translateX(-50%) translateY(-100%)`
      },
      [`&-placement-bottomLeft ${componentCls}-arrow`]: {
        left: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      },
      [`&-placement-bottomRight ${componentCls}-arrow`]: {
        right: {
          _skip_check_: true,
          value: dropdownArrowOffset
        }
      }
    })), isInject(!!arrowPlacement.left, {
      [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
        right: {
          _skip_check_: true,
          value: arrowDistance
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop ${componentCls}-arrow`]: {
        top: dropdownArrowOffsetVertical
      },
      [`&-placement-leftBottom ${componentCls}-arrow`]: {
        bottom: dropdownArrowOffsetVertical
      }
    })), isInject(!!arrowPlacement.right, {
      [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
        left: {
          _skip_check_: true,
          value: arrowDistance
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right ${componentCls}-arrow`]: {
        top: {
          _skip_check_: true,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop ${componentCls}-arrow`]: {
        top: dropdownArrowOffsetVertical
      },
      [`&-placement-rightBottom ${componentCls}-arrow`]: {
        bottom: dropdownArrowOffsetVertical
      }
    }))
  };
}
const genTooltipStyle = (token2) => {
  const {
    componentCls,
    tooltipMaxWidth,
    tooltipColor,
    tooltipBg,
    tooltipBorderRadius,
    zIndexPopup,
    controlHeight,
    boxShadowSecondary,
    paddingSM,
    paddingXS,
    tooltipRadiusOuter
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        zIndex: zIndexPopup,
        display: "block",
        "&": [{
          width: "max-content"
        }, {
          width: "intrinsic"
        }],
        maxWidth: tooltipMaxWidth,
        visibility: "visible",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": tooltipBg,
        [`${componentCls}-inner`]: {
          minWidth: controlHeight,
          minHeight: controlHeight,
          padding: `${paddingSM / 2}px ${paddingXS}px`,
          color: tooltipColor,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: tooltipBg,
          borderRadius: tooltipBorderRadius,
          boxShadow: boxShadowSecondary
        },
        [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
          [`${componentCls}-inner`]: {
            borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
          }
        },
        [`${componentCls}-content`]: {
          position: "relative"
        }
      }), genPresetColor(token2, (colorKey, _ref) => {
        let {
          darkColor
        } = _ref;
        return {
          [`&${componentCls}-${colorKey}`]: {
            [`${componentCls}-inner`]: {
              backgroundColor: darkColor
            },
            [`${componentCls}-arrow`]: {
              "--antd-arrow-background-color": darkColor
            }
          }
        };
      })), {
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    getArrowStyle(merge(token2, {
      borderRadiusOuter: tooltipRadiusOuter
    }), {
      colorBg: "var(--antd-arrow-background-color)",
      contentRadius: tooltipBorderRadius,
      limitVerticalRadius: true
    }),
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none"
      }
    }
  ];
};
const useStyle$k = (prefixCls, injectStyle) => {
  const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
    if (injectStyle === false) {
      return [];
    }
    const {
      borderRadius,
      colorTextLightSolid,
      colorBgDefault,
      borderRadiusOuter
    } = token2;
    const TooltipToken = merge(token2, {
      tooltipMaxWidth: 250,
      tooltipColor: colorTextLightSolid,
      tooltipBorderRadius: borderRadius,
      tooltipBg: colorBgDefault,
      tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
    });
    return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
  }, (_ref2) => {
    let {
      zIndexPopupBase,
      colorBgSpotlight
    } = _ref2;
    return {
      zIndexPopup: zIndexPopupBase + 70,
      colorBgDefault: colorBgSpotlight
    };
  });
  return useOriginHook(prefixCls);
};
const inverseColors = PresetColors.map((color) => `${color}-inverse`);
function isPresetColor(color) {
  let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  if (includeInverse) {
    return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
  }
  return PresetColors.includes(color);
}
function parseColor(prefixCls, color) {
  const isInternalColor = isPresetColor(color);
  const className = classNames({
    [`${prefixCls}-${color}`]: color && isInternalColor
  });
  const overlayStyle = {};
  const arrowStyle = {};
  if (color && !isInternalColor) {
    overlayStyle.background = color;
    arrowStyle["--antd-arrow-background-color"] = color;
  }
  return {
    className,
    overlayStyle,
    arrowStyle
  };
}
function PurePanel$7(props) {
  const {
    prefixCls: customizePrefixCls,
    className,
    placement = "top",
    title,
    color,
    overlayInnerStyle
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$k(prefixCls, true);
  const colorInfo = parseColor(prefixCls, color);
  const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
  const arrowContentStyle = colorInfo.arrowStyle;
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className),
      style: arrowContentStyle,
      children: /* @__PURE__ */ jsx(Popup, {
        ...Object.assign({}, props, {
          className: hashId,
          prefixCls,
          overlayInnerStyle: formattedOverlayInnerStyle
        }),
        children: title
      })
    })
  );
}
const getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
const getSolidColor = (baseColor, brightness) => {
  const instance = new TinyColor(baseColor);
  return instance.lighten(brightness).toHexString();
};
const generateColorPalettes = (baseColor) => {
  const colors = generate$3(baseColor, {
    theme: "dark"
  });
  return {
    1: colors[0],
    2: colors[1],
    3: colors[2],
    4: colors[3],
    5: colors[6],
    6: colors[5],
    7: colors[4],
    8: colors[6],
    9: colors[5],
    10: colors[4]
  };
};
const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
  const colorBgBase = bgBaseColor || "#000";
  const colorTextBase = textBaseColor || "#fff";
  return {
    colorBgBase,
    colorTextBase,
    colorText: getAlphaColor(colorTextBase, 0.85),
    colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
    colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
    colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
    colorFill: getAlphaColor(colorTextBase, 0.18),
    colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
    colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
    colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
    colorBgElevated: getSolidColor(colorBgBase, 12),
    colorBgContainer: getSolidColor(colorBgBase, 8),
    colorBgLayout: getSolidColor(colorBgBase, 0),
    colorBgSpotlight: getSolidColor(colorBgBase, 26),
    colorBorder: getSolidColor(colorBgBase, 26),
    colorBorderSecondary: getSolidColor(colorBgBase, 19)
  };
};
const derivative$1 = (token2, mapToken) => {
  const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
    const colors = generate$3(token2[colorKey], {
      theme: "dark"
    });
    return new Array(10).fill(1).reduce((prev2, _2, i2) => {
      prev2[`${colorKey}-${i2 + 1}`] = colors[i2];
      return prev2;
    }, {});
  }).reduce((prev2, cur) => {
    prev2 = Object.assign(Object.assign({}, prev2), cur);
    return prev2;
  }, {});
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
  return Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), genColorMapToken(token2, {
    generateColorPalettes,
    generateNeutralColorPalettes
  }));
};
const darkAlgorithm = derivative$1;
function genSizeMapToken(token2) {
  const {
    sizeUnit,
    sizeStep
  } = token2;
  const compactSizeStep = sizeStep - 2;
  return {
    sizeXXL: sizeUnit * (compactSizeStep + 10),
    sizeXL: sizeUnit * (compactSizeStep + 6),
    sizeLG: sizeUnit * (compactSizeStep + 2),
    sizeMD: sizeUnit * (compactSizeStep + 2),
    sizeMS: sizeUnit * (compactSizeStep + 1),
    size: sizeUnit * compactSizeStep,
    sizeSM: sizeUnit * compactSizeStep,
    sizeXS: sizeUnit * (compactSizeStep - 1),
    sizeXXS: sizeUnit * (compactSizeStep - 1)
  };
}
const derivative = (token2, mapToken) => {
  const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
  const fontSize = mergedMapToken.fontSizeSM;
  const controlHeight = mergedMapToken.controlHeight - 4;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token2)), genFontMapToken$1(fontSize)), {
    controlHeight
  }), genControlHeight$1(Object.assign(Object.assign({}, mergedMapToken), {
    controlHeight
  })));
};
const compactAlgorithm = derivative;
function useToken$2() {
  const [theme2, token2, hashId] = useToken$3();
  return {
    theme: theme2,
    token: token2,
    hashId
  };
}
const theme = {
  defaultConfig,
  defaultSeed: defaultConfig.token,
  useToken: useToken$2,
  defaultAlgorithm: derivative$2,
  darkAlgorithm,
  compactAlgorithm
};
var __rest$K = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const {
  useToken: useToken$1
} = theme;
const splitObject = (obj, keys2) => {
  const picked = {};
  const omitted = Object.assign({}, obj);
  keys2.forEach((key) => {
    if (obj && key in obj) {
      picked[key] = obj[key];
      delete omitted[key];
    }
  });
  return {
    picked,
    omitted
  };
};
function getDisabledCompatibleChildren(element, prefixCls) {
  const elementType = element.type;
  if ((elementType.__ANT_BUTTON === true || element.type === "button") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
    const {
      picked,
      omitted
    } = splitObject(element.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
    const spanStyle = Object.assign(Object.assign({
      display: "inline-block"
    }, picked), {
      cursor: "not-allowed",
      width: element.props.block ? "100%" : void 0
    });
    const buttonStyle = Object.assign(Object.assign({}, omitted), {
      pointerEvents: "none"
    });
    const child = cloneElement(element, {
      style: buttonStyle,
      className: null
    });
    return /* @__PURE__ */ jsx("span", {
      style: spanStyle,
      className: classNames(element.props.className, `${prefixCls}-disabled-compatible-wrapper`),
      children: child
    });
  }
  return element;
}
const Tooltip2 = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    openClassName,
    getTooltipContainer,
    overlayClassName,
    color,
    overlayInnerStyle,
    children,
    afterOpenChange,
    afterVisibleChange,
    arrow = true
  } = props;
  const mergedShowArrow = !!arrow;
  const {
    token: token2
  } = useToken$1();
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const [open2, setOpen] = useMergedState(false, {
    value: (_a = props.open) !== null && _a !== void 0 ? _a : props.visible,
    defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
  });
  const isNoTitle = () => {
    const {
      title,
      overlay
    } = props;
    return !title && !overlay && title !== 0;
  };
  const onOpenChange = (vis) => {
    var _a2, _b2;
    setOpen(isNoTitle() ? false : vis);
    if (!isNoTitle()) {
      (_a2 = props.onOpenChange) === null || _a2 === void 0 ? void 0 : _a2.call(props, vis);
      (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
    }
  };
  const getTooltipPlacements = () => {
    var _a2;
    const {
      builtinPlacements,
      arrowPointAtCenter = false,
      autoAdjustOverflow: autoAdjustOverflow2 = true
    } = props;
    const mergedArrowPointAtCenter = (_a2 = typeof arrow !== "boolean" && (arrow === null || arrow === void 0 ? void 0 : arrow.arrowPointAtCenter)) !== null && _a2 !== void 0 ? _a2 : arrowPointAtCenter;
    return builtinPlacements || getPlacements({
      arrowPointAtCenter: mergedArrowPointAtCenter,
      autoAdjustOverflow: autoAdjustOverflow2,
      arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
      offset: token2.marginXXS
    });
  };
  const onPopupAlign = (domNode, align) => {
    const placements2 = getTooltipPlacements();
    const placement2 = Object.keys(placements2).find((key) => {
      var _a2, _b2;
      return placements2[key].points[0] === ((_a2 = align.points) === null || _a2 === void 0 ? void 0 : _a2[0]) && placements2[key].points[1] === ((_b2 = align.points) === null || _b2 === void 0 ? void 0 : _b2[1]);
    });
    if (placement2) {
      const rect = domNode.getBoundingClientRect();
      const transformOrigin = {
        top: "50%",
        left: "50%"
      };
      if (/top|Bottom/.test(placement2)) {
        transformOrigin.top = `${rect.height - align.offset[1]}px`;
      } else if (/Top|bottom/.test(placement2)) {
        transformOrigin.top = `${-align.offset[1]}px`;
      }
      if (/left|Right/.test(placement2)) {
        transformOrigin.left = `${rect.width - align.offset[0]}px`;
      } else if (/right|Left/.test(placement2)) {
        transformOrigin.left = `${-align.offset[0]}px`;
      }
      domNode.style.transformOrigin = `${transformOrigin.left} ${transformOrigin.top}`;
    }
  };
  const getOverlay2 = () => {
    const {
      title,
      overlay
    } = props;
    if (title === 0) {
      return title;
    }
    return overlay || title || "";
  };
  const {
    getPopupContainer,
    placement = "top",
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    overlayStyle,
    rootClassName
  } = props, otherProps = __rest$K(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
  const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const injectFromPopover = props["data-popover-inject"];
  let tempOpen = open2;
  if (!("open" in props) && !("visible" in props) && isNoTitle()) {
    tempOpen = false;
  }
  const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ jsx("span", {
    children
  }), prefixCls);
  const childProps = child.props;
  const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, {
    [openClassName || `${prefixCls}-open`]: true
  }) : childProps.className;
  const [wrapSSR, hashId] = useStyle$k(prefixCls, !injectFromPopover);
  const colorInfo = parseColor(prefixCls, color);
  const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
  const arrowContentStyle = colorInfo.arrowStyle;
  const customOverlayClassName = classNames(overlayClassName, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, colorInfo.className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsx(Tooltip$3, {
      ...Object.assign({}, otherProps, {
        showArrow: mergedShowArrow,
        placement,
        mouseEnterDelay,
        mouseLeaveDelay,
        prefixCls,
        overlayClassName: customOverlayClassName,
        overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
        getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
        ref,
        builtinPlacements: getTooltipPlacements(),
        overlay: getOverlay2(),
        visible: tempOpen,
        onVisibleChange: onOpenChange,
        afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
        onPopupAlign,
        overlayInnerStyle: formattedOverlayInnerStyle,
        arrowContent: /* @__PURE__ */ jsx("span", {
          className: `${prefixCls}-arrow-content`
        }),
        motion: {
          motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
          motionDeadline: 1e3
        }
      }),
      children: tempOpen ? cloneElement(child, {
        className: childCls
      }) : child
    })
  );
});
Tooltip2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$7;
const Tooltip$1 = Tooltip2;
const getRenderPropValue = (propValue) => {
  if (!propValue) {
    return null;
  }
  if (typeof propValue === "function") {
    return propValue();
  }
  return propValue;
};
const genBaseStyle$2 = (token2) => {
  const {
    componentCls,
    popoverBg,
    popoverColor,
    width,
    fontWeightStrong,
    popoverPadding,
    boxShadowSecondary,
    colorTextHeading,
    borderRadiusLG: borderRadius,
    zIndexPopup,
    marginXS,
    colorBgElevated
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: 0,
        left: {
          _skip_check_: true,
          value: 0
        },
        zIndex: zIndexPopup,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        "--antd-arrow-background-color": colorBgElevated,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${componentCls}-content`]: {
          position: "relative"
        },
        [`${componentCls}-inner`]: {
          backgroundColor: popoverBg,
          backgroundClip: "padding-box",
          borderRadius,
          boxShadow: boxShadowSecondary,
          padding: popoverPadding
        },
        [`${componentCls}-title`]: {
          minWidth: width,
          marginBottom: marginXS,
          color: colorTextHeading,
          fontWeight: fontWeightStrong
        },
        [`${componentCls}-inner-content`]: {
          color: popoverColor
        }
      })
    },
    getArrowStyle(token2, {
      colorBg: "var(--antd-arrow-background-color)"
    }),
    {
      [`${componentCls}-pure`]: {
        position: "relative",
        maxWidth: "none",
        [`${componentCls}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
};
const genColorStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: PresetColors.map((colorKey) => {
      const lightColor = token2[`${colorKey}-6`];
      return {
        [`&${componentCls}-${colorKey}`]: {
          "--antd-arrow-background-color": lightColor,
          [`${componentCls}-inner`]: {
            backgroundColor: lightColor
          },
          [`${componentCls}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
};
const genWireframeStyle = (token2) => {
  const {
    componentCls,
    lineWidth,
    lineType,
    colorSplit,
    paddingSM,
    controlHeight,
    fontSize,
    lineHeight,
    padding
  } = token2;
  const titlePaddingBlockDist = controlHeight - Math.round(fontSize * lineHeight);
  const popoverTitlePaddingBlockTop = titlePaddingBlockDist / 2;
  const popoverTitlePaddingBlockBottom = titlePaddingBlockDist / 2 - lineWidth;
  const popoverPaddingHorizontal = padding;
  return {
    [componentCls]: {
      [`${componentCls}-inner`]: {
        padding: 0
      },
      [`${componentCls}-title`]: {
        margin: 0,
        padding: `${popoverTitlePaddingBlockTop}px ${popoverPaddingHorizontal}px ${popoverTitlePaddingBlockBottom}px`,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      [`${componentCls}-inner-content`]: {
        padding: `${paddingSM}px ${popoverPaddingHorizontal}px`
      }
    }
  };
};
const useStyle$j = genComponentStyleHook("Popover", (token2) => {
  const {
    colorBgElevated,
    colorText,
    wireframe
  } = token2;
  const popoverToken = merge(token2, {
    popoverBg: colorBgElevated,
    popoverColor: colorText,
    popoverPadding: 12
  });
  return [genBaseStyle$2(popoverToken), genColorStyle(popoverToken), wireframe && genWireframeStyle(popoverToken), initZoomMotion(popoverToken, "zoom-big")];
}, (_ref) => {
  let {
    zIndexPopupBase
  } = _ref;
  return {
    zIndexPopup: zIndexPopupBase + 30,
    width: 177
  };
});
var __rest$J = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const getOverlay = (prefixCls, title, content) => {
  if (!title && !content)
    return void 0;
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [title && /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-title`,
      children: getRenderPropValue(title)
    }), /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-inner-content`,
      children: getRenderPropValue(content)
    })]
  });
};
function RawPurePanel(props) {
  const {
    hashId,
    prefixCls,
    className,
    style: style2,
    placement = "top",
    title,
    content,
    children
  } = props;
  return /* @__PURE__ */ jsx("div", {
    className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className),
    style: style2,
    children: /* @__PURE__ */ jsx(Popup, {
      ...Object.assign({}, props, {
        className: hashId,
        prefixCls
      }),
      children: children || getOverlay(prefixCls, title, content)
    })
  });
}
function PurePanel$6(props) {
  const {
    prefixCls: customizePrefixCls
  } = props, restProps = __rest$J(props, ["prefixCls"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$j(prefixCls);
  return wrapSSR(
    /* @__PURE__ */ jsx(RawPurePanel, {
      ...Object.assign({}, restProps, {
        prefixCls,
        hashId
      })
    })
  );
}
var __rest$I = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Overlay = (_ref) => {
  let {
    title,
    content,
    prefixCls
  } = _ref;
  if (!title && !content) {
    return null;
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [title && /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-title`,
      children: getRenderPropValue(title)
    }), /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-inner-content`,
      children: getRenderPropValue(content)
    })]
  });
};
const Popover = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  var _a, _b;
  const {
    prefixCls: customizePrefixCls,
    title,
    content,
    overlayClassName,
    placement = "top",
    trigger = "hover",
    mouseEnterDelay = 0.1,
    mouseLeaveDelay = 0.1,
    overlayStyle = {},
    arrowPointAtCenter,
    arrow
  } = props, otherProps = __rest$I(props, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "arrowPointAtCenter", "arrow"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("popover", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$j(prefixCls);
  const rootPrefixCls = getPrefixCls();
  const overlayCls = classNames(overlayClassName, hashId);
  const mergedArrowPointAtCenter = (_b = (_a = typeof arrow !== "boolean" && (arrow === null || arrow === void 0 ? void 0 : arrow.arrowPointAtCenter)) !== null && _a !== void 0 ? _a : arrowPointAtCenter) !== null && _b !== void 0 ? _b : false;
  const mergedArrow = arrow !== null && arrow !== void 0 ? arrow : {
    arrowPointAtCenter: mergedArrowPointAtCenter
  };
  return wrapSSR(
    /* @__PURE__ */ jsx(Tooltip$1, {
      ...Object.assign({
        placement,
        arrow: mergedArrow,
        trigger,
        mouseEnterDelay,
        mouseLeaveDelay,
        overlayStyle
      }, otherProps, {
        prefixCls,
        overlayClassName: overlayCls,
        ref,
        overlay: /* @__PURE__ */ jsx(Overlay, {
          prefixCls,
          title,
          content
        }),
        transitionName: getTransitionName(rootPrefixCls, "zoom-big", otherProps.transitionName),
        "data-popover-inject": true
      })
    })
  );
});
Popover._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$6;
const Popover$1 = Popover;
const Group$4 = (props) => {
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    maxCount,
    maxStyle,
    size
  } = props;
  const prefixCls = getPrefixCls("avatar", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const [wrapSSR, hashId] = useStyle$l(prefixCls);
  const cls = classNames(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  const {
    children,
    maxPopoverPlacement = "top",
    maxPopoverTrigger = "hover"
  } = props;
  const childrenWithProps = toArray$3(children).map((child, index2) => cloneElement(child, {
    key: `avatar-key-${index2}`
  }));
  const numOfChildren = childrenWithProps.length;
  if (maxCount && maxCount < numOfChildren) {
    const childrenShow = childrenWithProps.slice(0, maxCount);
    const childrenHidden = childrenWithProps.slice(maxCount, numOfChildren);
    childrenShow.push(
      /* @__PURE__ */ jsx(Popover$1, {
        content: childrenHidden,
        trigger: maxPopoverTrigger,
        placement: maxPopoverPlacement,
        overlayClassName: `${groupPrefixCls}-popover`,
        children: /* @__PURE__ */ jsx(InternalAvatar$1, {
          style: maxStyle,
          children: `+${numOfChildren - maxCount}`
        })
      }, "avatar-popover-key")
    );
    return wrapSSR(
      /* @__PURE__ */ jsx(SizeContextProvider, {
        size,
        children: /* @__PURE__ */ jsx("div", {
          className: cls,
          style: props.style,
          children: childrenShow
        })
      })
    );
  }
  return wrapSSR(
    /* @__PURE__ */ jsx(SizeContextProvider, {
      size,
      children: /* @__PURE__ */ jsx("div", {
        className: cls,
        style: props.style,
        children: childrenWithProps
      })
    })
  );
};
const Group$5 = Group$4;
const Avatar = InternalAvatar$1;
Avatar.Group = Group$5;
const Avatar$1 = Avatar;
const initFloatButtonGroupMotion = (token2) => {
  const {
    componentCls,
    floatButtonSize,
    motionDurationSlow,
    motionEaseInOutCirc
  } = token2;
  const groupPrefixCls = `${componentCls}-group`;
  const moveDownIn2 = new Keyframe("antFloatButtonMoveDownIn", {
    "0%": {
      transform: `translate3d(0, ${floatButtonSize}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  });
  const moveDownOut2 = new Keyframe("antFloatButtonMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: `translate3d(0, ${floatButtonSize}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  return [{
    [`${groupPrefixCls}-wrap`]: Object.assign({}, initMotion(`${groupPrefixCls}-wrap`, moveDownIn2, moveDownOut2, motionDurationSlow, true))
  }, {
    [`${groupPrefixCls}-wrap`]: {
      [`
          &${groupPrefixCls}-wrap-enter,
          &${groupPrefixCls}-wrap-appear
        `]: {
        opacity: 0,
        animationTimingFunction: motionEaseInOutCirc
      },
      [`&${groupPrefixCls}-wrap-leave`]: {
        animationTimingFunction: motionEaseInOutCirc
      }
    }
  }];
};
const floatButtonGroupStyle = (token2) => {
  const {
    componentCls,
    floatButtonSize,
    margin,
    borderRadiusLG
  } = token2;
  const groupPrefixCls = `${componentCls}-group`;
  return {
    [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      zIndex: 99,
      display: "block",
      border: "none",
      position: "fixed",
      width: floatButtonSize,
      height: "auto",
      boxShadow: "none",
      minHeight: floatButtonSize,
      insetInlineEnd: token2.floatButtonInsetInlineEnd,
      insetBlockEnd: token2.floatButtonInsetBlockEnd,
      borderRadius: borderRadiusLG,
      [`${groupPrefixCls}-wrap`]: {
        zIndex: -1,
        display: "block",
        position: "relative",
        marginBottom: margin
      },
      [`&${groupPrefixCls}-rtl`]: {
        direction: "rtl"
      },
      [componentCls]: {
        position: "static"
      }
    }),
    [`${groupPrefixCls}-circle`]: {
      [`${componentCls}-circle:not(:last-child)`]: {
        marginBottom: token2.margin,
        [`${componentCls}-body`]: {
          width: floatButtonSize,
          height: floatButtonSize
        }
      }
    },
    [`${groupPrefixCls}-square`]: {
      [`${componentCls}-square`]: {
        borderRadius: 0,
        padding: 0,
        "&:first-child": {
          borderStartStartRadius: borderRadiusLG,
          borderStartEndRadius: borderRadiusLG
        },
        "&:last-child": {
          borderEndStartRadius: borderRadiusLG,
          borderEndEndRadius: borderRadiusLG
        },
        "&:not(:last-child)": {
          borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
        }
      },
      [`${groupPrefixCls}-wrap`]: {
        display: "block",
        borderRadius: borderRadiusLG,
        boxShadow: token2.boxShadowSecondary,
        overflow: "hidden",
        [`${componentCls}-square`]: {
          boxShadow: "none",
          marginTop: 0,
          borderRadius: 0,
          padding: token2.paddingXXS,
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderStartEndRadius: borderRadiusLG
          },
          "&:last-child": {
            borderEndStartRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          },
          "&:not(:last-child)": {
            borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
          },
          [`${componentCls}-body`]: {
            width: floatButtonSize - token2.paddingXXS * 2,
            height: floatButtonSize - token2.paddingXXS * 2
          }
        }
      }
    },
    [`${groupPrefixCls}-circle-shadow`]: {
      boxShadow: "none"
    },
    [`${groupPrefixCls}-square-shadow`]: {
      boxShadow: token2.boxShadowSecondary,
      [`${componentCls}-square`]: {
        boxShadow: "none",
        padding: token2.paddingXXS,
        [`${componentCls}-body`]: {
          width: floatButtonSize - token2.paddingXXS * 2,
          height: floatButtonSize - token2.paddingXXS * 2
        }
      }
    }
  };
};
const sharedFloatButtonStyle = (token2) => {
  const {
    componentCls,
    floatButtonIconSize,
    floatButtonSize,
    borderRadiusLG
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      border: "none",
      position: "fixed",
      cursor: "pointer",
      overflow: "hidden",
      zIndex: 99,
      display: "block",
      justifyContent: "center",
      alignItems: "center",
      width: floatButtonSize,
      height: floatButtonSize,
      insetInlineEnd: token2.floatButtonInsetInlineEnd,
      insetBlockEnd: token2.floatButtonInsetBlockEnd,
      boxShadow: token2.boxShadowSecondary,
      "&-pure": {
        position: "relative",
        inset: "auto"
      },
      "&:empty": {
        display: "none"
      },
      [`${componentCls}-body`]: {
        width: "100%",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        transition: `all ${token2.motionDurationMid}`,
        [`${componentCls}-content`]: {
          overflow: "hidden",
          textAlign: "center",
          minHeight: floatButtonSize,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          padding: `2px 4px`,
          [`${componentCls}-icon`]: {
            textAlign: "center",
            margin: "auto",
            width: floatButtonIconSize,
            fontSize: floatButtonIconSize,
            lineHeight: 1
          }
        }
      }
    }),
    [`${componentCls}-circle`]: {
      height: floatButtonSize,
      borderRadius: "50%",
      [`${componentCls}-body`]: {
        borderRadius: "50%"
      }
    },
    [`${componentCls}-square`]: {
      height: "auto",
      minHeight: floatButtonSize,
      borderRadius: borderRadiusLG,
      [`${componentCls}-body`]: {
        height: "auto",
        borderRadius: token2.borderRadiusSM
      }
    },
    [`${componentCls}-default`]: {
      backgroundColor: token2.floatButtonBackgroundColor,
      transition: `background-color ${token2.motionDurationMid}`,
      [`${componentCls}-body`]: {
        backgroundColor: token2.floatButtonBackgroundColor,
        transition: `background-color ${token2.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token2.colorFillContent
        },
        [`${componentCls}-content`]: {
          [`${componentCls}-icon`]: {
            color: token2.colorText
          },
          [`${componentCls}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${token2.fontSizeLG}px`,
            color: token2.colorText,
            fontSize: token2.fontSizeSM
          }
        }
      }
    },
    [`${componentCls}-primary`]: {
      backgroundColor: token2.colorPrimary,
      [`${componentCls}-body`]: {
        backgroundColor: token2.colorPrimary,
        transition: `background-color ${token2.motionDurationMid}`,
        "&:hover": {
          backgroundColor: token2.colorPrimaryHover
        },
        [`${componentCls}-content`]: {
          [`${componentCls}-icon`]: {
            color: token2.colorTextLightSolid
          },
          [`${componentCls}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${token2.fontSizeLG}px`,
            color: token2.colorTextLightSolid,
            fontSize: token2.fontSizeSM
          }
        }
      }
    }
  };
};
const useStyle$i = genComponentStyleHook("FloatButton", (token2) => {
  const {
    colorTextLightSolid,
    colorBgElevated,
    controlHeightLG,
    marginXXL,
    marginLG,
    fontSize,
    fontSizeIcon,
    controlItemBgHover
  } = token2;
  const floatButtonToken = merge(token2, {
    floatButtonBackgroundColor: colorBgElevated,
    floatButtonColor: colorTextLightSolid,
    floatButtonHoverBackgroundColor: controlItemBgHover,
    floatButtonFontSize: fontSize,
    floatButtonIconSize: fontSizeIcon * 1.5,
    floatButtonSize: controlHeightLG,
    floatButtonInsetBlockEnd: marginXXL,
    floatButtonInsetInlineEnd: marginLG
  });
  return [floatButtonGroupStyle(floatButtonToken), sharedFloatButtonStyle(floatButtonToken), initFadeMotion(token2), initFloatButtonGroupMotion(floatButtonToken)];
});
var FileTextOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, "name": "file-text", "theme": "outlined" };
const FileTextOutlinedSvg = FileTextOutlined$2;
var FileTextOutlined = function FileTextOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: FileTextOutlinedSvg
    })
  });
};
FileTextOutlined.displayName = "FileTextOutlined";
const FileTextOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FileTextOutlined);
const FloatButtonContent = (props) => {
  const {
    icon,
    description,
    prefixCls,
    className
  } = props;
  const defaultElement = /* @__PURE__ */ jsx("div", {
    className: `${prefixCls}-icon`,
    children: /* @__PURE__ */ jsx(FileTextOutlined$1, {})
  });
  return /* @__PURE__ */ jsx("div", {
    onClick: props.onClick,
    onFocus: props.onFocus,
    onMouseEnter: props.onMouseEnter,
    onMouseLeave: props.onMouseLeave,
    className: classNames(className, `${prefixCls}-content`),
    children: icon || description ? /* @__PURE__ */ jsxs(Fragment, {
      children: [icon && /* @__PURE__ */ jsx("div", {
        className: `${prefixCls}-icon`,
        children: icon
      }), description && /* @__PURE__ */ jsx("div", {
        className: `${prefixCls}-description`,
        children: description
      })]
    }) : defaultElement
  });
};
const Content$2 = /* @__PURE__ */ react.exports.memo(FloatButtonContent);
const FloatButtonGroupContext = /* @__PURE__ */ React.createContext(void 0);
const {
  Provider: FloatButtonGroupProvider
} = FloatButtonGroupContext;
const FloatButtonGroupContext$1 = FloatButtonGroupContext;
var __rest$H = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const floatButtonPrefixCls = "float-btn";
const FloatButton = (props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    type: type4 = "default",
    shape = "circle",
    icon,
    description,
    tooltip
  } = props, restProps = __rest$H(props, ["prefixCls", "className", "rootClassName", "type", "shape", "icon", "description", "tooltip"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const groupShape = react.exports.useContext(FloatButtonGroupContext$1);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$i(prefixCls);
  const mergeShape = groupShape || shape;
  const classString = classNames(hashId, prefixCls, className, rootClassName, `${prefixCls}-${type4}`, `${prefixCls}-${mergeShape}`, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  const contentProps = react.exports.useMemo(() => ({
    prefixCls,
    description,
    icon,
    type: type4
  }), [prefixCls, description, icon, type4]);
  const buttonNode = /* @__PURE__ */ jsx(Tooltip$1, {
    title: tooltip,
    placement: "left",
    children: /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-body`,
      children: /* @__PURE__ */ jsx(Content$2, {
        ...Object.assign({}, contentProps)
      })
    })
  });
  return wrapSSR(props.href ? /* @__PURE__ */ jsx("a", {
    ...Object.assign({
      ref
    }, restProps, {
      className: classString
    }),
    children: buttonNode
  }) : /* @__PURE__ */ jsx("button", {
    ...Object.assign({
      ref
    }, restProps, {
      className: classString,
      type: "button"
    }),
    children: buttonNode
  }));
};
const ForwardFloatButton = /* @__PURE__ */ React.forwardRef(FloatButton);
const FloatButton$1 = ForwardFloatButton;
const FloatButtonGroup = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    shape = "circle",
    type: type4 = "default",
    icon = /* @__PURE__ */ jsx(FileTextOutlined$1, {}),
    closeIcon = /* @__PURE__ */ jsx(CloseOutlined$1, {}),
    description,
    trigger,
    children,
    onOpenChange
  } = props;
  const {
    direction,
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$i(prefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const groupCls = classNames(groupPrefixCls, hashId, className, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl",
    [`${groupPrefixCls}-${shape}`]: shape,
    [`${groupPrefixCls}-${shape}-shadow`]: !trigger
  });
  const wrapperCls = classNames(hashId, `${groupPrefixCls}-wrap`);
  const [open2, setOpen] = useMergedState(false, {
    value: props.open
  });
  const floatButtonGroupRef = react.exports.useRef(null);
  const floatButtonRef = react.exports.useRef(null);
  const hoverAction = react.exports.useMemo(() => {
    const hoverTypeAction = {
      onMouseEnter() {
        setOpen(true);
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(true);
      },
      onMouseLeave() {
        setOpen(false);
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false);
      }
    };
    return trigger === "hover" ? hoverTypeAction : {};
  }, [trigger]);
  const handleOpenChange = () => {
    setOpen((prevState) => {
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!prevState);
      return !prevState;
    });
  };
  const onClick = react.exports.useCallback((e2) => {
    var _a, _b;
    if ((_a = floatButtonGroupRef.current) === null || _a === void 0 ? void 0 : _a.contains(e2.target)) {
      if ((_b = floatButtonRef.current) === null || _b === void 0 ? void 0 : _b.contains(e2.target)) {
        handleOpenChange();
      }
      return;
    }
    setOpen(false);
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false);
  }, [trigger]);
  react.exports.useEffect(() => {
    if (trigger === "click") {
      document.addEventListener("click", onClick);
      return () => {
        document.removeEventListener("click", onClick);
      };
    }
  }, [trigger]);
  return wrapSSR(
    /* @__PURE__ */ jsx(FloatButtonGroupProvider, {
      value: shape,
      children: /* @__PURE__ */ jsx("div", {
        ...Object.assign({
          ref: floatButtonGroupRef,
          className: groupCls,
          style: style2
        }, hoverAction),
        children: trigger && ["click", "hover"].includes(trigger) ? /* @__PURE__ */ jsxs(Fragment, {
          children: [/* @__PURE__ */ jsx(CSSMotion, {
            visible: open2,
            motionName: `${groupPrefixCls}-wrap`,
            children: (_ref) => {
              let {
                className: motionClassName
              } = _ref;
              return /* @__PURE__ */ jsx("div", {
                className: classNames(motionClassName, wrapperCls),
                children
              });
            }
          }), /* @__PURE__ */ jsx(FloatButton$1, {
            ref: floatButtonRef,
            type: type4,
            shape,
            icon: open2 ? closeIcon : icon,
            description
          })]
        }) : children
      })
    })
  );
};
const FloatButtonGroup$1 = /* @__PURE__ */ react.exports.memo(FloatButtonGroup);
var VerticalAlignTopOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, "name": "vertical-align-top", "theme": "outlined" };
const VerticalAlignTopOutlinedSvg = VerticalAlignTopOutlined$2;
var VerticalAlignTopOutlined = function VerticalAlignTopOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: VerticalAlignTopOutlinedSvg
    })
  });
};
VerticalAlignTopOutlined.displayName = "VerticalAlignTopOutlined";
const VerticalAlignTopOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(VerticalAlignTopOutlined);
var __rest$G = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const BackTop = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    type: type4 = "default",
    shape = "circle",
    visibilityHeight = 400,
    icon = /* @__PURE__ */ jsx(VerticalAlignTopOutlined$1, {}),
    target,
    onClick,
    duration = 450
  } = props, restProps = __rest$G(props, ["prefixCls", "className", "type", "shape", "visibilityHeight", "icon", "target", "onClick", "duration"]);
  const [visible, setVisible] = react.exports.useState(visibilityHeight === 0);
  const ref = react.exports.useRef(null);
  const getDefaultTarget = () => ref.current && ref.current.ownerDocument ? ref.current.ownerDocument : window;
  const handleScroll = throttleByAnimationFrame((e2) => {
    const scrollTop = getScroll$1(e2.target, true);
    setVisible(scrollTop >= visibilityHeight);
  });
  react.exports.useEffect(() => {
    const getTarget = target || getDefaultTarget;
    const container = getTarget();
    handleScroll({
      target: container
    });
    container === null || container === void 0 ? void 0 : container.addEventListener("scroll", handleScroll);
    return () => {
      handleScroll.cancel();
      container === null || container === void 0 ? void 0 : container.removeEventListener("scroll", handleScroll);
    };
  }, [target]);
  const scrollToTop = (e2) => {
    scrollTo(0, {
      getContainer: target || getDefaultTarget,
      duration
    });
    onClick === null || onClick === void 0 ? void 0 : onClick(e2);
  };
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const rootPrefixCls = getPrefixCls();
  const [wrapSSR] = useStyle$i(prefixCls);
  const groupShape = react.exports.useContext(FloatButtonGroupContext$1);
  const mergeShape = groupShape || shape;
  const contentProps = Object.assign({
    prefixCls,
    icon,
    type: type4,
    shape: mergeShape
  }, restProps);
  return wrapSSR(
    /* @__PURE__ */ jsx(CSSMotion, {
      visible,
      motionName: `${rootPrefixCls}-fade`,
      children: (_ref) => {
        let {
          className: motionClassName
        } = _ref;
        return /* @__PURE__ */ jsx(FloatButton$1, {
          ...Object.assign({
            ref
          }, contentProps, {
            onClick: scrollToTop,
            className: classNames(className, motionClassName)
          })
        });
      }
    })
  );
};
const BackTop$1 = /* @__PURE__ */ react.exports.memo(BackTop);
var __rest$F = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const PureFloatButton = (_a) => {
  var {
    backTop
  } = _a, props = __rest$F(_a, ["backTop"]);
  return backTop ? /* @__PURE__ */ jsx(BackTop$1, {
    ...Object.assign({}, props, {
      visibilityHeight: 0
    })
  }) : /* @__PURE__ */ jsx(FloatButton$1, {
    ...Object.assign({}, props)
  });
};
function PurePanel$4(_a) {
  var {
    className,
    items
  } = _a, props = __rest$F(_a, ["className", "items"]);
  const {
    prefixCls: customizePrefixCls
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
  const pureCls = `${prefixCls}-pure`;
  if (items) {
    return /* @__PURE__ */ jsx(FloatButtonGroup$1, {
      ...Object.assign({
        className: classNames(className, pureCls)
      }, props),
      children: items.map((item, index2) => /* @__PURE__ */ jsx(PureFloatButton, {
        ...Object.assign({
          key: index2
        }, item)
      }))
    });
  }
  return /* @__PURE__ */ jsx(PureFloatButton, {
    ...Object.assign({
      className: classNames(className, pureCls)
    }, props)
  });
}
const PurePanel$5 = /* @__PURE__ */ react.exports.memo(PurePanel$4);
FloatButton$1.BackTop = BackTop$1;
FloatButton$1.Group = FloatButtonGroup$1;
FloatButton$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$5;
var IdContext = /* @__PURE__ */ react.exports.createContext(null);
function getMenuId(uuid2, eventKey) {
  if (uuid2 === void 0) {
    return null;
  }
  return "".concat(uuid2, "-").concat(eventKey);
}
function useMenuId(eventKey) {
  var id2 = react.exports.useContext(IdContext);
  return getMenuId(id2, eventKey);
}
var _excluded$i = ["children", "locked"];
var MenuContext$2 = /* @__PURE__ */ react.exports.createContext(null);
function mergeProps(origin, target) {
  var clone2 = _objectSpread2$1({}, origin);
  Object.keys(target).forEach(function(key) {
    var value = target[key];
    if (value !== void 0) {
      clone2[key] = value;
    }
  });
  return clone2;
}
function InheritableContextProvider(_ref) {
  var children = _ref.children, locked = _ref.locked, restProps = _objectWithoutProperties(_ref, _excluded$i);
  var context = react.exports.useContext(MenuContext$2);
  var inheritableContext = useMemo(function() {
    return mergeProps(context, restProps);
  }, [context, restProps], function(prev2, next2) {
    return !locked && (prev2[0] !== next2[0] || !isEqual$1(prev2[1], next2[1], true));
  });
  return /* @__PURE__ */ jsx(MenuContext$2.Provider, {
    value: inheritableContext,
    children
  });
}
var EmptyList = [];
var PathRegisterContext = /* @__PURE__ */ react.exports.createContext(null);
function useMeasure() {
  return react.exports.useContext(PathRegisterContext);
}
var PathTrackerContext = /* @__PURE__ */ react.exports.createContext(EmptyList);
function useFullPath(eventKey) {
  var parentKeyPath = react.exports.useContext(PathTrackerContext);
  return react.exports.useMemo(function() {
    return eventKey !== void 0 ? [].concat(_toConsumableArray(parentKeyPath), [eventKey]) : parentKeyPath;
  }, [parentKeyPath, eventKey]);
}
var PathUserContext = /* @__PURE__ */ react.exports.createContext(null);
var PrivateContext = /* @__PURE__ */ react.exports.createContext({});
function focusable(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  if (isVisible(node2)) {
    var nodeName = node2.nodeName.toLowerCase();
    var isFocusableElement = ["input", "select", "textarea", "button"].includes(nodeName) || node2.isContentEditable || nodeName === "a" && !!node2.getAttribute("href");
    var tabIndexAttr = node2.getAttribute("tabindex");
    var tabIndexNum = Number(tabIndexAttr);
    var tabIndex = null;
    if (tabIndexAttr && !Number.isNaN(tabIndexNum)) {
      tabIndex = tabIndexNum;
    } else if (isFocusableElement && tabIndex === null) {
      tabIndex = 0;
    }
    if (isFocusableElement && node2.disabled) {
      tabIndex = null;
    }
    return tabIndex !== null && (tabIndex >= 0 || includePositive && tabIndex < 0);
  }
  return false;
}
function getFocusNodeList(node2) {
  var includePositive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var res = _toConsumableArray(node2.querySelectorAll("*")).filter(function(child) {
    return focusable(child, includePositive);
  });
  if (focusable(node2, includePositive)) {
    res.unshift(node2);
  }
  return res;
}
var LEFT = KeyCode.LEFT, RIGHT = KeyCode.RIGHT, UP = KeyCode.UP, DOWN = KeyCode.DOWN, ENTER = KeyCode.ENTER, ESC$1 = KeyCode.ESC, HOME = KeyCode.HOME, END = KeyCode.END;
var ArrowKeys = [UP, DOWN, LEFT, RIGHT];
function getOffset(mode, isRootLevel, isRtl, which) {
  var _inline, _horizontal, _vertical, _offsets;
  var prev2 = "prev";
  var next2 = "next";
  var children = "children";
  var parent = "parent";
  if (mode === "inline" && which === ENTER) {
    return {
      inlineTrigger: true
    };
  }
  var inline2 = (_inline = {}, _defineProperty$1(_inline, UP, prev2), _defineProperty$1(_inline, DOWN, next2), _inline);
  var horizontal = (_horizontal = {}, _defineProperty$1(_horizontal, LEFT, isRtl ? next2 : prev2), _defineProperty$1(_horizontal, RIGHT, isRtl ? prev2 : next2), _defineProperty$1(_horizontal, DOWN, children), _defineProperty$1(_horizontal, ENTER, children), _horizontal);
  var vertical = (_vertical = {}, _defineProperty$1(_vertical, UP, prev2), _defineProperty$1(_vertical, DOWN, next2), _defineProperty$1(_vertical, ENTER, children), _defineProperty$1(_vertical, ESC$1, parent), _defineProperty$1(_vertical, LEFT, isRtl ? children : parent), _defineProperty$1(_vertical, RIGHT, isRtl ? parent : children), _vertical);
  var offsets = {
    inline: inline2,
    horizontal,
    vertical,
    inlineSub: inline2,
    horizontalSub: vertical,
    verticalSub: vertical
  };
  var type4 = (_offsets = offsets["".concat(mode).concat(isRootLevel ? "" : "Sub")]) === null || _offsets === void 0 ? void 0 : _offsets[which];
  switch (type4) {
    case prev2:
      return {
        offset: -1,
        sibling: true
      };
    case next2:
      return {
        offset: 1,
        sibling: true
      };
    case parent:
      return {
        offset: -1,
        sibling: false
      };
    case children:
      return {
        offset: 1,
        sibling: false
      };
    default:
      return null;
  }
}
function findContainerUL(element) {
  var current = element;
  while (current) {
    if (current.getAttribute("data-menu-list")) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusElement(activeElement, elements) {
  var current = activeElement || document.activeElement;
  while (current) {
    if (elements.has(current)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function getFocusableElements(container, elements) {
  var list = getFocusNodeList(container, true);
  return list.filter(function(ele) {
    return elements.has(ele);
  });
}
function getNextFocusElement(parentQueryContainer, elements, focusMenuElement) {
  var offset2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!parentQueryContainer) {
    return null;
  }
  var sameLevelFocusableMenuElementList = getFocusableElements(parentQueryContainer, elements);
  var count = sameLevelFocusableMenuElementList.length;
  var focusIndex = sameLevelFocusableMenuElementList.findIndex(function(ele) {
    return focusMenuElement === ele;
  });
  if (offset2 < 0) {
    if (focusIndex === -1) {
      focusIndex = count - 1;
    } else {
      focusIndex -= 1;
    }
  } else if (offset2 > 0) {
    focusIndex += 1;
  }
  focusIndex = (focusIndex + count) % count;
  return sameLevelFocusableMenuElementList[focusIndex];
}
function useAccessibility$1(mode, activeKey, isRtl, id2, containerRef, getKeys, getKeyPath, triggerActiveKey, triggerAccessibilityOpen, originOnKeyDown) {
  var rafRef = react.exports.useRef();
  var activeRef = react.exports.useRef();
  activeRef.current = activeKey;
  var cleanRaf = function cleanRaf2() {
    wrapperRaf.cancel(rafRef.current);
  };
  react.exports.useEffect(function() {
    return function() {
      cleanRaf();
    };
  }, []);
  return function(e2) {
    var which = e2.which;
    if ([].concat(ArrowKeys, [ENTER, ESC$1, HOME, END]).includes(which)) {
      var elements;
      var key2element;
      var element2key;
      var refreshElements = function refreshElements2() {
        elements = /* @__PURE__ */ new Set();
        key2element = /* @__PURE__ */ new Map();
        element2key = /* @__PURE__ */ new Map();
        var keys2 = getKeys();
        keys2.forEach(function(key) {
          var element = document.querySelector("[data-menu-id='".concat(getMenuId(id2, key), "']"));
          if (element) {
            elements.add(element);
            element2key.set(element, key);
            key2element.set(key, element);
          }
        });
        return elements;
      };
      refreshElements();
      var activeElement = key2element.get(activeKey);
      var focusMenuElement = getFocusElement(activeElement, elements);
      var focusMenuKey = element2key.get(focusMenuElement);
      var offsetObj = getOffset(mode, getKeyPath(focusMenuKey, true).length === 1, isRtl, which);
      if (!offsetObj && which !== HOME && which !== END) {
        return;
      }
      if (ArrowKeys.includes(which) || [HOME, END].includes(which)) {
        e2.preventDefault();
      }
      var tryFocus = function tryFocus2(menuElement) {
        if (menuElement) {
          var focusTargetElement = menuElement;
          var link = menuElement.querySelector("a");
          if (link !== null && link !== void 0 && link.getAttribute("href")) {
            focusTargetElement = link;
          }
          var targetKey = element2key.get(menuElement);
          triggerActiveKey(targetKey);
          cleanRaf();
          rafRef.current = wrapperRaf(function() {
            if (activeRef.current === targetKey) {
              focusTargetElement.focus();
            }
          });
        }
      };
      if ([HOME, END].includes(which) || offsetObj.sibling || !focusMenuElement) {
        var parentQueryContainer;
        if (!focusMenuElement || mode === "inline") {
          parentQueryContainer = containerRef.current;
        } else {
          parentQueryContainer = findContainerUL(focusMenuElement);
        }
        var targetElement;
        var focusableElements = getFocusableElements(parentQueryContainer, elements);
        if (which === HOME) {
          targetElement = focusableElements[0];
        } else if (which === END) {
          targetElement = focusableElements[focusableElements.length - 1];
        } else {
          targetElement = getNextFocusElement(parentQueryContainer, elements, focusMenuElement, offsetObj.offset);
        }
        tryFocus(targetElement);
      } else if (offsetObj.inlineTrigger) {
        triggerAccessibilityOpen(focusMenuKey);
      } else if (offsetObj.offset > 0) {
        triggerAccessibilityOpen(focusMenuKey, true);
        cleanRaf();
        rafRef.current = wrapperRaf(function() {
          refreshElements();
          var controlId = focusMenuElement.getAttribute("aria-controls");
          var subQueryContainer = document.getElementById(controlId);
          var targetElement2 = getNextFocusElement(subQueryContainer, elements);
          tryFocus(targetElement2);
        }, 5);
      } else if (offsetObj.offset < 0) {
        var keyPath = getKeyPath(focusMenuKey, true);
        var parentKey = keyPath[keyPath.length - 2];
        var parentMenuElement = key2element.get(parentKey);
        triggerAccessibilityOpen(parentKey, false);
        tryFocus(parentMenuElement);
      }
    }
    originOnKeyDown === null || originOnKeyDown === void 0 ? void 0 : originOnKeyDown(e2);
  };
}
function nextSlice(callback) {
  Promise.resolve().then(callback);
}
var PATH_SPLIT = "__RC_UTIL_PATH_SPLIT__";
var getPathStr = function getPathStr2(keyPath) {
  return keyPath.join(PATH_SPLIT);
};
var getPathKeys = function getPathKeys2(keyPathStr) {
  return keyPathStr.split(PATH_SPLIT);
};
var OVERFLOW_KEY = "rc-menu-more";
function useKeyRecords() {
  var _React$useState = react.exports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), internalForceUpdate = _React$useState2[1];
  var key2pathRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var path2keyRef = react.exports.useRef(/* @__PURE__ */ new Map());
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), overflowKeys = _React$useState4[0], setOverflowKeys = _React$useState4[1];
  var updateRef = react.exports.useRef(0);
  var destroyRef = react.exports.useRef(false);
  var forceUpdate = function forceUpdate2() {
    if (!destroyRef.current) {
      internalForceUpdate({});
    }
  };
  var registerPath = react.exports.useCallback(function(key, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.set(connectedPath, key);
    key2pathRef.current.set(key, connectedPath);
    updateRef.current += 1;
    var id2 = updateRef.current;
    nextSlice(function() {
      if (id2 === updateRef.current) {
        forceUpdate();
      }
    });
  }, []);
  var unregisterPath = react.exports.useCallback(function(key, keyPath) {
    var connectedPath = getPathStr(keyPath);
    path2keyRef.current.delete(connectedPath);
    key2pathRef.current.delete(key);
  }, []);
  var refreshOverflowKeys = react.exports.useCallback(function(keys2) {
    setOverflowKeys(keys2);
  }, []);
  var getKeyPath = react.exports.useCallback(function(eventKey, includeOverflow) {
    var fullPath = key2pathRef.current.get(eventKey) || "";
    var keys2 = getPathKeys(fullPath);
    if (includeOverflow && overflowKeys.includes(keys2[0])) {
      keys2.unshift(OVERFLOW_KEY);
    }
    return keys2;
  }, [overflowKeys]);
  var isSubPathKey = react.exports.useCallback(function(pathKeys, eventKey) {
    return pathKeys.some(function(pathKey) {
      var pathKeyList = getKeyPath(pathKey, true);
      return pathKeyList.includes(eventKey);
    });
  }, [getKeyPath]);
  var getKeys = function getKeys2() {
    var keys2 = _toConsumableArray(key2pathRef.current.keys());
    if (overflowKeys.length) {
      keys2.push(OVERFLOW_KEY);
    }
    return keys2;
  };
  var getSubPathKeys = react.exports.useCallback(function(key) {
    var connectedPath = "".concat(key2pathRef.current.get(key)).concat(PATH_SPLIT);
    var pathKeys = /* @__PURE__ */ new Set();
    _toConsumableArray(path2keyRef.current.keys()).forEach(function(pathKey) {
      if (pathKey.startsWith(connectedPath)) {
        pathKeys.add(path2keyRef.current.get(pathKey));
      }
    });
    return pathKeys;
  }, []);
  react.exports.useEffect(function() {
    return function() {
      destroyRef.current = true;
    };
  }, []);
  return {
    registerPath,
    unregisterPath,
    refreshOverflowKeys,
    isSubPathKey,
    getKeyPath,
    getKeys,
    getSubPathKeys
  };
}
function useMemoCallback(func) {
  var funRef = react.exports.useRef(func);
  funRef.current = func;
  var callback = react.exports.useCallback(function() {
    var _funRef$current;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return (_funRef$current = funRef.current) === null || _funRef$current === void 0 ? void 0 : _funRef$current.call.apply(_funRef$current, [funRef].concat(args));
  }, []);
  return func ? callback : void 0;
}
var uniquePrefix = Math.random().toFixed(5).toString().slice(2);
var internalId = 0;
function useUUID(id2) {
  var _useMergedState = useMergedState(id2, {
    value: id2
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), uuid2 = _useMergedState2[0], setUUID = _useMergedState2[1];
  react.exports.useEffect(function() {
    internalId += 1;
    var newId = "".concat(uniquePrefix, "-").concat(internalId);
    setUUID("rc-menu-uuid-".concat(newId));
  }, []);
  return uuid2;
}
function useActive(eventKey, disabled, onMouseEnter, onMouseLeave) {
  var _React$useContext = react.exports.useContext(MenuContext$2), activeKey = _React$useContext.activeKey, onActive = _React$useContext.onActive, onInactive = _React$useContext.onInactive;
  var ret = {
    active: activeKey === eventKey
  };
  if (!disabled) {
    ret.onMouseEnter = function(domEvent) {
      onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
        key: eventKey,
        domEvent
      });
      onActive(eventKey);
    };
    ret.onMouseLeave = function(domEvent) {
      onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
        key: eventKey,
        domEvent
      });
      onInactive(eventKey);
    };
  }
  return ret;
}
var _excluded$h = ["item"];
function warnItemProp(_ref) {
  var item = _ref.item, restInfo = _objectWithoutProperties(_ref, _excluded$h);
  Object.defineProperty(restInfo, "item", {
    get: function get2() {
      warningOnce(false, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future.");
      return item;
    }
  });
  return restInfo;
}
function Icon$1(_ref) {
  var icon = _ref.icon, props = _ref.props, children = _ref.children;
  var iconNode;
  if (typeof icon === "function") {
    iconNode = /* @__PURE__ */ react.exports.createElement(icon, _objectSpread2$1({}, props));
  } else {
    iconNode = icon;
  }
  return iconNode || children || null;
}
function useDirectionStyle(level) {
  var _React$useContext = react.exports.useContext(MenuContext$2), mode = _React$useContext.mode, rtl = _React$useContext.rtl, inlineIndent = _React$useContext.inlineIndent;
  if (mode !== "inline") {
    return null;
  }
  var len = level;
  return rtl ? {
    paddingRight: len * inlineIndent
  } : {
    paddingLeft: len * inlineIndent
  };
}
var _excluded$g = ["title", "attribute", "elementRef"], _excluded2$3 = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], _excluded3 = ["active"];
var LegacyMenuItem = /* @__PURE__ */ function(_React$Component) {
  _inherits(LegacyMenuItem2, _React$Component);
  var _super = _createSuper(LegacyMenuItem2);
  function LegacyMenuItem2() {
    _classCallCheck(this, LegacyMenuItem2);
    return _super.apply(this, arguments);
  }
  _createClass(LegacyMenuItem2, [{
    key: "render",
    value: function render2() {
      var _this$props = this.props, title = _this$props.title, attribute = _this$props.attribute, elementRef = _this$props.elementRef, restProps = _objectWithoutProperties(_this$props, _excluded$g);
      var passedProps = omit(restProps, ["eventKey"]);
      warningOnce(!attribute, "`attribute` of Menu.Item is deprecated. Please pass attribute directly.");
      return /* @__PURE__ */ jsx(ForwardOverflow.Item, {
        ...attribute,
        title: typeof title === "string" ? title : void 0,
        ...passedProps,
        ref: elementRef
      });
    }
  }]);
  return LegacyMenuItem2;
}(react.exports.Component);
var InternalMenuItem = function InternalMenuItem2(props) {
  var _classNames;
  var style2 = props.style, className = props.className, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, itemIcon = props.itemIcon, children = props.children, role = props.role, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onClick = props.onClick, onKeyDown2 = props.onKeyDown, onFocus2 = props.onFocus, restProps = _objectWithoutProperties(props, _excluded2$3);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, onItemClick = _React$useContext.onItemClick, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, contextItemIcon = _React$useContext.itemIcon, selectedKeys = _React$useContext.selectedKeys, onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext), _internalRenderMenuItem = _React$useContext2._internalRenderMenuItem;
  var itemCls = "".concat(prefixCls, "-item");
  var legacyMenuItemRef = react.exports.useRef();
  var elementRef = react.exports.useRef();
  var mergedDisabled = contextDisabled || disabled;
  var connectedKeys = useFullPath(eventKey);
  var getEventInfo = function getEventInfo2(e2) {
    return {
      key: eventKey,
      keyPath: _toConsumableArray(connectedKeys).reverse(),
      item: legacyMenuItemRef.current,
      domEvent: e2
    };
  };
  var mergedItemIcon = itemIcon || contextItemIcon;
  var _useActive = useActive(eventKey, mergedDisabled, onMouseEnter, onMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded3);
  var selected = selectedKeys.includes(eventKey);
  var directionStyle = useDirectionStyle(connectedKeys.length);
  var onInternalClick = function onInternalClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    var info = getEventInfo(e2);
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  };
  var onInternalKeyDown = function onInternalKeyDown2(e2) {
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
    if (e2.which === KeyCode.ENTER) {
      var info = getEventInfo(e2);
      onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
      onItemClick(info);
    }
  };
  var onInternalFocus = function onInternalFocus2(e2) {
    onActive(eventKey);
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e2);
  };
  var optionRoleProps = {};
  if (props.role === "option") {
    optionRoleProps["aria-selected"] = selected;
  }
  var renderNode = /* @__PURE__ */ jsxs(LegacyMenuItem, {
    ref: legacyMenuItemRef,
    elementRef,
    role: role === null ? "none" : role || "menuitem",
    tabIndex: disabled ? null : -1,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    ...restProps,
    ...activeProps,
    ...optionRoleProps,
    component: "li",
    "aria-disabled": disabled,
    style: _objectSpread2$1(_objectSpread2$1({}, directionStyle), style2),
    className: classNames(itemCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(itemCls, "-active"), active), _defineProperty$1(_classNames, "".concat(itemCls, "-selected"), selected), _defineProperty$1(_classNames, "".concat(itemCls, "-disabled"), mergedDisabled), _classNames), className),
    onClick: onInternalClick,
    onKeyDown: onInternalKeyDown,
    onFocus: onInternalFocus,
    children: [children, /* @__PURE__ */ jsx(Icon$1, {
      props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
        isSelected: selected
      }),
      icon: mergedItemIcon
    })]
  });
  if (_internalRenderMenuItem) {
    renderNode = _internalRenderMenuItem(renderNode, props, {
      selected
    });
  }
  return renderNode;
};
function MenuItem$1(props) {
  var eventKey = props.eventKey;
  var measure = useMeasure();
  var connectedKeyPath = useFullPath(eventKey);
  react.exports.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ jsx(InternalMenuItem, {
    ...props
  });
}
var _excluded$f = ["className", "children"];
var InternalSubMenuList = function InternalSubMenuList2(_ref, ref) {
  var className = _ref.className, children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded$f);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, rtl = _React$useContext.rtl;
  return /* @__PURE__ */ jsx("ul", {
    className: classNames(prefixCls, rtl && "".concat(prefixCls, "-rtl"), "".concat(prefixCls, "-sub"), "".concat(prefixCls, "-").concat(mode === "inline" ? "inline" : "vertical"), className),
    role: "menu",
    ...restProps,
    "data-menu-list": true,
    ref,
    children
  });
};
var SubMenuList = /* @__PURE__ */ react.exports.forwardRef(InternalSubMenuList);
SubMenuList.displayName = "SubMenuList";
var _excluded$e = ["label", "children", "key", "type"];
function parseChildren(children, keyPath) {
  return toArray$3(children).map(function(child, index2) {
    if (/* @__PURE__ */ react.exports.isValidElement(child)) {
      var _eventKey, _child$props;
      var key = child.key;
      var eventKey = (_eventKey = (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.eventKey) !== null && _eventKey !== void 0 ? _eventKey : key;
      var emptyKey = eventKey === null || eventKey === void 0;
      if (emptyKey) {
        eventKey = "tmp_key-".concat([].concat(_toConsumableArray(keyPath), [index2]).join("-"));
      }
      var cloneProps = {
        key: eventKey,
        eventKey
      };
      return /* @__PURE__ */ react.exports.cloneElement(child, cloneProps);
    }
    return child;
  });
}
function convertItemsToNodes$1(list) {
  return (list || []).map(function(opt, index2) {
    if (opt && _typeof$1(opt) === "object") {
      var _ref = opt, label = _ref.label, children = _ref.children, key = _ref.key, type4 = _ref.type, restProps = _objectWithoutProperties(_ref, _excluded$e);
      var mergedKey = key !== null && key !== void 0 ? key : "tmp-".concat(index2);
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ jsx(MenuItemGroup, {
            ...restProps,
            title: label,
            children: convertItemsToNodes$1(children)
          }, mergedKey);
        }
        return /* @__PURE__ */ jsx(SubMenu$2, {
          ...restProps,
          title: label,
          children: convertItemsToNodes$1(children)
        }, mergedKey);
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ jsx(Divider$2, {
          ...restProps
        }, mergedKey);
      }
      return /* @__PURE__ */ jsx(MenuItem$1, {
        ...restProps,
        children: label
      }, mergedKey);
    }
    return null;
  }).filter(function(opt) {
    return opt;
  });
}
function parseItems(children, items, keyPath) {
  var childNodes = children;
  if (items) {
    childNodes = convertItemsToNodes$1(items);
  }
  return parseChildren(childNodes, keyPath);
}
var autoAdjustOverflow$1 = {
  adjustX: 1,
  adjustY: 1
};
var placements$1 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
var placementsRtl = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow$1,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: autoAdjustOverflow$1,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: autoAdjustOverflow$1,
    offset: [4, 0]
  }
};
function getMotion$2(mode, motion2, defaultMotions) {
  if (motion2) {
    return motion2;
  }
  if (defaultMotions) {
    return defaultMotions[mode] || defaultMotions.other;
  }
  return void 0;
}
var popupPlacementMap = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function PopupTrigger(_ref) {
  var prefixCls = _ref.prefixCls, visible = _ref.visible, children = _ref.children, popup = _ref.popup, popupClassName = _ref.popupClassName, popupOffset = _ref.popupOffset, disabled = _ref.disabled, mode = _ref.mode, onVisibleChange = _ref.onVisibleChange;
  var _React$useContext = react.exports.useContext(MenuContext$2), getPopupContainer = _React$useContext.getPopupContainer, rtl = _React$useContext.rtl, subMenuOpenDelay = _React$useContext.subMenuOpenDelay, subMenuCloseDelay = _React$useContext.subMenuCloseDelay, builtinPlacements = _React$useContext.builtinPlacements, triggerSubMenuAction = _React$useContext.triggerSubMenuAction, forceSubMenuRender = _React$useContext.forceSubMenuRender, rootClassName = _React$useContext.rootClassName, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), innerVisible = _React$useState2[0], setInnerVisible = _React$useState2[1];
  var placement = rtl ? _objectSpread2$1(_objectSpread2$1({}, placementsRtl), builtinPlacements) : _objectSpread2$1(_objectSpread2$1({}, placements$1), builtinPlacements);
  var popupPlacement = popupPlacementMap[mode];
  var targetMotion = getMotion$2(mode, motion2, defaultMotions);
  var targetMotionRef = react.exports.useRef(targetMotion);
  if (mode !== "inline") {
    targetMotionRef.current = targetMotion;
  }
  var mergedMotion = _objectSpread2$1(_objectSpread2$1({}, targetMotionRef.current), {}, {
    leavedClassName: "".concat(prefixCls, "-hidden"),
    removeOnLeave: false,
    motionAppear: true
  });
  var visibleRef = react.exports.useRef();
  react.exports.useEffect(function() {
    visibleRef.current = wrapperRaf(function() {
      setInnerVisible(visible);
    });
    return function() {
      wrapperRaf.cancel(visibleRef.current);
    };
  }, [visible]);
  return /* @__PURE__ */ jsx(Trigger, {
    prefixCls,
    popupClassName: classNames("".concat(prefixCls, "-popup"), _defineProperty$1({}, "".concat(prefixCls, "-rtl"), rtl), popupClassName, rootClassName),
    stretch: mode === "horizontal" ? "minWidth" : null,
    getPopupContainer,
    builtinPlacements: placement,
    popupPlacement,
    popupVisible: innerVisible,
    popup,
    popupAlign: popupOffset && {
      offset: popupOffset
    },
    action: disabled ? [] : [triggerSubMenuAction],
    mouseEnterDelay: subMenuOpenDelay,
    mouseLeaveDelay: subMenuCloseDelay,
    onPopupVisibleChange: onVisibleChange,
    forceRender: forceSubMenuRender,
    popupMotion: mergedMotion,
    children
  });
}
function InlineSubMenuList(_ref) {
  var id2 = _ref.id, open2 = _ref.open, keyPath = _ref.keyPath, children = _ref.children;
  var fixedMode = "inline";
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, forceSubMenuRender = _React$useContext.forceSubMenuRender, motion2 = _React$useContext.motion, defaultMotions = _React$useContext.defaultMotions, mode = _React$useContext.mode;
  var sameModeRef = react.exports.useRef(false);
  sameModeRef.current = mode === fixedMode;
  var _React$useState = react.exports.useState(!sameModeRef.current), _React$useState2 = _slicedToArray(_React$useState, 2), destroy2 = _React$useState2[0], setDestroy = _React$useState2[1];
  var mergedOpen = sameModeRef.current ? open2 : false;
  react.exports.useEffect(function() {
    if (sameModeRef.current) {
      setDestroy(false);
    }
  }, [mode]);
  var mergedMotion = _objectSpread2$1({}, getMotion$2(fixedMode, motion2, defaultMotions));
  if (keyPath.length > 1) {
    mergedMotion.motionAppear = false;
  }
  var originOnVisibleChanged = mergedMotion.onVisibleChanged;
  mergedMotion.onVisibleChanged = function(newVisible) {
    if (!sameModeRef.current && !newVisible) {
      setDestroy(true);
    }
    return originOnVisibleChanged === null || originOnVisibleChanged === void 0 ? void 0 : originOnVisibleChanged(newVisible);
  };
  if (destroy2) {
    return null;
  }
  return /* @__PURE__ */ jsx(InheritableContextProvider, {
    mode: fixedMode,
    locked: !sameModeRef.current,
    children: /* @__PURE__ */ jsx(CSSMotion, {
      visible: mergedOpen,
      ...mergedMotion,
      forceRender: forceSubMenuRender,
      removeOnLeave: false,
      leavedClassName: "".concat(prefixCls, "-hidden"),
      children: function(_ref2) {
        var motionClassName = _ref2.className, motionStyle = _ref2.style;
        return /* @__PURE__ */ jsx(SubMenuList, {
          id: id2,
          className: motionClassName,
          style: motionStyle,
          children
        });
      }
    })
  });
}
var _excluded$d = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _excluded2$2 = ["active"];
var InternalSubMenu = function InternalSubMenu2(props) {
  var _classNames;
  var style2 = props.style, className = props.className, title = props.title, eventKey = props.eventKey;
  props.warnKey;
  var disabled = props.disabled, internalPopupClose = props.internalPopupClose, children = props.children, itemIcon = props.itemIcon, expandIcon = props.expandIcon, popupClassName = props.popupClassName, popupOffset = props.popupOffset, onClick = props.onClick, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, onTitleClick = props.onTitleClick, onTitleMouseEnter = props.onTitleMouseEnter, onTitleMouseLeave = props.onTitleMouseLeave, restProps = _objectWithoutProperties(props, _excluded$d);
  var domDataId = useMenuId(eventKey);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls, mode = _React$useContext.mode, openKeys = _React$useContext.openKeys, contextDisabled = _React$useContext.disabled, overflowDisabled = _React$useContext.overflowDisabled, activeKey = _React$useContext.activeKey, selectedKeys = _React$useContext.selectedKeys, contextItemIcon = _React$useContext.itemIcon, contextExpandIcon = _React$useContext.expandIcon, onItemClick = _React$useContext.onItemClick, onOpenChange = _React$useContext.onOpenChange, onActive = _React$useContext.onActive;
  var _React$useContext2 = react.exports.useContext(PrivateContext), _internalRenderSubMenuItem = _React$useContext2._internalRenderSubMenuItem;
  var _React$useContext3 = react.exports.useContext(PathUserContext), isSubPathKey = _React$useContext3.isSubPathKey;
  var connectedPath = useFullPath();
  var subMenuPrefixCls = "".concat(prefixCls, "-submenu");
  var mergedDisabled = contextDisabled || disabled;
  var elementRef = react.exports.useRef();
  var popupRef = react.exports.useRef();
  var mergedItemIcon = itemIcon || contextItemIcon;
  var mergedExpandIcon = expandIcon || contextExpandIcon;
  var originOpen = openKeys.includes(eventKey);
  var open2 = !overflowDisabled && originOpen;
  var childrenSelected = isSubPathKey(selectedKeys, eventKey);
  var _useActive = useActive(eventKey, mergedDisabled, onTitleMouseEnter, onTitleMouseLeave), active = _useActive.active, activeProps = _objectWithoutProperties(_useActive, _excluded2$2);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), childrenActive = _React$useState2[0], setChildrenActive = _React$useState2[1];
  var triggerChildrenActive = function triggerChildrenActive2(newActive) {
    if (!mergedDisabled) {
      setChildrenActive(newActive);
    }
  };
  var onInternalMouseEnter = function onInternalMouseEnter2(domEvent) {
    triggerChildrenActive(true);
    onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter({
      key: eventKey,
      domEvent
    });
  };
  var onInternalMouseLeave = function onInternalMouseLeave2(domEvent) {
    triggerChildrenActive(false);
    onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave({
      key: eventKey,
      domEvent
    });
  };
  var mergedActive = react.exports.useMemo(function() {
    if (active) {
      return active;
    }
    if (mode !== "inline") {
      return childrenActive || isSubPathKey([activeKey], eventKey);
    }
    return false;
  }, [mode, active, activeKey, childrenActive, eventKey, isSubPathKey]);
  var directionStyle = useDirectionStyle(connectedPath.length);
  var onInternalTitleClick = function onInternalTitleClick2(e2) {
    if (mergedDisabled) {
      return;
    }
    onTitleClick === null || onTitleClick === void 0 ? void 0 : onTitleClick({
      key: eventKey,
      domEvent: e2
    });
    if (mode === "inline") {
      onOpenChange(eventKey, !originOpen);
    }
  };
  var onMergedItemClick = useMemoCallback(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    onItemClick(info);
  });
  var onPopupVisibleChange = function onPopupVisibleChange2(newVisible) {
    if (mode !== "inline") {
      onOpenChange(eventKey, newVisible);
    }
  };
  var onInternalFocus = function onInternalFocus2() {
    onActive(eventKey);
  };
  var popupId = domDataId && "".concat(domDataId, "-popup");
  var titleNode = /* @__PURE__ */ jsxs("div", {
    role: "menuitem",
    style: directionStyle,
    className: "".concat(subMenuPrefixCls, "-title"),
    tabIndex: mergedDisabled ? null : -1,
    ref: elementRef,
    title: typeof title === "string" ? title : null,
    "data-menu-id": overflowDisabled && domDataId ? null : domDataId,
    "aria-expanded": open2,
    "aria-haspopup": true,
    "aria-controls": popupId,
    "aria-disabled": mergedDisabled,
    onClick: onInternalTitleClick,
    onFocus: onInternalFocus,
    ...activeProps,
    children: [title, /* @__PURE__ */ jsx(Icon$1, {
      icon: mode !== "horizontal" ? mergedExpandIcon : null,
      props: _objectSpread2$1(_objectSpread2$1({}, props), {}, {
        isOpen: open2,
        isSubMenu: true
      }),
      children: /* @__PURE__ */ jsx("i", {
        className: "".concat(subMenuPrefixCls, "-arrow")
      })
    })]
  });
  var triggerModeRef = react.exports.useRef(mode);
  if (mode !== "inline" && connectedPath.length > 1) {
    triggerModeRef.current = "vertical";
  } else {
    triggerModeRef.current = mode;
  }
  if (!overflowDisabled) {
    var triggerMode = triggerModeRef.current;
    titleNode = /* @__PURE__ */ jsx(PopupTrigger, {
      mode: triggerMode,
      prefixCls: subMenuPrefixCls,
      visible: !internalPopupClose && open2 && mode !== "inline",
      popupClassName,
      popupOffset,
      popup: /* @__PURE__ */ jsx(InheritableContextProvider, {
        mode: triggerMode === "horizontal" ? "vertical" : triggerMode,
        children: /* @__PURE__ */ jsx(SubMenuList, {
          id: popupId,
          ref: popupRef,
          children
        })
      }),
      disabled: mergedDisabled,
      onVisibleChange: onPopupVisibleChange,
      children: titleNode
    });
  }
  var listNode = /* @__PURE__ */ jsxs(ForwardOverflow.Item, {
    role: "none",
    ...restProps,
    component: "li",
    style: style2,
    className: classNames(subMenuPrefixCls, "".concat(subMenuPrefixCls, "-").concat(mode), className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-open"), open2), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-active"), mergedActive), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-selected"), childrenSelected), _defineProperty$1(_classNames, "".concat(subMenuPrefixCls, "-disabled"), mergedDisabled), _classNames)),
    onMouseEnter: onInternalMouseEnter,
    onMouseLeave: onInternalMouseLeave,
    children: [titleNode, !overflowDisabled && /* @__PURE__ */ jsx(InlineSubMenuList, {
      id: popupId,
      open: open2,
      keyPath: connectedPath,
      children
    })]
  });
  if (_internalRenderSubMenuItem) {
    listNode = _internalRenderSubMenuItem(listNode, props, {
      selected: childrenSelected,
      active: mergedActive,
      open: open2,
      disabled: mergedDisabled
    });
  }
  return /* @__PURE__ */ jsx(InheritableContextProvider, {
    onItemClick: onMergedItemClick,
    mode: mode === "horizontal" ? "vertical" : mode,
    itemIcon: mergedItemIcon,
    expandIcon: mergedExpandIcon,
    children: listNode
  });
};
function SubMenu$2(props) {
  var eventKey = props.eventKey, children = props.children;
  var connectedKeyPath = useFullPath(eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  react.exports.useEffect(function() {
    if (measure) {
      measure.registerPath(eventKey, connectedKeyPath);
      return function() {
        measure.unregisterPath(eventKey, connectedKeyPath);
      };
    }
  }, [connectedKeyPath]);
  var renderNode;
  if (measure) {
    renderNode = childList;
  } else {
    renderNode = /* @__PURE__ */ jsx(InternalSubMenu, {
      ...props,
      children: childList
    });
  }
  return /* @__PURE__ */ jsx(PathTrackerContext.Provider, {
    value: connectedKeyPath,
    children: renderNode
  });
}
var _excluded$c = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"];
var EMPTY_LIST$2 = [];
var Menu$2 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _childList$, _classNames;
  var _ref = props, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-menu" : _ref$prefixCls, rootClassName = _ref.rootClassName, style2 = _ref.style, className = _ref.className, _ref$tabIndex = _ref.tabIndex, tabIndex = _ref$tabIndex === void 0 ? 0 : _ref$tabIndex, items = _ref.items, children = _ref.children, direction = _ref.direction, id2 = _ref.id, _ref$mode = _ref.mode, mode = _ref$mode === void 0 ? "vertical" : _ref$mode, inlineCollapsed = _ref.inlineCollapsed, disabled = _ref.disabled, disabledOverflow = _ref.disabledOverflow, _ref$subMenuOpenDelay = _ref.subMenuOpenDelay, subMenuOpenDelay = _ref$subMenuOpenDelay === void 0 ? 0.1 : _ref$subMenuOpenDelay, _ref$subMenuCloseDela = _ref.subMenuCloseDelay, subMenuCloseDelay = _ref$subMenuCloseDela === void 0 ? 0.1 : _ref$subMenuCloseDela, forceSubMenuRender = _ref.forceSubMenuRender, defaultOpenKeys = _ref.defaultOpenKeys, openKeys = _ref.openKeys, activeKey = _ref.activeKey, defaultActiveFirst = _ref.defaultActiveFirst, _ref$selectable = _ref.selectable, selectable = _ref$selectable === void 0 ? true : _ref$selectable, _ref$multiple = _ref.multiple, multiple = _ref$multiple === void 0 ? false : _ref$multiple, defaultSelectedKeys = _ref.defaultSelectedKeys, selectedKeys = _ref.selectedKeys, onSelect = _ref.onSelect, onDeselect = _ref.onDeselect, _ref$inlineIndent = _ref.inlineIndent, inlineIndent = _ref$inlineIndent === void 0 ? 24 : _ref$inlineIndent, motion2 = _ref.motion, defaultMotions = _ref.defaultMotions, _ref$triggerSubMenuAc = _ref.triggerSubMenuAction, triggerSubMenuAction = _ref$triggerSubMenuAc === void 0 ? "hover" : _ref$triggerSubMenuAc, builtinPlacements = _ref.builtinPlacements, itemIcon = _ref.itemIcon, expandIcon = _ref.expandIcon, _ref$overflowedIndica = _ref.overflowedIndicator, overflowedIndicator = _ref$overflowedIndica === void 0 ? "..." : _ref$overflowedIndica, overflowedIndicatorPopupClassName = _ref.overflowedIndicatorPopupClassName, getPopupContainer = _ref.getPopupContainer, onClick = _ref.onClick, onOpenChange = _ref.onOpenChange, onKeyDown2 = _ref.onKeyDown;
  _ref.openAnimation;
  _ref.openTransitionName;
  var _internalRenderMenuItem = _ref._internalRenderMenuItem, _internalRenderSubMenuItem = _ref._internalRenderSubMenuItem, restProps = _objectWithoutProperties(_ref, _excluded$c);
  var childList = react.exports.useMemo(function() {
    return parseItems(children, items, EMPTY_LIST$2);
  }, [children, items]);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mounted = _React$useState2[0], setMounted = _React$useState2[1];
  var containerRef = react.exports.useRef();
  var uuid2 = useUUID(id2);
  var isRtl = direction === "rtl";
  var _useMergedState = useMergedState(defaultOpenKeys, {
    value: openKeys,
    postState: function postState(keys2) {
      return keys2 || EMPTY_LIST$2;
    }
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedOpenKeys = _useMergedState2[0], setMergedOpenKeys = _useMergedState2[1];
  var triggerOpenKeys = function triggerOpenKeys2(keys2) {
    var forceFlush = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    function doUpdate() {
      setMergedOpenKeys(keys2);
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(keys2);
    }
    if (forceFlush) {
      reactDom.exports.flushSync(doUpdate);
    } else {
      doUpdate();
    }
  };
  var _React$useState3 = react.exports.useState(mergedOpenKeys), _React$useState4 = _slicedToArray(_React$useState3, 2), inlineCacheOpenKeys = _React$useState4[0], setInlineCacheOpenKeys = _React$useState4[1];
  var mountRef = react.exports.useRef(false);
  var _React$useMemo = react.exports.useMemo(function() {
    if ((mode === "inline" || mode === "vertical") && inlineCollapsed) {
      return ["vertical", inlineCollapsed];
    }
    return [mode, false];
  }, [mode, inlineCollapsed]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), mergedMode = _React$useMemo2[0], mergedInlineCollapsed = _React$useMemo2[1];
  var isInlineMode = mergedMode === "inline";
  var _React$useState5 = react.exports.useState(mergedMode), _React$useState6 = _slicedToArray(_React$useState5, 2), internalMode = _React$useState6[0], setInternalMode = _React$useState6[1];
  var _React$useState7 = react.exports.useState(mergedInlineCollapsed), _React$useState8 = _slicedToArray(_React$useState7, 2), internalInlineCollapsed = _React$useState8[0], setInternalInlineCollapsed = _React$useState8[1];
  react.exports.useEffect(function() {
    setInternalMode(mergedMode);
    setInternalInlineCollapsed(mergedInlineCollapsed);
    if (!mountRef.current) {
      return;
    }
    if (isInlineMode) {
      setMergedOpenKeys(inlineCacheOpenKeys);
    } else {
      triggerOpenKeys(EMPTY_LIST$2);
    }
  }, [mergedMode, mergedInlineCollapsed]);
  var _React$useState9 = react.exports.useState(0), _React$useState10 = _slicedToArray(_React$useState9, 2), lastVisibleIndex = _React$useState10[0], setLastVisibleIndex = _React$useState10[1];
  var allVisible = lastVisibleIndex >= childList.length - 1 || internalMode !== "horizontal" || disabledOverflow;
  react.exports.useEffect(function() {
    if (isInlineMode) {
      setInlineCacheOpenKeys(mergedOpenKeys);
    }
  }, [mergedOpenKeys]);
  react.exports.useEffect(function() {
    mountRef.current = true;
    return function() {
      mountRef.current = false;
    };
  }, []);
  var _useKeyRecords = useKeyRecords(), registerPath = _useKeyRecords.registerPath, unregisterPath = _useKeyRecords.unregisterPath, refreshOverflowKeys = _useKeyRecords.refreshOverflowKeys, isSubPathKey = _useKeyRecords.isSubPathKey, getKeyPath = _useKeyRecords.getKeyPath, getKeys = _useKeyRecords.getKeys, getSubPathKeys = _useKeyRecords.getSubPathKeys;
  var registerPathContext = react.exports.useMemo(function() {
    return {
      registerPath,
      unregisterPath
    };
  }, [registerPath, unregisterPath]);
  var pathUserContext = react.exports.useMemo(function() {
    return {
      isSubPathKey
    };
  }, [isSubPathKey]);
  react.exports.useEffect(function() {
    refreshOverflowKeys(allVisible ? EMPTY_LIST$2 : childList.slice(lastVisibleIndex + 1).map(function(child) {
      return child.key;
    }));
  }, [lastVisibleIndex, allVisible]);
  var _useMergedState3 = useMergedState(activeKey || defaultActiveFirst && ((_childList$ = childList[0]) === null || _childList$ === void 0 ? void 0 : _childList$.key), {
    value: activeKey
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedActiveKey = _useMergedState4[0], setMergedActiveKey = _useMergedState4[1];
  var onActive = useMemoCallback(function(key) {
    setMergedActiveKey(key);
  });
  var onInactive = useMemoCallback(function() {
    setMergedActiveKey(void 0);
  });
  react.exports.useImperativeHandle(ref, function() {
    return {
      list: containerRef.current,
      focus: function focus(options) {
        var _childList$find;
        var shouldFocusKey = mergedActiveKey !== null && mergedActiveKey !== void 0 ? mergedActiveKey : (_childList$find = childList.find(function(node2) {
          return !node2.props.disabled;
        })) === null || _childList$find === void 0 ? void 0 : _childList$find.key;
        if (shouldFocusKey) {
          var _containerRef$current, _containerRef$current2, _containerRef$current3;
          (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.querySelector("li[data-menu-id='".concat(getMenuId(uuid2, shouldFocusKey), "']"))) === null || _containerRef$current2 === void 0 ? void 0 : (_containerRef$current3 = _containerRef$current2.focus) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.call(_containerRef$current2, options);
        }
      }
    };
  });
  var _useMergedState5 = useMergedState(defaultSelectedKeys || [], {
    value: selectedKeys,
    postState: function postState(keys2) {
      if (Array.isArray(keys2)) {
        return keys2;
      }
      if (keys2 === null || keys2 === void 0) {
        return EMPTY_LIST$2;
      }
      return [keys2];
    }
  }), _useMergedState6 = _slicedToArray(_useMergedState5, 2), mergedSelectKeys = _useMergedState6[0], setMergedSelectKeys = _useMergedState6[1];
  var triggerSelection = function triggerSelection2(info) {
    if (selectable) {
      var targetKey = info.key;
      var exist = mergedSelectKeys.includes(targetKey);
      var newSelectKeys;
      if (multiple) {
        if (exist) {
          newSelectKeys = mergedSelectKeys.filter(function(key) {
            return key !== targetKey;
          });
        } else {
          newSelectKeys = [].concat(_toConsumableArray(mergedSelectKeys), [targetKey]);
        }
      } else {
        newSelectKeys = [targetKey];
      }
      setMergedSelectKeys(newSelectKeys);
      var selectInfo = _objectSpread2$1(_objectSpread2$1({}, info), {}, {
        selectedKeys: newSelectKeys
      });
      if (exist) {
        onDeselect === null || onDeselect === void 0 ? void 0 : onDeselect(selectInfo);
      } else {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(selectInfo);
      }
    }
    if (!multiple && mergedOpenKeys.length && internalMode !== "inline") {
      triggerOpenKeys(EMPTY_LIST$2);
    }
  };
  var onInternalClick = useMemoCallback(function(info) {
    onClick === null || onClick === void 0 ? void 0 : onClick(warnItemProp(info));
    triggerSelection(info);
  });
  var onInternalOpenChange = useMemoCallback(function(key, open2) {
    var newOpenKeys = mergedOpenKeys.filter(function(k2) {
      return k2 !== key;
    });
    if (open2) {
      newOpenKeys.push(key);
    } else if (internalMode !== "inline") {
      var subPathKeys = getSubPathKeys(key);
      newOpenKeys = newOpenKeys.filter(function(k2) {
        return !subPathKeys.has(k2);
      });
    }
    if (!isEqual$1(mergedOpenKeys, newOpenKeys, true)) {
      triggerOpenKeys(newOpenKeys, true);
    }
  });
  var getInternalPopupContainer = useMemoCallback(getPopupContainer);
  var triggerAccessibilityOpen = function triggerAccessibilityOpen2(key, open2) {
    var nextOpen = open2 !== null && open2 !== void 0 ? open2 : !mergedOpenKeys.includes(key);
    onInternalOpenChange(key, nextOpen);
  };
  var onInternalKeyDown = useAccessibility$1(internalMode, mergedActiveKey, isRtl, uuid2, containerRef, getKeys, getKeyPath, setMergedActiveKey, triggerAccessibilityOpen, onKeyDown2);
  react.exports.useEffect(function() {
    setMounted(true);
  }, []);
  var privateContext = react.exports.useMemo(function() {
    return {
      _internalRenderMenuItem,
      _internalRenderSubMenuItem
    };
  }, [_internalRenderMenuItem, _internalRenderSubMenuItem]);
  var wrappedChildList = internalMode !== "horizontal" || disabledOverflow ? childList : childList.map(function(child, index2) {
    return /* @__PURE__ */ jsx(InheritableContextProvider, {
      overflowDisabled: index2 > lastVisibleIndex,
      children: child
    }, child.key);
  });
  var container = /* @__PURE__ */ jsx(ForwardOverflow, {
    id: id2,
    ref: containerRef,
    prefixCls: "".concat(prefixCls, "-overflow"),
    component: "ul",
    itemComponent: MenuItem$1,
    className: classNames(prefixCls, "".concat(prefixCls, "-root"), "".concat(prefixCls, "-").concat(internalMode), className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-inline-collapsed"), internalInlineCollapsed), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), isRtl), _classNames), rootClassName),
    dir: direction,
    style: style2,
    role: "menu",
    tabIndex,
    data: wrappedChildList,
    renderRawItem: function renderRawItem(node2) {
      return node2;
    },
    renderRawRest: function renderRawRest(omitItems) {
      var len = omitItems.length;
      var originOmitItems = len ? childList.slice(-len) : null;
      return /* @__PURE__ */ jsx(SubMenu$2, {
        eventKey: OVERFLOW_KEY,
        title: overflowedIndicator,
        disabled: allVisible,
        internalPopupClose: len === 0,
        popupClassName: overflowedIndicatorPopupClassName,
        children: originOmitItems
      });
    },
    maxCount: internalMode !== "horizontal" || disabledOverflow ? ForwardOverflow.INVALIDATE : ForwardOverflow.RESPONSIVE,
    ssr: "full",
    "data-menu-list": true,
    onVisibleChange: function onVisibleChange(newLastIndex) {
      setLastVisibleIndex(newLastIndex);
    },
    onKeyDown: onInternalKeyDown,
    ...restProps
  });
  return /* @__PURE__ */ jsx(PrivateContext.Provider, {
    value: privateContext,
    children: /* @__PURE__ */ jsx(IdContext.Provider, {
      value: uuid2,
      children: /* @__PURE__ */ jsxs(InheritableContextProvider, {
        prefixCls,
        rootClassName,
        mode: internalMode,
        openKeys: mergedOpenKeys,
        rtl: isRtl,
        disabled,
        motion: mounted ? motion2 : null,
        defaultMotions: mounted ? defaultMotions : null,
        activeKey: mergedActiveKey,
        onActive,
        onInactive,
        selectedKeys: mergedSelectKeys,
        inlineIndent,
        subMenuOpenDelay,
        subMenuCloseDelay,
        forceSubMenuRender,
        builtinPlacements,
        triggerSubMenuAction,
        getPopupContainer: getInternalPopupContainer,
        itemIcon,
        expandIcon,
        onItemClick: onInternalClick,
        onOpenChange: onInternalOpenChange,
        children: [/* @__PURE__ */ jsx(PathUserContext.Provider, {
          value: pathUserContext,
          children: container
        }), /* @__PURE__ */ jsx("div", {
          style: {
            display: "none"
          },
          "aria-hidden": true,
          children: /* @__PURE__ */ jsx(PathRegisterContext.Provider, {
            value: registerPathContext,
            children: childList
          })
        })]
      })
    })
  });
});
var _excluded$b = ["className", "title", "eventKey", "children"], _excluded2$1 = ["children"];
var InternalMenuItemGroup = function InternalMenuItemGroup2(_ref) {
  var className = _ref.className, title = _ref.title;
  _ref.eventKey;
  var children = _ref.children, restProps = _objectWithoutProperties(_ref, _excluded$b);
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
  var groupPrefixCls = "".concat(prefixCls, "-item-group");
  return /* @__PURE__ */ jsxs("li", {
    role: "presentation",
    ...restProps,
    onClick: function onClick(e2) {
      return e2.stopPropagation();
    },
    className: classNames(groupPrefixCls, className),
    children: [/* @__PURE__ */ jsx("div", {
      role: "presentation",
      className: "".concat(groupPrefixCls, "-title"),
      title: typeof title === "string" ? title : void 0,
      children: title
    }), /* @__PURE__ */ jsx("ul", {
      role: "group",
      className: "".concat(groupPrefixCls, "-list"),
      children
    })]
  });
};
function MenuItemGroup(_ref2) {
  var children = _ref2.children, props = _objectWithoutProperties(_ref2, _excluded2$1);
  var connectedKeyPath = useFullPath(props.eventKey);
  var childList = parseChildren(children, connectedKeyPath);
  var measure = useMeasure();
  if (measure) {
    return childList;
  }
  return /* @__PURE__ */ jsx(InternalMenuItemGroup, {
    ...omit(props, ["warnKey"]),
    children: childList
  });
}
function Divider$2(_ref) {
  var className = _ref.className, style2 = _ref.style;
  var _React$useContext = react.exports.useContext(MenuContext$2), prefixCls = _React$useContext.prefixCls;
  var measure = useMeasure();
  if (measure) {
    return null;
  }
  return /* @__PURE__ */ jsx("li", {
    className: classNames("".concat(prefixCls, "-item-divider"), className),
    style: style2
  });
}
var ExportMenu = Menu$2;
ExportMenu.Item = MenuItem$1;
ExportMenu.SubMenu = SubMenu$2;
ExportMenu.ItemGroup = MenuItemGroup;
ExportMenu.Divider = Divider$2;
var EllipsisOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "ellipsis", "theme": "outlined" };
const EllipsisOutlinedSvg = EllipsisOutlined$2;
var EllipsisOutlined = function EllipsisOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: EllipsisOutlinedSvg
    })
  });
};
EllipsisOutlined.displayName = "EllipsisOutlined";
const EllipsisOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EllipsisOutlined);
const getHorizontalStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    menuHorizontalHeight,
    colorSplit,
    lineWidth,
    lineType,
    menuItemPaddingInline
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      lineHeight: `${menuHorizontalHeight}px`,
      border: 0,
      borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      [`${componentCls}-item, ${componentCls}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: menuItemPaddingInline
      },
      [`> ${componentCls}-item:hover,
        > ${componentCls}-item-active,
        > ${componentCls}-submenu ${componentCls}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`].join(",")
      },
      [`${componentCls}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
};
const getHorizontalStyle$1 = getHorizontalStyle;
const getRTLStyle = (_ref) => {
  let {
    componentCls,
    menuArrowOffset
  } = _ref;
  return {
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    [`${componentCls}-rtl${componentCls}-vertical,
    ${componentCls}-submenu-rtl ${componentCls}-vertical`]: {
      [`${componentCls}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(-${menuArrowOffset})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${menuArrowOffset})`
        }
      }
    }
  };
};
const getRTLStyle$1 = getRTLStyle;
const accessibilityFocus = (token2) => Object.assign({}, genFocusOutline(token2));
const getThemeStyle = (token2, themeSuffix) => {
  const {
    componentCls,
    colorItemText,
    colorItemTextSelected,
    colorGroupTitle,
    colorItemBg,
    colorSubItemBg,
    colorItemBgSelected,
    colorActiveBarHeight,
    colorActiveBarWidth,
    colorActiveBarBorderSize,
    motionDurationSlow,
    motionEaseInOut,
    motionEaseOut,
    menuItemPaddingInline,
    motionDurationMid,
    colorItemTextHover,
    lineType,
    colorSplit,
    colorItemTextDisabled,
    colorDangerItemText,
    colorDangerItemTextHover,
    colorDangerItemTextSelected,
    colorDangerItemBgActive,
    colorDangerItemBgSelected,
    colorItemBgHover,
    menuSubMenuBg,
    colorItemTextSelectedHorizontal,
    colorItemBgSelectedHorizontal
  } = token2;
  return {
    [`${componentCls}-${themeSuffix}`]: {
      color: colorItemText,
      background: colorItemBg,
      [`&${componentCls}-root:focus-visible`]: Object.assign({}, accessibilityFocus(token2)),
      [`${componentCls}-item-group-title`]: {
        color: colorGroupTitle
      },
      [`${componentCls}-submenu-selected`]: {
        [`> ${componentCls}-submenu-title`]: {
          color: colorItemTextSelected
        }
      },
      [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
        color: `${colorItemTextDisabled} !important`
      },
      [`${componentCls}-item:hover, ${componentCls}-submenu-title:hover`]: {
        [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
          color: colorItemTextHover
        }
      },
      [`&:not(${componentCls}-horizontal)`]: {
        [`${componentCls}-item:not(${componentCls}-item-selected)`]: {
          "&:hover": {
            backgroundColor: colorItemBgHover
          },
          "&:active": {
            backgroundColor: colorItemBgSelected
          }
        },
        [`${componentCls}-submenu-title`]: {
          "&:hover": {
            backgroundColor: colorItemBgHover
          },
          "&:active": {
            backgroundColor: colorItemBgSelected
          }
        }
      },
      [`${componentCls}-item-danger`]: {
        color: colorDangerItemText,
        [`&${componentCls}-item:hover`]: {
          [`&:not(${componentCls}-item-selected):not(${componentCls}-submenu-selected)`]: {
            color: colorDangerItemTextHover
          }
        },
        [`&${componentCls}-item:active`]: {
          background: colorDangerItemBgActive
        }
      },
      [`${componentCls}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${componentCls}-item-selected`]: {
        color: colorItemTextSelected,
        [`&${componentCls}-item-danger`]: {
          color: colorDangerItemTextSelected
        },
        [`a, a:hover`]: {
          color: "inherit"
        }
      },
      [`& ${componentCls}-item-selected`]: {
        backgroundColor: colorItemBgSelected,
        [`&${componentCls}-item-danger`]: {
          backgroundColor: colorDangerItemBgSelected
        }
      },
      [`${componentCls}-item, ${componentCls}-submenu-title`]: {
        [`&:not(${componentCls}-item-disabled):focus-visible`]: Object.assign({}, accessibilityFocus(token2))
      },
      [`&${componentCls}-submenu > ${componentCls}`]: {
        backgroundColor: menuSubMenuBg
      },
      [`&${componentCls}-popup > ${componentCls}`]: {
        backgroundColor: colorItemBg
      },
      [`&${componentCls}-horizontal`]: Object.assign(Object.assign({}, themeSuffix === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${componentCls}-item, > ${componentCls}-submenu`]: {
          top: colorActiveBarBorderSize,
          marginTop: -colorActiveBarBorderSize,
          marginBottom: 0,
          borderRadius: 0,
          "&::after": {
            position: "absolute",
            insetInline: menuItemPaddingInline,
            bottom: 0,
            borderBottom: `${colorActiveBarHeight}px solid transparent`,
            transition: `border-color ${motionDurationSlow} ${motionEaseInOut}`,
            content: '""'
          },
          [`&:hover, &-active, &-open`]: {
            "&::after": {
              borderBottomWidth: colorActiveBarHeight,
              borderBottomColor: colorItemTextSelectedHorizontal
            }
          },
          [`&-selected`]: {
            color: colorItemTextSelectedHorizontal,
            backgroundColor: colorItemBgSelectedHorizontal,
            "&::after": {
              borderBottomWidth: colorActiveBarHeight,
              borderBottomColor: colorItemTextSelectedHorizontal
            }
          }
        }
      }),
      [`&${componentCls}-root`]: {
        [`&${componentCls}-inline, &${componentCls}-vertical`]: {
          borderInlineEnd: `${colorActiveBarBorderSize}px ${lineType} ${colorSplit}`
        }
      },
      [`&${componentCls}-inline`]: {
        [`${componentCls}-sub${componentCls}-inline`]: {
          background: colorSubItemBg
        },
        [`${componentCls}-item, ${componentCls}-submenu-title`]: colorActiveBarBorderSize && colorActiveBarWidth ? {
          width: `calc(100% + ${colorActiveBarBorderSize}px)`
        } : {},
        [`${componentCls}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${colorActiveBarWidth}px solid ${colorItemTextSelected}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${motionDurationMid} ${motionEaseOut}`, `opacity ${motionDurationMid} ${motionEaseOut}`].join(","),
            content: '""'
          },
          [`&${componentCls}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: colorDangerItemTextSelected
            }
          }
        },
        [`${componentCls}-selected, ${componentCls}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${motionDurationMid} ${motionEaseInOut}`, `opacity ${motionDurationMid} ${motionEaseInOut}`].join(",")
          }
        }
      }
    }
  };
};
const getThemeStyle$1 = getThemeStyle;
const getVerticalInlineStyle = (token2) => {
  const {
    componentCls,
    menuItemHeight,
    itemMarginInline,
    padding,
    menuArrowSize,
    marginXS,
    marginXXS
  } = token2;
  const paddingWithArrow = padding + menuArrowSize + marginXS;
  return {
    [`${componentCls}-item`]: {
      position: "relative"
    },
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      height: menuItemHeight,
      lineHeight: `${menuItemHeight}px`,
      paddingInline: padding,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: itemMarginInline,
      marginBlock: marginXXS,
      width: `calc(100% - ${itemMarginInline * 2}px)`
    },
    [`${componentCls}-submenu`]: {
      paddingBottom: 0.02
    },
    [`> ${componentCls}-item,
            > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
      height: menuItemHeight,
      lineHeight: `${menuItemHeight}px`
    },
    [`${componentCls}-item-group-list ${componentCls}-submenu-title,
            ${componentCls}-submenu-title`]: {
      paddingInlineEnd: paddingWithArrow
    }
  };
};
const getVerticalStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    menuItemHeight,
    colorTextLightSolid,
    dropdownWidth,
    controlHeightLG,
    motionDurationMid,
    motionEaseOut,
    paddingXL,
    fontSizeSM,
    fontSizeLG,
    motionDurationSlow,
    paddingXS,
    boxShadowSecondary
  } = token2;
  const inlineItemStyle = {
    height: menuItemHeight,
    lineHeight: `${menuItemHeight}px`,
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [componentCls]: {
        [`&-inline, &-vertical`]: Object.assign({
          [`&${componentCls}-root`]: {
            boxShadow: "none"
          }
        }, getVerticalInlineStyle(token2))
      },
      [`${componentCls}-submenu-popup`]: {
        [`${componentCls}-vertical`]: Object.assign(Object.assign({}, getVerticalInlineStyle(token2)), {
          boxShadow: boxShadowSecondary
        })
      }
    },
    {
      [`${componentCls}-submenu-popup ${componentCls}-vertical${componentCls}-sub`]: {
        minWidth: dropdownWidth,
        maxHeight: `calc(100vh - ${controlHeightLG * 2.5}px)`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    {
      [`${componentCls}-inline`]: {
        width: "100%",
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationMid} ${motionEaseOut}`].join(","),
            [`> ${componentCls}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        [`${componentCls}-sub${componentCls}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${componentCls}-submenu > ${componentCls}-submenu-title`]: inlineItemStyle,
          [`& ${componentCls}-item-group-title`]: {
            paddingInlineStart: paddingXL
          }
        },
        [`${componentCls}-item`]: inlineItemStyle
      }
    },
    {
      [`${componentCls}-inline-collapsed`]: {
        width: menuItemHeight * 2,
        [`&${componentCls}-root`]: {
          [`${componentCls}-item, ${componentCls}-submenu ${componentCls}-submenu-title`]: {
            [`> ${componentCls}-inline-collapsed-noicon`]: {
              fontSize: fontSizeLG,
              textAlign: "center"
            }
          }
        },
        [`> ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-item,
          > ${componentCls}-item-group > ${componentCls}-item-group-list > ${componentCls}-submenu > ${componentCls}-submenu-title,
          > ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${fontSizeSM}px)`,
          textOverflow: "clip",
          [`
            ${componentCls}-submenu-arrow,
            ${componentCls}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${componentCls}-item-icon, ${iconCls}`]: {
            margin: 0,
            fontSize: fontSizeLG,
            lineHeight: `${menuItemHeight}px`,
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${componentCls}-item-icon, ${iconCls}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${componentCls}-item-icon, ${iconCls}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: colorTextLightSolid
          }
        },
        [`${componentCls}-item-group-title`]: Object.assign(Object.assign({}, textEllipsis), {
          paddingInline: paddingXS
        })
      }
    }
  ];
};
const getVerticalStyle$1 = getVerticalStyle;
const genMenuItemStyle = (token2) => {
  const {
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    motionEaseOut,
    iconCls,
    controlHeightSM
  } = token2;
  return {
    [`${componentCls}-item, ${componentCls}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${motionDurationSlow}`, `background ${motionDurationSlow}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(","),
      [`${componentCls}-item-icon, ${iconCls}`]: {
        minWidth: fontSize,
        fontSize,
        transition: [`font-size ${motionDurationMid} ${motionEaseOut}`, `margin ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow}`].join(","),
        "+ span": {
          marginInlineStart: controlHeightSM - fontSize,
          opacity: 1,
          transition: [`opacity ${motionDurationSlow} ${motionEaseInOut}`, `margin ${motionDurationSlow}`, `color ${motionDurationSlow}`].join(",")
        }
      },
      [`${componentCls}-item-icon`]: Object.assign({}, resetIcon()),
      [`&${componentCls}-item-only-child`]: {
        [`> ${iconCls}, > ${componentCls}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    [`${componentCls}-item-disabled, ${componentCls}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${componentCls}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
};
const genSubMenuArrowStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow,
    motionEaseInOut,
    borderRadius,
    menuArrowSize,
    menuArrowOffset
  } = token2;
  return {
    [`${componentCls}-submenu`]: {
      [`&-expand-icon, &-arrow`]: {
        position: "absolute",
        top: "50%",
        insetInlineEnd: token2.margin,
        width: menuArrowSize,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${motionDurationSlow} ${motionEaseInOut}, opacity ${motionDurationSlow}`
      },
      "&-arrow": {
        "&::before, &::after": {
          position: "absolute",
          width: menuArrowSize * 0.6,
          height: menuArrowSize * 0.15,
          backgroundColor: "currentcolor",
          borderRadius,
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `transform ${motionDurationSlow} ${motionEaseInOut}`, `top ${motionDurationSlow} ${motionEaseInOut}`, `color ${motionDurationSlow} ${motionEaseInOut}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(-${menuArrowOffset})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${menuArrowOffset})`
        }
      }
    }
  };
};
const getBaseStyle = (token2) => {
  const {
    antCls,
    componentCls,
    fontSize,
    motionDurationSlow,
    motionDurationMid,
    motionEaseInOut,
    lineHeight,
    paddingXS,
    padding,
    colorSplit,
    lineWidth,
    zIndexPopup,
    borderRadiusLG,
    radiusSubMenuItem,
    menuArrowSize,
    menuArrowOffset,
    lineType,
    menuPanelMaskInset
  } = token2;
  return [
    {
      "": {
        [`${componentCls}`]: Object.assign(Object.assign({}, clearFix()), {
          [`&-hidden`]: {
            display: "none"
          }
        })
      },
      [`${componentCls}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), clearFix()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        fontSize,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        transition: [
          `background ${motionDurationSlow}`,
          `width ${motionDurationSlow} cubic-bezier(0.2, 0, 0, 1) 0s`
        ].join(","),
        [`ul, ol`]: {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        [`&-overflow`]: {
          display: "flex",
          [`${componentCls}-item`]: {
            flex: "none"
          }
        },
        [`${componentCls}-item, ${componentCls}-submenu, ${componentCls}-submenu-title`]: {
          borderRadius: token2.radiusItem
        },
        [`${componentCls}-item-group-title`]: {
          padding: `${paddingXS}px ${padding}px`,
          fontSize,
          lineHeight,
          transition: `all ${motionDurationSlow}`
        },
        [`&-horizontal ${componentCls}-submenu`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu, ${componentCls}-submenu-inline`]: {
          transition: [`border-color ${motionDurationSlow} ${motionEaseInOut}`, `background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationMid} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-submenu ${componentCls}-sub`]: {
          cursor: "initial",
          transition: [`background ${motionDurationSlow} ${motionEaseInOut}`, `padding ${motionDurationSlow} ${motionEaseInOut}`].join(",")
        },
        [`${componentCls}-title-content`]: {
          transition: `color ${motionDurationSlow}`
        },
        [`${componentCls}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        [`${componentCls}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: colorSplit,
          borderStyle: lineType,
          borderWidth: 0,
          borderTopWidth: lineWidth,
          marginBlock: lineWidth,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), genMenuItemStyle(token2)), {
        [`${componentCls}-item-group`]: {
          [`${componentCls}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${componentCls}-item, ${componentCls}-submenu-title`]: {
              paddingInline: `${fontSize * 2}px ${padding}px`
            }
          }
        },
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: zIndexPopup,
            background: "transparent",
            borderRadius: borderRadiusLG,
            boxShadow: "none",
            transformOrigin: "0 0",
            "&::before": {
              position: "absolute",
              inset: `${menuPanelMaskInset}px 0 0`,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            }
          },
          "&-placement-rightTop::before": {
            top: 0,
            insetInlineStart: menuPanelMaskInset
          },
          [`> ${componentCls}`]: Object.assign(Object.assign(Object.assign({
            borderRadius: borderRadiusLG
          }, genMenuItemStyle(token2)), genSubMenuArrowStyle(token2)), {
            [`${componentCls}-item, ${componentCls}-submenu > ${componentCls}-submenu-title`]: {
              borderRadius: radiusSubMenuItem
            },
            [`${componentCls}-submenu-title::after`]: {
              transition: `transform ${motionDurationSlow} ${motionEaseInOut}`
            }
          })
        }
      }), genSubMenuArrowStyle(token2)), {
        [`&-inline-collapsed ${componentCls}-submenu-arrow,
        &-inline ${componentCls}-submenu-arrow`]: {
          "&::before": {
            transform: `rotate(-45deg) translateX(${menuArrowOffset})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(-${menuArrowOffset})`
          }
        },
        [`${componentCls}-submenu-open${componentCls}-submenu-inline > ${componentCls}-submenu-title > ${componentCls}-submenu-arrow`]: {
          transform: `translateY(-${menuArrowSize * 0.2}px)`,
          "&::after": {
            transform: `rotate(-45deg) translateX(-${menuArrowOffset})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${menuArrowOffset})`
          }
        }
      })
    },
    {
      [`${antCls}-layout-header`]: {
        [componentCls]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
};
const useStyle$h = (prefixCls, injectStyle) => {
  const useOriginHook = genComponentStyleHook("Menu", (token2, _ref) => {
    let {
      overrideComponentToken
    } = _ref;
    if (injectStyle === false) {
      return [];
    }
    const {
      colorBgElevated,
      colorPrimary,
      colorError,
      colorErrorHover,
      colorTextLightSolid
    } = token2;
    const {
      controlHeightLG,
      fontSize
    } = token2;
    const menuArrowSize = fontSize / 7 * 5;
    const menuToken = merge(token2, {
      menuItemHeight: controlHeightLG,
      menuItemPaddingInline: token2.margin,
      menuArrowSize,
      menuHorizontalHeight: controlHeightLG * 1.15,
      menuArrowOffset: `${menuArrowSize * 0.25}px`,
      menuPanelMaskInset: -7,
      menuSubMenuBg: colorBgElevated
    });
    const colorTextDark = new TinyColor(colorTextLightSolid).setAlpha(0.65).toRgbString();
    const menuDarkToken = merge(menuToken, {
      colorItemText: colorTextDark,
      colorItemTextHover: colorTextLightSolid,
      colorGroupTitle: colorTextDark,
      colorItemTextSelected: colorTextLightSolid,
      colorItemBg: "#001529",
      colorSubItemBg: "#000c17",
      colorItemBgActive: "transparent",
      colorItemBgSelected: colorPrimary,
      colorActiveBarWidth: 0,
      colorActiveBarHeight: 0,
      colorActiveBarBorderSize: 0,
      colorItemTextDisabled: new TinyColor(colorTextLightSolid).setAlpha(0.25).toRgbString(),
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorErrorHover,
      colorDangerItemTextSelected: colorTextLightSolid,
      colorDangerItemBgActive: colorError,
      colorDangerItemBgSelected: colorError,
      menuSubMenuBg: "#001529",
      colorItemTextSelectedHorizontal: colorTextLightSolid,
      colorItemBgSelectedHorizontal: colorPrimary
    }, Object.assign({}, overrideComponentToken));
    return [
      getBaseStyle(menuToken),
      getHorizontalStyle$1(menuToken),
      getVerticalStyle$1(menuToken),
      getThemeStyle$1(menuToken, "light"),
      getThemeStyle$1(menuDarkToken, "dark"),
      getRTLStyle$1(menuToken),
      genCollapseMotion$1(menuToken),
      initSlideMotion(menuToken, "slide-up"),
      initSlideMotion(menuToken, "slide-down"),
      initZoomMotion(menuToken, "zoom-big")
    ];
  }, (token2) => {
    const {
      colorPrimary,
      colorError,
      colorTextDisabled,
      colorErrorBg,
      colorText,
      colorTextDescription,
      colorBgContainer,
      colorFillAlter,
      colorFillContent,
      lineWidth,
      lineWidthBold,
      controlItemBgActive,
      colorBgTextHover
    } = token2;
    return {
      dropdownWidth: 160,
      zIndexPopup: token2.zIndexPopupBase + 50,
      radiusItem: token2.borderRadiusLG,
      radiusSubMenuItem: token2.borderRadiusSM,
      colorItemText: colorText,
      colorItemTextHover: colorText,
      colorItemTextHoverHorizontal: colorPrimary,
      colorGroupTitle: colorTextDescription,
      colorItemTextSelected: colorPrimary,
      colorItemTextSelectedHorizontal: colorPrimary,
      colorItemBg: colorBgContainer,
      colorItemBgHover: colorBgTextHover,
      colorItemBgActive: colorFillContent,
      colorSubItemBg: colorFillAlter,
      colorItemBgSelected: controlItemBgActive,
      colorItemBgSelectedHorizontal: "transparent",
      colorActiveBarWidth: 0,
      colorActiveBarHeight: lineWidthBold,
      colorActiveBarBorderSize: lineWidth,
      colorItemTextDisabled: colorTextDisabled,
      colorDangerItemText: colorError,
      colorDangerItemTextHover: colorError,
      colorDangerItemTextSelected: colorError,
      colorDangerItemBgActive: colorErrorBg,
      colorDangerItemBgSelected: colorErrorBg,
      itemMarginInline: token2.marginXXS
    };
  });
  return useOriginHook(prefixCls);
};
var __rest$E = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const OverrideContext = /* @__PURE__ */ react.exports.createContext(null);
const OverrideProvider = (props) => {
  const {
    children
  } = props, restProps = __rest$E(props, ["children"]);
  const override = react.exports.useContext(OverrideContext);
  const context = react.exports.useMemo(() => Object.assign(Object.assign({}, override), restProps), [
    override,
    restProps.prefixCls,
    restProps.mode,
    restProps.selectable
  ]);
  return /* @__PURE__ */ jsx(OverrideContext.Provider, {
    value: context,
    children
  });
};
const OverrideContext$1 = OverrideContext;
var __rest$D = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const MenuDivider = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    dashed
  } = props, restProps = __rest$D(props, ["prefixCls", "className", "dashed"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("menu", customizePrefixCls);
  const classString = classNames({
    [`${prefixCls}-item-divider-dashed`]: !!dashed
  }, className);
  return /* @__PURE__ */ jsx(Divider$2, {
    ...Object.assign({
      className: classString
    }, restProps)
  });
};
const MenuDivider$1 = MenuDivider;
var BarsOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "bars", "theme": "outlined" };
const BarsOutlinedSvg = BarsOutlined$2;
var BarsOutlined = function BarsOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: BarsOutlinedSvg
    })
  });
};
BarsOutlined.displayName = "BarsOutlined";
const BarsOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(BarsOutlined);
var LeftOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, "name": "left", "theme": "outlined" };
const LeftOutlinedSvg = LeftOutlined$2;
var LeftOutlined = function LeftOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: LeftOutlinedSvg
    })
  });
};
LeftOutlined.displayName = "LeftOutlined";
const LeftOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LeftOutlined);
var RightOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, "name": "right", "theme": "outlined" };
const RightOutlinedSvg = RightOutlined$2;
var RightOutlined = function RightOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: RightOutlinedSvg
    })
  });
};
RightOutlined.displayName = "RightOutlined";
const RightOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(RightOutlined);
const isNumeric = (value) => !isNaN(parseFloat(value)) && isFinite(value);
const isNumeric$1 = isNumeric;
const genLayoutLightStyle = (token2) => {
  const {
    componentCls,
    colorBgContainer,
    colorBgBody,
    colorText
  } = token2;
  return {
    [`${componentCls}-sider-light`]: {
      background: colorBgContainer,
      [`${componentCls}-sider-trigger`]: {
        color: colorText,
        background: colorBgContainer
      },
      [`${componentCls}-sider-zero-width-trigger`]: {
        color: colorText,
        background: colorBgContainer,
        border: `1px solid ${colorBgBody}`,
        borderInlineStart: 0
      }
    }
  };
};
const genLayoutLightStyle$1 = genLayoutLightStyle;
const genLayoutStyle = (token2) => {
  const {
    antCls,
    componentCls,
    colorText,
    colorTextLightSolid,
    colorBgHeader,
    colorBgBody,
    colorBgTrigger,
    layoutHeaderHeight,
    layoutHeaderPaddingInline,
    layoutHeaderColor,
    layoutFooterPadding,
    layoutTriggerHeight,
    layoutZeroTriggerSize,
    motionDurationMid,
    motionDurationSlow,
    fontSize,
    borderRadius
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      minHeight: 0,
      background: colorBgBody,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${componentCls}-has-sider`]: {
        flexDirection: "row",
        [`> ${componentCls}, > ${componentCls}-content`]: {
          width: 0
        }
      },
      [`${componentCls}-header, &${componentCls}-footer`]: {
        flex: "0 0 auto"
      },
      [`${componentCls}-sider`]: {
        position: "relative",
        minWidth: 0,
        background: colorBgHeader,
        transition: `all ${motionDurationMid}`,
        "&-children": {
          height: "100%",
          marginTop: -0.1,
          paddingTop: 0.1,
          [`${antCls}-menu${antCls}-menu-inline-collapsed`]: {
            width: "auto"
          }
        },
        "&-has-trigger": {
          paddingBottom: layoutTriggerHeight
        },
        "&-right": {
          order: 1
        },
        "&-trigger": {
          position: "fixed",
          bottom: 0,
          zIndex: 1,
          height: layoutTriggerHeight,
          color: colorTextLightSolid,
          lineHeight: `${layoutTriggerHeight}px`,
          textAlign: "center",
          background: colorBgTrigger,
          cursor: "pointer",
          transition: `all ${motionDurationMid}`
        },
        "&-zero-width": {
          "> *": {
            overflow: "hidden"
          },
          "&-trigger": {
            position: "absolute",
            top: layoutHeaderHeight,
            insetInlineEnd: -layoutZeroTriggerSize,
            zIndex: 1,
            width: layoutZeroTriggerSize,
            height: layoutZeroTriggerSize,
            color: colorTextLightSolid,
            fontSize: token2.fontSizeXL,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            background: colorBgHeader,
            borderStartStartRadius: 0,
            borderStartEndRadius: borderRadius,
            borderEndEndRadius: borderRadius,
            borderEndStartRadius: 0,
            cursor: "pointer",
            transition: `background ${motionDurationSlow} ease`,
            "&::after": {
              position: "absolute",
              inset: 0,
              background: "transparent",
              transition: `all ${motionDurationSlow}`,
              content: '""'
            },
            "&:hover::after": {
              background: `rgba(255, 255, 255, 0.2)`
            },
            "&-right": {
              insetInlineStart: -layoutZeroTriggerSize,
              borderStartStartRadius: borderRadius,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: borderRadius
            }
          }
        }
      }
    }, genLayoutLightStyle$1(token2)), {
      "&-rtl": {
        direction: "rtl"
      }
    }),
    [`${componentCls}-header`]: {
      height: layoutHeaderHeight,
      paddingInline: layoutHeaderPaddingInline,
      color: layoutHeaderColor,
      lineHeight: `${layoutHeaderHeight}px`,
      background: colorBgHeader,
      [`${antCls}-menu`]: {
        lineHeight: "inherit"
      }
    },
    [`${componentCls}-footer`]: {
      padding: layoutFooterPadding,
      color: colorText,
      fontSize,
      background: colorBgBody
    },
    [`${componentCls}-content`]: {
      flex: "auto",
      minHeight: 0
    }
  };
};
const useStyle$g = genComponentStyleHook("Layout", (token2) => {
  const {
    colorText,
    controlHeightSM,
    controlHeight,
    controlHeightLG,
    marginXXS
  } = token2;
  const layoutHeaderPaddingInline = controlHeightLG * 1.25;
  const layoutToken = merge(token2, {
    layoutHeaderHeight: controlHeight * 2,
    layoutHeaderPaddingInline,
    layoutHeaderColor: colorText,
    layoutFooterPadding: `${controlHeightSM}px ${layoutHeaderPaddingInline}px`,
    layoutTriggerHeight: controlHeightLG + marginXXS * 2,
    layoutZeroTriggerSize: controlHeightLG
  });
  return [genLayoutStyle(layoutToken)];
}, (token2) => {
  const {
    colorBgLayout
  } = token2;
  return {
    colorBgHeader: "#001529",
    colorBgBody: colorBgLayout,
    colorBgTrigger: "#002140"
  };
});
var __rest$C = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const LayoutContext = /* @__PURE__ */ react.exports.createContext({
  siderHook: {
    addSider: () => null,
    removeSider: () => null
  }
});
function generator(_ref) {
  let {
    suffixCls,
    tagName,
    displayName
  } = _ref;
  return (BasicComponent) => {
    const Adapter = /* @__PURE__ */ react.exports.forwardRef((props, ref) => /* @__PURE__ */ jsx(BasicComponent, {
      ...Object.assign({
        ref,
        suffixCls,
        tagName
      }, props)
    }));
    return Adapter;
  };
}
const Basic = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    suffixCls,
    className,
    tagName: TagName
  } = props, others = __rest$C(props, ["prefixCls", "suffixCls", "className", "tagName"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$g(prefixCls);
  const prefixWithSuffixCls = suffixCls ? `${prefixCls}-${suffixCls}` : prefixCls;
  return wrapSSR(
    /* @__PURE__ */ jsx(TagName, {
      ...Object.assign({
        className: classNames(customizePrefixCls || prefixWithSuffixCls, className, hashId),
        ref
      }, others)
    })
  );
});
const BasicLayout = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    direction
  } = react.exports.useContext(ConfigContext);
  const [siders, setSiders] = react.exports.useState([]);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    hasSider,
    tagName: Tag
  } = props, others = __rest$C(props, ["prefixCls", "className", "rootClassName", "children", "hasSider", "tagName"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("layout", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$g(prefixCls);
  const classString = classNames(prefixCls, {
    [`${prefixCls}-has-sider`]: typeof hasSider === "boolean" ? hasSider : siders.length > 0,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  const contextValue = react.exports.useMemo(() => ({
    siderHook: {
      addSider: (id2) => {
        setSiders((prev2) => [].concat(_toConsumableArray(prev2), [id2]));
      },
      removeSider: (id2) => {
        setSiders((prev2) => prev2.filter((currentId) => currentId !== id2));
      }
    }
  }), []);
  return wrapSSR(
    /* @__PURE__ */ jsx(LayoutContext.Provider, {
      value: contextValue,
      children: /* @__PURE__ */ jsx(Tag, {
        ...Object.assign({
          ref,
          className: classString
        }, others),
        children
      })
    })
  );
});
const Layout$2 = generator({
  tagName: "section",
  displayName: "Layout"
})(BasicLayout);
const Header$2 = generator({
  suffixCls: "header",
  tagName: "header",
  displayName: "Header"
})(Basic);
const Footer$1 = generator({
  suffixCls: "footer",
  tagName: "footer",
  displayName: "Footer"
})(Basic);
const Content$1 = generator({
  suffixCls: "content",
  tagName: "main",
  displayName: "Content"
})(Basic);
var __rest$B = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const dimensionMaxMap = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px"
};
const SiderContext = /* @__PURE__ */ react.exports.createContext({});
const generateId = (() => {
  let i2 = 0;
  return function() {
    let prefix = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    i2 += 1;
    return `${prefix}${i2}`;
  };
})();
const Sider$1 = /* @__PURE__ */ react.exports.forwardRef((_a, ref) => {
  var {
    prefixCls: customizePrefixCls,
    className,
    trigger,
    children,
    defaultCollapsed = false,
    theme: theme2 = "dark",
    style: style2 = {},
    collapsible = false,
    reverseArrow = false,
    width = 200,
    collapsedWidth = 80,
    zeroWidthTriggerStyle,
    breakpoint,
    onCollapse,
    onBreakpoint
  } = _a, props = __rest$B(_a, ["prefixCls", "className", "trigger", "children", "defaultCollapsed", "theme", "style", "collapsible", "reverseArrow", "width", "collapsedWidth", "zeroWidthTriggerStyle", "breakpoint", "onCollapse", "onBreakpoint"]);
  const {
    siderHook
  } = react.exports.useContext(LayoutContext);
  const [collapsed, setCollapsed] = react.exports.useState("collapsed" in props ? props.collapsed : defaultCollapsed);
  const [below, setBelow] = react.exports.useState(false);
  react.exports.useEffect(() => {
    if ("collapsed" in props) {
      setCollapsed(props.collapsed);
    }
  }, [props.collapsed]);
  const handleSetCollapsed = (value, type4) => {
    if (!("collapsed" in props)) {
      setCollapsed(value);
    }
    onCollapse === null || onCollapse === void 0 ? void 0 : onCollapse(value, type4);
  };
  const responsiveHandlerRef = react.exports.useRef();
  responsiveHandlerRef.current = (mql) => {
    setBelow(mql.matches);
    onBreakpoint === null || onBreakpoint === void 0 ? void 0 : onBreakpoint(mql.matches);
    if (collapsed !== mql.matches) {
      handleSetCollapsed(mql.matches, "responsive");
    }
  };
  react.exports.useEffect(() => {
    function responsiveHandler(mql2) {
      return responsiveHandlerRef.current(mql2);
    }
    let mql;
    if (typeof window !== "undefined") {
      const {
        matchMedia
      } = window;
      if (matchMedia && breakpoint && breakpoint in dimensionMaxMap) {
        mql = matchMedia(`(max-width: ${dimensionMaxMap[breakpoint]})`);
        try {
          mql.addEventListener("change", responsiveHandler);
        } catch (error) {
          mql.addListener(responsiveHandler);
        }
        responsiveHandler(mql);
      }
    }
    return () => {
      try {
        mql === null || mql === void 0 ? void 0 : mql.removeEventListener("change", responsiveHandler);
      } catch (error) {
        mql === null || mql === void 0 ? void 0 : mql.removeListener(responsiveHandler);
      }
    };
  }, [breakpoint]);
  react.exports.useEffect(() => {
    const uniqueId = generateId("ant-sider-");
    siderHook.addSider(uniqueId);
    return () => siderHook.removeSider(uniqueId);
  }, []);
  const toggle = () => {
    handleSetCollapsed(!collapsed, "clickTrigger");
  };
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const renderSider = () => {
    const prefixCls = getPrefixCls("layout-sider", customizePrefixCls);
    const divProps = omit(props, ["collapsed"]);
    const rawWidth = collapsed ? collapsedWidth : width;
    const siderWidth = isNumeric$1(rawWidth) ? `${rawWidth}px` : String(rawWidth);
    const zeroWidthTrigger = parseFloat(String(collapsedWidth || 0)) === 0 ? /* @__PURE__ */ jsx("span", {
      onClick: toggle,
      className: classNames(`${prefixCls}-zero-width-trigger`, `${prefixCls}-zero-width-trigger-${reverseArrow ? "right" : "left"}`),
      style: zeroWidthTriggerStyle,
      children: trigger || /* @__PURE__ */ jsx(BarsOutlined$1, {})
    }) : null;
    const iconObj = {
      expanded: reverseArrow ? /* @__PURE__ */ jsx(RightOutlined$1, {}) : /* @__PURE__ */ jsx(LeftOutlined$1, {}),
      collapsed: reverseArrow ? /* @__PURE__ */ jsx(LeftOutlined$1, {}) : /* @__PURE__ */ jsx(RightOutlined$1, {})
    };
    const status = collapsed ? "collapsed" : "expanded";
    const defaultTrigger = iconObj[status];
    const triggerDom = trigger !== null ? zeroWidthTrigger || /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-trigger`,
      onClick: toggle,
      style: {
        width: siderWidth
      },
      children: trigger || defaultTrigger
    }) : null;
    const divStyle = Object.assign(Object.assign({}, style2), {
      flex: `0 0 ${siderWidth}`,
      maxWidth: siderWidth,
      minWidth: siderWidth,
      width: siderWidth
    });
    const siderCls = classNames(prefixCls, `${prefixCls}-${theme2}`, {
      [`${prefixCls}-collapsed`]: !!collapsed,
      [`${prefixCls}-has-trigger`]: collapsible && trigger !== null && !zeroWidthTrigger,
      [`${prefixCls}-below`]: !!below,
      [`${prefixCls}-zero-width`]: parseFloat(siderWidth) === 0
    }, className);
    return /* @__PURE__ */ jsxs("aside", {
      ...Object.assign({
        className: siderCls
      }, divProps, {
        style: divStyle,
        ref
      }),
      children: [/* @__PURE__ */ jsx("div", {
        className: `${prefixCls}-children`,
        children
      }), collapsible || below && zeroWidthTrigger ? triggerDom : null]
    });
  };
  const contextValue = react.exports.useMemo(() => ({
    siderCollapsed: collapsed
  }), [collapsed]);
  return /* @__PURE__ */ jsx(SiderContext.Provider, {
    value: contextValue,
    children: renderSider()
  });
});
const Sider$2 = Sider$1;
const MenuContext = /* @__PURE__ */ react.exports.createContext({
  prefixCls: "",
  firstLevel: true,
  inlineCollapsed: false
});
const MenuContext$1 = MenuContext;
const MenuItem = (props) => {
  var _a;
  const {
    className,
    children,
    icon,
    title,
    danger
  } = props;
  const {
    prefixCls,
    firstLevel,
    direction,
    disableMenuItemTitleTooltip,
    inlineCollapsed: isInlineCollapsed
  } = react.exports.useContext(MenuContext$1);
  const renderItemChildren = (inlineCollapsed) => {
    const wrapNode = /* @__PURE__ */ jsx("span", {
      className: `${prefixCls}-title-content`,
      children
    });
    if (!icon || isValidElement(children) && children.type === "span") {
      if (children && inlineCollapsed && firstLevel && typeof children === "string") {
        return /* @__PURE__ */ jsx("div", {
          className: `${prefixCls}-inline-collapsed-noicon`,
          children: children.charAt(0)
        });
      }
    }
    return wrapNode;
  };
  const {
    siderCollapsed
  } = react.exports.useContext(SiderContext);
  let tooltipTitle = title;
  if (typeof title === "undefined") {
    tooltipTitle = firstLevel ? children : "";
  } else if (title === false) {
    tooltipTitle = "";
  }
  const tooltipProps = {
    title: tooltipTitle
  };
  if (!siderCollapsed && !isInlineCollapsed) {
    tooltipProps.title = null;
    tooltipProps.open = false;
  }
  const childrenLength = toArray$3(children).length;
  let returnNode = /* @__PURE__ */ jsxs(MenuItem$1, {
    ...Object.assign({}, omit(props, ["title", "icon", "danger"]), {
      className: classNames({
        [`${prefixCls}-item-danger`]: danger,
        [`${prefixCls}-item-only-child`]: (icon ? childrenLength + 1 : childrenLength) === 1
      }, className),
      title: typeof title === "string" ? title : void 0
    }),
    children: [cloneElement(icon, {
      className: classNames(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
    }), renderItemChildren(isInlineCollapsed)]
  });
  if (!disableMenuItemTitleTooltip) {
    returnNode = /* @__PURE__ */ jsx(Tooltip$1, {
      ...Object.assign({}, tooltipProps, {
        placement: direction === "rtl" ? "left" : "right",
        overlayClassName: `${prefixCls}-inline-collapsed-tooltip`
      }),
      children: returnNode
    });
  }
  return returnNode;
};
const Item$2 = MenuItem;
const SubMenu = (props) => {
  var _a;
  const {
    popupClassName,
    icon,
    title,
    theme: customTheme2
  } = props;
  const context = react.exports.useContext(MenuContext$1);
  const {
    prefixCls,
    inlineCollapsed,
    theme: contextTheme,
    mode
  } = context;
  const parentPath = useFullPath();
  let titleNode;
  if (!icon) {
    titleNode = inlineCollapsed && !parentPath.length && title && typeof title === "string" ? /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-inline-collapsed-noicon`,
      children: title.charAt(0)
    }) : /* @__PURE__ */ jsx("span", {
      className: `${prefixCls}-title-content`,
      children: title
    });
  } else {
    const titleIsSpan = isValidElement(title) && title.type === "span";
    titleNode = /* @__PURE__ */ jsxs(Fragment, {
      children: [cloneElement(icon, {
        className: classNames(isValidElement(icon) ? (_a = icon.props) === null || _a === void 0 ? void 0 : _a.className : "", `${prefixCls}-item-icon`)
      }), titleIsSpan ? title : /* @__PURE__ */ jsx("span", {
        className: `${prefixCls}-title-content`,
        children: title
      })]
    });
  }
  const contextValue = react.exports.useMemo(() => Object.assign(Object.assign({}, context), {
    firstLevel: false
  }), [context]);
  const popupOffset = mode === "horizontal" ? [0, 8] : [10, 0];
  return /* @__PURE__ */ jsx(MenuContext$1.Provider, {
    value: contextValue,
    children: /* @__PURE__ */ jsx(SubMenu$2, {
      ...Object.assign({
        popupOffset
      }, omit(props, ["icon"]), {
        title: titleNode,
        popupClassName: classNames(prefixCls, popupClassName, `${prefixCls}-${customTheme2 || contextTheme}`)
      })
    })
  });
};
const SubMenu$1 = SubMenu;
var __rest$A = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function convertItemsToNodes(list) {
  return (list || []).map((opt, index2) => {
    if (opt && typeof opt === "object") {
      const _a = opt, {
        label,
        children,
        key,
        type: type4
      } = _a, restProps = __rest$A(_a, ["label", "children", "key", "type"]);
      const mergedKey = key !== null && key !== void 0 ? key : `tmp-${index2}`;
      if (children || type4 === "group") {
        if (type4 === "group") {
          return /* @__PURE__ */ jsx(MenuItemGroup, {
            ...Object.assign({
              key: mergedKey
            }, restProps, {
              title: label
            }),
            children: convertItemsToNodes(children)
          });
        }
        return /* @__PURE__ */ jsx(SubMenu$1, {
          ...Object.assign({
            key: mergedKey
          }, restProps, {
            title: label
          }),
          children: convertItemsToNodes(children)
        });
      }
      if (type4 === "divider") {
        return /* @__PURE__ */ jsx(MenuDivider$1, {
          ...Object.assign({
            key: mergedKey
          }, restProps)
        });
      }
      return /* @__PURE__ */ jsx(Item$2, {
        ...Object.assign({
          key: mergedKey
        }, restProps),
        children: label
      });
    }
    return null;
  }).filter((opt) => opt);
}
function useItems(items) {
  return react.exports.useMemo(() => {
    if (!items) {
      return items;
    }
    return convertItemsToNodes(items);
  }, [items]);
}
var __rest$z = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const InternalMenu = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  var _a, _b;
  const override = react.exports.useContext(OverrideContext$1);
  const overrideObj = override || {};
  const {
    getPrefixCls,
    getPopupContainer,
    direction
  } = react.exports.useContext(ConfigContext);
  const rootPrefixCls = getPrefixCls();
  const {
    prefixCls: customizePrefixCls,
    className,
    theme: theme2 = "light",
    expandIcon,
    _internalDisableMenuItemTitleTooltip,
    inlineCollapsed,
    siderCollapsed,
    items,
    children,
    rootClassName,
    mode,
    selectable,
    onClick
  } = props, restProps = __rest$z(props, ["prefixCls", "className", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "rootClassName", "mode", "selectable", "onClick"]);
  const passedProps = omit(restProps, ["collapsedWidth"]);
  const mergedChildren = useItems(items) || children;
  (_a = overrideObj.validator) === null || _a === void 0 ? void 0 : _a.call(overrideObj, {
    mode
  });
  const onItemClick = useEvent(function() {
    var _a2;
    onClick === null || onClick === void 0 ? void 0 : onClick.apply(void 0, arguments);
    (_a2 = overrideObj.onClick) === null || _a2 === void 0 ? void 0 : _a2.call(overrideObj);
  });
  const mergedMode = overrideObj.mode || mode;
  const mergedSelectable = selectable !== null && selectable !== void 0 ? selectable : overrideObj.selectable;
  const mergedInlineCollapsed = react.exports.useMemo(() => {
    if (siderCollapsed !== void 0) {
      return siderCollapsed;
    }
    return inlineCollapsed;
  }, [inlineCollapsed, siderCollapsed]);
  const defaultMotions = {
    horizontal: {
      motionName: `${rootPrefixCls}-slide-up`
    },
    inline: initCollapseMotion$1(rootPrefixCls),
    other: {
      motionName: `${rootPrefixCls}-zoom-big`
    }
  };
  const prefixCls = getPrefixCls("menu", customizePrefixCls || overrideObj.prefixCls);
  const [wrapSSR, hashId] = useStyle$h(prefixCls, !override);
  const menuClassName = classNames(`${prefixCls}-${theme2}`, className);
  let mergedExpandIcon;
  if (typeof expandIcon === "function") {
    mergedExpandIcon = expandIcon;
  } else {
    const beClone = expandIcon || overrideObj.expandIcon;
    mergedExpandIcon = cloneElement(beClone, {
      className: classNames(`${prefixCls}-submenu-expand-icon`, (_b = beClone === null || beClone === void 0 ? void 0 : beClone.props) === null || _b === void 0 ? void 0 : _b.className)
    });
  }
  const contextValue = react.exports.useMemo(() => ({
    prefixCls,
    inlineCollapsed: mergedInlineCollapsed || false,
    direction,
    firstLevel: true,
    theme: theme2,
    mode: mergedMode,
    disableMenuItemTitleTooltip: _internalDisableMenuItemTitleTooltip
  }), [prefixCls, mergedInlineCollapsed, direction, _internalDisableMenuItemTitleTooltip, theme2]);
  return wrapSSR(
    /* @__PURE__ */ jsx(OverrideContext$1.Provider, {
      value: null,
      children: /* @__PURE__ */ jsx(MenuContext$1.Provider, {
        value: contextValue,
        children: /* @__PURE__ */ jsx(ExportMenu, {
          ...Object.assign({
            getPopupContainer,
            overflowedIndicator: /* @__PURE__ */ jsx(EllipsisOutlined$1, {}),
            overflowedIndicatorPopupClassName: `${prefixCls}-${theme2}`,
            mode: mergedMode,
            selectable: mergedSelectable,
            onClick: onItemClick
          }, passedProps, {
            inlineCollapsed: mergedInlineCollapsed,
            className: menuClassName,
            prefixCls,
            direction,
            defaultMotions,
            expandIcon: mergedExpandIcon,
            ref,
            rootClassName: classNames(rootClassName, hashId)
          }),
          children: mergedChildren
        })
      })
    })
  );
});
const InternalMenu$1 = InternalMenu;
const Menu = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const menuRef = react.exports.useRef(null);
  const context = react.exports.useContext(SiderContext);
  react.exports.useImperativeHandle(ref, () => ({
    menu: menuRef.current,
    focus: (options) => {
      var _a;
      (_a = menuRef.current) === null || _a === void 0 ? void 0 : _a.focus(options);
    }
  }));
  return /* @__PURE__ */ jsx(InternalMenu$1, {
    ...Object.assign({
      ref: menuRef
    }, props, context)
  });
});
Menu.Item = Item$2;
Menu.SubMenu = SubMenu$1;
Menu.Divider = MenuDivider$1;
Menu.ItemGroup = MenuItemGroup;
const Menu$1 = Menu;
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};
var targetOffset = [0, 0];
var placements = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  topRight: {
    points: ["br", "tr"],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset
  }
};
var ESC = KeyCode.ESC, TAB = KeyCode.TAB;
function useAccessibility(_ref) {
  var visible = _ref.visible, setTriggerVisible = _ref.setTriggerVisible, triggerRef = _ref.triggerRef, onVisibleChange = _ref.onVisibleChange, autoFocus = _ref.autoFocus;
  var focusMenuRef = react.exports.useRef(false);
  var handleCloseMenuAndReturnFocus = function handleCloseMenuAndReturnFocus2() {
    if (visible && triggerRef.current) {
      var _triggerRef$current, _triggerRef$current$t, _triggerRef$current$t2, _triggerRef$current$t3;
      (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : (_triggerRef$current$t = _triggerRef$current.triggerRef) === null || _triggerRef$current$t === void 0 ? void 0 : (_triggerRef$current$t2 = _triggerRef$current$t.current) === null || _triggerRef$current$t2 === void 0 ? void 0 : (_triggerRef$current$t3 = _triggerRef$current$t2.focus) === null || _triggerRef$current$t3 === void 0 ? void 0 : _triggerRef$current$t3.call(_triggerRef$current$t2);
      setTriggerVisible(false);
      if (typeof onVisibleChange === "function") {
        onVisibleChange(false);
      }
    }
  };
  var focusMenu = function focusMenu2() {
    var _triggerRef$current2, _triggerRef$current2$, _triggerRef$current2$2, _triggerRef$current2$3;
    var elements = getFocusNodeList((_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : (_triggerRef$current2$ = _triggerRef$current2.popupRef) === null || _triggerRef$current2$ === void 0 ? void 0 : (_triggerRef$current2$2 = _triggerRef$current2$.current) === null || _triggerRef$current2$2 === void 0 ? void 0 : (_triggerRef$current2$3 = _triggerRef$current2$2.getElement) === null || _triggerRef$current2$3 === void 0 ? void 0 : _triggerRef$current2$3.call(_triggerRef$current2$2));
    var firstElement = elements[0];
    if (firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus) {
      firstElement.focus();
      focusMenuRef.current = true;
      return true;
    }
    return false;
  };
  var handleKeyDown = function handleKeyDown2(event) {
    switch (event.keyCode) {
      case ESC:
        handleCloseMenuAndReturnFocus();
        break;
      case TAB: {
        var focusResult = false;
        if (!focusMenuRef.current) {
          focusResult = focusMenu();
        }
        if (focusResult) {
          event.preventDefault();
        } else {
          handleCloseMenuAndReturnFocus();
        }
        break;
      }
    }
  };
  react.exports.useEffect(function() {
    if (visible) {
      window.addEventListener("keydown", handleKeyDown);
      if (autoFocus) {
        wrapperRaf(focusMenu, 3);
      }
      return function() {
        window.removeEventListener("keydown", handleKeyDown);
        focusMenuRef.current = false;
      };
    }
    return function() {
      focusMenuRef.current = false;
    };
  }, [visible]);
}
var _excluded$a = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus"];
function Dropdown$2(props, ref) {
  var _props$arrow = props.arrow, arrow = _props$arrow === void 0 ? false : _props$arrow, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dropdown" : _props$prefixCls, transitionName = props.transitionName, animation = props.animation, align = props.align, _props$placement = props.placement, placement = _props$placement === void 0 ? "bottomLeft" : _props$placement, _props$placements = props.placements, placements$12 = _props$placements === void 0 ? placements : _props$placements, getPopupContainer = props.getPopupContainer, showAction = props.showAction, hideAction = props.hideAction, overlayClassName = props.overlayClassName, overlayStyle = props.overlayStyle, visible = props.visible, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, autoFocus = props.autoFocus, otherProps = _objectWithoutProperties(props, _excluded$a);
  var _React$useState = react.exports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), triggerVisible = _React$useState2[0], setTriggerVisible = _React$useState2[1];
  var mergedVisible = "visible" in props ? visible : triggerVisible;
  var triggerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, function() {
    return triggerRef.current;
  });
  useAccessibility({
    visible: mergedVisible,
    setTriggerVisible,
    triggerRef,
    onVisibleChange: props.onVisibleChange,
    autoFocus
  });
  var getOverlayElement = function getOverlayElement2() {
    var overlay = props.overlay;
    var overlayElement;
    if (typeof overlay === "function") {
      overlayElement = overlay();
    } else {
      overlayElement = overlay;
    }
    return overlayElement;
  };
  var onClick = function onClick2(e2) {
    var onOverlayClick = props.onOverlayClick;
    setTriggerVisible(false);
    if (onOverlayClick) {
      onOverlayClick(e2);
    }
  };
  var onVisibleChange = function onVisibleChange2(newVisible) {
    var onVisibleChangeProp = props.onVisibleChange;
    setTriggerVisible(newVisible);
    if (typeof onVisibleChangeProp === "function") {
      onVisibleChangeProp(newVisible);
    }
  };
  var getMenuElement = function getMenuElement2() {
    var overlayElement = getOverlayElement();
    return /* @__PURE__ */ jsxs(Fragment, {
      children: [arrow && /* @__PURE__ */ jsx("div", {
        className: "".concat(prefixCls, "-arrow")
      }), overlayElement]
    });
  };
  var getMenuElementOrLambda = function getMenuElementOrLambda2() {
    var overlay = props.overlay;
    if (typeof overlay === "function") {
      return getMenuElement;
    }
    return getMenuElement();
  };
  var getMinOverlayWidthMatchTrigger = function getMinOverlayWidthMatchTrigger2() {
    var minOverlayWidthMatchTrigger = props.minOverlayWidthMatchTrigger, alignPoint2 = props.alignPoint;
    if ("minOverlayWidthMatchTrigger" in props) {
      return minOverlayWidthMatchTrigger;
    }
    return !alignPoint2;
  };
  var getOpenClassName = function getOpenClassName2() {
    var openClassName = props.openClassName;
    if (openClassName !== void 0) {
      return openClassName;
    }
    return "".concat(prefixCls, "-open");
  };
  var renderChildren = function renderChildren2() {
    var children = props.children;
    var childrenProps = children.props ? children.props : {};
    var childClassName = classNames(childrenProps.className, getOpenClassName());
    return mergedVisible && children ? /* @__PURE__ */ react.exports.cloneElement(children, {
      className: childClassName
    }) : children;
  };
  var triggerHideAction = hideAction;
  if (!triggerHideAction && trigger.indexOf("contextMenu") !== -1) {
    triggerHideAction = ["click"];
  }
  return /* @__PURE__ */ jsx(Trigger, {
    ..._objectSpread2$1(_objectSpread2$1({
      builtinPlacements: placements$12
    }, otherProps), {}, {
      prefixCls,
      ref: triggerRef,
      popupClassName: classNames(overlayClassName, _defineProperty$1({}, "".concat(prefixCls, "-show-arrow"), arrow)),
      popupStyle: overlayStyle,
      action: trigger,
      showAction,
      hideAction: triggerHideAction || [],
      popupPlacement: placement,
      popupAlign: align,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupVisible: mergedVisible,
      stretch: getMinOverlayWidthMatchTrigger() ? "minWidth" : "",
      popup: getMenuElementOrLambda(),
      onPopupVisibleChange: onVisibleChange,
      onPopupClick: onClick,
      getPopupContainer
    }),
    children: renderChildren()
  });
}
const Dropdown$3 = /* @__PURE__ */ react.exports.forwardRef(Dropdown$2);
const genWaveStyle = (token2) => {
  const {
    componentCls,
    colorPrimary
  } = token2;
  return {
    [componentCls]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${colorPrimary})`,
      boxShadow: `0 0 0 0 currentcolor`,
      opacity: 0.2,
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: `0 0 0 6px currentcolor`,
          opacity: 0
        }
      }
    }
  };
};
const useStyle$f = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
var fullClone = _objectSpread2$1({}, ReactDOM$1);
var version$3 = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
var createRoot;
try {
  var mainVersion = Number((version$3 || "").split(".")[0]);
  if (mainVersion >= 18) {
    createRoot = fullClone.createRoot;
  }
} catch (e2) {
}
function toggleWarning(skip) {
  var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof$1(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
  }
}
var MARK = "__rc_react_root__";
function modernRender(node2, container) {
  toggleWarning(true);
  var root2 = container[MARK] || createRoot(container);
  toggleWarning(false);
  root2.render(node2);
  container[MARK] = root2;
}
function legacyRender(node2, container) {
  reactRender(node2, container);
}
function render(node2, container) {
  if (createRoot) {
    modernRender(node2, container);
    return;
  }
  legacyRender(node2, container);
}
function modernUnmount(_x) {
  return _modernUnmount.apply(this, arguments);
}
function _modernUnmount() {
  _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1)
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", Promise.resolve().then(function() {
              var _container$MARK;
              (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
              delete container[MARK];
            }));
          case 1:
          case "end":
            return _context.stop();
        }
    }, _callee);
  }));
  return _modernUnmount.apply(this, arguments);
}
function legacyUnmount(container) {
  unmountComponentAtNode(container);
}
function unmount(_x2) {
  return _unmount.apply(this, arguments);
}
function _unmount() {
  _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1)
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(createRoot !== void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return", modernUnmount(container));
          case 2:
            legacyUnmount(container);
          case 3:
          case "end":
            return _context2.stop();
        }
    }, _callee2);
  }));
  return _unmount.apply(this, arguments);
}
function isNotGrey(color) {
  const match = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  if (match && match[1] && match[2] && match[3]) {
    return !(match[1] === match[2] && match[2] === match[3]);
  }
  return true;
}
function isValidWaveColor(color) {
  return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && color !== "transparent";
}
function getTargetWaveColor(node2) {
  const {
    borderTopColor,
    borderColor,
    backgroundColor
  } = getComputedStyle(node2);
  if (isValidWaveColor(borderTopColor)) {
    return borderTopColor;
  }
  if (isValidWaveColor(borderColor)) {
    return borderColor;
  }
  if (isValidWaveColor(backgroundColor)) {
    return backgroundColor;
  }
  return null;
}
function validateNum(value) {
  return Number.isNaN(value) ? 0 : value;
}
const WaveEffect = (props) => {
  const {
    className,
    target
  } = props;
  const divRef = react.exports.useRef(null);
  const [color, setWaveColor] = react.exports.useState(null);
  const [borderRadius, setBorderRadius] = react.exports.useState([]);
  const [left, setLeft] = react.exports.useState(0);
  const [top, setTop] = react.exports.useState(0);
  const [width, setWidth] = react.exports.useState(0);
  const [height, setHeight] = react.exports.useState(0);
  const [enabled, setEnabled] = react.exports.useState(false);
  const waveStyle = {
    left,
    top,
    width,
    height,
    borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
  };
  if (color) {
    waveStyle["--wave-color"] = color;
  }
  function syncPos() {
    const nodeStyle = getComputedStyle(target);
    setWaveColor(getTargetWaveColor(target));
    const isStatic = nodeStyle.position === "static";
    const {
      borderLeftWidth,
      borderTopWidth
    } = nodeStyle;
    setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
    setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
    setWidth(target.offsetWidth);
    setHeight(target.offsetHeight);
    const {
      borderTopLeftRadius,
      borderTopRightRadius,
      borderBottomLeftRadius,
      borderBottomRightRadius
    } = nodeStyle;
    setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
  }
  react.exports.useEffect(() => {
    if (target) {
      const id2 = wrapperRaf(() => {
        syncPos();
        setEnabled(true);
      });
      let resizeObserver2;
      if (typeof ResizeObserver !== "undefined") {
        resizeObserver2 = new ResizeObserver(syncPos);
        resizeObserver2.observe(target);
      }
      return () => {
        wrapperRaf.cancel(id2);
        resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
      };
    }
  }, []);
  if (!enabled) {
    return null;
  }
  return /* @__PURE__ */ jsx(CSSMotion, {
    visible: true,
    motionAppear: true,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (_2, event) => {
      var _a;
      if (event.deadline || event.propertyName === "opacity") {
        const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
        unmount(holder).then(() => {
          var _a2;
          (_a2 = holder.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(holder);
        });
      }
      return false;
    },
    children: (_ref) => {
      let {
        className: motionClassName
      } = _ref;
      return /* @__PURE__ */ jsx("div", {
        ref: divRef,
        className: classNames(className, motionClassName),
        style: waveStyle
      });
    }
  });
};
function showWaveEffect(node2, className) {
  const holder = document.createElement("div");
  holder.style.position = "absolute";
  holder.style.left = `0px`;
  holder.style.top = `0px`;
  node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
  render(
    /* @__PURE__ */ jsx(WaveEffect, {
      target: node2,
      className
    }),
    holder
  );
}
function useWave(nodeRef, className) {
  function showWave() {
    const node2 = nodeRef.current;
    showWaveEffect(node2, className);
  }
  return showWave;
}
const Wave = (props) => {
  const {
    children,
    disabled
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const containerRef = react.exports.useRef(null);
  const prefixCls = getPrefixCls("wave");
  const [, hashId] = useStyle$f(prefixCls);
  const showWave = useWave(containerRef, classNames(prefixCls, hashId));
  React.useEffect(() => {
    const node2 = containerRef.current;
    if (!node2 || node2.nodeType !== 1 || disabled) {
      return;
    }
    const onClick = (e2) => {
      if (e2.target.tagName === "INPUT" || !isVisible(e2.target) || !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
        return;
      }
      showWave();
    };
    node2.addEventListener("click", onClick, true);
    return () => {
      node2.removeEventListener("click", onClick, true);
    };
  }, [disabled]);
  if (!/* @__PURE__ */ React.isValidElement(children)) {
    return children !== null && children !== void 0 ? children : null;
  }
  const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
  return cloneElement(children, {
    ref
  });
};
const Wave$1 = Wave;
var __rest$y = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const GroupSizeContext = /* @__PURE__ */ react.exports.createContext(void 0);
const ButtonGroup = (props) => {
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    size,
    className
  } = props, others = __rest$y(props, ["prefixCls", "size", "className"]);
  const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
  const [, , hashId] = useToken$3();
  let sizeCls = "";
  switch (size) {
    case "large":
      sizeCls = "lg";
      break;
    case "small":
      sizeCls = "sm";
      break;
  }
  const classes = classNames(prefixCls, {
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  return /* @__PURE__ */ jsx(GroupSizeContext.Provider, {
    value: size,
    children: /* @__PURE__ */ jsx("div", {
      ...Object.assign({}, others, {
        className: classes
      })
    })
  });
};
const Group$3 = ButtonGroup;
const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
function isString(str) {
  return typeof str === "string";
}
function isUnBorderedButtonType(type4) {
  return type4 === "text" || type4 === "link";
}
function splitCNCharsBySpace(child, needInserted) {
  if (child === null || child === void 0) {
    return;
  }
  const SPACE = needInserted ? " " : "";
  if (typeof child !== "string" && typeof child !== "number" && isString(child.type) && isTwoCNChar(child.props.children)) {
    return cloneElement(child, {
      children: child.props.children.split("").join(SPACE)
    });
  }
  if (typeof child === "string") {
    return isTwoCNChar(child) ? /* @__PURE__ */ jsx("span", {
      children: child.split("").join(SPACE)
    }) : /* @__PURE__ */ jsx("span", {
      children: child
    });
  }
  if (isFragment(child)) {
    return /* @__PURE__ */ jsx("span", {
      children: child
    });
  }
  return child;
}
function spaceChildren(children, needInserted) {
  let isPrevChildPure = false;
  const childList = [];
  React.Children.forEach(children, (child) => {
    const type4 = typeof child;
    const isCurrentChildPure = type4 === "string" || type4 === "number";
    if (isPrevChildPure && isCurrentChildPure) {
      const lastIndex = childList.length - 1;
      const lastChild = childList[lastIndex];
      childList[lastIndex] = `${lastChild}${child}`;
    } else {
      childList.push(child);
    }
    isPrevChildPure = isCurrentChildPure;
  });
  return React.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
}
const getCollapsedWidth = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
});
const getRealWidth = (node2) => ({
  width: node2.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
});
const LoadingIcon = (_ref) => {
  let {
    prefixCls,
    loading,
    existIcon
  } = _ref;
  const visible = !!loading;
  if (existIcon) {
    return /* @__PURE__ */ jsx("span", {
      className: `${prefixCls}-loading-icon`,
      children: /* @__PURE__ */ jsx(LoadingOutlined$1, {})
    });
  }
  return /* @__PURE__ */ jsx(CSSMotion, {
    visible,
    motionName: `${prefixCls}-loading-icon-motion`,
    removeOnLeave: true,
    onAppearStart: getCollapsedWidth,
    onAppearActive: getRealWidth,
    onEnterStart: getCollapsedWidth,
    onEnterActive: getRealWidth,
    onLeaveStart: getRealWidth,
    onLeaveActive: getCollapsedWidth,
    children: (_ref2, ref) => {
      let {
        className,
        style: style2
      } = _ref2;
      return /* @__PURE__ */ jsx("span", {
        className: `${prefixCls}-loading-icon`,
        style: style2,
        ref,
        children: /* @__PURE__ */ jsx(LoadingOutlined$1, {
          className
        })
      });
    }
  });
};
const LoadingIcon$1 = LoadingIcon;
const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
  [`> span, > ${buttonTypeCls}`]: {
    "&:not(:last-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: borderColor
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${buttonTypeCls}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: borderColor
        }
      }
    }
  }
});
const genGroupStyle$1 = (token2) => {
  const {
    componentCls,
    fontSize,
    lineWidth,
    colorPrimaryHover,
    colorErrorHover
  } = token2;
  return {
    [`${componentCls}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        [`> span, > ${componentCls}`]: {
          "&:not(:last-child)": {
            [`&, & > ${componentCls}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -lineWidth,
            [`&, & > ${componentCls}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [componentCls]: {
          position: "relative",
          zIndex: 1,
          [`&:hover,
          &:focus,
          &:active`]: {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${componentCls}-icon-only`]: {
          fontSize
        }
      },
      genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
      genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
    ]
  };
};
const genGroupStyle$2 = genGroupStyle$1;
function compactItemVerticalBorder(token2, parentCls) {
  return {
    [`&-item:not(${parentCls}-last-item)`]: {
      marginBottom: -token2.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function compactItemBorderVerticalRadius(prefixCls, parentCls) {
  return {
    [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
      [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function genCompactItemVerticalStyle(token2) {
  const compactCls = `${token2.componentCls}-compact-vertical`;
  return {
    [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
  };
}
const genSharedButtonStyle = (token2) => {
  const {
    componentCls,
    iconCls
  } = token2;
  return {
    [componentCls]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${token2.lineWidth}px ${token2.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: token2.lineHeight,
      color: token2.colorText,
      "> span": {
        display: "inline-block"
      },
      [`> ${iconCls} + span, > span + ${iconCls}`]: {
        marginInlineStart: token2.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
      [`&-icon-only${componentCls}-compact-item`]: {
        flex: "none"
      },
      [`&-compact-item${componentCls}-primary`]: {
        [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -token2.lineWidth,
            insetInlineStart: -token2.lineWidth,
            display: "inline-block",
            width: token2.lineWidth,
            height: `calc(100% + ${token2.lineWidth * 2}px)`,
            backgroundColor: token2.colorPrimaryHover,
            content: '""'
          }
        }
      },
      "&-compact-vertical-item": {
        [`&${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${token2.lineWidth * 2}px)`,
              height: token2.lineWidth,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
};
const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
  "&:not(:disabled)": {
    "&:hover": hoverStyle,
    "&:active": activeStyle
  }
});
const genCircleButtonStyle = (token2) => ({
  minWidth: token2.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
});
const genRoundButtonStyle = (token2) => ({
  borderRadius: token2.controlHeight,
  paddingInlineStart: token2.controlHeight / 2,
  paddingInlineEnd: token2.controlHeight / 2
});
const genDisabledStyle$1 = (token2) => ({
  cursor: "not-allowed",
  borderColor: token2.colorBorder,
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  boxShadow: "none"
});
const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
  [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
    color: textColor || void 0,
    backgroundColor: "transparent",
    borderColor: borderColor || void 0,
    boxShadow: "none"
  }, genHoverActiveButtonStyle(Object.assign({
    backgroundColor: "transparent"
  }, hoverStyle), Object.assign({
    backgroundColor: "transparent"
  }, activeStyle))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: textColorDisabled || void 0,
      borderColor: borderColorDisabled || void 0
    }
  })
});
const genSolidDisabledButtonStyle = (token2) => ({
  "&:disabled": Object.assign({}, genDisabledStyle$1(token2))
});
const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
const genPureDisabledButtonStyle = (token2) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: token2.colorTextDisabled
  }
});
const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
  backgroundColor: token2.colorBgContainer,
  borderColor: token2.colorBorder,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
}), genHoverActiveButtonStyle({
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    color: token2.colorError,
    borderColor: token2.colorError
  }, genHoverActiveButtonStyle({
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorBorderHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
});
const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimary,
  boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
}), genHoverActiveButtonStyle({
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryHover
}, {
  color: token2.colorTextLightSolid,
  backgroundColor: token2.colorPrimaryActive
})), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
  color: token2.colorPrimaryHover,
  borderColor: token2.colorPrimaryHover
}, {
  color: token2.colorPrimaryActive,
  borderColor: token2.colorPrimaryActive
})), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    backgroundColor: token2.colorError,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
  }, genHoverActiveButtonStyle({
    backgroundColor: token2.colorErrorHover
  }, {
    backgroundColor: token2.colorErrorActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorErrorHover,
    borderColor: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive,
    borderColor: token2.colorErrorActive
  })), genSolidDisabledButtonStyle(token2))
});
const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
  borderStyle: "dashed"
});
const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
  color: token2.colorLink
}, genHoverActiveButtonStyle({
  color: token2.colorLinkHover
}, {
  color: token2.colorLinkActive
})), genPureDisabledButtonStyle(token2)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: token2.colorError
  }, genHoverActiveButtonStyle({
    color: token2.colorErrorHover
  }, {
    color: token2.colorErrorActive
  })), genPureDisabledButtonStyle(token2))
});
const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle({
  color: token2.colorText,
  backgroundColor: token2.colorBgTextHover
}, {
  color: token2.colorText,
  backgroundColor: token2.colorBgTextActive
})), genPureDisabledButtonStyle(token2)), {
  [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: token2.colorError
  }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }, {
    color: token2.colorErrorHover,
    backgroundColor: token2.colorErrorBg
  }))
});
const genDisabledButtonStyle = (token2) => Object.assign(Object.assign({}, genDisabledStyle$1(token2)), {
  [`&${token2.componentCls}:hover`]: Object.assign({}, genDisabledStyle$1(token2))
});
const genTypeButtonStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-default`]: genDefaultButtonStyle(token2),
    [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
    [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
    [`${componentCls}-link`]: genLinkButtonStyle(token2),
    [`${componentCls}-text`]: genTextButtonStyle(token2),
    [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
  };
};
const genSizeButtonStyle = function(token2) {
  let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls,
    iconCls,
    controlHeight,
    fontSize,
    lineHeight,
    lineWidth,
    borderRadius,
    buttonPaddingHorizontal
  } = token2;
  const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
  const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
  const iconOnlyCls = `${componentCls}-icon-only`;
  return [
    {
      [`${componentCls}${sizePrefixCls}`]: {
        fontSize,
        height: controlHeight,
        padding: `${paddingVertical}px ${paddingHorizontal}px`,
        borderRadius,
        [`&${iconOnlyCls}`]: {
          width: controlHeight,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${componentCls}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
          }
        },
        [`&${componentCls}-loading`]: {
          opacity: token2.opacityLoading,
          cursor: "default"
        },
        [`${componentCls}-loading-icon`]: {
          transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`&:not(${iconOnlyCls}) ${componentCls}-loading-icon > ${iconCls}`]: {
          marginInlineEnd: token2.marginXS
        }
      }
    },
    {
      [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
    },
    {
      [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
    }
  ];
};
const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
const genSizeSmallButtonStyle = (token2) => {
  const smallToken = merge(token2, {
    controlHeight: token2.controlHeightSM,
    padding: token2.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: token2.borderRadiusSM
  });
  return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
};
const genSizeLargeButtonStyle = (token2) => {
  const largeToken = merge(token2, {
    controlHeight: token2.controlHeightLG,
    fontSize: token2.fontSizeLG,
    borderRadius: token2.borderRadiusLG
  });
  return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
};
const genBlockButtonStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      [`&${componentCls}-block`]: {
        width: "100%"
      }
    }
  };
};
const useStyle$e = genComponentStyleHook("Button", (token2) => {
  const {
    controlTmpOutline,
    paddingContentHorizontal
  } = token2;
  const buttonToken = merge(token2, {
    colorOutlineDefault: controlTmpOutline,
    buttonPaddingHorizontal: paddingContentHorizontal
  });
  return [
    genSharedButtonStyle(buttonToken),
    genSizeSmallButtonStyle(buttonToken),
    genSizeBaseButtonStyle(buttonToken),
    genSizeLargeButtonStyle(buttonToken),
    genBlockButtonStyle(buttonToken),
    genTypeButtonStyle(buttonToken),
    genGroupStyle$2(buttonToken),
    genCompactItemStyle(token2, {
      focus: false
    }),
    genCompactItemVerticalStyle(token2)
  ];
});
var __rest$x = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function getLoadingConfig(loading) {
  if (typeof loading === "object" && loading) {
    const delay = loading === null || loading === void 0 ? void 0 : loading.delay;
    const isDelay = !Number.isNaN(delay) && typeof delay === "number";
    return {
      loading: false,
      delay: isDelay ? delay : 0
    };
  }
  return {
    loading: !!loading,
    delay: 0
  };
}
const InternalButton = (props, ref) => {
  const {
    loading = false,
    prefixCls: customizePrefixCls,
    type: type4 = "default",
    danger,
    shape = "default",
    size: customizeSize,
    disabled: customDisabled,
    className,
    rootClassName,
    children,
    icon,
    ghost = false,
    block = false,
    htmlType = "button"
  } = props, rest = __rest$x(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType"]);
  const {
    getPrefixCls,
    autoInsertSpaceInButton,
    direction
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("btn", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$e(prefixCls);
  const size = react.exports.useContext(SizeContext$2);
  const disabled = react.exports.useContext(DisabledContext);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const groupSize = react.exports.useContext(GroupSizeContext);
  const loadingOrDelay = react.exports.useMemo(() => getLoadingConfig(loading), [loading]);
  const [innerLoading, setLoading] = react.exports.useState(loadingOrDelay.loading);
  const [hasTwoCNChar, setHasTwoCNChar] = react.exports.useState(false);
  const buttonRef = ref || /* @__PURE__ */ react.exports.createRef();
  const isNeedInserted = () => react.exports.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type4);
  const fixTwoCNChar = () => {
    if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
      return;
    }
    const buttonText = buttonRef.current.textContent;
    if (isNeedInserted() && isTwoCNChar(buttonText)) {
      if (!hasTwoCNChar) {
        setHasTwoCNChar(true);
      }
    } else if (hasTwoCNChar) {
      setHasTwoCNChar(false);
    }
  };
  react.exports.useEffect(() => {
    let delayTimer = null;
    if (loadingOrDelay.delay > 0) {
      delayTimer = window.setTimeout(() => {
        delayTimer = null;
        setLoading(true);
      }, loadingOrDelay.delay);
    } else {
      setLoading(loadingOrDelay.loading);
    }
    function cleanupTimer() {
      if (delayTimer) {
        window.clearTimeout(delayTimer);
        delayTimer = null;
      }
    }
    return cleanupTimer;
  }, [loadingOrDelay]);
  react.exports.useEffect(fixTwoCNChar, [buttonRef]);
  const handleClick = (e2) => {
    const {
      onClick
    } = props;
    if (innerLoading || mergedDisabled) {
      e2.preventDefault();
      return;
    }
    onClick === null || onClick === void 0 ? void 0 : onClick(e2);
  };
  const autoInsertSpace = autoInsertSpaceInButton !== false;
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const sizeClassNameMap = {
    large: "lg",
    small: "sm",
    middle: void 0
  };
  const sizeFullname = compactSize || groupSize || customizeSize || size;
  const sizeCls = sizeFullname ? sizeClassNameMap[sizeFullname] || "" : "";
  const iconType = innerLoading ? "loading" : icon;
  const linkButtonRestProps = omit(rest, ["navigate"]);
  const hrefAndDisabled = linkButtonRestProps.href !== void 0 && mergedDisabled;
  const classes = classNames(prefixCls, hashId, {
    [`${prefixCls}-${shape}`]: shape !== "default" && shape,
    [`${prefixCls}-${type4}`]: type4,
    [`${prefixCls}-${sizeCls}`]: sizeCls,
    [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
    [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type4),
    [`${prefixCls}-loading`]: innerLoading,
    [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
    [`${prefixCls}-block`]: block,
    [`${prefixCls}-dangerous`]: !!danger,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-disabled`]: hrefAndDisabled
  }, compactItemClassnames, className, rootClassName);
  const iconNode = icon && !innerLoading ? icon : /* @__PURE__ */ jsx(LoadingIcon$1, {
    existIcon: !!icon,
    prefixCls,
    loading: !!innerLoading
  });
  const kids = children || children === 0 ? spaceChildren(children, isNeedInserted() && autoInsertSpace) : null;
  if (linkButtonRestProps.href !== void 0) {
    return wrapSSR(
      /* @__PURE__ */ jsxs("a", {
        ...Object.assign({}, linkButtonRestProps, {
          className: classes,
          onClick: handleClick,
          ref: buttonRef
        }),
        children: [iconNode, kids]
      })
    );
  }
  let buttonNode = /* @__PURE__ */ jsxs("button", {
    ...Object.assign({}, rest, {
      type: htmlType,
      className: classes,
      onClick: handleClick,
      disabled: mergedDisabled,
      ref: buttonRef
    }),
    children: [iconNode, kids]
  });
  if (!isUnBorderedButtonType(type4)) {
    buttonNode = /* @__PURE__ */ jsx(Wave$1, {
      disabled: !!innerLoading,
      children: buttonNode
    });
  }
  return wrapSSR(buttonNode);
};
const Button = /* @__PURE__ */ react.exports.forwardRef(InternalButton);
Button.Group = Group$3;
Button.__ANT_BUTTON = true;
const Button$1 = Button;
var isStyleNameSupport = function isStyleNameSupport2(styleName) {
  if (canUseDom() && window.document.documentElement) {
    var styleNameList = Array.isArray(styleName) ? styleName : [styleName];
    var documentElement = window.document.documentElement;
    return styleNameList.some(function(name2) {
      return name2 in documentElement.style;
    });
  }
  return false;
};
var isStyleValueSupport = function isStyleValueSupport2(styleName, value) {
  if (!isStyleNameSupport(styleName)) {
    return false;
  }
  var ele = document.createElement("div");
  var origin = ele.style[styleName];
  ele.style[styleName] = value;
  return ele.style[styleName] !== origin;
};
function isStyleSupport(styleName, styleValue) {
  if (!Array.isArray(styleName) && styleValue !== void 0) {
    return isStyleValueSupport(styleName, styleValue);
  }
  return isStyleNameSupport(styleName);
}
const canUseDocElement = () => canUseDom() && window.document.documentElement;
let flexGapSupported;
const detectFlexGapSupported = () => {
  if (!canUseDocElement()) {
    return false;
  }
  if (flexGapSupported !== void 0) {
    return flexGapSupported;
  }
  const flex = document.createElement("div");
  flex.style.display = "flex";
  flex.style.flexDirection = "column";
  flex.style.rowGap = "1px";
  flex.appendChild(document.createElement("div"));
  flex.appendChild(document.createElement("div"));
  document.body.appendChild(flex);
  flexGapSupported = flex.scrollHeight === 1;
  document.body.removeChild(flex);
  return flexGapSupported;
};
const useFlexGapSupport = () => {
  const [flexible, setFlexible] = react.exports.useState(false);
  react.exports.useEffect(() => {
    setFlexible(detectFlexGapSupported());
  }, []);
  return flexible;
};
function Item$1(_ref) {
  let {
    className,
    direction,
    index: index2,
    marginDirection,
    children,
    split,
    wrap: wrap2
  } = _ref;
  const {
    horizontalSize,
    verticalSize,
    latestIndex,
    supportFlexGap
  } = react.exports.useContext(SpaceContext);
  let style2 = {};
  if (!supportFlexGap) {
    if (direction === "vertical") {
      if (index2 < latestIndex) {
        style2 = {
          marginBottom: horizontalSize / (split ? 2 : 1)
        };
      }
    } else {
      style2 = Object.assign(Object.assign({}, index2 < latestIndex && {
        [marginDirection]: horizontalSize / (split ? 2 : 1)
      }), wrap2 && {
        paddingBottom: verticalSize
      });
    }
  }
  if (children === null || children === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("div", {
      className,
      style: style2,
      children
    }), index2 < latestIndex && split && /* @__PURE__ */ jsx("span", {
      className: `${className}-split`,
      style: style2,
      children: split
    })]
  });
}
var __rest$w = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const SpaceContext = /* @__PURE__ */ react.exports.createContext({
  latestIndex: 0,
  horizontalSize: 0,
  verticalSize: 0,
  supportFlexGap: false
});
const spaceSize = {
  small: 8,
  middle: 16,
  large: 24
};
function getNumberSize(size) {
  return typeof size === "string" ? spaceSize[size] : size || 0;
}
const Space = (props) => {
  const {
    getPrefixCls,
    space,
    direction: directionConfig
  } = react.exports.useContext(ConfigContext);
  const {
    size = (space === null || space === void 0 ? void 0 : space.size) || "small",
    align,
    className,
    rootClassName,
    children,
    direction = "horizontal",
    prefixCls: customizePrefixCls,
    split,
    style: style2,
    wrap: wrap2 = false
  } = props, otherProps = __rest$w(props, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap"]);
  const supportFlexGap = useFlexGapSupport();
  const [horizontalSize, verticalSize] = react.exports.useMemo(() => (Array.isArray(size) ? size : [size, size]).map((item) => getNumberSize(item)), [size]);
  const childNodes = toArray$3(children, {
    keepEmpty: true
  });
  const mergedAlign = align === void 0 && direction === "horizontal" ? "center" : align;
  const prefixCls = getPrefixCls("space", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$m(prefixCls);
  const cn = classNames(prefixCls, hashId, `${prefixCls}-${direction}`, {
    [`${prefixCls}-rtl`]: directionConfig === "rtl",
    [`${prefixCls}-align-${mergedAlign}`]: mergedAlign
  }, className, rootClassName);
  const itemClassName = `${prefixCls}-item`;
  const marginDirection = directionConfig === "rtl" ? "marginLeft" : "marginRight";
  let latestIndex = 0;
  const nodes = childNodes.map((child, i2) => {
    if (child !== null && child !== void 0) {
      latestIndex = i2;
    }
    const key = child && child.key || `${itemClassName}-${i2}`;
    return /* @__PURE__ */ jsx(Item$1, {
      className: itemClassName,
      direction,
      index: i2,
      marginDirection,
      split,
      wrap: wrap2,
      children: child
    }, key);
  });
  const spaceContext = react.exports.useMemo(() => ({
    horizontalSize,
    verticalSize,
    latestIndex,
    supportFlexGap
  }), [horizontalSize, verticalSize, latestIndex, supportFlexGap]);
  if (childNodes.length === 0) {
    return null;
  }
  const gapStyle = {};
  if (wrap2) {
    gapStyle.flexWrap = "wrap";
    if (!supportFlexGap) {
      gapStyle.marginBottom = -verticalSize;
    }
  }
  if (supportFlexGap) {
    gapStyle.columnGap = horizontalSize;
    gapStyle.rowGap = verticalSize;
  }
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      ...Object.assign({
        className: cn,
        style: Object.assign(Object.assign({}, gapStyle), style2)
      }, otherProps),
      children: /* @__PURE__ */ jsx(SpaceContext.Provider, {
        value: spaceContext,
        children: nodes
      })
    })
  );
};
const CompoundedSpace = Space;
CompoundedSpace.Compact = Compact$1;
const Space$1 = CompoundedSpace;
const genButtonStyle = (token2) => {
  const {
    componentCls,
    antCls,
    paddingXS,
    opacityLoading
  } = token2;
  return {
    [`${componentCls}-button`]: {
      whiteSpace: "nowrap",
      [`&${antCls}-btn-group > ${antCls}-btn`]: {
        [`&-loading, &-loading + ${antCls}-btn`]: {
          cursor: "default",
          pointerEvents: "none",
          opacity: opacityLoading
        },
        [`&:last-child:not(:first-child):not(${antCls}-btn-icon-only)`]: {
          paddingInline: paddingXS
        }
      }
    }
  };
};
const genButtonStyle$1 = genButtonStyle;
const genStatusStyle$1 = (token2) => {
  const {
    componentCls,
    menuCls,
    colorError,
    colorTextLightSolid
  } = token2;
  const itemCls = `${menuCls}-item`;
  return {
    [`${componentCls}, ${componentCls}-menu-submenu`]: {
      [`${menuCls} ${itemCls}`]: {
        [`&${itemCls}-danger:not(${itemCls}-disabled)`]: {
          color: colorError,
          "&:hover": {
            color: colorTextLightSolid,
            backgroundColor: colorError
          }
        }
      }
    }
  };
};
const genStatusStyle$2 = genStatusStyle$1;
const genBaseStyle$1 = (token2) => {
  const {
    componentCls,
    menuCls,
    zIndexPopup,
    dropdownArrowDistance,
    sizePopupArrow,
    antCls,
    iconCls,
    motionDurationMid,
    dropdownPaddingVertical,
    fontSize,
    dropdownEdgeChildPadding,
    colorTextDisabled,
    fontSizeIcon,
    controlPaddingHorizontal,
    colorBgElevated
  } = token2;
  return [
    {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: true,
          value: -9999
        },
        zIndex: zIndexPopup,
        display: "block",
        "&::before": {
          position: "absolute",
          insetBlock: -dropdownArrowDistance + sizePopupArrow / 2,
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        [`${componentCls}-wrap`]: {
          position: "relative",
          [`${antCls}-btn > ${iconCls}-down`]: {
            fontSize: fontSizeIcon
          },
          [`${iconCls}-down::before`]: {
            transition: `transform ${motionDurationMid}`
          }
        },
        [`${componentCls}-wrap-open`]: {
          [`${iconCls}-down::before`]: {
            transform: `rotate(180deg)`
          }
        },
        [`
        &-hidden,
        &-menu-hidden,
        &-menu-submenu-hidden
      `]: {
          display: "none"
        },
        [`&${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-enter${antCls}-slide-down-enter-active${componentCls}-placement-bottomRight,
          &${antCls}-slide-down-appear${antCls}-slide-down-appear-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpIn
        },
        [`&${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-top,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-top,
          &${antCls}-slide-up-enter${antCls}-slide-up-enter-active${componentCls}-placement-topRight,
          &${antCls}-slide-up-appear${antCls}-slide-up-appear-active${componentCls}-placement-topRight`]: {
          animationName: slideDownIn
        },
        [`&${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomLeft,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottom,
          &${antCls}-slide-down-leave${antCls}-slide-down-leave-active${componentCls}-placement-bottomRight`]: {
          animationName: slideUpOut
        },
        [`&${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topLeft,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-top,
          &${antCls}-slide-up-leave${antCls}-slide-up-leave-active${componentCls}-placement-topRight`]: {
          animationName: slideDownOut
        }
      })
    },
    getArrowStyle(token2, {
      colorBg: colorBgElevated,
      limitVerticalRadius: true,
      arrowPlacement: {
        top: true,
        bottom: true
      }
    }),
    {
      [`${componentCls} ${menuCls}`]: {
        position: "relative",
        margin: 0
      },
      [`${menuCls}-submenu-popup`]: {
        position: "absolute",
        zIndex: zIndexPopup,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul, li": {
          listStyle: "none",
          margin: 0
        }
      },
      [`${componentCls}, ${componentCls}-menu-submenu`]: {
        [menuCls]: Object.assign(Object.assign({
          padding: dropdownEdgeChildPadding,
          listStyleType: "none",
          backgroundColor: colorBgElevated,
          backgroundClip: "padding-box",
          borderRadius: token2.borderRadiusLG,
          outline: "none",
          boxShadow: token2.boxShadowSecondary
        }, genFocusStyle(token2)), {
          [`${menuCls}-item-group-title`]: {
            padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
            color: token2.colorTextDescription,
            transition: `all ${motionDurationMid}`
          },
          [`${menuCls}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center"
          },
          [`${menuCls}-item-icon`]: {
            minWidth: fontSize,
            marginInlineEnd: token2.marginXS,
            fontSize: token2.fontSizeSM
          },
          [`${menuCls}-title-content`]: {
            flex: "auto",
            "> a": {
              color: "inherit",
              transition: `all ${motionDurationMid}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            }
          },
          [`${menuCls}-item, ${menuCls}-submenu-title`]: Object.assign(Object.assign({
            clear: "both",
            margin: 0,
            padding: `${dropdownPaddingVertical}px ${controlPaddingHorizontal}px`,
            color: token2.colorText,
            fontWeight: "normal",
            fontSize,
            lineHeight: token2.lineHeight,
            cursor: "pointer",
            transition: `all ${motionDurationMid}`,
            borderRadius: token2.borderRadiusSM,
            [`&:hover, &-active`]: {
              backgroundColor: token2.controlItemBgHover
            }
          }, genFocusStyle(token2)), {
            "&-selected": {
              color: token2.colorPrimary,
              backgroundColor: token2.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: token2.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                color: colorTextDisabled,
                backgroundColor: colorBgElevated,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              margin: `${token2.marginXXS}px 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: token2.colorSplit
            },
            [`${componentCls}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: token2.paddingXS,
              [`${componentCls}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: token2.colorTextDescription,
                fontSize: fontSizeIcon,
                fontStyle: "normal"
              }
            }
          }),
          [`${menuCls}-item-group-list`]: {
            margin: `0 ${token2.marginXS}px`,
            padding: 0,
            listStyle: "none"
          },
          [`${menuCls}-submenu-title`]: {
            paddingInlineEnd: controlPaddingHorizontal + token2.fontSizeSM
          },
          [`${menuCls}-submenu-vertical`]: {
            position: "relative"
          },
          [`${menuCls}-submenu${menuCls}-submenu-disabled ${componentCls}-menu-submenu-title`]: {
            [`&, ${componentCls}-menu-submenu-arrow-icon`]: {
              color: colorTextDisabled,
              backgroundColor: colorBgElevated,
              cursor: "not-allowed"
            }
          },
          [`${menuCls}-submenu-selected ${componentCls}-menu-submenu-title`]: {
            color: token2.colorPrimary
          }
        })
      }
    },
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down"), initMoveMotion(token2, "move-up"), initMoveMotion(token2, "move-down"), initZoomMotion(token2, "zoom-big")]
  ];
};
const useStyle$d = genComponentStyleHook("Dropdown", (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const {
    marginXXS,
    sizePopupArrow,
    controlHeight,
    fontSize,
    lineHeight,
    paddingXXS,
    componentCls,
    borderRadiusLG
  } = token2;
  const dropdownPaddingVertical = (controlHeight - fontSize * lineHeight) / 2;
  const {
    dropdownArrowOffset
  } = getArrowOffset({
    contentRadius: borderRadiusLG
  });
  const dropdownToken = merge(token2, {
    menuCls: `${componentCls}-menu`,
    rootPrefixCls,
    dropdownArrowDistance: sizePopupArrow / 2 + marginXXS,
    dropdownArrowOffset,
    dropdownPaddingVertical,
    dropdownEdgeChildPadding: paddingXXS
  });
  return [genBaseStyle$1(dropdownToken), genButtonStyle$1(dropdownToken), genStatusStyle$2(dropdownToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
var __rest$v = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const DropdownButton = (props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    type: type4 = "default",
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    children,
    className,
    menu,
    arrow,
    autoFocus,
    overlay,
    trigger,
    align,
    open: open2,
    onOpenChange,
    placement,
    getPopupContainer,
    href,
    icon = /* @__PURE__ */ jsx(EllipsisOutlined$1, {}),
    title,
    buttonsRender = (buttons) => buttons,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender
  } = props, restProps = __rest$v(props, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "dropdownRender"]);
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const buttonPrefixCls = `${prefixCls}-button`;
  const [wrapSSR, hashId] = useStyle$d(prefixCls);
  const dropdownProps = {
    menu,
    arrow,
    autoFocus,
    align,
    disabled,
    trigger: disabled ? [] : trigger,
    onOpenChange,
    getPopupContainer: getPopupContainer || getContextPopupContainer,
    mouseEnterDelay,
    mouseLeaveDelay,
    overlayClassName,
    overlayStyle,
    destroyPopupOnHide,
    dropdownRender
  };
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const classes = classNames(buttonPrefixCls, compactItemClassnames, className, hashId);
  if ("overlay" in props) {
    dropdownProps.overlay = overlay;
  }
  if ("open" in props) {
    dropdownProps.open = open2;
  }
  if ("placement" in props) {
    dropdownProps.placement = placement;
  } else {
    dropdownProps.placement = direction === "rtl" ? "bottomLeft" : "bottomRight";
  }
  const leftButton = /* @__PURE__ */ jsx(Button$1, {
    type: type4,
    danger,
    disabled,
    loading,
    onClick,
    htmlType,
    href,
    title,
    children
  });
  const rightButton = /* @__PURE__ */ jsx(Button$1, {
    type: type4,
    danger,
    icon
  });
  const [leftButtonToRender, rightButtonToRender] = buttonsRender([leftButton, rightButton]);
  return wrapSSR(
    /* @__PURE__ */ jsxs(Space$1.Compact, {
      ...Object.assign({
        className: classes,
        size: compactSize,
        block: true
      }, restProps),
      children: [leftButtonToRender, /* @__PURE__ */ jsx(Dropdown$1, {
        ...Object.assign({}, dropdownProps),
        children: rightButtonToRender
      })]
    })
  );
};
DropdownButton.__ANT_BUTTON = true;
const DropdownButton$1 = DropdownButton;
const Dropdown = (props) => {
  const {
    getPopupContainer: getContextPopupContainer,
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const getTransitionName2 = () => {
    const rootPrefixCls = getPrefixCls();
    const {
      placement = "",
      transitionName
    } = props;
    if (transitionName !== void 0) {
      return transitionName;
    }
    if (placement.includes("top")) {
      return `${rootPrefixCls}-slide-down`;
    }
    return `${rootPrefixCls}-slide-up`;
  };
  const getPlacement = () => {
    const {
      placement
    } = props;
    if (!placement) {
      return direction === "rtl" ? "bottomRight" : "bottomLeft";
    }
    if (placement.includes("Center")) {
      const newPlacement = placement.slice(0, placement.indexOf("Center"));
      return newPlacement;
    }
    return placement;
  };
  const {
    menu,
    arrow,
    prefixCls: customizePrefixCls,
    children,
    trigger,
    disabled,
    dropdownRender,
    getPopupContainer,
    overlayClassName,
    rootClassName,
    open: open2,
    onOpenChange,
    visible,
    onVisibleChange,
    mouseEnterDelay = 0.15,
    mouseLeaveDelay = 0.1,
    autoAdjustOverflow: autoAdjustOverflow2 = true
  } = props;
  const prefixCls = getPrefixCls("dropdown", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$d(prefixCls);
  const {
    token: token2
  } = theme.useToken();
  const child = react.exports.Children.only(children);
  const dropdownTrigger = cloneElement(child, {
    className: classNames(`${prefixCls}-trigger`, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, child.props.className),
    disabled
  });
  const triggerActions = disabled ? [] : trigger;
  let alignPoint2;
  if (triggerActions && triggerActions.includes("contextMenu")) {
    alignPoint2 = true;
  }
  const [mergedOpen, setOpen] = useMergedState(false, {
    value: open2 !== null && open2 !== void 0 ? open2 : visible
  });
  const onInnerOpenChange = useEvent((nextOpen) => {
    onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(nextOpen);
    onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(nextOpen);
    setOpen(nextOpen);
  });
  const overlayClassNameCustomized = classNames(overlayClassName, rootClassName, hashId, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  });
  const builtinPlacements = getPlacements({
    arrowPointAtCenter: typeof arrow === "object" && arrow.pointAtCenter,
    autoAdjustOverflow: autoAdjustOverflow2,
    offset: token2.marginXXS,
    arrowWidth: arrow ? token2.sizePopupArrow : 0
  });
  const onMenuClick = react.exports.useCallback(() => {
    setOpen(false);
  }, []);
  const renderOverlay = () => {
    const {
      overlay
    } = props;
    let overlayNode;
    if (menu === null || menu === void 0 ? void 0 : menu.items) {
      overlayNode = /* @__PURE__ */ jsx(Menu$1, {
        ...Object.assign({}, menu)
      });
    } else if (typeof overlay === "function") {
      overlayNode = overlay();
    } else {
      overlayNode = overlay;
    }
    if (dropdownRender) {
      overlayNode = dropdownRender(overlayNode);
    }
    overlayNode = react.exports.Children.only(typeof overlayNode === "string" ? /* @__PURE__ */ jsx("span", {
      children: overlayNode
    }) : overlayNode);
    return /* @__PURE__ */ jsx(OverrideProvider, {
      prefixCls: `${prefixCls}-menu`,
      expandIcon: /* @__PURE__ */ jsx("span", {
        className: `${prefixCls}-menu-submenu-arrow`,
        children: /* @__PURE__ */ jsx(RightOutlined$1, {
          className: `${prefixCls}-menu-submenu-arrow-icon`
        })
      }),
      mode: "vertical",
      selectable: false,
      onClick: onMenuClick,
      validator: (_ref3) => {
      },
      children: /* @__PURE__ */ jsx(NoCompactStyle, {
        children: overlayNode
      })
    });
  };
  return wrapSSR(
    /* @__PURE__ */ jsx(Dropdown$3, {
      ...Object.assign({
        alignPoint: alignPoint2
      }, omit(props, ["rootClassName"]), {
        mouseEnterDelay,
        mouseLeaveDelay,
        visible: mergedOpen,
        builtinPlacements,
        arrow: !!arrow,
        overlayClassName: overlayClassNameCustomized,
        prefixCls,
        getPopupContainer: getPopupContainer || getContextPopupContainer,
        transitionName: getTransitionName2(),
        trigger: triggerActions,
        overlay: renderOverlay,
        placement: getPlacement(),
        onVisibleChange: onInnerOpenChange
      }),
      children: dropdownTrigger
    })
  );
};
Dropdown.Button = DropdownButton$1;
const PurePanel$3 = genPurePanel(Dropdown, "dropdown", (prefixCls) => prefixCls);
const WrapPurePanel = (props) => /* @__PURE__ */ jsx(PurePanel$3, {
  ...Object.assign({}, props),
  children: /* @__PURE__ */ jsx("span", {})
});
Dropdown._InternalPanelDoNotUseOrYouWillBeFired = WrapPurePanel;
const Dropdown$1 = Dropdown;
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t2 = 1e3, e2 = 6e4, n2 = 36e5, r2 = "millisecond", i2 = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", f2 = "month", h2 = "quarter", c2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M2 = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t3 % 100;
      return "[" + t3 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t3, e3, n3) {
      var r3 = String(t3);
      return !r3 || r3.length >= e3 ? t3 : "" + Array(e3 + 1 - r3.length).join(n3) + t3;
    }, v2 = { s: m2, z: function(t3) {
      var e3 = -t3.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i3 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i3, 2, "0");
    }, m: function t3(e3, n3) {
      if (e3.date() < n3.date())
        return -t3(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i3 = e3.clone().add(r3, f2), s3 = n3 - i3 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), f2);
      return +(-(r3 + (n3 - i3) / (s3 ? i3 - u3 : u3 - i3)) || 0);
    }, a: function(t3) {
      return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
    }, p: function(t3) {
      return { M: f2, y: c2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i2, ms: r2, Q: h2 }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t3) {
      return void 0 === t3;
    } }, g2 = "en", D2 = {};
    D2[g2] = M2;
    var p2 = function(t3) {
      return t3 instanceof _2;
    }, S2 = function t3(e3, n3, r3) {
      var i3;
      if (!e3)
        return g2;
      if ("string" == typeof e3) {
        var s3 = e3.toLowerCase();
        D2[s3] && (i3 = s3), n3 && (D2[s3] = n3, i3 = s3);
        var u3 = e3.split("-");
        if (!i3 && u3.length > 1)
          return t3(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i3 = a3;
      }
      return !r3 && i3 && (g2 = i3), i3 || !r3 && g2;
    }, w2 = function(t3, e3) {
      if (p2(t3))
        return t3.clone();
      var n3 = "object" == typeof e3 ? e3 : {};
      return n3.date = t3, n3.args = arguments, new _2(n3);
    }, O2 = v2;
    O2.l = S2, O2.i = p2, O2.w = function(t3, e3) {
      return w2(t3, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _2 = function() {
      function M3(t3) {
        this.$L = S2(t3.locale, null, true), this.parse(t3);
      }
      var m3 = M3.prototype;
      return m3.parse = function(t3) {
        this.$d = function(t4) {
          var e3 = t4.date, n3 = t4.utc;
          if (null === e3)
            return new Date(NaN);
          if (O2.u(e3))
            return new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r3 = e3.match($);
            if (r3) {
              var i3 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i3, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t3), this.$x = t3.x || {}, this.init();
      }, m3.init = function() {
        var t3 = this.$d;
        this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
      }, m3.$utils = function() {
        return O2;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t3, e3) {
        var n3 = w2(t3);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t3, e3) {
        return w2(t3) < this.startOf(e3);
      }, m3.isBefore = function(t3, e3) {
        return this.endOf(e3) < w2(t3);
      }, m3.$g = function(t3, e3, n3) {
        return O2.u(t3) ? this[e3] : this.set(n3, t3);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t3, e3) {
        var n3 = this, r3 = !!O2.u(e3) || e3, h3 = O2.p(t3), l3 = function(t4, e4) {
          var i3 = O2.w(n3.$u ? Date.UTC(n3.$y, e4, t4) : new Date(n3.$y, e4, t4), n3);
          return r3 ? i3 : i3.endOf(a2);
        }, $2 = function(t4, e4) {
          return O2.w(n3.toDate()[t4].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M4 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case f2:
            return r3 ? l3(1, M4) : l3(0, M4 + 1);
          case o2:
            var g3 = this.$locale().weekStart || 0, D3 = (y3 < g3 ? y3 + 7 : y3) - g3;
            return l3(r3 ? m4 - D3 : m4 + (6 - D3), M4);
          case a2:
          case d2:
            return $2(v3 + "Hours", 0);
          case u2:
            return $2(v3 + "Minutes", 1);
          case s2:
            return $2(v3 + "Seconds", 2);
          case i2:
            return $2(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t3) {
        return this.startOf(t3, false);
      }, m3.$set = function(t3, e3) {
        var n3, o3 = O2.p(t3), h3 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = h3 + "Date", n3[d2] = h3 + "Date", n3[f2] = h3 + "Month", n3[c2] = h3 + "FullYear", n3[u2] = h3 + "Hours", n3[s2] = h3 + "Minutes", n3[i2] = h3 + "Seconds", n3[r2] = h3 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === f2 || o3 === c2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m3.set = function(t3, e3) {
        return this.clone().$set(t3, e3);
      }, m3.get = function(t3) {
        return this[O2.p(t3)]();
      }, m3.add = function(r3, h3) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $2 = O2.p(h3), y3 = function(t3) {
          var e3 = w2(l3);
          return O2.w(e3.date(e3.date() + Math.round(t3 * r3)), l3);
        };
        if ($2 === f2)
          return this.set(f2, this.$M + r3);
        if ($2 === c2)
          return this.set(c2, this.$y + r3);
        if ($2 === a2)
          return y3(1);
        if ($2 === o2)
          return y3(7);
        var M4 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i2] = t2, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M4;
        return O2.w(m4, this);
      }, m3.subtract = function(t3, e3) {
        return this.add(-1 * t3, e3);
      }, m3.format = function(t3) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i3 = O2.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, f3 = n3.months, h3 = function(t4, n4, i4, s4) {
          return t4 && (t4[n4] || t4(e3, r3)) || i4[n4].slice(0, s4);
        }, c3 = function(t4) {
          return O2.s(s3 % 12 || 12, t4, "0");
        }, d3 = n3.meridiem || function(t4, e4, n4) {
          var r4 = t4 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        }, $2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a3 + 1, MM: O2.s(a3 + 1, 2, "0"), MMM: h3(n3.monthsShort, a3, f3, 3), MMMM: h3(f3, a3), D: this.$D, DD: O2.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n3.weekdaysMin, this.$W, o3, 2), ddd: h3(n3.weekdaysShort, this.$W, o3, 3), dddd: o3[this.$W], H: String(s3), HH: O2.s(s3, 2, "0"), h: c3(1), hh: c3(2), a: d3(s3, u3, true), A: d3(s3, u3, false), m: String(u3), mm: O2.s(u3, 2, "0"), s: String(this.$s), ss: O2.s(this.$s, 2, "0"), SSS: O2.s(this.$ms, 3, "0"), Z: i3 };
        return r3.replace(y2, function(t4, e4) {
          return e4 || $2[t4] || i3.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $2, y3 = O2.p(d3), M4 = w2(r3), m4 = (M4.utcOffset() - this.utcOffset()) * e2, v3 = this - M4, g3 = O2.m(this, M4);
        return g3 = ($2 = {}, $2[c2] = g3 / 12, $2[f2] = g3, $2[h2] = g3 / 3, $2[o2] = (v3 - m4) / 6048e5, $2[a2] = (v3 - m4) / 864e5, $2[u2] = v3 / n2, $2[s2] = v3 / e2, $2[i2] = v3 / t2, $2)[y3] || v3, l3 ? g3 : O2.a(g3);
      }, m3.daysInMonth = function() {
        return this.endOf(f2).$D;
      }, m3.$locale = function() {
        return D2[this.$L];
      }, m3.locale = function(t3, e3) {
        if (!t3)
          return this.$L;
        var n3 = this.clone(), r3 = S2(t3, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return O2.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M3;
    }(), T2 = _2.prototype;
    return w2.prototype = T2, [["$ms", r2], ["$s", i2], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", f2], ["$y", c2], ["$D", d2]].forEach(function(t3) {
      T2[t3[1]] = function(e3) {
        return this.$g(e3, t3[0], t3[1]);
      };
    }), w2.extend = function(t3, e3) {
      return t3.$i || (t3(e3, _2, w2), t3.$i = true), w2;
    }, w2.locale = S2, w2.isDayjs = p2, w2.unix = function(t3) {
      return w2(1e3 * t3);
    }, w2.en = D2[g2], w2.Ls = D2, w2.p = {}, w2;
  });
})(dayjs_min);
const dayjs = dayjs_min.exports;
var Checkbox$3 = /* @__PURE__ */ function(_Component) {
  _inherits(Checkbox2, _Component);
  var _super = _createSuper(Checkbox2);
  function Checkbox2(props) {
    var _this;
    _classCallCheck(this, Checkbox2);
    _this = _super.call(this, props);
    _this.handleChange = function(e2) {
      var _this$props = _this.props, disabled = _this$props.disabled, onChange2 = _this$props.onChange;
      if (disabled) {
        return;
      }
      if (!("checked" in _this.props)) {
        _this.setState({
          checked: e2.target.checked
        });
      }
      if (onChange2) {
        onChange2({
          target: _objectSpread2$1(_objectSpread2$1({}, _this.props), {}, {
            checked: e2.target.checked
          }),
          stopPropagation: function stopPropagation() {
            e2.stopPropagation();
          },
          preventDefault: function preventDefault() {
            e2.preventDefault();
          },
          nativeEvent: e2.nativeEvent
        });
      }
    };
    _this.saveInput = function(node2) {
      _this.input = node2;
    };
    var checked = "checked" in props ? props.checked : props.defaultChecked;
    _this.state = {
      checked
    };
    return _this;
  }
  _createClass(Checkbox2, [{
    key: "focus",
    value: function focus() {
      this.input.focus();
    }
  }, {
    key: "blur",
    value: function blur() {
      this.input.blur();
    }
  }, {
    key: "render",
    value: function render2() {
      var _classNames;
      var _this$props2 = this.props, prefixCls = _this$props2.prefixCls, className = _this$props2.className, style2 = _this$props2.style, name2 = _this$props2.name, id2 = _this$props2.id, type4 = _this$props2.type, disabled = _this$props2.disabled, readOnly = _this$props2.readOnly, tabIndex = _this$props2.tabIndex, onClick = _this$props2.onClick, onFocus2 = _this$props2.onFocus, onBlur2 = _this$props2.onBlur, onKeyDown2 = _this$props2.onKeyDown, onKeyPress2 = _this$props2.onKeyPress, onKeyUp2 = _this$props2.onKeyUp, autoFocus = _this$props2.autoFocus, value = _this$props2.value, required4 = _this$props2.required, others = _objectWithoutProperties(_this$props2, ["prefixCls", "className", "style", "name", "id", "type", "disabled", "readOnly", "tabIndex", "onClick", "onFocus", "onBlur", "onKeyDown", "onKeyPress", "onKeyUp", "autoFocus", "value", "required"]);
      var globalProps = Object.keys(others).reduce(function(prev2, key) {
        if (key.substr(0, 5) === "aria-" || key.substr(0, 5) === "data-" || key === "role") {
          prev2[key] = others[key];
        }
        return prev2;
      }, {});
      var checked = this.state.checked;
      var classString = classNames(prefixCls, className, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-checked"), checked), _defineProperty$1(_classNames, "".concat(prefixCls, "-disabled"), disabled), _classNames));
      return /* @__PURE__ */ jsxs("span", {
        className: classString,
        style: style2,
        children: [/* @__PURE__ */ jsx("input", {
          name: name2,
          id: id2,
          type: type4,
          required: required4,
          readOnly,
          disabled,
          tabIndex,
          className: "".concat(prefixCls, "-input"),
          checked: !!checked,
          onClick,
          onFocus: onFocus2,
          onBlur: onBlur2,
          onKeyUp: onKeyUp2,
          onKeyDown: onKeyDown2,
          onKeyPress: onKeyPress2,
          onChange: this.handleChange,
          autoFocus,
          ref: this.saveInput,
          value,
          ...globalProps
        }), /* @__PURE__ */ jsx("span", {
          className: "".concat(prefixCls, "-inner")
        })]
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      if ("checked" in props) {
        return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
          checked: props.checked
        });
      }
      return null;
    }
  }]);
  return Checkbox2;
}(react.exports.Component);
Checkbox$3.defaultProps = {
  prefixCls: "rc-checkbox",
  className: "",
  style: {},
  type: "checkbox",
  defaultChecked: false,
  onFocus: function onFocus() {
  },
  onBlur: function onBlur() {
  },
  onChange: function onChange() {
  },
  onKeyDown: function onKeyDown() {
  },
  onKeyPress: function onKeyPress() {
  },
  onKeyUp: function onKeyUp() {
  }
};
const genPlaceholderStyle = (color) => ({
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color,
    userSelect: "none"
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
});
const genHoverStyle = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  borderInlineEndWidth: token2.lineWidth
});
const genActiveStyle = (token2) => ({
  borderColor: token2.inputBorderHoverColor,
  boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`,
  borderInlineEndWidth: token2.lineWidth,
  outline: 0
});
const genDisabledStyle = (token2) => ({
  color: token2.colorTextDisabled,
  backgroundColor: token2.colorBgContainerDisabled,
  borderColor: token2.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": Object.assign({}, genHoverStyle(merge(token2, {
    inputBorderHoverColor: token2.colorBorder
  })))
});
const genInputLargeStyle = (token2) => {
  const {
    inputPaddingVerticalLG,
    fontSizeLG,
    lineHeightLG,
    borderRadiusLG,
    inputPaddingHorizontalLG
  } = token2;
  return {
    padding: `${inputPaddingVerticalLG}px ${inputPaddingHorizontalLG}px`,
    fontSize: fontSizeLG,
    lineHeight: lineHeightLG,
    borderRadius: borderRadiusLG
  };
};
const genInputSmallStyle = (token2) => ({
  padding: `${token2.inputPaddingVerticalSM}px ${token2.controlPaddingHorizontalSM - 1}px`,
  borderRadius: token2.borderRadiusSM
});
const genStatusStyle = (token2, parentCls) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    colorErrorOutline,
    colorWarningOutline,
    colorErrorBorderHover,
    colorWarningBorderHover
  } = token2;
  return {
    [`&-status-error:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
      borderColor: colorError,
      "&:hover": {
        borderColor: colorErrorBorderHover
      },
      "&:focus, &-focused": Object.assign({}, genActiveStyle(merge(token2, {
        inputBorderActiveColor: colorError,
        inputBorderHoverColor: colorError,
        controlOutline: colorErrorOutline
      }))),
      [`${componentCls}-prefix, ${componentCls}-suffix`]: {
        color: colorError
      }
    },
    [`&-status-warning:not(${parentCls}-disabled):not(${parentCls}-borderless)${parentCls}`]: {
      borderColor: colorWarning,
      "&:hover": {
        borderColor: colorWarningBorderHover
      },
      "&:focus, &-focused": Object.assign({}, genActiveStyle(merge(token2, {
        inputBorderActiveColor: colorWarning,
        inputBorderHoverColor: colorWarning,
        controlOutline: colorWarningOutline
      }))),
      [`${componentCls}-prefix, ${componentCls}-suffix`]: {
        color: colorWarning
      }
    }
  };
};
const genBasicInputStyle = (token2) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${token2.inputPaddingVertical}px ${token2.inputPaddingHorizontal}px`,
  color: token2.colorText,
  fontSize: token2.fontSize,
  lineHeight: token2.lineHeight,
  backgroundColor: token2.colorBgContainer,
  backgroundImage: "none",
  borderWidth: token2.lineWidth,
  borderStyle: token2.lineType,
  borderColor: token2.colorBorder,
  borderRadius: token2.borderRadius,
  transition: `all ${token2.motionDurationMid}`
}, genPlaceholderStyle(token2.colorTextPlaceholder)), {
  "&:hover": Object.assign({}, genHoverStyle(token2)),
  "&:focus, &-focused": Object.assign({}, genActiveStyle(token2)),
  "&-disabled, &[disabled]": Object.assign({}, genDisabledStyle(token2)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: token2.controlHeight,
    lineHeight: token2.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${token2.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  "&-lg": Object.assign({}, genInputLargeStyle(token2)),
  "&-sm": Object.assign({}, genInputSmallStyle(token2)),
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
});
const genInputGroupStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    [`&[class*='col-']`]: {
      paddingInlineEnd: token2.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token2)),
    [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token2)),
    [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightLG
    },
    [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
      height: token2.controlHeightSM
    },
    [`> ${componentCls}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${componentCls}-group`]: {
      [`&-addon, &-wrap`]: {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${token2.inputPaddingHorizontal}px`,
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        textAlign: "center",
        backgroundColor: token2.colorFillAlter,
        border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
        borderRadius: token2.borderRadius,
        transition: `all ${token2.motionDurationSlow}`,
        lineHeight: 1,
        [`${antCls}-select`]: {
          margin: `-${token2.inputPaddingVertical + 1}px -${token2.inputPaddingHorizontal}px`,
          [`&${antCls}-select-single:not(${antCls}-select-customize-input)`]: {
            [`${antCls}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${token2.lineWidth}px ${token2.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${antCls}-select-selector`]: {
              color: token2.colorPrimary
            }
          }
        },
        [`${antCls}-cascader-picker`]: {
          margin: `-9px -${token2.inputPaddingHorizontal}px`,
          backgroundColor: "transparent",
          [`${antCls}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    [`${componentCls}`]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}-affix-wrapper`]: {
      [`&:not(:first-child) ${componentCls}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${componentCls}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      [`${antCls}-select ${antCls}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${componentCls}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${componentCls}-search &`]: {
          borderStartStartRadius: token2.borderRadius,
          borderEndStartRadius: token2.borderRadius
        }
      },
      [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, clearFix()), {
      [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: token2.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        borderRadius: 0
      },
      [`& > ${componentCls}-affix-wrapper`]: {
        display: "inline-flex"
      },
      [`& > ${antCls}-picker-range`]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: -token2.lineWidth,
        borderInlineEndWidth: token2.lineWidth
      },
      [`${componentCls}`]: {
        float: "none"
      },
      [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${antCls}-select-focused`]: {
        zIndex: 1
      },
      [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
        zIndex: 1
      },
      [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
        borderStartStartRadius: token2.borderRadius,
        borderEndStartRadius: token2.borderRadius
      },
      [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
        borderInlineEndWidth: token2.lineWidth,
        borderStartEndRadius: token2.borderRadius,
        borderEndEndRadius: token2.borderRadius
      },
      [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
        verticalAlign: "top"
      },
      [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
        marginInlineStart: -token2.lineWidth,
        [`${componentCls}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${componentCls}-group-wrapper:not(:last-child)`]: {
        [`&${componentCls}-search > ${componentCls}-group`]: {
          [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${componentCls}`]: {
            borderStartStartRadius: token2.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: token2.borderRadius
          }
        }
      }
    })
  };
};
const genInputStyle = (token2) => {
  const {
    componentCls,
    controlHeightSM,
    lineWidth
  } = token2;
  const FIXED_CHROME_COLOR_HEIGHT = 16;
  const colorSmallPadding = (controlHeightSM - lineWidth * 2 - FIXED_CHROME_COLOR_HEIGHT) / 2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genBasicInputStyle(token2)), genStatusStyle(token2, componentCls)), {
      '&[type="color"]': {
        height: token2.controlHeight,
        [`&${componentCls}-lg`]: {
          height: token2.controlHeightLG
        },
        [`&${componentCls}-sm`]: {
          height: controlHeightSM,
          paddingTop: colorSmallPadding,
          paddingBottom: colorSmallPadding
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    })
  };
};
const genAllowClearStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [`${componentCls}-clear-icon`]: {
      margin: 0,
      color: token2.colorTextQuaternary,
      fontSize: token2.fontSizeIcon,
      verticalAlign: -1,
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "&:hover": {
        color: token2.colorTextTertiary
      },
      "&:active": {
        color: token2.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${token2.inputAffixPadding}px`
      }
    }
  };
};
const genAffixStyle = (token2) => {
  const {
    componentCls,
    inputAffixPadding,
    colorTextDescription,
    motionDurationSlow,
    colorIcon,
    colorIconHover,
    iconCls
  } = token2;
  return {
    [`${componentCls}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token2)), {
      display: "inline-flex",
      [`&:not(${componentCls}-affix-wrapper-disabled):hover`]: Object.assign(Object.assign({}, genHoverStyle(token2)), {
        zIndex: 1,
        [`${componentCls}-search-with-button &`]: {
          zIndex: 0
        }
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${componentCls}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> input${componentCls}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${componentCls}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: token2.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: colorTextDescription
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: token2.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: inputAffixPadding
        },
        "&-suffix": {
          marginInlineStart: inputAffixPadding
        }
      }
    }), genAllowClearStyle(token2)), {
      [`${iconCls}${componentCls}-password-icon`]: {
        color: colorIcon,
        cursor: "pointer",
        transition: `all ${motionDurationSlow}`,
        "&:hover": {
          color: colorIconHover
        }
      }
    }), genStatusStyle(token2, `${componentCls}-affix-wrapper`))
  };
};
const genGroupStyle = (token2) => {
  const {
    componentCls,
    colorError,
    colorWarning,
    borderRadiusLG,
    borderRadiusSM
  } = token2;
  return {
    [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), genInputGroupStyle(token2)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        "&-lg": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusLG
          }
        },
        "&-sm": {
          [`${componentCls}-group-addon`]: {
            borderRadius: borderRadiusSM
          }
        },
        "&-status-error": {
          [`${componentCls}-group-addon`]: {
            color: colorError,
            borderColor: colorError
          }
        },
        "&-status-warning": {
          [`${componentCls}-group-addon`]: {
            color: colorWarning,
            borderColor: colorWarning
          }
        },
        "&-disabled": {
          [`${componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token2))
        }
      }
    })
  };
};
const genSearchInputStyle = (token2) => {
  const {
    componentCls,
    antCls
  } = token2;
  const searchPrefixCls = `${componentCls}-search`;
  return {
    [searchPrefixCls]: {
      [`${componentCls}`]: {
        "&:hover, &:focus": {
          borderColor: token2.colorPrimaryHover,
          [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            borderInlineStartColor: token2.colorPrimaryHover
          }
        }
      },
      [`${componentCls}-affix-wrapper`]: {
        borderRadius: 0
      },
      [`${componentCls}-lg`]: {
        lineHeight: token2.lineHeightLG - 2e-4
      },
      [`> ${componentCls}-group`]: {
        [`> ${componentCls}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${searchPrefixCls}-button`]: {
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: token2.borderRadius,
            borderEndEndRadius: token2.borderRadius,
            borderEndStartRadius: 0
          },
          [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
            color: token2.colorTextDescription,
            "&:hover": {
              color: token2.colorPrimaryHover
            },
            "&:active": {
              color: token2.colorPrimaryActive
            },
            [`&${antCls}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${searchPrefixCls}-button`]: {
        height: token2.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${searchPrefixCls}-button`]: {
        height: token2.controlHeightLG
      },
      [`&-small ${searchPrefixCls}-button`]: {
        height: token2.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      [`&${componentCls}-compact-item`]: {
        [`&:not(${componentCls}-compact-last-item)`]: {
          [`${componentCls}-group-addon`]: {
            [`${componentCls}-search-button`]: {
              marginInlineEnd: -token2.lineWidth,
              borderRadius: 0
            }
          }
        },
        [`&:not(${componentCls}-compact-first-item)`]: {
          [`${componentCls},${componentCls}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${componentCls}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
function initInputToken(token2) {
  return merge(token2, {
    inputAffixPadding: token2.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((token2.controlHeight - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((token2.controlHeightLG - token2.fontSizeLG * token2.lineHeightLG) / 2 * 10) / 10 - token2.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((token2.controlHeightSM - token2.fontSize * token2.lineHeight) / 2 * 10) / 10 - token2.lineWidth, 0),
    inputPaddingHorizontal: token2.paddingSM - token2.lineWidth,
    inputPaddingHorizontalSM: token2.paddingXS - token2.lineWidth,
    inputPaddingHorizontalLG: token2.controlPaddingHorizontal - token2.lineWidth,
    inputBorderHoverColor: token2.colorPrimaryHover,
    inputBorderActiveColor: token2.colorPrimaryHover
  });
}
const genTextAreaStyle = (token2) => {
  const {
    componentCls,
    paddingLG
  } = token2;
  const textareaPrefixCls = `${componentCls}-textarea`;
  return {
    [textareaPrefixCls]: {
      position: "relative",
      "&-show-count": {
        [`> ${componentCls}`]: {
          height: "100%"
        },
        [`${componentCls}-data-count`]: {
          color: token2.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none",
          float: "right",
          marginBottom: -token2.fontSize * token2.lineHeight
        },
        "&-rtl": {
          [`${componentCls}-data-count`]: {
            float: "left"
          }
        }
      },
      [`&-affix-wrapper${textareaPrefixCls}-has-feedback`]: {
        [`${componentCls}`]: {
          paddingInlineEnd: paddingLG
        }
      },
      [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${componentCls}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${componentCls}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          [`${componentCls}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: token2.paddingXS,
            insetBlockStart: token2.paddingXS
          },
          [`${textareaPrefixCls}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: token2.inputPaddingHorizontal,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      }
    }
  };
};
const useStyle$c = genComponentStyleHook("Input", (token2) => {
  const inputToken = initInputToken(token2);
  return [
    genInputStyle(inputToken),
    genTextAreaStyle(inputToken),
    genAffixStyle(inputToken),
    genGroupStyle(inputToken),
    genSearchInputStyle(inputToken),
    genCompactItemStyle(inputToken)
  ];
});
const Element$1 = (props) => {
  const {
    prefixCls,
    className,
    style: style2,
    size,
    shape
  } = props;
  const sizeCls = classNames({
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-sm`]: size === "small"
  });
  const shapeCls = classNames({
    [`${prefixCls}-circle`]: shape === "circle",
    [`${prefixCls}-square`]: shape === "square",
    [`${prefixCls}-round`]: shape === "round"
  });
  const sizeStyle = react.exports.useMemo(() => typeof size === "number" ? {
    width: size,
    height: size,
    lineHeight: `${size}px`
  } : {}, [size]);
  return /* @__PURE__ */ jsx("span", {
    className: classNames(prefixCls, sizeCls, shapeCls, className),
    style: Object.assign(Object.assign({}, sizeStyle), style2)
  });
};
const Element$2 = Element$1;
const skeletonClsLoading = new Keyframe(`ant-skeleton-loading`, {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
});
const genSkeletonElementCommonSize = (size) => ({
  height: size,
  lineHeight: `${size}px`
});
const genSkeletonElementAvatarSize = (size) => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonColor = (token2) => ({
  background: token2.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: skeletonClsLoading,
  animationDuration: token2.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
});
const genSkeletonElementInputSize = (size) => Object.assign({
  width: size * 5,
  minWidth: size * 5
}, genSkeletonElementCommonSize(size));
const genSkeletonElementAvatar = (token2) => {
  const {
    skeletonAvatarCls,
    color,
    controlHeight,
    controlHeightLG,
    controlHeightSM
  } = token2;
  return {
    [`${skeletonAvatarCls}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: color
    }, genSkeletonElementAvatarSize(controlHeight)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
      borderRadius: "50%"
    },
    [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
    [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
  };
};
const genSkeletonElementInput = (token2) => {
  const {
    controlHeight,
    borderRadiusSM,
    skeletonInputCls,
    controlHeightLG,
    controlHeightSM,
    color
  } = token2;
  return {
    [`${skeletonInputCls}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM
    }, genSkeletonElementInputSize(controlHeight)),
    [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG)),
    [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM))
  };
};
const genSkeletonElementImageSize = (size) => Object.assign({
  width: size
}, genSkeletonElementCommonSize(size));
const genSkeletonElementImage = (token2) => {
  const {
    skeletonImageCls,
    imageSizeBase,
    color,
    borderRadiusSM
  } = token2;
  return {
    [`${skeletonImageCls}`]: Object.assign(Object.assign({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM
    }, genSkeletonElementImageSize(imageSizeBase * 2)), {
      [`${skeletonImageCls}-path`]: {
        fill: "#bfbfbf"
      },
      [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
        maxWidth: imageSizeBase * 4,
        maxHeight: imageSizeBase * 4
      }),
      [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
      borderRadius: "50%"
    }
  };
};
const genSkeletonElementButtonShape = (token2, size, buttonCls) => {
  const {
    skeletonButtonCls
  } = token2;
  return {
    [`${buttonCls}${skeletonButtonCls}-circle`]: {
      width: size,
      minWidth: size,
      borderRadius: "50%"
    },
    [`${buttonCls}${skeletonButtonCls}-round`]: {
      borderRadius: size
    }
  };
};
const genSkeletonElementButtonSize = (size) => Object.assign({
  width: size * 2,
  minWidth: size * 2
}, genSkeletonElementCommonSize(size));
const genSkeletonElementButton = (token2) => {
  const {
    borderRadiusSM,
    skeletonButtonCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color
  } = token2;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    [`${skeletonButtonCls}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: color,
      borderRadius: borderRadiusSM,
      width: controlHeight * 2,
      minWidth: controlHeight * 2
    }, genSkeletonElementButtonSize(controlHeight))
  }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
    [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG))
  }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
    [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM))
  }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
};
const genBaseStyle = (token2) => {
  const {
    componentCls,
    skeletonAvatarCls,
    skeletonTitleCls,
    skeletonParagraphCls,
    skeletonButtonCls,
    skeletonInputCls,
    skeletonImageCls,
    controlHeight,
    controlHeightLG,
    controlHeightSM,
    color,
    padding,
    marginSM,
    borderRadius,
    skeletonTitleHeight,
    skeletonBlockRadius,
    skeletonParagraphLineHeight,
    controlHeightXS,
    skeletonParagraphMarginTop
  } = token2;
  return {
    [`${componentCls}`]: {
      display: "table",
      width: "100%",
      [`${componentCls}-header`]: {
        display: "table-cell",
        paddingInlineEnd: padding,
        verticalAlign: "top",
        [`${skeletonAvatarCls}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: color
        }, genSkeletonElementAvatarSize(controlHeight)),
        [`${skeletonAvatarCls}-circle`]: {
          borderRadius: "50%"
        },
        [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
        [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
      },
      [`${componentCls}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        [`${skeletonTitleCls}`]: {
          width: "100%",
          height: skeletonTitleHeight,
          background: color,
          borderRadius: skeletonBlockRadius,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: controlHeightSM
          }
        },
        [`${skeletonParagraphCls}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: skeletonParagraphLineHeight,
            listStyle: "none",
            background: color,
            borderRadius: skeletonBlockRadius,
            "+ li": {
              marginBlockStart: controlHeightXS
            }
          }
        },
        [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${componentCls}-content`]: {
        [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
          borderRadius
        }
      }
    },
    [`${componentCls}-with-avatar ${componentCls}-content`]: {
      [`${skeletonTitleCls}`]: {
        marginBlockStart: marginSM,
        [`+ ${skeletonParagraphCls}`]: {
          marginBlockStart: skeletonParagraphMarginTop
        }
      }
    },
    [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
      display: "inline-block",
      width: "auto"
    }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
    [`${componentCls}${componentCls}-block`]: {
      width: "100%",
      [`${skeletonButtonCls}`]: {
        width: "100%"
      },
      [`${skeletonInputCls}`]: {
        width: "100%"
      }
    },
    [`${componentCls}${componentCls}-active`]: {
      [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token2))
    }
  };
};
const useStyle$b = genComponentStyleHook("Skeleton", (token2) => {
  const {
    componentCls
  } = token2;
  const skeletonToken = merge(token2, {
    skeletonAvatarCls: `${componentCls}-avatar`,
    skeletonTitleCls: `${componentCls}-title`,
    skeletonParagraphCls: `${componentCls}-paragraph`,
    skeletonButtonCls: `${componentCls}-button`,
    skeletonInputCls: `${componentCls}-input`,
    skeletonImageCls: `${componentCls}-image`,
    imageSizeBase: token2.controlHeight * 1.5,
    skeletonTitleHeight: token2.controlHeight / 2,
    skeletonBlockRadius: token2.borderRadiusSM,
    skeletonParagraphLineHeight: token2.controlHeight / 2,
    skeletonParagraphMarginTop: token2.marginLG + token2.marginXXS,
    borderRadius: 100,
    skeletonLoadingBackground: `linear-gradient(90deg, ${token2.color} 25%, ${token2.colorGradientEnd} 37%, ${token2.color} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [genBaseStyle(skeletonToken)];
}, (token2) => {
  const {
    colorFillContent,
    colorFill
  } = token2;
  return {
    color: colorFillContent,
    colorGradientEnd: colorFill
  };
});
const SkeletonAvatar = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    shape = "circle",
    size = "default"
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  const otherProps = omit(props, ["prefixCls", "className"]);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className: cls,
      children: /* @__PURE__ */ jsx(Element$2, {
        ...Object.assign({
          prefixCls: `${prefixCls}-avatar`,
          shape,
          size
        }, otherProps)
      })
    })
  );
};
const SkeletonAvatar$1 = SkeletonAvatar;
const SkeletonButton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block = false,
    size = "default"
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  const otherProps = omit(props, ["prefixCls"]);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className: cls,
      children: /* @__PURE__ */ jsx(Element$2, {
        ...Object.assign({
          prefixCls: `${prefixCls}-button`,
          size
        }, otherProps)
      })
    })
  );
};
const SkeletonButton$1 = SkeletonButton;
var DotChartOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "dot-chart", "theme": "outlined" };
const DotChartOutlinedSvg = DotChartOutlined$2;
var DotChartOutlined = function DotChartOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: DotChartOutlinedSvg
    })
  });
};
DotChartOutlined.displayName = "DotChartOutlined";
const DotChartOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(DotChartOutlined);
const SkeletonNode = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    active,
    children
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, hashId, className, rootClassName);
  const content = children !== null && children !== void 0 ? children : /* @__PURE__ */ jsx(DotChartOutlined$1, {});
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className: cls,
      children: /* @__PURE__ */ jsx("div", {
        className: classNames(`${prefixCls}-image`, className),
        style: style2,
        children: content
      })
    })
  );
};
const SkeletonNode$1 = SkeletonNode;
const path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
const SkeletonImage = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    active
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active
  }, className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className: cls,
      children: /* @__PURE__ */ jsx("div", {
        className: classNames(`${prefixCls}-image`, className),
        style: style2,
        children: /* @__PURE__ */ jsx("svg", {
          viewBox: "0 0 1098 1024",
          xmlns: "http://www.w3.org/2000/svg",
          className: `${prefixCls}-image-svg`,
          children: /* @__PURE__ */ jsx("path", {
            d: path,
            className: `${prefixCls}-image-path`
          })
        })
      })
    })
  );
};
const SkeletonImage$1 = SkeletonImage;
const SkeletonInput = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    active,
    block,
    size = "default"
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  const otherProps = omit(props, ["prefixCls"]);
  const cls = classNames(prefixCls, `${prefixCls}-element`, {
    [`${prefixCls}-active`]: active,
    [`${prefixCls}-block`]: block
  }, className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className: cls,
      children: /* @__PURE__ */ jsx(Element$2, {
        ...Object.assign({
          prefixCls: `${prefixCls}-input`,
          size
        }, otherProps)
      })
    })
  );
};
const SkeletonInput$1 = SkeletonInput;
const Paragraph$2 = (props) => {
  const getWidth3 = (index2) => {
    const {
      width,
      rows: rows2 = 2
    } = props;
    if (Array.isArray(width)) {
      return width[index2];
    }
    if (rows2 - 1 === index2) {
      return width;
    }
    return void 0;
  };
  const {
    prefixCls,
    className,
    style: style2,
    rows
  } = props;
  const rowList = _toConsumableArray(Array(rows)).map((_2, index2) => /* @__PURE__ */ jsx("li", {
    style: {
      width: getWidth3(index2)
    }
  }, index2));
  return /* @__PURE__ */ jsx("ul", {
    className: classNames(prefixCls, className),
    style: style2,
    children: rowList
  });
};
const Paragraph$3 = Paragraph$2;
const Title$7 = (_ref) => {
  let {
    prefixCls,
    className,
    width,
    style: style2
  } = _ref;
  return /* @__PURE__ */ jsx("h3", {
    className: classNames(prefixCls, className),
    style: Object.assign({
      width
    }, style2)
  });
};
const Title$8 = Title$7;
function getComponentProps(prop) {
  if (prop && typeof prop === "object") {
    return prop;
  }
  return {};
}
function getAvatarBasicProps(hasTitle, hasParagraph) {
  if (hasTitle && !hasParagraph) {
    return {
      size: "large",
      shape: "square"
    };
  }
  return {
    size: "large",
    shape: "circle"
  };
}
function getTitleBasicProps(hasAvatar, hasParagraph) {
  if (!hasAvatar && hasParagraph) {
    return {
      width: "38%"
    };
  }
  if (hasAvatar && hasParagraph) {
    return {
      width: "50%"
    };
  }
  return {};
}
function getParagraphBasicProps(hasAvatar, hasTitle) {
  const basicProps = {};
  if (!hasAvatar || !hasTitle) {
    basicProps.width = "61%";
  }
  if (!hasAvatar && hasTitle) {
    basicProps.rows = 3;
  } else {
    basicProps.rows = 2;
  }
  return basicProps;
}
const Skeleton = (props) => {
  const {
    prefixCls: customizePrefixCls,
    loading,
    className,
    rootClassName,
    style: style2,
    children,
    avatar = false,
    title = true,
    paragraph = true,
    active,
    round
  } = props;
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$b(prefixCls);
  if (loading || !("loading" in props)) {
    const hasAvatar = !!avatar;
    const hasTitle = !!title;
    const hasParagraph = !!paragraph;
    let avatarNode;
    if (hasAvatar) {
      const avatarProps = Object.assign(Object.assign({
        prefixCls: `${prefixCls}-avatar`
      }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
      avatarNode = /* @__PURE__ */ jsx("div", {
        className: `${prefixCls}-header`,
        children: /* @__PURE__ */ jsx(Element$2, {
          ...Object.assign({}, avatarProps)
        })
      });
    }
    let contentNode;
    if (hasTitle || hasParagraph) {
      let $title;
      if (hasTitle) {
        const titleProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-title`
        }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
        $title = /* @__PURE__ */ jsx(Title$8, {
          ...Object.assign({}, titleProps)
        });
      }
      let paragraphNode;
      if (hasParagraph) {
        const paragraphProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-paragraph`
        }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
        paragraphNode = /* @__PURE__ */ jsx(Paragraph$3, {
          ...Object.assign({}, paragraphProps)
        });
      }
      contentNode = /* @__PURE__ */ jsxs("div", {
        className: `${prefixCls}-content`,
        children: [$title, paragraphNode]
      });
    }
    const cls = classNames(prefixCls, {
      [`${prefixCls}-with-avatar`]: hasAvatar,
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-round`]: round
    }, className, rootClassName, hashId);
    return wrapSSR(
      /* @__PURE__ */ jsxs("div", {
        className: cls,
        style: style2,
        children: [avatarNode, contentNode]
      })
    );
  }
  return typeof children !== "undefined" ? children : null;
};
Skeleton.Button = SkeletonButton$1;
Skeleton.Avatar = SkeletonAvatar$1;
Skeleton.Input = SkeletonInput$1;
Skeleton.Image = SkeletonImage$1;
Skeleton.Node = SkeletonNode$1;
const Skeleton$1 = Skeleton;
var PlusOutlined$4 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "defs", "attrs": {}, "children": [{ "tag": "style", "attrs": {} }] }, { "tag": "path", "attrs": { "d": "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { "tag": "path", "attrs": { "d": "M176 474h672q8 0 8 8v60q0 8-8 8H176q-8 0-8-8v-60q0-8 8-8z" } }] }, "name": "plus", "theme": "outlined" };
const PlusOutlinedSvg = PlusOutlined$4;
var PlusOutlined$2 = function PlusOutlined(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: PlusOutlinedSvg
    })
  });
};
PlusOutlined$2.displayName = "PlusOutlined";
const PlusOutlined$3 = /* @__PURE__ */ react.exports.forwardRef(PlusOutlined$2);
const TabContext = /* @__PURE__ */ react.exports.createContext(null);
var TabPane$2 = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var prefixCls = _ref.prefixCls, className = _ref.className, style2 = _ref.style, id2 = _ref.id, active = _ref.active, tabKey = _ref.tabKey, children = _ref.children;
  return /* @__PURE__ */ jsx("div", {
    id: id2 && "".concat(id2, "-panel-").concat(tabKey),
    role: "tabpanel",
    tabIndex: active ? 0 : -1,
    "aria-labelledby": id2 && "".concat(id2, "-tab-").concat(tabKey),
    "aria-hidden": !active,
    style: style2,
    className: classNames(prefixCls, active && "".concat(prefixCls, "-active"), className),
    ref,
    children
  });
});
var _excluded$9 = ["key", "forceRender", "style", "className"];
function TabPanelList(_ref) {
  var id2 = _ref.id, activeKey = _ref.activeKey, animated = _ref.animated, tabPosition = _ref.tabPosition, destroyInactiveTabPane = _ref.destroyInactiveTabPane;
  var _React$useContext = react.exports.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
  var tabPaneAnimated = animated.tabPane;
  var tabPanePrefixCls = "".concat(prefixCls, "-tabpane");
  return /* @__PURE__ */ jsx("div", {
    className: classNames("".concat(prefixCls, "-content-holder")),
    children: /* @__PURE__ */ jsx("div", {
      className: classNames("".concat(prefixCls, "-content"), "".concat(prefixCls, "-content-").concat(tabPosition), _defineProperty$1({}, "".concat(prefixCls, "-content-animated"), tabPaneAnimated)),
      children: tabs.map(function(_ref2) {
        var key = _ref2.key, forceRender = _ref2.forceRender, paneStyle = _ref2.style, paneClassName = _ref2.className, restTabProps = _objectWithoutProperties(_ref2, _excluded$9);
        var active = key === activeKey;
        return /* @__PURE__ */ jsx(CSSMotion, {
          visible: active,
          forceRender,
          removeOnLeave: !!destroyInactiveTabPane,
          leavedClassName: "".concat(tabPanePrefixCls, "-hidden"),
          ...animated.tabPaneMotion,
          children: function(_ref3, ref) {
            var motionStyle = _ref3.style, motionClassName = _ref3.className;
            return /* @__PURE__ */ jsx(TabPane$2, {
              ...restTabProps,
              prefixCls: tabPanePrefixCls,
              id: id2,
              tabKey: key,
              animated: tabPaneAnimated,
              active,
              style: _objectSpread2$1(_objectSpread2$1({}, paneStyle), motionStyle),
              className: classNames(paneClassName, motionClassName),
              ref
            });
          }
        }, key);
      })
    })
  });
}
var DEFAULT_SIZE$1 = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function useOffsets(tabs, tabSizes, holderScrollWidth) {
  return react.exports.useMemo(function() {
    var _tabs$;
    var map = /* @__PURE__ */ new Map();
    var lastOffset = tabSizes.get((_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key) || DEFAULT_SIZE$1;
    var rightOffset = lastOffset.left + lastOffset.width;
    for (var i2 = 0; i2 < tabs.length; i2 += 1) {
      var key = tabs[i2].key;
      var data = tabSizes.get(key);
      if (!data) {
        var _tabs;
        data = tabSizes.get((_tabs = tabs[i2 - 1]) === null || _tabs === void 0 ? void 0 : _tabs.key) || DEFAULT_SIZE$1;
      }
      var entity = map.get(key) || _objectSpread2$1({}, data);
      entity.right = rightOffset - entity.left - entity.width;
      map.set(key, entity);
    }
    return map;
  }, [tabs.map(function(tab) {
    return tab.key;
  }).join("_"), tabSizes, holderScrollWidth]);
}
function useSyncState(defaultState, onChange2) {
  var stateRef = react.exports.useRef(defaultState);
  var _React$useState = react.exports.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
  function setState(updater) {
    var newValue = typeof updater === "function" ? updater(stateRef.current) : updater;
    if (newValue !== stateRef.current) {
      onChange2(newValue, stateRef.current);
    }
    stateRef.current = newValue;
    forceUpdate({});
  }
  return [stateRef.current, setState];
}
var MIN_SWIPE_DISTANCE = 0.1;
var STOP_SWIPE_DISTANCE = 0.01;
var REFRESH_INTERVAL = 20;
var SPEED_OFF_MULTIPLE = Math.pow(0.995, REFRESH_INTERVAL);
function useTouchMove(ref, onOffset) {
  var _useState = react.exports.useState(), _useState2 = _slicedToArray(_useState, 2), touchPosition = _useState2[0], setTouchPosition = _useState2[1];
  var _useState3 = react.exports.useState(0), _useState4 = _slicedToArray(_useState3, 2), lastTimestamp = _useState4[0], setLastTimestamp = _useState4[1];
  var _useState5 = react.exports.useState(0), _useState6 = _slicedToArray(_useState5, 2), lastTimeDiff = _useState6[0], setLastTimeDiff = _useState6[1];
  var _useState7 = react.exports.useState(), _useState8 = _slicedToArray(_useState7, 2), lastOffset = _useState8[0], setLastOffset = _useState8[1];
  var motionRef = react.exports.useRef();
  function onTouchStart(e2) {
    var _e$touches$ = e2.touches[0], screenX = _e$touches$.screenX, screenY = _e$touches$.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    window.clearInterval(motionRef.current);
  }
  function onTouchMove(e2) {
    if (!touchPosition)
      return;
    e2.preventDefault();
    var _e$touches$2 = e2.touches[0], screenX = _e$touches$2.screenX, screenY = _e$touches$2.screenY;
    setTouchPosition({
      x: screenX,
      y: screenY
    });
    var offsetX = screenX - touchPosition.x;
    var offsetY = screenY - touchPosition.y;
    onOffset(offsetX, offsetY);
    var now = Date.now();
    setLastTimestamp(now);
    setLastTimeDiff(now - lastTimestamp);
    setLastOffset({
      x: offsetX,
      y: offsetY
    });
  }
  function onTouchEnd() {
    if (!touchPosition)
      return;
    setTouchPosition(null);
    setLastOffset(null);
    if (lastOffset) {
      var distanceX = lastOffset.x / lastTimeDiff;
      var distanceY = lastOffset.y / lastTimeDiff;
      var absX = Math.abs(distanceX);
      var absY = Math.abs(distanceY);
      if (Math.max(absX, absY) < MIN_SWIPE_DISTANCE)
        return;
      var currentX = distanceX;
      var currentY = distanceY;
      motionRef.current = window.setInterval(function() {
        if (Math.abs(currentX) < STOP_SWIPE_DISTANCE && Math.abs(currentY) < STOP_SWIPE_DISTANCE) {
          window.clearInterval(motionRef.current);
          return;
        }
        currentX *= SPEED_OFF_MULTIPLE;
        currentY *= SPEED_OFF_MULTIPLE;
        onOffset(currentX * REFRESH_INTERVAL, currentY * REFRESH_INTERVAL);
      }, REFRESH_INTERVAL);
    }
  }
  var lastWheelDirectionRef = react.exports.useRef();
  function onWheel(e2) {
    var deltaX = e2.deltaX, deltaY = e2.deltaY;
    var mixed = 0;
    var absX = Math.abs(deltaX);
    var absY = Math.abs(deltaY);
    if (absX === absY) {
      mixed = lastWheelDirectionRef.current === "x" ? deltaX : deltaY;
    } else if (absX > absY) {
      mixed = deltaX;
      lastWheelDirectionRef.current = "x";
    } else {
      mixed = deltaY;
      lastWheelDirectionRef.current = "y";
    }
    if (onOffset(-mixed, -mixed)) {
      e2.preventDefault();
    }
  }
  var touchEventsRef = react.exports.useRef(null);
  touchEventsRef.current = {
    onTouchStart,
    onTouchMove,
    onTouchEnd,
    onWheel
  };
  react.exports.useEffect(function() {
    function onProxyTouchStart(e2) {
      touchEventsRef.current.onTouchStart(e2);
    }
    function onProxyTouchMove(e2) {
      touchEventsRef.current.onTouchMove(e2);
    }
    function onProxyTouchEnd(e2) {
      touchEventsRef.current.onTouchEnd(e2);
    }
    function onProxyWheel(e2) {
      touchEventsRef.current.onWheel(e2);
    }
    document.addEventListener("touchmove", onProxyTouchMove, {
      passive: false
    });
    document.addEventListener("touchend", onProxyTouchEnd, {
      passive: false
    });
    ref.current.addEventListener("touchstart", onProxyTouchStart, {
      passive: false
    });
    ref.current.addEventListener("wheel", onProxyWheel);
    return function() {
      document.removeEventListener("touchmove", onProxyTouchMove);
      document.removeEventListener("touchend", onProxyTouchEnd);
    };
  }, []);
}
function useUpdate(callback) {
  var _useState = react.exports.useState(0), _useState2 = _slicedToArray(_useState, 2), count = _useState2[0], setCount = _useState2[1];
  var effectRef = react.exports.useRef(0);
  var callbackRef = react.exports.useRef();
  callbackRef.current = callback;
  useLayoutUpdateEffect(function() {
    var _callbackRef$current;
    (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef);
  }, [count]);
  return function() {
    if (effectRef.current !== count) {
      return;
    }
    effectRef.current += 1;
    setCount(effectRef.current);
  };
}
function useUpdateState(defaultState) {
  var batchRef = react.exports.useRef([]);
  var _useState3 = react.exports.useState({}), _useState4 = _slicedToArray(_useState3, 2), forceUpdate = _useState4[1];
  var state = react.exports.useRef(typeof defaultState === "function" ? defaultState() : defaultState);
  var flushUpdate = useUpdate(function() {
    var current = state.current;
    batchRef.current.forEach(function(callback) {
      current = callback(current);
    });
    batchRef.current = [];
    state.current = current;
    forceUpdate({});
  });
  function updater(callback) {
    batchRef.current.push(callback);
    flushUpdate();
  }
  return [state.current, updater];
}
var DEFAULT_SIZE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function useVisibleRange(tabOffsets, visibleTabContentValue, transform, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, _ref) {
  var tabs = _ref.tabs, tabPosition = _ref.tabPosition, rtl = _ref.rtl;
  var charUnit;
  var position2;
  var transformSize;
  if (["top", "bottom"].includes(tabPosition)) {
    charUnit = "width";
    position2 = rtl ? "right" : "left";
    transformSize = Math.abs(transform);
  } else {
    charUnit = "height";
    position2 = "top";
    transformSize = -transform;
  }
  return react.exports.useMemo(function() {
    if (!tabs.length) {
      return [0, 0];
    }
    var len = tabs.length;
    var endIndex = len;
    for (var i2 = 0; i2 < len; i2 += 1) {
      var offset2 = tabOffsets.get(tabs[i2].key) || DEFAULT_SIZE;
      if (offset2[position2] + offset2[charUnit] > transformSize + visibleTabContentValue) {
        endIndex = i2 - 1;
        break;
      }
    }
    var startIndex = 0;
    for (var _i = len - 1; _i >= 0; _i -= 1) {
      var _offset = tabOffsets.get(tabs[_i].key) || DEFAULT_SIZE;
      if (_offset[position2] < transformSize) {
        startIndex = _i + 1;
        break;
      }
    }
    return [startIndex, endIndex];
  }, [tabOffsets, visibleTabContentValue, tabContentSizeValue, addNodeSizeValue, operationNodeSizeValue, transformSize, tabPosition, tabs.map(function(tab) {
    return tab.key;
  }).join("_"), rtl]);
}
function stringify(obj) {
  var tgt;
  if (obj instanceof Map) {
    tgt = {};
    obj.forEach(function(v2, k2) {
      tgt[k2] = v2;
    });
  } else {
    tgt = obj;
  }
  return JSON.stringify(tgt);
}
function AddButton(_ref, ref) {
  var prefixCls = _ref.prefixCls, editable = _ref.editable, locale2 = _ref.locale, style2 = _ref.style;
  if (!editable || editable.showAdd === false) {
    return null;
  }
  return /* @__PURE__ */ jsx("button", {
    ref,
    type: "button",
    className: "".concat(prefixCls, "-nav-add"),
    style: style2,
    "aria-label": (locale2 === null || locale2 === void 0 ? void 0 : locale2.addAriaLabel) || "Add tab",
    onClick: function onClick(event) {
      editable.onEdit("add", {
        event
      });
    },
    children: editable.addIcon || "+"
  });
}
const AddButton$1 = /* @__PURE__ */ react.exports.forwardRef(AddButton);
var ExtraContent = /* @__PURE__ */ react.exports.forwardRef(function(_ref, ref) {
  var position2 = _ref.position, prefixCls = _ref.prefixCls, extra = _ref.extra;
  if (!extra)
    return null;
  var content;
  var assertExtra = {};
  if (_typeof$1(extra) === "object" && !/* @__PURE__ */ react.exports.isValidElement(extra)) {
    assertExtra = extra;
  } else {
    assertExtra.right = extra;
  }
  if (position2 === "right") {
    content = assertExtra.right;
  }
  if (position2 === "left") {
    content = assertExtra.left;
  }
  return content ? /* @__PURE__ */ jsx("div", {
    className: "".concat(prefixCls, "-extra-content"),
    ref,
    children: content
  }) : null;
});
function OperationNode(_ref, ref) {
  var prefixCls = _ref.prefixCls, id2 = _ref.id, tabs = _ref.tabs, locale2 = _ref.locale, mobile = _ref.mobile, _ref$moreIcon = _ref.moreIcon, moreIcon = _ref$moreIcon === void 0 ? "More" : _ref$moreIcon, moreTransitionName = _ref.moreTransitionName, style2 = _ref.style, className = _ref.className, editable = _ref.editable, tabBarGutter = _ref.tabBarGutter, rtl = _ref.rtl, removeAriaLabel = _ref.removeAriaLabel, onTabClick = _ref.onTabClick, getPopupContainer = _ref.getPopupContainer, popupClassName = _ref.popupClassName;
  var _useState = react.exports.useState(false), _useState2 = _slicedToArray(_useState, 2), open2 = _useState2[0], setOpen = _useState2[1];
  var _useState3 = react.exports.useState(null), _useState4 = _slicedToArray(_useState3, 2), selectedKey = _useState4[0], setSelectedKey = _useState4[1];
  var popupId = "".concat(id2, "-more-popup");
  var dropdownPrefix = "".concat(prefixCls, "-dropdown");
  var selectedItemId = selectedKey !== null ? "".concat(popupId, "-").concat(selectedKey) : null;
  var dropdownAriaLabel = locale2 === null || locale2 === void 0 ? void 0 : locale2.dropdownAriaLabel;
  function onRemoveTab(event, key) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  var menu = /* @__PURE__ */ jsx(ExportMenu, {
    onClick: function onClick(_ref2) {
      var key = _ref2.key, domEvent = _ref2.domEvent;
      onTabClick(key, domEvent);
      setOpen(false);
    },
    prefixCls: "".concat(dropdownPrefix, "-menu"),
    id: popupId,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": selectedItemId,
    selectedKeys: [selectedKey],
    "aria-label": dropdownAriaLabel !== void 0 ? dropdownAriaLabel : "expanded dropdown",
    children: tabs.map(function(tab) {
      var removable = editable && tab.closable !== false && !tab.disabled;
      return /* @__PURE__ */ jsxs(MenuItem$1, {
        id: "".concat(popupId, "-").concat(tab.key),
        role: "option",
        "aria-controls": id2 && "".concat(id2, "-panel-").concat(tab.key),
        disabled: tab.disabled,
        children: [/* @__PURE__ */ jsx("span", {
          children: tab.label
        }), removable && /* @__PURE__ */ jsx("button", {
          type: "button",
          "aria-label": removeAriaLabel || "remove",
          tabIndex: 0,
          className: "".concat(dropdownPrefix, "-menu-item-remove"),
          onClick: function onClick(e2) {
            e2.stopPropagation();
            onRemoveTab(e2, tab.key);
          },
          children: tab.closeIcon || editable.removeIcon || "\xD7"
        })]
      }, tab.key);
    })
  });
  function selectOffset(offset2) {
    var enabledTabs = tabs.filter(function(tab2) {
      return !tab2.disabled;
    });
    var selectedIndex = enabledTabs.findIndex(function(tab2) {
      return tab2.key === selectedKey;
    }) || 0;
    var len = enabledTabs.length;
    for (var i2 = 0; i2 < len; i2 += 1) {
      selectedIndex = (selectedIndex + offset2 + len) % len;
      var tab = enabledTabs[selectedIndex];
      if (!tab.disabled) {
        setSelectedKey(tab.key);
        return;
      }
    }
  }
  function onKeyDown2(e2) {
    var which = e2.which;
    if (!open2) {
      if ([KeyCode.DOWN, KeyCode.SPACE, KeyCode.ENTER].includes(which)) {
        setOpen(true);
        e2.preventDefault();
      }
      return;
    }
    switch (which) {
      case KeyCode.UP:
        selectOffset(-1);
        e2.preventDefault();
        break;
      case KeyCode.DOWN:
        selectOffset(1);
        e2.preventDefault();
        break;
      case KeyCode.ESC:
        setOpen(false);
        break;
      case KeyCode.SPACE:
      case KeyCode.ENTER:
        if (selectedKey !== null)
          onTabClick(selectedKey, e2);
        break;
    }
  }
  react.exports.useEffect(function() {
    var ele = document.getElementById(selectedItemId);
    if (ele && ele.scrollIntoView) {
      ele.scrollIntoView(false);
    }
  }, [selectedKey]);
  react.exports.useEffect(function() {
    if (!open2) {
      setSelectedKey(null);
    }
  }, [open2]);
  var moreStyle = _defineProperty$1({}, rtl ? "marginRight" : "marginLeft", tabBarGutter);
  if (!tabs.length) {
    moreStyle.visibility = "hidden";
    moreStyle.order = 1;
  }
  var overlayClassName = classNames(_defineProperty$1({}, "".concat(dropdownPrefix, "-rtl"), rtl));
  var moreNode = mobile ? null : /* @__PURE__ */ jsx(Dropdown$3, {
    prefixCls: dropdownPrefix,
    overlay: menu,
    trigger: ["hover"],
    visible: tabs.length ? open2 : false,
    transitionName: moreTransitionName,
    onVisibleChange: setOpen,
    overlayClassName: classNames(overlayClassName, popupClassName),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer,
    children: /* @__PURE__ */ jsx("button", {
      type: "button",
      className: "".concat(prefixCls, "-nav-more"),
      style: moreStyle,
      tabIndex: -1,
      "aria-hidden": "true",
      "aria-haspopup": "listbox",
      "aria-controls": popupId,
      id: "".concat(id2, "-more"),
      "aria-expanded": open2,
      onKeyDown: onKeyDown2,
      children: moreIcon
    })
  });
  return /* @__PURE__ */ jsxs("div", {
    className: classNames("".concat(prefixCls, "-nav-operations"), className),
    style: style2,
    ref,
    children: [moreNode, /* @__PURE__ */ jsx(AddButton$1, {
      prefixCls,
      locale: locale2,
      editable
    })]
  });
}
const OperationNode$1 = /* @__PURE__ */ react.exports.memo(/* @__PURE__ */ react.exports.forwardRef(OperationNode), function(_2, next2) {
  return next2.tabMoving;
});
function TabNode(_ref) {
  var _classNames;
  var prefixCls = _ref.prefixCls, id2 = _ref.id, active = _ref.active, _ref$tab = _ref.tab, key = _ref$tab.key, label = _ref$tab.label, disabled = _ref$tab.disabled, closeIcon = _ref$tab.closeIcon, closable = _ref.closable, renderWrapper = _ref.renderWrapper, removeAriaLabel = _ref.removeAriaLabel, editable = _ref.editable, onClick = _ref.onClick, onFocus2 = _ref.onFocus, style2 = _ref.style;
  var tabPrefix = "".concat(prefixCls, "-tab");
  var removable = editable && closable !== false && !disabled;
  function onInternalClick(e2) {
    if (disabled) {
      return;
    }
    onClick(e2);
  }
  function onRemoveTab(event) {
    event.preventDefault();
    event.stopPropagation();
    editable.onEdit("remove", {
      key,
      event
    });
  }
  var node2 = /* @__PURE__ */ jsxs("div", {
    "data-node-key": key,
    className: classNames(tabPrefix, (_classNames = {}, _defineProperty$1(_classNames, "".concat(tabPrefix, "-with-remove"), removable), _defineProperty$1(_classNames, "".concat(tabPrefix, "-active"), active), _defineProperty$1(_classNames, "".concat(tabPrefix, "-disabled"), disabled), _classNames)),
    style: style2,
    onClick: onInternalClick,
    children: [/* @__PURE__ */ jsx("div", {
      role: "tab",
      "aria-selected": active,
      id: id2 && "".concat(id2, "-tab-").concat(key),
      className: "".concat(tabPrefix, "-btn"),
      "aria-controls": id2 && "".concat(id2, "-panel-").concat(key),
      "aria-disabled": disabled,
      tabIndex: disabled ? null : 0,
      onClick: function onClick2(e2) {
        e2.stopPropagation();
        onInternalClick(e2);
      },
      onKeyDown: function onKeyDown2(e2) {
        if ([KeyCode.SPACE, KeyCode.ENTER].includes(e2.which)) {
          e2.preventDefault();
          onInternalClick(e2);
        }
      },
      onFocus: onFocus2,
      children: label
    }), removable && /* @__PURE__ */ jsx("button", {
      type: "button",
      "aria-label": removeAriaLabel || "remove",
      tabIndex: 0,
      className: "".concat(tabPrefix, "-remove"),
      onClick: function onClick2(e2) {
        e2.stopPropagation();
        onRemoveTab(e2);
      },
      children: closeIcon || editable.removeIcon || "\xD7"
    })]
  }, key);
  return renderWrapper ? renderWrapper(node2) : node2;
}
var getSize = function getSize2(refObj) {
  var _ref = refObj.current || {}, _ref$offsetWidth = _ref.offsetWidth, offsetWidth = _ref$offsetWidth === void 0 ? 0 : _ref$offsetWidth, _ref$offsetHeight = _ref.offsetHeight, offsetHeight = _ref$offsetHeight === void 0 ? 0 : _ref$offsetHeight;
  return [offsetWidth, offsetHeight];
};
var getUnitValue = function getUnitValue2(size, tabPositionTopOrBottom) {
  return size[tabPositionTopOrBottom ? 0 : 1];
};
function TabNavList(props, ref) {
  var _classNames;
  var _React$useContext = react.exports.useContext(TabContext), prefixCls = _React$useContext.prefixCls, tabs = _React$useContext.tabs;
  var className = props.className, style2 = props.style, id2 = props.id, animated = props.animated, activeKey = props.activeKey, rtl = props.rtl, extra = props.extra, editable = props.editable, locale2 = props.locale, tabPosition = props.tabPosition, tabBarGutter = props.tabBarGutter, children = props.children, onTabClick = props.onTabClick, onTabScroll = props.onTabScroll;
  var containerRef = react.exports.useRef();
  var extraLeftRef = react.exports.useRef();
  var extraRightRef = react.exports.useRef();
  var tabsWrapperRef = react.exports.useRef();
  var tabListRef = react.exports.useRef();
  var operationsRef = react.exports.useRef();
  var innerAddButtonRef = react.exports.useRef();
  var tabPositionTopOrBottom = tabPosition === "top" || tabPosition === "bottom";
  var _useSyncState = useSyncState(0, function(next2, prev2) {
    if (tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next2 > prev2 ? "left" : "right"
      });
    }
  }), _useSyncState2 = _slicedToArray(_useSyncState, 2), transformLeft = _useSyncState2[0], setTransformLeft = _useSyncState2[1];
  var _useSyncState3 = useSyncState(0, function(next2, prev2) {
    if (!tabPositionTopOrBottom && onTabScroll) {
      onTabScroll({
        direction: next2 > prev2 ? "top" : "bottom"
      });
    }
  }), _useSyncState4 = _slicedToArray(_useSyncState3, 2), transformTop = _useSyncState4[0], setTransformTop = _useSyncState4[1];
  var _useState = react.exports.useState([0, 0]), _useState2 = _slicedToArray(_useState, 2), containerExcludeExtraSize = _useState2[0], setContainerExcludeExtraSize = _useState2[1];
  var _useState3 = react.exports.useState([0, 0]), _useState4 = _slicedToArray(_useState3, 2), tabContentSize = _useState4[0], setTabContentSize = _useState4[1];
  var _useState5 = react.exports.useState([0, 0]), _useState6 = _slicedToArray(_useState5, 2), addSize = _useState6[0], setAddSize = _useState6[1];
  var _useState7 = react.exports.useState([0, 0]), _useState8 = _slicedToArray(_useState7, 2), operationSize = _useState8[0], setOperationSize = _useState8[1];
  var _useUpdateState = useUpdateState(/* @__PURE__ */ new Map()), _useUpdateState2 = _slicedToArray(_useUpdateState, 2), tabSizes = _useUpdateState2[0], setTabSizes = _useUpdateState2[1];
  var tabOffsets = useOffsets(tabs, tabSizes, tabContentSize[0]);
  var containerExcludeExtraSizeValue = getUnitValue(containerExcludeExtraSize, tabPositionTopOrBottom);
  var tabContentSizeValue = getUnitValue(tabContentSize, tabPositionTopOrBottom);
  var addSizeValue = getUnitValue(addSize, tabPositionTopOrBottom);
  var operationSizeValue = getUnitValue(operationSize, tabPositionTopOrBottom);
  var needScroll = containerExcludeExtraSizeValue < tabContentSizeValue + addSizeValue;
  var visibleTabContentValue = needScroll ? containerExcludeExtraSizeValue - operationSizeValue : containerExcludeExtraSizeValue - addSizeValue;
  var operationsHiddenClassName = "".concat(prefixCls, "-nav-operations-hidden");
  var transformMin = 0;
  var transformMax = 0;
  if (!tabPositionTopOrBottom) {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  } else if (rtl) {
    transformMin = 0;
    transformMax = Math.max(0, tabContentSizeValue - visibleTabContentValue);
  } else {
    transformMin = Math.min(0, visibleTabContentValue - tabContentSizeValue);
    transformMax = 0;
  }
  function alignInRange(value) {
    if (value < transformMin) {
      return transformMin;
    }
    if (value > transformMax) {
      return transformMax;
    }
    return value;
  }
  var touchMovingRef = react.exports.useRef();
  var _useState9 = react.exports.useState(), _useState10 = _slicedToArray(_useState9, 2), lockAnimation = _useState10[0], setLockAnimation = _useState10[1];
  function doLockAnimation() {
    setLockAnimation(Date.now());
  }
  function clearTouchMoving() {
    window.clearTimeout(touchMovingRef.current);
  }
  useTouchMove(tabsWrapperRef, function(offsetX, offsetY) {
    function doMove(setState, offset2) {
      setState(function(value) {
        var newValue = alignInRange(value + offset2);
        return newValue;
      });
    }
    if (!needScroll) {
      return false;
    }
    if (tabPositionTopOrBottom) {
      doMove(setTransformLeft, offsetX);
    } else {
      doMove(setTransformTop, offsetY);
    }
    clearTouchMoving();
    doLockAnimation();
    return true;
  });
  react.exports.useEffect(function() {
    clearTouchMoving();
    if (lockAnimation) {
      touchMovingRef.current = window.setTimeout(function() {
        setLockAnimation(0);
      }, 100);
    }
    return clearTouchMoving;
  }, [lockAnimation]);
  var _useVisibleRange = useVisibleRange(
    tabOffsets,
    visibleTabContentValue,
    tabPositionTopOrBottom ? transformLeft : transformTop,
    tabContentSizeValue,
    addSizeValue,
    operationSizeValue,
    _objectSpread2$1(_objectSpread2$1({}, props), {}, {
      tabs
    })
  ), _useVisibleRange2 = _slicedToArray(_useVisibleRange, 2), visibleStart = _useVisibleRange2[0], visibleEnd = _useVisibleRange2[1];
  var scrollToTab = useEvent(function() {
    var key = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : activeKey;
    var tabOffset = tabOffsets.get(key) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (tabPositionTopOrBottom) {
      var newTransform = transformLeft;
      if (rtl) {
        if (tabOffset.right < transformLeft) {
          newTransform = tabOffset.right;
        } else if (tabOffset.right + tabOffset.width > transformLeft + visibleTabContentValue) {
          newTransform = tabOffset.right + tabOffset.width - visibleTabContentValue;
        }
      } else if (tabOffset.left < -transformLeft) {
        newTransform = -tabOffset.left;
      } else if (tabOffset.left + tabOffset.width > -transformLeft + visibleTabContentValue) {
        newTransform = -(tabOffset.left + tabOffset.width - visibleTabContentValue);
      }
      setTransformTop(0);
      setTransformLeft(alignInRange(newTransform));
    } else {
      var _newTransform = transformTop;
      if (tabOffset.top < -transformTop) {
        _newTransform = -tabOffset.top;
      } else if (tabOffset.top + tabOffset.height > -transformTop + visibleTabContentValue) {
        _newTransform = -(tabOffset.top + tabOffset.height - visibleTabContentValue);
      }
      setTransformLeft(0);
      setTransformTop(alignInRange(_newTransform));
    }
  });
  var tabNodeStyle = {};
  if (tabPosition === "top" || tabPosition === "bottom") {
    tabNodeStyle[rtl ? "marginRight" : "marginLeft"] = tabBarGutter;
  } else {
    tabNodeStyle.marginTop = tabBarGutter;
  }
  var tabNodes = tabs.map(function(tab, i2) {
    var key = tab.key;
    return /* @__PURE__ */ jsx(TabNode, {
      id: id2,
      prefixCls,
      tab,
      style: i2 === 0 ? void 0 : tabNodeStyle,
      closable: tab.closable,
      editable,
      active: key === activeKey,
      renderWrapper: children,
      removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
      onClick: function onClick(e2) {
        onTabClick(key, e2);
      },
      onFocus: function onFocus2() {
        scrollToTab(key);
        doLockAnimation();
        if (!tabsWrapperRef.current) {
          return;
        }
        if (!rtl) {
          tabsWrapperRef.current.scrollLeft = 0;
        }
        tabsWrapperRef.current.scrollTop = 0;
      }
    }, key);
  });
  var updateTabSizes = function updateTabSizes2() {
    return setTabSizes(function() {
      var newSizes = /* @__PURE__ */ new Map();
      tabs.forEach(function(_ref2) {
        var _tabListRef$current;
        var key = _ref2.key;
        var btnNode = (_tabListRef$current = tabListRef.current) === null || _tabListRef$current === void 0 ? void 0 : _tabListRef$current.querySelector('[data-node-key="'.concat(key, '"]'));
        if (btnNode) {
          newSizes.set(key, {
            width: btnNode.offsetWidth,
            height: btnNode.offsetHeight,
            left: btnNode.offsetLeft,
            top: btnNode.offsetTop
          });
        }
      });
      return newSizes;
    });
  };
  react.exports.useEffect(function() {
    updateTabSizes();
  }, [tabs.map(function(tab) {
    return tab.key;
  }).join("_")]);
  var onListHolderResize = useUpdate(function() {
    var containerSize = getSize(containerRef);
    var extraLeftSize = getSize(extraLeftRef);
    var extraRightSize = getSize(extraRightRef);
    setContainerExcludeExtraSize([containerSize[0] - extraLeftSize[0] - extraRightSize[0], containerSize[1] - extraLeftSize[1] - extraRightSize[1]]);
    var newAddSize = getSize(innerAddButtonRef);
    setAddSize(newAddSize);
    var newOperationSize = getSize(operationsRef);
    setOperationSize(newOperationSize);
    var tabContentFullSize = getSize(tabListRef);
    setTabContentSize([tabContentFullSize[0] - newAddSize[0], tabContentFullSize[1] - newAddSize[1]]);
    updateTabSizes();
  });
  var startHiddenTabs = tabs.slice(0, visibleStart);
  var endHiddenTabs = tabs.slice(visibleEnd + 1);
  var hiddenTabs = [].concat(_toConsumableArray(startHiddenTabs), _toConsumableArray(endHiddenTabs));
  var _useState11 = react.exports.useState(), _useState12 = _slicedToArray(_useState11, 2), inkStyle = _useState12[0], setInkStyle = _useState12[1];
  var activeTabOffset = tabOffsets.get(activeKey);
  var inkBarRafRef = react.exports.useRef();
  function cleanInkBarRaf() {
    wrapperRaf.cancel(inkBarRafRef.current);
  }
  react.exports.useEffect(function() {
    var newInkStyle = {};
    if (activeTabOffset) {
      if (tabPositionTopOrBottom) {
        if (rtl) {
          newInkStyle.right = activeTabOffset.right;
        } else {
          newInkStyle.left = activeTabOffset.left;
        }
        newInkStyle.width = activeTabOffset.width;
      } else {
        newInkStyle.top = activeTabOffset.top;
        newInkStyle.height = activeTabOffset.height;
      }
    }
    cleanInkBarRaf();
    inkBarRafRef.current = wrapperRaf(function() {
      setInkStyle(newInkStyle);
    });
    return cleanInkBarRaf;
  }, [activeTabOffset, tabPositionTopOrBottom, rtl]);
  react.exports.useEffect(function() {
    scrollToTab();
  }, [activeKey, transformMin, transformMax, stringify(activeTabOffset), stringify(tabOffsets), tabPositionTopOrBottom]);
  react.exports.useEffect(function() {
    onListHolderResize();
  }, [rtl]);
  var hasDropdown = !!hiddenTabs.length;
  var wrapPrefix = "".concat(prefixCls, "-nav-wrap");
  var pingLeft;
  var pingRight;
  var pingTop;
  var pingBottom;
  if (tabPositionTopOrBottom) {
    if (rtl) {
      pingRight = transformLeft > 0;
      pingLeft = transformLeft !== transformMax;
    } else {
      pingLeft = transformLeft < 0;
      pingRight = transformLeft !== transformMin;
    }
  } else {
    pingTop = transformTop < 0;
    pingBottom = transformTop !== transformMin;
  }
  return /* @__PURE__ */ jsx(RefResizeObserver, {
    onResize: onListHolderResize,
    children: /* @__PURE__ */ jsxs("div", {
      ref: useComposeRef(ref, containerRef),
      role: "tablist",
      className: classNames("".concat(prefixCls, "-nav"), className),
      style: style2,
      onKeyDown: function onKeyDown2() {
        doLockAnimation();
      },
      children: [/* @__PURE__ */ jsx(ExtraContent, {
        ref: extraLeftRef,
        position: "left",
        extra,
        prefixCls
      }), /* @__PURE__ */ jsx("div", {
        className: classNames(wrapPrefix, (_classNames = {}, _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-left"), pingLeft), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-right"), pingRight), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-top"), pingTop), _defineProperty$1(_classNames, "".concat(wrapPrefix, "-ping-bottom"), pingBottom), _classNames)),
        ref: tabsWrapperRef,
        children: /* @__PURE__ */ jsx(RefResizeObserver, {
          onResize: onListHolderResize,
          children: /* @__PURE__ */ jsxs("div", {
            ref: tabListRef,
            className: "".concat(prefixCls, "-nav-list"),
            style: {
              transform: "translate(".concat(transformLeft, "px, ").concat(transformTop, "px)"),
              transition: lockAnimation ? "none" : void 0
            },
            children: [tabNodes, /* @__PURE__ */ jsx(AddButton$1, {
              ref: innerAddButtonRef,
              prefixCls,
              locale: locale2,
              editable,
              style: _objectSpread2$1(_objectSpread2$1({}, tabNodes.length === 0 ? void 0 : tabNodeStyle), {}, {
                visibility: hasDropdown ? "hidden" : null
              })
            }), /* @__PURE__ */ jsx("div", {
              className: classNames("".concat(prefixCls, "-ink-bar"), _defineProperty$1({}, "".concat(prefixCls, "-ink-bar-animated"), animated.inkBar)),
              style: inkStyle
            })]
          })
        })
      }), /* @__PURE__ */ jsx(OperationNode$1, {
        ...props,
        removeAriaLabel: locale2 === null || locale2 === void 0 ? void 0 : locale2.removeAriaLabel,
        ref: operationsRef,
        prefixCls,
        tabs: hiddenTabs,
        className: !hasDropdown && operationsHiddenClassName,
        tabMoving: !!lockAnimation
      }), /* @__PURE__ */ jsx(ExtraContent, {
        ref: extraRightRef,
        position: "right",
        extra,
        prefixCls
      })]
    })
  });
}
const TabNavList$1 = /* @__PURE__ */ react.exports.forwardRef(TabNavList);
var _excluded$8 = ["renderTabBar"], _excluded2 = ["label", "key"];
function TabNavListWrapper(_ref) {
  var renderTabBar = _ref.renderTabBar, restProps = _objectWithoutProperties(_ref, _excluded$8);
  var _React$useContext = react.exports.useContext(TabContext), tabs = _React$useContext.tabs;
  if (renderTabBar) {
    var tabNavBarProps = _objectSpread2$1(_objectSpread2$1({}, restProps), {}, {
      panes: tabs.map(function(_ref2) {
        var label = _ref2.label, key = _ref2.key, restTabProps = _objectWithoutProperties(_ref2, _excluded2);
        return /* @__PURE__ */ jsx(TabPane$2, {
          tab: label,
          tabKey: key,
          ...restTabProps
        }, key);
      })
    });
    return renderTabBar(tabNavBarProps, TabNavList$1);
  }
  return /* @__PURE__ */ jsx(TabNavList$1, {
    ...restProps
  });
}
function useAnimateConfig$1() {
  var animated = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    inkBar: true,
    tabPane: false
  };
  var mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: false
    };
  } else {
    mergedAnimated = _objectSpread2$1({
      inkBar: true
    }, _typeof$1(animated) === "object" ? animated : {});
  }
  if (mergedAnimated.tabPaneMotion && mergedAnimated.tabPane === void 0) {
    mergedAnimated.tabPane = true;
  }
  if (!mergedAnimated.tabPaneMotion && mergedAnimated.tabPane) {
    mergedAnimated.tabPane = false;
  }
  return mergedAnimated;
}
var _excluded$7 = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "moreIcon", "moreTransitionName", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName"];
var uuid$1 = 0;
function Tabs$1(_ref, ref) {
  var _classNames;
  var id2 = _ref.id, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-tabs" : _ref$prefixCls, className = _ref.className, items = _ref.items, direction = _ref.direction, activeKey = _ref.activeKey, defaultActiveKey = _ref.defaultActiveKey, editable = _ref.editable, animated = _ref.animated, _ref$tabPosition = _ref.tabPosition, tabPosition = _ref$tabPosition === void 0 ? "top" : _ref$tabPosition, tabBarGutter = _ref.tabBarGutter, tabBarStyle = _ref.tabBarStyle, tabBarExtraContent = _ref.tabBarExtraContent, locale2 = _ref.locale, moreIcon = _ref.moreIcon, moreTransitionName = _ref.moreTransitionName, destroyInactiveTabPane = _ref.destroyInactiveTabPane, renderTabBar = _ref.renderTabBar, onChange2 = _ref.onChange, onTabClick = _ref.onTabClick, onTabScroll = _ref.onTabScroll, getPopupContainer = _ref.getPopupContainer, popupClassName = _ref.popupClassName, restProps = _objectWithoutProperties(_ref, _excluded$7);
  var tabs = react.exports.useMemo(function() {
    return (items || []).filter(function(item) {
      return item && _typeof$1(item) === "object" && "key" in item;
    });
  }, [items]);
  var rtl = direction === "rtl";
  var mergedAnimated = useAnimateConfig$1(animated);
  var _useState = react.exports.useState(false), _useState2 = _slicedToArray(_useState, 2), mobile = _useState2[0], setMobile = _useState2[1];
  react.exports.useEffect(function() {
    setMobile(isMobile());
  }, []);
  var _useMergedState = useMergedState(function() {
    var _tabs$;
    return (_tabs$ = tabs[0]) === null || _tabs$ === void 0 ? void 0 : _tabs$.key;
  }, {
    value: activeKey,
    defaultValue: defaultActiveKey
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedActiveKey = _useMergedState2[0], setMergedActiveKey = _useMergedState2[1];
  var _useState3 = react.exports.useState(function() {
    return tabs.findIndex(function(tab) {
      return tab.key === mergedActiveKey;
    });
  }), _useState4 = _slicedToArray(_useState3, 2), activeIndex = _useState4[0], setActiveIndex = _useState4[1];
  react.exports.useEffect(function() {
    var newActiveIndex = tabs.findIndex(function(tab) {
      return tab.key === mergedActiveKey;
    });
    if (newActiveIndex === -1) {
      var _tabs$newActiveIndex;
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) === null || _tabs$newActiveIndex === void 0 ? void 0 : _tabs$newActiveIndex.key);
    }
    setActiveIndex(newActiveIndex);
  }, [tabs.map(function(tab) {
    return tab.key;
  }).join("_"), mergedActiveKey, activeIndex]);
  var _useMergedState3 = useMergedState(null, {
    value: id2
  }), _useMergedState4 = _slicedToArray(_useMergedState3, 2), mergedId = _useMergedState4[0], setMergedId = _useMergedState4[1];
  react.exports.useEffect(function() {
    if (!id2) {
      setMergedId("rc-tabs-".concat(uuid$1));
      uuid$1 += 1;
    }
  }, []);
  function onInternalTabClick(key, e2) {
    onTabClick === null || onTabClick === void 0 ? void 0 : onTabClick(key, e2);
    var isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(key);
    }
  }
  var sharedProps = {
    id: mergedId,
    activeKey: mergedActiveKey,
    animated: mergedAnimated,
    tabPosition,
    rtl,
    mobile
  };
  var tabNavBar;
  var tabNavBarProps = _objectSpread2$1(_objectSpread2$1({}, sharedProps), {}, {
    editable,
    locale: locale2,
    moreIcon,
    moreTransitionName,
    tabBarGutter,
    onTabClick: onInternalTabClick,
    onTabScroll,
    extra: tabBarExtraContent,
    style: tabBarStyle,
    panes: null,
    getPopupContainer,
    popupClassName
  });
  return /* @__PURE__ */ jsx(TabContext.Provider, {
    value: {
      tabs,
      prefixCls
    },
    children: /* @__PURE__ */ jsxs("div", {
      ref,
      id: id2,
      className: classNames(prefixCls, "".concat(prefixCls, "-").concat(tabPosition), (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-mobile"), mobile), _defineProperty$1(_classNames, "".concat(prefixCls, "-editable"), editable), _defineProperty$1(_classNames, "".concat(prefixCls, "-rtl"), rtl), _classNames), className),
      ...restProps,
      children: [tabNavBar, /* @__PURE__ */ jsx(TabNavListWrapper, {
        ...tabNavBarProps,
        renderTabBar
      }), /* @__PURE__ */ jsx(TabPanelList, {
        destroyInactiveTabPane,
        ...sharedProps,
        animated: mergedAnimated
      })]
    })
  });
}
var ForwardTabs = /* @__PURE__ */ react.exports.forwardRef(Tabs$1);
const motion = {
  motionAppear: false,
  motionEnter: true,
  motionLeave: true
};
function useAnimateConfig(prefixCls) {
  let animated = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inkBar: true,
    tabPane: false
  };
  let mergedAnimated;
  if (animated === false) {
    mergedAnimated = {
      inkBar: false,
      tabPane: false
    };
  } else if (animated === true) {
    mergedAnimated = {
      inkBar: true,
      tabPane: true
    };
  } else {
    mergedAnimated = Object.assign({
      inkBar: true
    }, typeof animated === "object" ? animated : {});
  }
  if (mergedAnimated.tabPane) {
    mergedAnimated.tabPaneMotion = Object.assign(Object.assign({}, motion), {
      motionName: getTransitionName(prefixCls, "switch")
    });
  }
  return mergedAnimated;
}
var __rest$u = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function filter2(items) {
  return items.filter((item) => item);
}
function useLegacyItems(items, children) {
  if (items) {
    return items;
  }
  const childrenItems = toArray$3(children).map((node2) => {
    if (/* @__PURE__ */ react.exports.isValidElement(node2)) {
      const {
        key,
        props
      } = node2;
      const _a = props || {}, {
        tab
      } = _a, restProps = __rest$u(_a, ["tab"]);
      const item = Object.assign(Object.assign({
        key: String(key)
      }, restProps), {
        label: tab
      });
      return item;
    }
    return null;
  });
  return filter2(childrenItems);
}
const TabPane = () => null;
const TabPane$1 = TabPane;
const genMotionStyle$2 = (token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  return [
    {
      [componentCls]: {
        [`${componentCls}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${motionDurationSlow}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${motionDurationSlow}`
            }
          }
        }
      }
    },
    [initSlideMotion(token2, "slide-up"), initSlideMotion(token2, "slide-down")]
  ];
};
const genMotionStyle$3 = genMotionStyle$2;
const genCardStyle$1 = (token2) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeadBackground,
    tabsCardGutter,
    colorSplit
  } = token2;
  return {
    [`${componentCls}-card`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: 0,
          padding: tabsCardHorizontalPadding,
          background: tabsCardHeadBackground,
          border: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
        },
        [`${componentCls}-tab-active`]: {
          color: token2.colorPrimary,
          background: token2.colorBgContainer
        },
        [`${componentCls}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      [`&${componentCls}-top, &${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginLeft: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            }
          }
        }
      },
      [`&${componentCls}-top`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
          },
          [`${componentCls}-tab-active`]: {
            borderBottomColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
          },
          [`${componentCls}-tab-active`]: {
            borderTopColor: token2.colorBgContainer
          }
        }
      },
      [`&${componentCls}-left, &${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginTop: `${tabsCardGutter}px`
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token2.borderRadiusLG}px 0 0 ${token2.borderRadiusLG}px`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderRightColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0`
            }
          },
          [`${componentCls}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: true,
              value: token2.colorBgContainer
            }
          }
        }
      }
    }
  };
};
const genDropdownStyle = (token2) => {
  const {
    componentCls,
    tabsHoverColor,
    dropdownEdgeChildVerticalPadding
  } = token2;
  return {
    [`${componentCls}-dropdown`]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: true,
        value: -9999
      },
      zIndex: token2.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${componentCls}-dropdown-menu`]: {
        maxHeight: token2.tabsDropdownHeight,
        margin: 0,
        padding: `${dropdownEdgeChildVerticalPadding}px 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: true,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: token2.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: token2.borderRadiusLG,
        outline: "none",
        boxShadow: token2.boxShadowSecondary,
        "&-item": Object.assign(Object.assign({}, textEllipsis), {
          display: "flex",
          alignItems: "center",
          minWidth: token2.tabsDropdownWidth,
          margin: 0,
          padding: `${token2.paddingXXS}px ${token2.paddingSM}px`,
          color: token2.colorText,
          fontWeight: "normal",
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight,
          cursor: "pointer",
          transition: `all ${token2.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: true,
              value: token2.marginSM
            },
            color: token2.colorTextDescription,
            fontSize: token2.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: tabsHoverColor
            }
          },
          "&:hover": {
            background: token2.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: token2.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
};
const genPositionStyle = (token2) => {
  const {
    componentCls,
    margin,
    colorSplit
  } = token2;
  return {
    [`${componentCls}-top, ${componentCls}-bottom`]: {
      flexDirection: "column",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        margin: `0 0 ${margin}px 0`,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: true,
            value: 0
          },
          left: {
            _skip_check_: true,
            value: 0
          },
          borderBottom: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
          content: "''"
        },
        [`${componentCls}-ink-bar`]: {
          height: token2.lineWidthBold,
          "&-animated": {
            transition: `width ${token2.motionDurationSlow}, left ${token2.motionDurationSlow},
            right ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: token2.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            boxShadow: token2.boxShadowTabsOverflowRight
          },
          [`&${componentCls}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${componentCls}-top`]: {
      [`> ${componentCls}-nav,
        > div > ${componentCls}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${componentCls}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${componentCls}-bottom`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        marginTop: `${margin}px`,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${componentCls}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0
      }
    },
    [`${componentCls}-left, ${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        flexDirection: "column",
        minWidth: token2.controlHeight * 1.25,
        [`${componentCls}-tab`]: {
          padding: `${token2.paddingXS}px ${token2.paddingLG}px`,
          textAlign: "center"
        },
        [`${componentCls}-tab + ${componentCls}-tab`]: {
          margin: `${token2.margin}px 0 0 0`
        },
        [`${componentCls}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: true,
              value: 0
            },
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: token2.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: token2.boxShadowTabsOverflowBottom
          },
          [`&${componentCls}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${componentCls}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        [`${componentCls}-ink-bar`]: {
          width: token2.lineWidthBold,
          "&-animated": {
            transition: `height ${token2.motionDurationSlow}, top ${token2.motionDurationSlow}`
          }
        },
        [`${componentCls}-nav-list, ${componentCls}-nav-operations`]: {
          flex: "1 0 auto",
          flexDirection: "column"
        }
      }
    },
    [`${componentCls}-left`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-ink-bar`]: {
          right: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        marginLeft: {
          _skip_check_: true,
          value: `-${token2.lineWidth}px`
        },
        borderLeft: {
          _skip_check_: true,
          value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingLeft: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    },
    [`${componentCls}-right`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        order: 1,
        [`${componentCls}-ink-bar`]: {
          left: {
            _skip_check_: true,
            value: 0
          }
        }
      },
      [`> ${componentCls}-content-holder, > div > ${componentCls}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: true,
          value: -token2.lineWidth
        },
        borderRight: {
          _skip_check_: true,
          value: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
        },
        [`> ${componentCls}-content > ${componentCls}-tabpane`]: {
          paddingRight: {
            _skip_check_: true,
            value: token2.paddingLG
          }
        }
      }
    }
  };
};
const genSizeStyle = (token2) => {
  const {
    componentCls,
    padding
  } = token2;
  return {
    [componentCls]: {
      "&-small": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXS}px 0`,
            fontSize: token2.fontSize
          }
        }
      },
      "&-large": {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${padding}px 0`,
            fontSize: token2.fontSizeLG
          }
        }
      }
    },
    [`${componentCls}-card`]: {
      [`&${componentCls}-small`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXXS * 1.5}px ${padding}px`
          }
        },
        [`&${componentCls}-bottom`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `0 0 ${token2.borderRadius}px ${token2.borderRadius}px`
          }
        },
        [`&${componentCls}-top`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: `${token2.borderRadius}px ${token2.borderRadius}px 0 0`
          }
        },
        [`&${componentCls}-right`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `0 ${token2.borderRadius}px ${token2.borderRadius}px 0`
            }
          }
        },
        [`&${componentCls}-left`]: {
          [`> ${componentCls}-nav ${componentCls}-tab`]: {
            borderRadius: {
              _skip_check_: true,
              value: `${token2.borderRadius}px 0 0 ${token2.borderRadius}px`
            }
          }
        }
      },
      [`&${componentCls}-large`]: {
        [`> ${componentCls}-nav`]: {
          [`${componentCls}-tab`]: {
            padding: `${token2.paddingXS}px ${padding}px ${token2.paddingXXS * 1.5}px`
          }
        }
      }
    }
  };
};
const genTabStyle = (token2) => {
  const {
    componentCls,
    tabsActiveColor,
    tabsHoverColor,
    iconCls,
    tabsHorizontalGutter
  } = token2;
  const tabCls = `${componentCls}-tab`;
  return {
    [tabCls]: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      padding: `${token2.paddingSM}px 0`,
      fontSize: `${token2.fontSize}px`,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      "&-btn, &-remove": Object.assign({
        "&:focus:not(:focus-visible), &:active": {
          color: tabsActiveColor
        }
      }, genFocusStyle(token2)),
      "&-btn": {
        outline: "none",
        transition: "all 0.3s"
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: true,
          value: -token2.marginXXS
        },
        marginLeft: {
          _skip_check_: true,
          value: token2.marginXS
        },
        color: token2.colorTextDescription,
        fontSize: token2.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${token2.motionDurationSlow}`,
        "&:hover": {
          color: token2.colorTextHeading
        }
      },
      "&:hover": {
        color: tabsHoverColor
      },
      [`&${tabCls}-active ${tabCls}-btn`]: {
        color: token2.colorPrimary,
        textShadow: token2.tabsActiveTextShadow
      },
      [`&${tabCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${tabCls}-disabled ${tabCls}-btn, &${tabCls}-disabled ${componentCls}-remove`]: {
        "&:focus, &:active": {
          color: token2.colorTextDisabled
        }
      },
      [`& ${tabCls}-remove ${iconCls}`]: {
        margin: 0
      },
      [iconCls]: {
        marginRight: {
          _skip_check_: true,
          value: token2.marginSM
        }
      }
    },
    [`${tabCls} + ${tabCls}`]: {
      margin: {
        _skip_check_: true,
        value: `0 0 0 ${tabsHorizontalGutter}px`
      }
    }
  };
};
const genRtlStyle = (token2) => {
  const {
    componentCls,
    tabsHorizontalGutter,
    iconCls,
    tabsCardGutter
  } = token2;
  const rtlCls = `${componentCls}-rtl`;
  return {
    [rtlCls]: {
      direction: "rtl",
      [`${componentCls}-nav`]: {
        [`${componentCls}-tab`]: {
          margin: {
            _skip_check_: true,
            value: `0 0 0 ${tabsHorizontalGutter}px`
          },
          [`${componentCls}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          },
          [iconCls]: {
            marginRight: {
              _skip_check_: true,
              value: 0
            },
            marginLeft: {
              _skip_check_: true,
              value: `${token2.marginSM}px`
            }
          },
          [`${componentCls}-tab-remove`]: {
            marginRight: {
              _skip_check_: true,
              value: `${token2.marginXS}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: `-${token2.marginXXS}px`
            },
            [iconCls]: {
              margin: 0
            }
          }
        }
      },
      [`&${componentCls}-left`]: {
        [`> ${componentCls}-nav`]: {
          order: 1
        },
        [`> ${componentCls}-content-holder`]: {
          order: 0
        }
      },
      [`&${componentCls}-right`]: {
        [`> ${componentCls}-nav`]: {
          order: 0
        },
        [`> ${componentCls}-content-holder`]: {
          order: 1
        }
      },
      [`&${componentCls}-card${componentCls}-top, &${componentCls}-card${componentCls}-bottom`]: {
        [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
          [`${componentCls}-tab + ${componentCls}-tab`]: {
            marginRight: {
              _skip_check_: true,
              value: `${tabsCardGutter}px`
            },
            marginLeft: {
              _skip_check_: true,
              value: 0
            }
          }
        }
      }
    },
    [`${componentCls}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${componentCls}-menu-item`]: {
      [`${componentCls}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: true,
          value: "right"
        }
      }
    }
  };
};
const genTabsStyle = (token2) => {
  const {
    componentCls,
    tabsCardHorizontalPadding,
    tabsCardHeight,
    tabsCardGutter,
    tabsHoverColor,
    tabsActiveColor,
    colorSplit
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
      display: "flex",
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${componentCls}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${token2.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${componentCls}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${token2.motionDurationSlow}`
        },
        [`${componentCls}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${componentCls}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${componentCls}-nav-more`]: {
          position: "relative",
          padding: tabsCardHorizontalPadding,
          background: "transparent",
          border: 0,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: true,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: true,
              value: 0
            },
            height: token2.controlHeightLG / 8,
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${componentCls}-nav-add`]: Object.assign({
          minWidth: `${tabsCardHeight}px`,
          marginLeft: {
            _skip_check_: true,
            value: `${tabsCardGutter}px`
          },
          padding: `0 ${token2.paddingXS}px`,
          background: "transparent",
          border: `${token2.lineWidth}px ${token2.lineType} ${colorSplit}`,
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
          outline: "none",
          cursor: "pointer",
          color: token2.colorText,
          transition: `all ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
          "&:hover": {
            color: tabsHoverColor
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: tabsActiveColor
          }
        }, genFocusStyle(token2))
      },
      [`${componentCls}-extra-content`]: {
        flex: "none"
      },
      [`${componentCls}-ink-bar`]: {
        position: "absolute",
        background: token2.colorPrimary,
        pointerEvents: "none"
      }
    }), genTabStyle(token2)), {
      [`${componentCls}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${componentCls}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${componentCls}-tabpane`]: {
        outline: "none",
        "&-hidden": {
          display: "none"
        }
      }
    }),
    [`${componentCls}-centered`]: {
      [`> ${componentCls}-nav, > div > ${componentCls}-nav`]: {
        [`${componentCls}-nav-wrap`]: {
          [`&:not([class*='${componentCls}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
};
const useStyle$a = genComponentStyleHook("Tabs", (token2) => {
  const tabsCardHeight = token2.controlHeightLG;
  const tabsToken = merge(token2, {
    tabsHoverColor: token2.colorPrimaryHover,
    tabsActiveColor: token2.colorPrimaryActive,
    tabsCardHorizontalPadding: `${(tabsCardHeight - Math.round(token2.fontSize * token2.lineHeight)) / 2 - token2.lineWidth}px ${token2.padding}px`,
    tabsCardHeight,
    tabsCardGutter: token2.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: token2.colorFillAlter,
    dropdownEdgeChildVerticalPadding: token2.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [genSizeStyle(tabsToken), genRtlStyle(tabsToken), genPositionStyle(tabsToken), genDropdownStyle(tabsToken), genCardStyle$1(tabsToken), genTabsStyle(tabsToken), genMotionStyle$3(tabsToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50
}));
var __rest$t = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function Tabs(_a) {
  var {
    type: type4,
    className,
    rootClassName,
    size: propSize,
    onEdit,
    hideAdd,
    centered,
    addIcon,
    popupClassName,
    children,
    items,
    animated
  } = _a, props = __rest$t(_a, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "popupClassName", "children", "items", "animated"]);
  const {
    prefixCls: customizePrefixCls,
    moreIcon = /* @__PURE__ */ jsx(EllipsisOutlined$1, {})
  } = props;
  const {
    direction,
    getPrefixCls,
    getPopupContainer
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("tabs", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$a(prefixCls);
  let editable;
  if (type4 === "editable-card") {
    editable = {
      onEdit: (editType, _ref) => {
        let {
          key,
          event
        } = _ref;
        onEdit === null || onEdit === void 0 ? void 0 : onEdit(editType === "add" ? event : key, editType);
      },
      removeIcon: /* @__PURE__ */ jsx(CloseOutlined$1, {}),
      addIcon: addIcon || /* @__PURE__ */ jsx(PlusOutlined$3, {}),
      showAdd: hideAdd !== true
    };
  }
  const rootPrefixCls = getPrefixCls();
  const mergedItems = useLegacyItems(items, children);
  const mergedAnimated = useAnimateConfig(prefixCls, animated);
  const contextSize = react.exports.useContext(SizeContext$2);
  const size = propSize !== void 0 ? propSize : contextSize;
  return wrapSSR(
    /* @__PURE__ */ jsx(ForwardTabs, {
      ...Object.assign({
        direction,
        getPopupContainer,
        moreTransitionName: `${rootPrefixCls}-slide-up`
      }, props, {
        items: mergedItems,
        className: classNames({
          [`${prefixCls}-${size}`]: size,
          [`${prefixCls}-card`]: ["card", "editable-card"].includes(type4),
          [`${prefixCls}-editable-card`]: type4 === "editable-card",
          [`${prefixCls}-centered`]: centered
        }, className, rootClassName, hashId),
        popupClassName: classNames(popupClassName, hashId),
        editable,
        moreIcon,
        prefixCls,
        animated: mergedAnimated
      })
    })
  );
}
Tabs.TabPane = TabPane$1;
var __rest$s = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Grid = (_a) => {
  var {
    prefixCls,
    className,
    hoverable = true
  } = _a, props = __rest$s(_a, ["prefixCls", "className", "hoverable"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefix = getPrefixCls("card", prefixCls);
  const classString = classNames(`${prefix}-grid`, className, {
    [`${prefix}-grid-hoverable`]: hoverable
  });
  return /* @__PURE__ */ jsx("div", {
    ...Object.assign({}, props, {
      className: classString
    })
  });
};
const Grid$1 = Grid;
const genCardHeadStyle = (token2) => {
  const {
    antCls,
    componentCls,
    cardHeadHeight,
    cardPaddingBase,
    cardHeadTabsMarginBottom
  } = token2;
  return Object.assign(Object.assign({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: cardHeadHeight,
    marginBottom: -1,
    padding: `0 ${cardPaddingBase}px`,
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG,
    background: "transparent",
    borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`,
    borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
  }, clearFix()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": Object.assign(Object.assign({
      display: "inline-block",
      flex: 1
    }, textEllipsis), {
      [`
          > ${componentCls}-typography,
          > ${componentCls}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${antCls}-tabs-top`]: {
      clear: "both",
      marginBottom: cardHeadTabsMarginBottom,
      color: token2.colorText,
      fontWeight: "normal",
      fontSize: token2.fontSize,
      "&-bar": {
        borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorderSecondary}`
      }
    }
  });
};
const genCardGridStyle = (token2) => {
  const {
    cardPaddingBase,
    colorBorderSecondary,
    cardShadow,
    lineWidth
  } = token2;
  return {
    width: "33.33%",
    padding: cardPaddingBase,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${lineWidth}px 0 0 0 ${colorBorderSecondary},
      0 ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px ${lineWidth}px 0 0 ${colorBorderSecondary},
      ${lineWidth}px 0 0 0 ${colorBorderSecondary} inset,
      0 ${lineWidth}px 0 0 ${colorBorderSecondary} inset;
    `,
    transition: `all ${token2.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: cardShadow
    }
  };
};
const genCardActionsStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    cardActionsLiMargin,
    cardActionsIconSize,
    colorBorderSecondary
  } = token2;
  return Object.assign(Object.assign({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: token2.colorBgContainer,
    borderTop: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
    display: "flex",
    borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px `
  }, clearFix()), {
    "& > li": {
      margin: cardActionsLiMargin,
      color: token2.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: token2.cardActionsIconSize * 2,
        fontSize: token2.fontSize,
        lineHeight: token2.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: token2.colorPrimary,
          transition: `color ${token2.motionDurationMid}`
        },
        [`a:not(${componentCls}-btn), > ${iconCls}`]: {
          display: "inline-block",
          width: "100%",
          color: token2.colorTextDescription,
          lineHeight: `${token2.fontSize * token2.lineHeight}px`,
          transition: `color ${token2.motionDurationMid}`,
          "&:hover": {
            color: token2.colorPrimary
          }
        },
        [`> ${iconCls}`]: {
          fontSize: cardActionsIconSize,
          lineHeight: `${cardActionsIconSize * token2.lineHeight}px`
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`
      }
    }
  });
};
const genCardMetaStyle = (token2) => Object.assign(Object.assign({
  margin: `-${token2.marginXXS}px 0`,
  display: "flex"
}, clearFix()), {
  "&-avatar": {
    paddingInlineEnd: token2.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: token2.marginXS
    }
  },
  "&-title": Object.assign({
    color: token2.colorTextHeading,
    fontWeight: token2.fontWeightStrong,
    fontSize: token2.fontSizeLG
  }, textEllipsis),
  "&-description": {
    color: token2.colorTextDescription
  }
});
const genCardTypeInnerStyle = (token2) => {
  const {
    componentCls,
    cardPaddingBase,
    colorFillAlter
  } = token2;
  return {
    [`${componentCls}-head`]: {
      padding: `0 ${cardPaddingBase}px`,
      background: colorFillAlter,
      "&-title": {
        fontSize: token2.fontSize
      }
    },
    [`${componentCls}-body`]: {
      padding: `${token2.padding}px ${cardPaddingBase}px`
    }
  };
};
const genCardLoadingStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    overflow: "hidden",
    [`${componentCls}-body`]: {
      userSelect: "none"
    }
  };
};
const genCardStyle = (token2) => {
  const {
    componentCls,
    cardShadow,
    cardHeadPadding,
    colorBorderSecondary,
    boxShadowTertiary,
    cardPaddingBase
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      position: "relative",
      background: token2.colorBgContainer,
      borderRadius: token2.borderRadiusLG,
      [`&:not(${componentCls}-bordered)`]: {
        boxShadow: boxShadowTertiary
      },
      [`${componentCls}-head`]: genCardHeadStyle(token2),
      [`${componentCls}-extra`]: {
        marginInlineStart: "auto",
        color: "",
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`${componentCls}-body`]: Object.assign({
        padding: cardPaddingBase,
        borderRadius: ` 0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`
      }, clearFix()),
      [`${componentCls}-grid`]: genCardGridStyle(token2),
      [`${componentCls}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        img: {
          borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`
        }
      },
      [`${componentCls}-actions`]: genCardActionsStyle(token2),
      [`${componentCls}-meta`]: genCardMetaStyle(token2)
    }),
    [`${componentCls}-bordered`]: {
      border: `${token2.lineWidth}px ${token2.lineType} ${colorBorderSecondary}`,
      [`${componentCls}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${componentCls}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${token2.motionDurationMid}, border-color ${token2.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: cardShadow
      }
    },
    [`${componentCls}-contain-grid`]: {
      [`${componentCls}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${componentCls}-loading) ${componentCls}-body`]: {
        marginBlockStart: -token2.lineWidth,
        marginInlineStart: -token2.lineWidth,
        padding: 0
      }
    },
    [`${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          paddingTop: cardHeadPadding
        }
      }
    },
    [`${componentCls}-type-inner`]: genCardTypeInnerStyle(token2),
    [`${componentCls}-loading`]: genCardLoadingStyle(token2),
    [`${componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
};
const genCardSizeStyle = (token2) => {
  const {
    componentCls,
    cardPaddingSM,
    cardHeadHeightSM
  } = token2;
  return {
    [`${componentCls}-small`]: {
      [`> ${componentCls}-head`]: {
        minHeight: cardHeadHeightSM,
        padding: `0 ${cardPaddingSM}px`,
        fontSize: token2.fontSize,
        [`> ${componentCls}-head-wrapper`]: {
          [`> ${componentCls}-extra`]: {
            fontSize: token2.fontSize
          }
        }
      },
      [`> ${componentCls}-body`]: {
        padding: cardPaddingSM
      }
    },
    [`${componentCls}-small${componentCls}-contain-tabs`]: {
      [`> ${componentCls}-head`]: {
        [`${componentCls}-head-title, ${componentCls}-extra`]: {
          minHeight: cardHeadHeightSM,
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
};
const useStyle$9 = genComponentStyleHook("Card", (token2) => {
  const cardToken = merge(token2, {
    cardShadow: token2.boxShadowCard,
    cardHeadHeight: token2.fontSizeLG * token2.lineHeightLG + token2.padding * 2,
    cardHeadHeightSM: token2.fontSize * token2.lineHeight + token2.paddingXS * 2,
    cardHeadPadding: token2.padding,
    cardPaddingBase: token2.paddingLG,
    cardHeadTabsMarginBottom: -token2.padding - token2.lineWidth,
    cardActionsLiMargin: `${token2.paddingSM}px 0`,
    cardActionsIconSize: token2.fontSize,
    cardPaddingSM: 12
  });
  return [
    genCardStyle(cardToken),
    genCardSizeStyle(cardToken)
  ];
});
var __rest$r = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function getAction(actions) {
  const actionList = actions.map((action, index2) => /* @__PURE__ */ jsx("li", {
    style: {
      width: `${100 / actions.length}%`
    },
    children: /* @__PURE__ */ jsx("span", {
      children: action
    })
  }, `action-${index2}`));
  return actionList;
}
const Card$2 = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const size = react.exports.useContext(SizeContext$2);
  const onTabChange = (key) => {
    var _a;
    (_a = props.onTabChange) === null || _a === void 0 ? void 0 : _a.call(props, key);
  };
  const isContainGrid = () => {
    let containGrid;
    react.exports.Children.forEach(props.children, (element) => {
      if (element && element.type && element.type === Grid$1) {
        containGrid = true;
      }
    });
    return containGrid;
  };
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    extra,
    headStyle = {},
    bodyStyle = {},
    title,
    loading,
    bordered = true,
    size: customizeSize,
    type: type4,
    cover,
    actions,
    tabList,
    children,
    activeTabKey,
    defaultActiveTabKey,
    tabBarExtraContent,
    hoverable,
    tabProps = {}
  } = props, others = __rest$r(props, ["prefixCls", "className", "rootClassName", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps"]);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$9(prefixCls);
  const loadingBlock = /* @__PURE__ */ jsx(Skeleton$1, {
    loading: true,
    active: true,
    paragraph: {
      rows: 4
    },
    title: false,
    children
  });
  const hasActiveTabKey = activeTabKey !== void 0;
  const extraProps = Object.assign(Object.assign({}, tabProps), {
    [hasActiveTabKey ? "activeKey" : "defaultActiveKey"]: hasActiveTabKey ? activeTabKey : defaultActiveTabKey,
    tabBarExtraContent
  });
  let head;
  const tabs = tabList && tabList.length ? /* @__PURE__ */ jsx(Tabs, {
    ...Object.assign({
      size: "large"
    }, extraProps, {
      className: `${prefixCls}-head-tabs`,
      onChange: onTabChange,
      items: tabList.map((item) => {
        var _a;
        return {
          label: item.tab,
          key: item.key,
          disabled: (_a = item.disabled) !== null && _a !== void 0 ? _a : false
        };
      })
    })
  }) : null;
  if (title || extra || tabs) {
    head = /* @__PURE__ */ jsxs("div", {
      className: `${prefixCls}-head`,
      style: headStyle,
      children: [/* @__PURE__ */ jsxs("div", {
        className: `${prefixCls}-head-wrapper`,
        children: [title && /* @__PURE__ */ jsx("div", {
          className: `${prefixCls}-head-title`,
          children: title
        }), extra && /* @__PURE__ */ jsx("div", {
          className: `${prefixCls}-extra`,
          children: extra
        })]
      }), tabs]
    });
  }
  const coverDom = cover ? /* @__PURE__ */ jsx("div", {
    className: `${prefixCls}-cover`,
    children: cover
  }) : null;
  const body = /* @__PURE__ */ jsx("div", {
    className: `${prefixCls}-body`,
    style: bodyStyle,
    children: loading ? loadingBlock : children
  });
  const actionDom = actions && actions.length ? /* @__PURE__ */ jsx("ul", {
    className: `${prefixCls}-actions`,
    children: getAction(actions)
  }) : null;
  const divProps = omit(others, ["onTabChange"]);
  const mergedSize = customizeSize || size;
  const classString = classNames(prefixCls, {
    [`${prefixCls}-loading`]: loading,
    [`${prefixCls}-bordered`]: bordered,
    [`${prefixCls}-hoverable`]: hoverable,
    [`${prefixCls}-contain-grid`]: isContainGrid(),
    [`${prefixCls}-contain-tabs`]: tabList && tabList.length,
    [`${prefixCls}-${mergedSize}`]: mergedSize,
    [`${prefixCls}-type-${type4}`]: !!type4,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsxs("div", {
      ...Object.assign({
        ref
      }, divProps, {
        className: classString
      }),
      children: [head, coverDom, body, actionDom]
    })
  );
});
const InternalCard = Card$2;
var __rest$q = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Meta = (props) => {
  const {
    prefixCls: customizePrefixCls,
    className,
    avatar,
    title,
    description
  } = props, others = __rest$q(props, ["prefixCls", "className", "avatar", "title", "description"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("card", customizePrefixCls);
  const classString = classNames(`${prefixCls}-meta`, className);
  const avatarDom = avatar ? /* @__PURE__ */ jsx("div", {
    className: `${prefixCls}-meta-avatar`,
    children: avatar
  }) : null;
  const titleDom = title ? /* @__PURE__ */ jsx("div", {
    className: `${prefixCls}-meta-title`,
    children: title
  }) : null;
  const descriptionDom = description ? /* @__PURE__ */ jsx("div", {
    className: `${prefixCls}-meta-description`,
    children: description
  }) : null;
  const MetaDetail = titleDom || descriptionDom ? /* @__PURE__ */ jsxs("div", {
    className: `${prefixCls}-meta-detail`,
    children: [titleDom, descriptionDom]
  }) : null;
  return /* @__PURE__ */ jsxs("div", {
    ...Object.assign({}, others, {
      className: classString
    }),
    children: [avatarDom, MetaDetail]
  });
};
const Meta$1 = Meta;
const Card = InternalCard;
Card.Grid = Grid$1;
Card.Meta = Meta$1;
const Card$1 = Card;
var initialState = {
  animating: false,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: false,
  edgeDragged: false,
  initialized: false,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: false,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: false,
  swiping: false,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
function throttle(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle(delay, callback, {
    debounceMode: atBegin !== false
  });
}
function clamp(number4, lowerBound, upperBound) {
  return Math.max(lowerBound, Math.min(number4, upperBound));
}
var safePreventDefault = function safePreventDefault2(event) {
  var passiveEvents = ["onTouchStart", "onTouchMove", "onWheel"];
  if (!passiveEvents.includes(event._reactName)) {
    event.preventDefault();
  }
};
var getOnDemandLazySlides = function getOnDemandLazySlides2(spec) {
  var onDemandSlides = [];
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  for (var slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {
    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {
      onDemandSlides.push(slideIndex);
    }
  }
  return onDemandSlides;
};
var lazyStartIndex = function lazyStartIndex2(spec) {
  return spec.currentSlide - lazySlidesOnLeft(spec);
};
var lazyEndIndex = function lazyEndIndex2(spec) {
  return spec.currentSlide + lazySlidesOnRight(spec);
};
var lazySlidesOnLeft = function lazySlidesOnLeft2(spec) {
  return spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;
};
var lazySlidesOnRight = function lazySlidesOnRight2(spec) {
  return spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow;
};
var getWidth = function getWidth2(elem) {
  return elem && elem.offsetWidth || 0;
};
var getHeight = function getHeight2(elem) {
  return elem && elem.offsetHeight || 0;
};
var getSwipeDirection = function getSwipeDirection2(touchObject) {
  var verticalSwiping = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var xDist, yDist, r2, swipeAngle;
  xDist = touchObject.startX - touchObject.curX;
  yDist = touchObject.startY - touchObject.curY;
  r2 = Math.atan2(yDist, xDist);
  swipeAngle = Math.round(r2 * 180 / Math.PI);
  if (swipeAngle < 0) {
    swipeAngle = 360 - Math.abs(swipeAngle);
  }
  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {
    return "left";
  }
  if (swipeAngle >= 135 && swipeAngle <= 225) {
    return "right";
  }
  if (verticalSwiping === true) {
    if (swipeAngle >= 35 && swipeAngle <= 135) {
      return "up";
    } else {
      return "down";
    }
  }
  return "vertical";
};
var canGoNext = function canGoNext2(spec) {
  var canGo = true;
  if (!spec.infinite) {
    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {
      canGo = false;
    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {
      canGo = false;
    }
  }
  return canGo;
};
var extractObject = function extractObject2(spec, keys2) {
  var newObject = {};
  keys2.forEach(function(key) {
    return newObject[key] = spec[key];
  });
  return newObject;
};
var initializedState = function initializedState2(spec) {
  var slideCount = React.Children.count(spec.children);
  var listNode = spec.listRef;
  var listWidth = Math.ceil(getWidth(listNode));
  var trackNode = spec.trackRef && spec.trackRef.node;
  var trackWidth = Math.ceil(getWidth(trackNode));
  var slideWidth;
  if (!spec.vertical) {
    var centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;
    if (typeof spec.centerPadding === "string" && spec.centerPadding.slice(-1) === "%") {
      centerPaddingAdj *= listWidth / 100;
    }
    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);
  } else {
    slideWidth = listWidth;
  }
  var slideHeight = listNode && getHeight(listNode.querySelector('[data-index="0"]'));
  var listHeight = slideHeight * spec.slidesToShow;
  var currentSlide = spec.currentSlide === void 0 ? spec.initialSlide : spec.currentSlide;
  if (spec.rtl && spec.currentSlide === void 0) {
    currentSlide = slideCount - 1 - spec.initialSlide;
  }
  var lazyLoadedList = spec.lazyLoadedList || [];
  var slidesToLoad = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
    currentSlide,
    lazyLoadedList
  }));
  lazyLoadedList = lazyLoadedList.concat(slidesToLoad);
  var state = {
    slideCount,
    slideWidth,
    listWidth,
    trackWidth,
    currentSlide,
    slideHeight,
    listHeight,
    lazyLoadedList
  };
  if (spec.autoplaying === null && spec.autoplay) {
    state["autoplaying"] = "playing";
  }
  return state;
};
var slideHandler = function slideHandler2(spec) {
  var waitForAnimate = spec.waitForAnimate, animating = spec.animating, fade = spec.fade, infinite = spec.infinite, index2 = spec.index, slideCount = spec.slideCount, lazyLoad = spec.lazyLoad, currentSlide = spec.currentSlide, centerMode = spec.centerMode, slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, useCSS = spec.useCSS;
  var lazyLoadedList = spec.lazyLoadedList;
  if (waitForAnimate && animating)
    return {};
  var animationSlide = index2, finalSlide, animationLeft, finalLeft;
  var state = {}, nextState = {};
  var targetSlide = infinite ? index2 : clamp(index2, 0, slideCount - 1);
  if (fade) {
    if (!infinite && (index2 < 0 || index2 >= slideCount))
      return {};
    if (index2 < 0) {
      animationSlide = index2 + slideCount;
    } else if (index2 >= slideCount) {
      animationSlide = index2 - slideCount;
    }
    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {
      lazyLoadedList = lazyLoadedList.concat(animationSlide);
    }
    state = {
      animating: true,
      currentSlide: animationSlide,
      lazyLoadedList,
      targetSlide: animationSlide
    };
    nextState = {
      animating: false,
      targetSlide: animationSlide
    };
  } else {
    finalSlide = animationSlide;
    if (animationSlide < 0) {
      finalSlide = animationSlide + slideCount;
      if (!infinite)
        finalSlide = 0;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = slideCount - slideCount % slidesToScroll;
    } else if (!canGoNext(spec) && animationSlide > currentSlide) {
      animationSlide = finalSlide = currentSlide;
    } else if (centerMode && animationSlide >= slideCount) {
      animationSlide = infinite ? slideCount : slideCount - 1;
      finalSlide = infinite ? 0 : slideCount - 1;
    } else if (animationSlide >= slideCount) {
      finalSlide = animationSlide - slideCount;
      if (!infinite)
        finalSlide = slideCount - slidesToShow;
      else if (slideCount % slidesToScroll !== 0)
        finalSlide = 0;
    }
    if (!infinite && animationSlide + slidesToShow >= slideCount) {
      finalSlide = slideCount - slidesToShow;
    }
    animationLeft = getTrackLeft(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      slideIndex: animationSlide
    }));
    finalLeft = getTrackLeft(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      slideIndex: finalSlide
    }));
    if (!infinite) {
      if (animationLeft === finalLeft)
        animationSlide = finalSlide;
      animationLeft = finalLeft;
    }
    if (lazyLoad) {
      lazyLoadedList = lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
        currentSlide: animationSlide
      })));
    }
    if (!useCSS) {
      state = {
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          left: finalLeft
        })),
        lazyLoadedList,
        targetSlide
      };
    } else {
      state = {
        animating: true,
        currentSlide: finalSlide,
        trackStyle: getTrackAnimateCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          left: animationLeft
        })),
        lazyLoadedList,
        targetSlide
      };
      nextState = {
        animating: false,
        currentSlide: finalSlide,
        trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          left: finalLeft
        })),
        swipeLeft: null,
        targetSlide
      };
    }
  }
  return {
    state,
    nextState
  };
};
var changeSlide = function changeSlide2(spec, options) {
  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;
  var slidesToScroll = spec.slidesToScroll, slidesToShow = spec.slidesToShow, slideCount = spec.slideCount, currentSlide = spec.currentSlide, previousTargetSlide = spec.targetSlide, lazyLoad = spec.lazyLoad, infinite = spec.infinite;
  unevenOffset = slideCount % slidesToScroll !== 0;
  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;
  if (options.message === "previous") {
    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;
    targetSlide = currentSlide - slideOffset;
    if (lazyLoad && !infinite) {
      previousInt = currentSlide - slideOffset;
      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide - slidesToScroll;
    }
  } else if (options.message === "next") {
    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;
    targetSlide = currentSlide + slideOffset;
    if (lazyLoad && !infinite) {
      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;
    }
    if (!infinite) {
      targetSlide = previousTargetSlide + slidesToScroll;
    }
  } else if (options.message === "dots") {
    targetSlide = options.index * options.slidesToScroll;
  } else if (options.message === "children") {
    targetSlide = options.index;
    if (infinite) {
      var direction = siblingDirection(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
        targetSlide
      }));
      if (targetSlide > options.currentSlide && direction === "left") {
        targetSlide = targetSlide - slideCount;
      } else if (targetSlide < options.currentSlide && direction === "right") {
        targetSlide = targetSlide + slideCount;
      }
    }
  } else if (options.message === "index") {
    targetSlide = Number(options.index);
  }
  return targetSlide;
};
var keyHandler = function keyHandler2(e2, accessibility, rtl) {
  if (e2.target.tagName.match("TEXTAREA|INPUT|SELECT") || !accessibility)
    return "";
  if (e2.keyCode === 37)
    return rtl ? "next" : "previous";
  if (e2.keyCode === 39)
    return rtl ? "previous" : "next";
  return "";
};
var swipeStart = function swipeStart2(e2, swipe, draggable) {
  e2.target.tagName === "IMG" && safePreventDefault(e2);
  if (!swipe || !draggable && e2.type.indexOf("mouse") !== -1)
    return "";
  return {
    dragging: true,
    touchObject: {
      startX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      startY: e2.touches ? e2.touches[0].pageY : e2.clientY,
      curX: e2.touches ? e2.touches[0].pageX : e2.clientX,
      curY: e2.touches ? e2.touches[0].pageY : e2.clientY
    }
  };
};
var swipeMove = function swipeMove2(e2, spec) {
  var scrolling = spec.scrolling, animating = spec.animating, vertical = spec.vertical, swipeToSlide = spec.swipeToSlide, verticalSwiping = spec.verticalSwiping, rtl = spec.rtl, currentSlide = spec.currentSlide, edgeFriction = spec.edgeFriction, edgeDragged = spec.edgeDragged, onEdge = spec.onEdge, swiped = spec.swiped, swiping = spec.swiping, slideCount = spec.slideCount, slidesToScroll = spec.slidesToScroll, infinite = spec.infinite, touchObject = spec.touchObject, swipeEvent = spec.swipeEvent, listHeight = spec.listHeight, listWidth = spec.listWidth;
  if (scrolling)
    return;
  if (animating)
    return safePreventDefault(e2);
  if (vertical && swipeToSlide && verticalSwiping)
    safePreventDefault(e2);
  var swipeLeft, state = {};
  var curLeft = getTrackLeft(spec);
  touchObject.curX = e2.touches ? e2.touches[0].pageX : e2.clientX;
  touchObject.curY = e2.touches ? e2.touches[0].pageY : e2.clientY;
  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));
  var verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));
  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {
    return {
      scrolling: true
    };
  }
  if (verticalSwiping)
    touchObject.swipeLength = verticalSwipeLength;
  var positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);
  if (verticalSwiping)
    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;
  var dotCount = Math.ceil(slideCount / slidesToScroll);
  var swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);
  var touchSwipeLength = touchObject.swipeLength;
  if (!infinite) {
    if (currentSlide === 0 && (swipeDirection === "right" || swipeDirection === "down") || currentSlide + 1 >= dotCount && (swipeDirection === "left" || swipeDirection === "up") || !canGoNext(spec) && (swipeDirection === "left" || swipeDirection === "up")) {
      touchSwipeLength = touchObject.swipeLength * edgeFriction;
      if (edgeDragged === false && onEdge) {
        onEdge(swipeDirection);
        state["edgeDragged"] = true;
      }
    }
  }
  if (!swiped && swipeEvent) {
    swipeEvent(swipeDirection);
    state["swiped"] = true;
  }
  if (!vertical) {
    if (!rtl) {
      swipeLeft = curLeft + touchSwipeLength * positionOffset;
    } else {
      swipeLeft = curLeft - touchSwipeLength * positionOffset;
    }
  } else {
    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;
  }
  if (verticalSwiping) {
    swipeLeft = curLeft + touchSwipeLength * positionOffset;
  }
  state = _objectSpread2$1(_objectSpread2$1({}, state), {}, {
    touchObject,
    swipeLeft,
    trackStyle: getTrackCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      left: swipeLeft
    }))
  });
  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {
    return state;
  }
  if (touchObject.swipeLength > 10) {
    state["swiping"] = true;
    safePreventDefault(e2);
  }
  return state;
};
var swipeEnd = function swipeEnd2(e2, spec) {
  var dragging = spec.dragging, swipe = spec.swipe, touchObject = spec.touchObject, listWidth = spec.listWidth, touchThreshold = spec.touchThreshold, verticalSwiping = spec.verticalSwiping, listHeight = spec.listHeight, swipeToSlide = spec.swipeToSlide, scrolling = spec.scrolling, onSwipe = spec.onSwipe, targetSlide = spec.targetSlide, currentSlide = spec.currentSlide, infinite = spec.infinite;
  if (!dragging) {
    if (swipe)
      safePreventDefault(e2);
    return {};
  }
  var minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;
  var swipeDirection = getSwipeDirection(touchObject, verticalSwiping);
  var state = {
    dragging: false,
    edgeDragged: false,
    scrolling: false,
    swiping: false,
    swiped: false,
    swipeLeft: null,
    touchObject: {}
  };
  if (scrolling) {
    return state;
  }
  if (!touchObject.swipeLength) {
    return state;
  }
  if (touchObject.swipeLength > minSwipe) {
    safePreventDefault(e2);
    if (onSwipe) {
      onSwipe(swipeDirection);
    }
    var slideCount, newSlide;
    var activeSlide = infinite ? currentSlide : targetSlide;
    switch (swipeDirection) {
      case "left":
      case "up":
        newSlide = activeSlide + getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 0;
        break;
      case "right":
      case "down":
        newSlide = activeSlide - getSlideCount(spec);
        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;
        state["currentDirection"] = 1;
        break;
      default:
        slideCount = activeSlide;
    }
    state["triggerSlideHandler"] = slideCount;
  } else {
    var currentLeft = getTrackLeft(spec);
    state["trackStyle"] = getTrackAnimateCSS(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      left: currentLeft
    }));
  }
  return state;
};
var getNavigableIndexes = function getNavigableIndexes2(spec) {
  var max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;
  var breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;
  var counter = spec.infinite ? spec.slidesToShow * -1 : 0;
  var indexes = [];
  while (breakpoint < max) {
    indexes.push(breakpoint);
    breakpoint = counter + spec.slidesToScroll;
    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);
  }
  return indexes;
};
var checkNavigable = function checkNavigable2(spec, index2) {
  var navigables = getNavigableIndexes(spec);
  var prevNavigable = 0;
  if (index2 > navigables[navigables.length - 1]) {
    index2 = navigables[navigables.length - 1];
  } else {
    for (var n2 in navigables) {
      if (index2 < navigables[n2]) {
        index2 = prevNavigable;
        break;
      }
      prevNavigable = navigables[n2];
    }
  }
  return index2;
};
var getSlideCount = function getSlideCount2(spec) {
  var centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;
  if (spec.swipeToSlide) {
    var swipedSlide;
    var slickList = spec.listRef;
    var slides = slickList.querySelectorAll && slickList.querySelectorAll(".slick-slide") || [];
    Array.from(slides).every(function(slide) {
      if (!spec.vertical) {
        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      } else {
        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {
          swipedSlide = slide;
          return false;
        }
      }
      return true;
    });
    if (!swipedSlide) {
      return 0;
    }
    var currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;
    var slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;
    return slidesTraversed;
  } else {
    return spec.slidesToScroll;
  }
};
var checkSpecKeys = function checkSpecKeys2(spec, keysArray) {
  return keysArray.reduce(function(value, key) {
    return value && spec.hasOwnProperty(key);
  }, true) ? null : console.error("Keys Missing:", spec);
};
var getTrackCSS = function getTrackCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  var trackWidth, trackHeight;
  var trackChildren = spec.slideCount + 2 * spec.slidesToShow;
  if (!spec.vertical) {
    trackWidth = getTotalSlides(spec) * spec.slideWidth;
  } else {
    trackHeight = trackChildren * spec.slideHeight;
  }
  var style2 = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (spec.useTransform) {
    var WebkitTransform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var transform = !spec.vertical ? "translate3d(" + spec.left + "px, 0px, 0px)" : "translate3d(0px, " + spec.left + "px, 0px)";
    var msTransform = !spec.vertical ? "translateX(" + spec.left + "px)" : "translateY(" + spec.left + "px)";
    style2 = _objectSpread2$1(_objectSpread2$1({}, style2), {}, {
      WebkitTransform,
      transform,
      msTransform
    });
  } else {
    if (spec.vertical) {
      style2["top"] = spec.left;
    } else {
      style2["left"] = spec.left;
    }
  }
  if (spec.fade)
    style2 = {
      opacity: 1
    };
  if (trackWidth)
    style2.width = trackWidth;
  if (trackHeight)
    style2.height = trackHeight;
  if (window && !window.addEventListener && window.attachEvent) {
    if (!spec.vertical) {
      style2.marginLeft = spec.left + "px";
    } else {
      style2.marginTop = spec.left + "px";
    }
  }
  return style2;
};
var getTrackAnimateCSS = function getTrackAnimateCSS2(spec) {
  checkSpecKeys(spec, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  var style2 = getTrackCSS(spec);
  if (spec.useTransform) {
    style2.WebkitTransition = "-webkit-transform " + spec.speed + "ms " + spec.cssEase;
    style2.transition = "transform " + spec.speed + "ms " + spec.cssEase;
  } else {
    if (spec.vertical) {
      style2.transition = "top " + spec.speed + "ms " + spec.cssEase;
    } else {
      style2.transition = "left " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getTrackLeft = function getTrackLeft2(spec) {
  if (spec.unslick) {
    return 0;
  }
  checkSpecKeys(spec, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  var slideIndex = spec.slideIndex, trackRef = spec.trackRef, infinite = spec.infinite, centerMode = spec.centerMode, slideCount = spec.slideCount, slidesToShow = spec.slidesToShow, slidesToScroll = spec.slidesToScroll, slideWidth = spec.slideWidth, listWidth = spec.listWidth, variableWidth = spec.variableWidth, slideHeight = spec.slideHeight, fade = spec.fade, vertical = spec.vertical;
  var slideOffset = 0;
  var targetLeft;
  var targetSlide;
  var verticalOffset = 0;
  if (fade || spec.slideCount === 1) {
    return 0;
  }
  var slidesToOffset = 0;
  if (infinite) {
    slidesToOffset = -getPreClones(spec);
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);
    }
    if (centerMode) {
      slidesToOffset += parseInt(slidesToShow / 2);
    }
  } else {
    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {
      slidesToOffset = slidesToShow - slideCount % slidesToScroll;
    }
    if (centerMode) {
      slidesToOffset = parseInt(slidesToShow / 2);
    }
  }
  slideOffset = slidesToOffset * slideWidth;
  verticalOffset = slidesToOffset * slideHeight;
  if (!vertical) {
    targetLeft = slideIndex * slideWidth * -1 + slideOffset;
  } else {
    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;
  }
  if (variableWidth === true) {
    var targetSlideIndex;
    var trackElem = trackRef && trackRef.node;
    targetSlideIndex = slideIndex + getPreClones(spec);
    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];
    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;
    if (centerMode === true) {
      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;
      targetSlide = trackElem && trackElem.children[targetSlideIndex];
      targetLeft = 0;
      for (var slide = 0; slide < targetSlideIndex; slide++) {
        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;
      }
      targetLeft -= parseInt(spec.centerPadding);
      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;
    }
  }
  return targetLeft;
};
var getPreClones = function getPreClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  if (spec.variableWidth) {
    return spec.slideCount;
  }
  return spec.slidesToShow + (spec.centerMode ? 1 : 0);
};
var getPostClones = function getPostClones2(spec) {
  if (spec.unslick || !spec.infinite) {
    return 0;
  }
  return spec.slideCount;
};
var getTotalSlides = function getTotalSlides2(spec) {
  return spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);
};
var siblingDirection = function siblingDirection2(spec) {
  if (spec.targetSlide > spec.currentSlide) {
    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {
      return "left";
    }
    return "right";
  } else {
    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {
      return "right";
    }
    return "left";
  }
};
var slidesOnRight = function slidesOnRight2(_ref) {
  var slidesToShow = _ref.slidesToShow, centerMode = _ref.centerMode, rtl = _ref.rtl, centerPadding = _ref.centerPadding;
  if (centerMode) {
    var right = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      right += 1;
    if (rtl && slidesToShow % 2 === 0)
      right += 1;
    return right;
  }
  if (rtl) {
    return 0;
  }
  return slidesToShow - 1;
};
var slidesOnLeft = function slidesOnLeft2(_ref2) {
  var slidesToShow = _ref2.slidesToShow, centerMode = _ref2.centerMode, rtl = _ref2.rtl, centerPadding = _ref2.centerPadding;
  if (centerMode) {
    var left = (slidesToShow - 1) / 2 + 1;
    if (parseInt(centerPadding) > 0)
      left += 1;
    if (!rtl && slidesToShow % 2 === 0)
      left += 1;
    return left;
  }
  if (rtl) {
    return slidesToShow - 1;
  }
  return 0;
};
var canUseDOM = function canUseDOM2() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
};
var getSlideClasses = function getSlideClasses2(spec) {
  var slickActive, slickCenter, slickCloned;
  var centerOffset, index2;
  if (spec.rtl) {
    index2 = spec.slideCount - 1 - spec.index;
  } else {
    index2 = spec.index;
  }
  slickCloned = index2 < 0 || index2 >= spec.slideCount;
  if (spec.centerMode) {
    centerOffset = Math.floor(spec.slidesToShow / 2);
    slickCenter = (index2 - spec.currentSlide) % spec.slideCount === 0;
    if (index2 > spec.currentSlide - centerOffset - 1 && index2 <= spec.currentSlide + centerOffset) {
      slickActive = true;
    }
  } else {
    slickActive = spec.currentSlide <= index2 && index2 < spec.currentSlide + spec.slidesToShow;
  }
  var focusedSlide;
  if (spec.targetSlide < 0) {
    focusedSlide = spec.targetSlide + spec.slideCount;
  } else if (spec.targetSlide >= spec.slideCount) {
    focusedSlide = spec.targetSlide - spec.slideCount;
  } else {
    focusedSlide = spec.targetSlide;
  }
  var slickCurrent = index2 === focusedSlide;
  return {
    "slick-slide": true,
    "slick-active": slickActive,
    "slick-center": slickCenter,
    "slick-cloned": slickCloned,
    "slick-current": slickCurrent
  };
};
var getSlideStyle = function getSlideStyle2(spec) {
  var style2 = {};
  if (spec.variableWidth === void 0 || spec.variableWidth === false) {
    style2.width = spec.slideWidth;
  }
  if (spec.fade) {
    style2.position = "relative";
    if (spec.vertical) {
      style2.top = -spec.index * parseInt(spec.slideHeight);
    } else {
      style2.left = -spec.index * parseInt(spec.slideWidth);
    }
    style2.opacity = spec.currentSlide === spec.index ? 1 : 0;
    if (spec.useCSS) {
      style2.transition = "opacity " + spec.speed + "ms " + spec.cssEase + ", visibility " + spec.speed + "ms " + spec.cssEase;
    }
  }
  return style2;
};
var getKey$2 = function getKey(child, fallbackKey) {
  return child.key + "-" + fallbackKey;
};
var renderSlides = function renderSlides2(spec) {
  var key;
  var slides = [];
  var preCloneSlides = [];
  var postCloneSlides = [];
  var childrenCount = React.Children.count(spec.children);
  var startIndex = lazyStartIndex(spec);
  var endIndex = lazyEndIndex(spec);
  React.Children.forEach(spec.children, function(elem, index2) {
    var child;
    var childOnClickOptions = {
      message: "children",
      index: index2,
      slidesToScroll: spec.slidesToScroll,
      currentSlide: spec.currentSlide
    };
    if (!spec.lazyLoad || spec.lazyLoad && spec.lazyLoadedList.indexOf(index2) >= 0) {
      child = elem;
    } else {
      child = /* @__PURE__ */ jsx("div", {});
    }
    var childStyle = getSlideStyle(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      index: index2
    }));
    var slideClass = child.props.className || "";
    var slideClasses = getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
      index: index2
    }));
    slides.push(/* @__PURE__ */ React.cloneElement(child, {
      key: "original" + getKey$2(child, index2),
      "data-index": index2,
      className: classNames(slideClasses, slideClass),
      tabIndex: "-1",
      "aria-hidden": !slideClasses["slick-active"],
      style: _objectSpread2$1(_objectSpread2$1({
        outline: "none"
      }, child.props.style || {}), childStyle),
      onClick: function onClick(e2) {
        child.props && child.props.onClick && child.props.onClick(e2);
        if (spec.focusOnSelect) {
          spec.focusOnSelect(childOnClickOptions);
        }
      }
    }));
    if (spec.infinite && spec.fade === false) {
      var preCloneNo = childrenCount - index2;
      if (preCloneNo <= getPreClones(spec) && childrenCount !== spec.slidesToShow) {
        key = -preCloneNo;
        if (key >= startIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          index: key
        }));
        preCloneSlides.push(/* @__PURE__ */ React.cloneElement(child, {
          key: "precloned" + getKey$2(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: classNames(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2$1(_objectSpread2$1({}, child.props.style || {}), childStyle),
          onClick: function onClick(e2) {
            child.props && child.props.onClick && child.props.onClick(e2);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
      if (childrenCount !== spec.slidesToShow) {
        key = childrenCount + index2;
        if (key < endIndex) {
          child = elem;
        }
        slideClasses = getSlideClasses(_objectSpread2$1(_objectSpread2$1({}, spec), {}, {
          index: key
        }));
        postCloneSlides.push(/* @__PURE__ */ React.cloneElement(child, {
          key: "postcloned" + getKey$2(child, key),
          "data-index": key,
          tabIndex: "-1",
          className: classNames(slideClasses, slideClass),
          "aria-hidden": !slideClasses["slick-active"],
          style: _objectSpread2$1(_objectSpread2$1({}, child.props.style || {}), childStyle),
          onClick: function onClick(e2) {
            child.props && child.props.onClick && child.props.onClick(e2);
            if (spec.focusOnSelect) {
              spec.focusOnSelect(childOnClickOptions);
            }
          }
        }));
      }
    }
  });
  if (spec.rtl) {
    return preCloneSlides.concat(slides, postCloneSlides).reverse();
  } else {
    return preCloneSlides.concat(slides, postCloneSlides);
  }
};
var Track = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(Track2, _React$PureComponent);
  var _super = _createSuper(Track2);
  function Track2() {
    var _this;
    _classCallCheck(this, Track2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized(_this), "node", null);
    _defineProperty$1(_assertThisInitialized(_this), "handleRef", function(ref) {
      _this.node = ref;
    });
    return _this;
  }
  _createClass(Track2, [{
    key: "render",
    value: function render2() {
      var slides = renderSlides(this.props);
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave;
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      return /* @__PURE__ */ jsx("div", {
        ref: this.handleRef,
        className: "slick-track",
        style: this.props.trackStyle,
        ...mouseEvents,
        children: slides
      });
    }
  }]);
  return Track2;
}(React.PureComponent);
var getDotCount = function getDotCount2(spec) {
  var dots;
  if (spec.infinite) {
    dots = Math.ceil(spec.slideCount / spec.slidesToScroll);
  } else {
    dots = Math.ceil((spec.slideCount - spec.slidesToShow) / spec.slidesToScroll) + 1;
  }
  return dots;
};
var Dots = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(Dots2, _React$PureComponent);
  var _super = _createSuper(Dots2);
  function Dots2() {
    _classCallCheck(this, Dots2);
    return _super.apply(this, arguments);
  }
  _createClass(Dots2, [{
    key: "clickHandler",
    value: function clickHandler(options, e2) {
      e2.preventDefault();
      this.props.clickHandler(options);
    }
  }, {
    key: "render",
    value: function render2() {
      var _this$props = this.props, onMouseEnter = _this$props.onMouseEnter, onMouseOver = _this$props.onMouseOver, onMouseLeave = _this$props.onMouseLeave, infinite = _this$props.infinite, slidesToScroll = _this$props.slidesToScroll, slidesToShow = _this$props.slidesToShow, slideCount = _this$props.slideCount, currentSlide = _this$props.currentSlide;
      var dotCount = getDotCount({
        slideCount,
        slidesToScroll,
        slidesToShow,
        infinite
      });
      var mouseEvents = {
        onMouseEnter,
        onMouseOver,
        onMouseLeave
      };
      var dots = [];
      for (var i2 = 0; i2 < dotCount; i2++) {
        var _rightBound = (i2 + 1) * slidesToScroll - 1;
        var rightBound = infinite ? _rightBound : clamp(_rightBound, 0, slideCount - 1);
        var _leftBound = rightBound - (slidesToScroll - 1);
        var leftBound = infinite ? _leftBound : clamp(_leftBound, 0, slideCount - 1);
        var className = classNames({
          "slick-active": infinite ? currentSlide >= leftBound && currentSlide <= rightBound : currentSlide === leftBound
        });
        var dotOptions = {
          message: "dots",
          index: i2,
          slidesToScroll,
          currentSlide
        };
        var onClick = this.clickHandler.bind(this, dotOptions);
        dots = dots.concat(
          /* @__PURE__ */ jsx("li", {
            className,
            children: /* @__PURE__ */ React.cloneElement(this.props.customPaging(i2), {
              onClick
            })
          }, i2)
        );
      }
      return /* @__PURE__ */ React.cloneElement(this.props.appendDots(dots), _objectSpread2$1({
        className: this.props.dotsClass
      }, mouseEvents));
    }
  }]);
  return Dots2;
}(React.PureComponent);
var PrevArrow = /* @__PURE__ */ function(_React$PureComponent) {
  _inherits(PrevArrow2, _React$PureComponent);
  var _super = _createSuper(PrevArrow2);
  function PrevArrow2() {
    _classCallCheck(this, PrevArrow2);
    return _super.apply(this, arguments);
  }
  _createClass(PrevArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e2) {
      if (e2) {
        e2.preventDefault();
      }
      this.props.clickHandler(options, e2);
    }
  }, {
    key: "render",
    value: function render2() {
      var prevClasses = {
        "slick-arrow": true,
        "slick-prev": true
      };
      var prevHandler = this.clickHandler.bind(this, {
        message: "previous"
      });
      if (!this.props.infinite && (this.props.currentSlide === 0 || this.props.slideCount <= this.props.slidesToShow)) {
        prevClasses["slick-disabled"] = true;
        prevHandler = null;
      }
      var prevArrowProps = {
        key: "0",
        "data-role": "none",
        className: classNames(prevClasses),
        style: {
          display: "block"
        },
        onClick: prevHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var prevArrow;
      if (this.props.prevArrow) {
        prevArrow = /* @__PURE__ */ React.cloneElement(this.props.prevArrow, _objectSpread2$1(_objectSpread2$1({}, prevArrowProps), customProps));
      } else {
        prevArrow = /* @__PURE__ */ jsxs("button", {
          type: "button",
          ...prevArrowProps,
          children: [" ", "Previous"]
        }, "0");
      }
      return prevArrow;
    }
  }]);
  return PrevArrow2;
}(React.PureComponent);
var NextArrow = /* @__PURE__ */ function(_React$PureComponent2) {
  _inherits(NextArrow2, _React$PureComponent2);
  var _super2 = _createSuper(NextArrow2);
  function NextArrow2() {
    _classCallCheck(this, NextArrow2);
    return _super2.apply(this, arguments);
  }
  _createClass(NextArrow2, [{
    key: "clickHandler",
    value: function clickHandler(options, e2) {
      if (e2) {
        e2.preventDefault();
      }
      this.props.clickHandler(options, e2);
    }
  }, {
    key: "render",
    value: function render2() {
      var nextClasses = {
        "slick-arrow": true,
        "slick-next": true
      };
      var nextHandler = this.clickHandler.bind(this, {
        message: "next"
      });
      if (!canGoNext(this.props)) {
        nextClasses["slick-disabled"] = true;
        nextHandler = null;
      }
      var nextArrowProps = {
        key: "1",
        "data-role": "none",
        className: classNames(nextClasses),
        style: {
          display: "block"
        },
        onClick: nextHandler
      };
      var customProps = {
        currentSlide: this.props.currentSlide,
        slideCount: this.props.slideCount
      };
      var nextArrow;
      if (this.props.nextArrow) {
        nextArrow = /* @__PURE__ */ React.cloneElement(this.props.nextArrow, _objectSpread2$1(_objectSpread2$1({}, nextArrowProps), customProps));
      } else {
        nextArrow = /* @__PURE__ */ jsxs("button", {
          type: "button",
          ...nextArrowProps,
          children: [" ", "Next"]
        }, "1");
      }
      return nextArrow;
    }
  }]);
  return NextArrow2;
}(React.PureComponent);
var _excluded$6 = ["animating"];
var InnerSlider = /* @__PURE__ */ function(_React$Component) {
  _inherits(InnerSlider2, _React$Component);
  var _super = _createSuper(InnerSlider2);
  function InnerSlider2(props) {
    var _this;
    _classCallCheck(this, InnerSlider2);
    _this = _super.call(this, props);
    _defineProperty$1(_assertThisInitialized(_this), "listRefHandler", function(ref) {
      return _this.list = ref;
    });
    _defineProperty$1(_assertThisInitialized(_this), "trackRefHandler", function(ref) {
      return _this.track = ref;
    });
    _defineProperty$1(_assertThisInitialized(_this), "adaptHeight", function() {
      if (_this.props.adaptiveHeight && _this.list) {
        var elem = _this.list.querySelector('[data-index="'.concat(_this.state.currentSlide, '"]'));
        _this.list.style.height = getHeight(elem) + "px";
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "componentDidMount", function() {
      _this.props.onInit && _this.props.onInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      var spec = _objectSpread2$1({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props);
      _this.updateState(spec, true, function() {
        _this.adaptHeight();
        _this.props.autoplay && _this.autoPlay("playing");
      });
      if (_this.props.lazyLoad === "progressive") {
        _this.lazyLoadTimer = setInterval(_this.progressiveLazyLoad, 1e3);
      }
      _this.ro = new index$1(function() {
        if (_this.state.animating) {
          _this.onWindowResized(false);
          _this.callbackTimers.push(setTimeout(function() {
            return _this.onWindowResized();
          }, _this.props.speed));
        } else {
          _this.onWindowResized();
        }
      });
      _this.ro.observe(_this.list);
      document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), function(slide) {
        slide.onfocus = _this.props.pauseOnFocus ? _this.onSlideFocus : null;
        slide.onblur = _this.props.pauseOnFocus ? _this.onSlideBlur : null;
      });
      if (window.addEventListener) {
        window.addEventListener("resize", _this.onWindowResized);
      } else {
        window.attachEvent("onresize", _this.onWindowResized);
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "componentWillUnmount", function() {
      if (_this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
      }
      if (_this.lazyLoadTimer) {
        clearInterval(_this.lazyLoadTimer);
      }
      if (_this.callbackTimers.length) {
        _this.callbackTimers.forEach(function(timer) {
          return clearTimeout(timer);
        });
        _this.callbackTimers = [];
      }
      if (window.addEventListener) {
        window.removeEventListener("resize", _this.onWindowResized);
      } else {
        window.detachEvent("onresize", _this.onWindowResized);
      }
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      _this.ro.disconnect();
    });
    _defineProperty$1(_assertThisInitialized(_this), "componentDidUpdate", function(prevProps) {
      _this.checkImagesLoad();
      _this.props.onReInit && _this.props.onReInit();
      if (_this.props.lazyLoad) {
        var slidesToLoad = getOnDemandLazySlides(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state));
        if (slidesToLoad.length > 0) {
          _this.setState(function(prevState) {
            return {
              lazyLoadedList: prevState.lazyLoadedList.concat(slidesToLoad)
            };
          });
          if (_this.props.onLazyLoad) {
            _this.props.onLazyLoad(slidesToLoad);
          }
        }
      }
      _this.adaptHeight();
      var spec = _objectSpread2$1(_objectSpread2$1({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      var setTrackStyle = _this.didPropsChange(prevProps);
      setTrackStyle && _this.updateState(spec, setTrackStyle, function() {
        if (_this.state.currentSlide >= React.Children.count(_this.props.children)) {
          _this.changeSlide({
            message: "index",
            index: React.Children.count(_this.props.children) - _this.props.slidesToShow,
            currentSlide: _this.state.currentSlide
          });
        }
        if (prevProps.autoplay !== _this.props.autoplay || prevProps.autoplaySpeed !== _this.props.autoplaySpeed) {
          if (!prevProps.autoplay && _this.props.autoplay) {
            _this.autoPlay("playing");
          } else if (_this.props.autoplay) {
            _this.autoPlay("update");
          } else {
            _this.pause("paused");
          }
        }
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "onWindowResized", function(setTrackStyle) {
      if (_this.debouncedResize)
        _this.debouncedResize.cancel();
      _this.debouncedResize = debounce(50, function() {
        return _this.resizeWindow(setTrackStyle);
      });
      _this.debouncedResize();
    });
    _defineProperty$1(_assertThisInitialized(_this), "resizeWindow", function() {
      var setTrackStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var isTrackMounted = Boolean(_this.track && _this.track.node);
      if (!isTrackMounted)
        return;
      var spec = _objectSpread2$1(_objectSpread2$1({
        listRef: _this.list,
        trackRef: _this.track
      }, _this.props), _this.state);
      _this.updateState(spec, setTrackStyle, function() {
        if (_this.props.autoplay)
          _this.autoPlay("update");
        else
          _this.pause("paused");
      });
      _this.setState({
        animating: false
      });
      clearTimeout(_this.animationEndCallback);
      delete _this.animationEndCallback;
    });
    _defineProperty$1(_assertThisInitialized(_this), "updateState", function(spec, setTrackStyle, callback) {
      var updatedState = initializedState(spec);
      spec = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, spec), updatedState), {}, {
        slideIndex: updatedState.currentSlide
      });
      var targetLeft = getTrackLeft(spec);
      spec = _objectSpread2$1(_objectSpread2$1({}, spec), {}, {
        left: targetLeft
      });
      var trackStyle = getTrackCSS(spec);
      if (setTrackStyle || React.Children.count(_this.props.children) !== React.Children.count(spec.children)) {
        updatedState["trackStyle"] = trackStyle;
      }
      _this.setState(updatedState, callback);
    });
    _defineProperty$1(_assertThisInitialized(_this), "ssrInit", function() {
      if (_this.props.variableWidth) {
        var _trackWidth = 0, _trackLeft = 0;
        var childrenWidths = [];
        var preClones = getPreClones(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        var postClones = getPostClones(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state), {}, {
          slideCount: _this.props.children.length
        }));
        _this.props.children.forEach(function(child) {
          childrenWidths.push(child.props.style.width);
          _trackWidth += child.props.style.width;
        });
        for (var i2 = 0; i2 < preClones; i2++) {
          _trackLeft += childrenWidths[childrenWidths.length - 1 - i2];
          _trackWidth += childrenWidths[childrenWidths.length - 1 - i2];
        }
        for (var _i = 0; _i < postClones; _i++) {
          _trackWidth += childrenWidths[_i];
        }
        for (var _i2 = 0; _i2 < _this.state.currentSlide; _i2++) {
          _trackLeft += childrenWidths[_i2];
        }
        var _trackStyle = {
          width: _trackWidth + "px",
          left: -_trackLeft + "px"
        };
        if (_this.props.centerMode) {
          var currentWidth = "".concat(childrenWidths[_this.state.currentSlide], "px");
          _trackStyle.left = "calc(".concat(_trackStyle.left, " + (100% - ").concat(currentWidth, ") / 2 ) ");
        }
        return {
          trackStyle: _trackStyle
        };
      }
      var childrenCount = React.Children.count(_this.props.children);
      var spec = _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state), {}, {
        slideCount: childrenCount
      });
      var slideCount = getPreClones(spec) + getPostClones(spec) + childrenCount;
      var trackWidth = 100 / _this.props.slidesToShow * slideCount;
      var slideWidth = 100 / slideCount;
      var trackLeft = -slideWidth * (getPreClones(spec) + _this.state.currentSlide) * trackWidth / 100;
      if (_this.props.centerMode) {
        trackLeft += (100 - slideWidth * trackWidth / 100) / 2;
      }
      var trackStyle = {
        width: trackWidth + "%",
        left: trackLeft + "%"
      };
      return {
        slideWidth: slideWidth + "%",
        trackStyle
      };
    });
    _defineProperty$1(_assertThisInitialized(_this), "checkImagesLoad", function() {
      var images = _this.list && _this.list.querySelectorAll && _this.list.querySelectorAll(".slick-slide img") || [];
      var imagesCount = images.length, loadedCount = 0;
      Array.prototype.forEach.call(images, function(image) {
        var handler = function handler2() {
          return ++loadedCount && loadedCount >= imagesCount && _this.onWindowResized();
        };
        if (!image.onclick) {
          image.onclick = function() {
            return image.parentNode.focus();
          };
        } else {
          var prevClickHandler = image.onclick;
          image.onclick = function(e2) {
            prevClickHandler(e2);
            image.parentNode.focus();
          };
        }
        if (!image.onload) {
          if (_this.props.lazyLoad) {
            image.onload = function() {
              _this.adaptHeight();
              _this.callbackTimers.push(setTimeout(_this.onWindowResized, _this.props.speed));
            };
          } else {
            image.onload = handler;
            image.onerror = function() {
              handler();
              _this.props.onLazyLoadError && _this.props.onLazyLoadError();
            };
          }
        }
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "progressiveLazyLoad", function() {
      var slidesToLoad = [];
      var spec = _objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state);
      for (var index2 = _this.state.currentSlide; index2 < _this.state.slideCount + getPostClones(spec); index2++) {
        if (_this.state.lazyLoadedList.indexOf(index2) < 0) {
          slidesToLoad.push(index2);
          break;
        }
      }
      for (var _index = _this.state.currentSlide - 1; _index >= -getPreClones(spec); _index--) {
        if (_this.state.lazyLoadedList.indexOf(_index) < 0) {
          slidesToLoad.push(_index);
          break;
        }
      }
      if (slidesToLoad.length > 0) {
        _this.setState(function(state) {
          return {
            lazyLoadedList: state.lazyLoadedList.concat(slidesToLoad)
          };
        });
        if (_this.props.onLazyLoad) {
          _this.props.onLazyLoad(slidesToLoad);
        }
      } else {
        if (_this.lazyLoadTimer) {
          clearInterval(_this.lazyLoadTimer);
          delete _this.lazyLoadTimer;
        }
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "slideHandler", function(index2) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var _this$props = _this.props, asNavFor = _this$props.asNavFor, beforeChange = _this$props.beforeChange, onLazyLoad = _this$props.onLazyLoad, speed = _this$props.speed, afterChange = _this$props.afterChange;
      var currentSlide = _this.state.currentSlide;
      var _slideHandler = slideHandler(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
        index: index2
      }, _this.props), _this.state), {}, {
        trackRef: _this.track,
        useCSS: _this.props.useCSS && !dontAnimate
      })), state = _slideHandler.state, nextState = _slideHandler.nextState;
      if (!state)
        return;
      beforeChange && beforeChange(currentSlide, state.currentSlide);
      var slidesToLoad = state.lazyLoadedList.filter(function(value) {
        return _this.state.lazyLoadedList.indexOf(value) < 0;
      });
      onLazyLoad && slidesToLoad.length > 0 && onLazyLoad(slidesToLoad);
      if (!_this.props.waitForAnimate && _this.animationEndCallback) {
        clearTimeout(_this.animationEndCallback);
        afterChange && afterChange(currentSlide);
        delete _this.animationEndCallback;
      }
      _this.setState(state, function() {
        if (asNavFor && _this.asNavForIndex !== index2) {
          _this.asNavForIndex = index2;
          asNavFor.innerSlider.slideHandler(index2);
        }
        if (!nextState)
          return;
        _this.animationEndCallback = setTimeout(function() {
          var animating = nextState.animating, firstBatch = _objectWithoutProperties(nextState, _excluded$6);
          _this.setState(firstBatch, function() {
            _this.callbackTimers.push(setTimeout(function() {
              return _this.setState({
                animating
              });
            }, 10));
            afterChange && afterChange(state.currentSlide);
            delete _this.animationEndCallback;
          });
        }, speed);
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "changeSlide", function(options) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var spec = _objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state);
      var targetSlide = changeSlide(spec, options);
      if (targetSlide !== 0 && !targetSlide)
        return;
      if (dontAnimate === true) {
        _this.slideHandler(targetSlide, dontAnimate);
      } else {
        _this.slideHandler(targetSlide);
      }
      _this.props.autoplay && _this.autoPlay("update");
      if (_this.props.focusOnSelect) {
        var nodes = _this.list.querySelectorAll(".slick-current");
        nodes[0] && nodes[0].focus();
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "clickHandler", function(e2) {
      if (_this.clickable === false) {
        e2.stopPropagation();
        e2.preventDefault();
      }
      _this.clickable = true;
    });
    _defineProperty$1(_assertThisInitialized(_this), "keyHandler", function(e2) {
      var dir = keyHandler(e2, _this.props.accessibility, _this.props.rtl);
      dir !== "" && _this.changeSlide({
        message: dir
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "selectHandler", function(options) {
      _this.changeSlide(options);
    });
    _defineProperty$1(_assertThisInitialized(_this), "disableBodyScroll", function() {
      var preventDefault = function preventDefault2(e2) {
        e2 = e2 || window.event;
        if (e2.preventDefault)
          e2.preventDefault();
        e2.returnValue = false;
      };
      window.ontouchmove = preventDefault;
    });
    _defineProperty$1(_assertThisInitialized(_this), "enableBodyScroll", function() {
      window.ontouchmove = null;
    });
    _defineProperty$1(_assertThisInitialized(_this), "swipeStart", function(e2) {
      if (_this.props.verticalSwiping) {
        _this.disableBodyScroll();
      }
      var state = swipeStart(e2, _this.props.swipe, _this.props.draggable);
      state !== "" && _this.setState(state);
    });
    _defineProperty$1(_assertThisInitialized(_this), "swipeMove", function(e2) {
      var state = swipeMove(e2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      if (state["swiping"]) {
        _this.clickable = false;
      }
      _this.setState(state);
    });
    _defineProperty$1(_assertThisInitialized(_this), "swipeEnd", function(e2) {
      var state = swipeEnd(e2, _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state), {}, {
        trackRef: _this.track,
        listRef: _this.list,
        slideIndex: _this.state.currentSlide
      }));
      if (!state)
        return;
      var triggerSlideHandler = state["triggerSlideHandler"];
      delete state["triggerSlideHandler"];
      _this.setState(state);
      if (triggerSlideHandler === void 0)
        return;
      _this.slideHandler(triggerSlideHandler);
      if (_this.props.verticalSwiping) {
        _this.enableBodyScroll();
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "touchEnd", function(e2) {
      _this.swipeEnd(e2);
      _this.clickable = true;
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickPrev", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "previous"
        });
      }, 0));
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickNext", function() {
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "next"
        });
      }, 0));
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      slide = Number(slide);
      if (isNaN(slide))
        return "";
      _this.callbackTimers.push(setTimeout(function() {
        return _this.changeSlide({
          message: "index",
          index: slide,
          currentSlide: _this.state.currentSlide
        }, dontAnimate);
      }, 0));
    });
    _defineProperty$1(_assertThisInitialized(_this), "play", function() {
      var nextIndex;
      if (_this.props.rtl) {
        nextIndex = _this.state.currentSlide - _this.props.slidesToScroll;
      } else {
        if (canGoNext(_objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state))) {
          nextIndex = _this.state.currentSlide + _this.props.slidesToScroll;
        } else {
          return false;
        }
      }
      _this.slideHandler(nextIndex);
    });
    _defineProperty$1(_assertThisInitialized(_this), "autoPlay", function(playType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
      }
      var autoplaying = _this.state.autoplaying;
      if (playType === "update") {
        if (autoplaying === "hovered" || autoplaying === "focused" || autoplaying === "paused") {
          return;
        }
      } else if (playType === "leave") {
        if (autoplaying === "paused" || autoplaying === "focused") {
          return;
        }
      } else if (playType === "blur") {
        if (autoplaying === "paused" || autoplaying === "hovered") {
          return;
        }
      }
      _this.autoplayTimer = setInterval(_this.play, _this.props.autoplaySpeed + 50);
      _this.setState({
        autoplaying: "playing"
      });
    });
    _defineProperty$1(_assertThisInitialized(_this), "pause", function(pauseType) {
      if (_this.autoplayTimer) {
        clearInterval(_this.autoplayTimer);
        _this.autoplayTimer = null;
      }
      var autoplaying = _this.state.autoplaying;
      if (pauseType === "paused") {
        _this.setState({
          autoplaying: "paused"
        });
      } else if (pauseType === "focused") {
        if (autoplaying === "hovered" || autoplaying === "playing") {
          _this.setState({
            autoplaying: "focused"
          });
        }
      } else {
        if (autoplaying === "playing") {
          _this.setState({
            autoplaying: "hovered"
          });
        }
      }
    });
    _defineProperty$1(_assertThisInitialized(_this), "onDotsOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty$1(_assertThisInitialized(_this), "onDotsLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty$1(_assertThisInitialized(_this), "onTrackOver", function() {
      return _this.props.autoplay && _this.pause("hovered");
    });
    _defineProperty$1(_assertThisInitialized(_this), "onTrackLeave", function() {
      return _this.props.autoplay && _this.state.autoplaying === "hovered" && _this.autoPlay("leave");
    });
    _defineProperty$1(_assertThisInitialized(_this), "onSlideFocus", function() {
      return _this.props.autoplay && _this.pause("focused");
    });
    _defineProperty$1(_assertThisInitialized(_this), "onSlideBlur", function() {
      return _this.props.autoplay && _this.state.autoplaying === "focused" && _this.autoPlay("blur");
    });
    _defineProperty$1(_assertThisInitialized(_this), "render", function() {
      var className = classNames("slick-slider", _this.props.className, {
        "slick-vertical": _this.props.vertical,
        "slick-initialized": true
      });
      var spec = _objectSpread2$1(_objectSpread2$1({}, _this.props), _this.state);
      var trackProps = extractObject(spec, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
      var pauseOnHover = _this.props.pauseOnHover;
      trackProps = _objectSpread2$1(_objectSpread2$1({}, trackProps), {}, {
        onMouseEnter: pauseOnHover ? _this.onTrackOver : null,
        onMouseLeave: pauseOnHover ? _this.onTrackLeave : null,
        onMouseOver: pauseOnHover ? _this.onTrackOver : null,
        focusOnSelect: _this.props.focusOnSelect && _this.clickable ? _this.selectHandler : null
      });
      var dots;
      if (_this.props.dots === true && _this.state.slideCount >= _this.props.slidesToShow) {
        var dotProps = extractObject(spec, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "customPaging", "infinite", "appendDots"]);
        var pauseOnDotsHover = _this.props.pauseOnDotsHover;
        dotProps = _objectSpread2$1(_objectSpread2$1({}, dotProps), {}, {
          clickHandler: _this.changeSlide,
          onMouseEnter: pauseOnDotsHover ? _this.onDotsLeave : null,
          onMouseOver: pauseOnDotsHover ? _this.onDotsOver : null,
          onMouseLeave: pauseOnDotsHover ? _this.onDotsLeave : null
        });
        dots = /* @__PURE__ */ jsx(Dots, {
          ...dotProps
        });
      }
      var prevArrow, nextArrow;
      var arrowProps = extractObject(spec, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow", "prevArrow", "nextArrow"]);
      arrowProps.clickHandler = _this.changeSlide;
      if (_this.props.arrows) {
        prevArrow = /* @__PURE__ */ jsx(PrevArrow, {
          ...arrowProps
        });
        nextArrow = /* @__PURE__ */ jsx(NextArrow, {
          ...arrowProps
        });
      }
      var verticalHeightStyle = null;
      if (_this.props.vertical) {
        verticalHeightStyle = {
          height: _this.state.listHeight
        };
      }
      var centerPaddingStyle = null;
      if (_this.props.vertical === false) {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: "0px " + _this.props.centerPadding
          };
        }
      } else {
        if (_this.props.centerMode === true) {
          centerPaddingStyle = {
            padding: _this.props.centerPadding + " 0px"
          };
        }
      }
      var listStyle = _objectSpread2$1(_objectSpread2$1({}, verticalHeightStyle), centerPaddingStyle);
      var touchMove = _this.props.touchMove;
      var listProps = {
        className: "slick-list",
        style: listStyle,
        onClick: _this.clickHandler,
        onMouseDown: touchMove ? _this.swipeStart : null,
        onMouseMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onMouseUp: touchMove ? _this.swipeEnd : null,
        onMouseLeave: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onTouchStart: touchMove ? _this.swipeStart : null,
        onTouchMove: _this.state.dragging && touchMove ? _this.swipeMove : null,
        onTouchEnd: touchMove ? _this.touchEnd : null,
        onTouchCancel: _this.state.dragging && touchMove ? _this.swipeEnd : null,
        onKeyDown: _this.props.accessibility ? _this.keyHandler : null
      };
      var innerSliderProps = {
        className,
        dir: "ltr",
        style: _this.props.style
      };
      if (_this.props.unslick) {
        listProps = {
          className: "slick-list"
        };
        innerSliderProps = {
          className
        };
      }
      return /* @__PURE__ */ jsxs("div", {
        ...innerSliderProps,
        children: [!_this.props.unslick ? prevArrow : "", /* @__PURE__ */ jsx("div", {
          ref: _this.listRefHandler,
          ...listProps,
          children: /* @__PURE__ */ jsx(Track, {
            ref: _this.trackRefHandler,
            ...trackProps,
            children: _this.props.children
          })
        }), !_this.props.unslick ? nextArrow : "", !_this.props.unslick ? dots : ""]
      });
    });
    _this.list = null;
    _this.track = null;
    _this.state = _objectSpread2$1(_objectSpread2$1({}, initialState), {}, {
      currentSlide: _this.props.initialSlide,
      slideCount: React.Children.count(_this.props.children)
    });
    _this.callbackTimers = [];
    _this.clickable = true;
    _this.debouncedResize = null;
    var ssrState = _this.ssrInit();
    _this.state = _objectSpread2$1(_objectSpread2$1({}, _this.state), ssrState);
    return _this;
  }
  _createClass(InnerSlider2, [{
    key: "didPropsChange",
    value: function didPropsChange(prevProps) {
      var setTrackStyle = false;
      for (var _i3 = 0, _Object$keys = Object.keys(this.props); _i3 < _Object$keys.length; _i3++) {
        var key = _Object$keys[_i3];
        if (!prevProps.hasOwnProperty(key)) {
          setTrackStyle = true;
          break;
        }
        if (_typeof$1(prevProps[key]) === "object" || typeof prevProps[key] === "function") {
          continue;
        }
        if (prevProps[key] !== this.props[key]) {
          setTrackStyle = true;
          break;
        }
      }
      return setTrackStyle || React.Children.count(this.props.children) !== React.Children.count(prevProps.children);
    }
  }]);
  return InnerSlider2;
}(React.Component);
var camel2hyphen$1 = function(str) {
  return str.replace(/[A-Z]/g, function(match) {
    return "-" + match.toLowerCase();
  }).toLowerCase();
};
var camel2hyphen_1 = camel2hyphen$1;
var camel2hyphen = camel2hyphen_1;
var isDimension = function(feature) {
  var re2 = /[height|width]$/;
  return re2.test(feature);
};
var obj2mq = function(obj) {
  var mq = "";
  var features = Object.keys(obj);
  features.forEach(function(feature, index2) {
    var value = obj[feature];
    feature = camel2hyphen(feature);
    if (isDimension(feature) && typeof value === "number") {
      value = value + "px";
    }
    if (value === true) {
      mq += feature;
    } else if (value === false) {
      mq += "not " + feature;
    } else {
      mq += "(" + feature + ": " + value + ")";
    }
    if (index2 < features.length - 1) {
      mq += " and ";
    }
  });
  return mq;
};
var json2mq = function(query) {
  var mq = "";
  if (typeof query === "string") {
    return query;
  }
  if (query instanceof Array) {
    query.forEach(function(q2, index2) {
      mq += obj2mq(q2);
      if (index2 < query.length - 1) {
        mq += ", ";
      }
    });
    return mq;
  }
  return obj2mq(query);
};
var json2mq_1 = json2mq;
var defaultProps = {
  accessibility: true,
  adaptiveHeight: false,
  afterChange: null,
  appendDots: function appendDots(dots) {
    return /* @__PURE__ */ jsx("ul", {
      style: {
        display: "block"
      },
      children: dots
    });
  },
  arrows: true,
  autoplay: false,
  autoplaySpeed: 3e3,
  beforeChange: null,
  centerMode: false,
  centerPadding: "50px",
  className: "",
  cssEase: "ease",
  customPaging: function customPaging(i2) {
    return /* @__PURE__ */ jsx("button", {
      children: i2 + 1
    });
  },
  dots: false,
  dotsClass: "slick-dots",
  draggable: true,
  easing: "linear",
  edgeFriction: 0.35,
  fade: false,
  focusOnSelect: false,
  infinite: true,
  initialSlide: 0,
  lazyLoad: null,
  nextArrow: null,
  onEdge: null,
  onInit: null,
  onLazyLoadError: null,
  onReInit: null,
  pauseOnDotsHover: false,
  pauseOnFocus: false,
  pauseOnHover: true,
  prevArrow: null,
  responsive: null,
  rows: 1,
  rtl: false,
  slide: "div",
  slidesPerRow: 1,
  slidesToScroll: 1,
  slidesToShow: 1,
  speed: 500,
  swipe: true,
  swipeEvent: null,
  swipeToSlide: false,
  touchMove: true,
  touchThreshold: 5,
  useCSS: true,
  useTransform: true,
  variableWidth: false,
  vertical: false,
  waitForAnimate: true
};
var Slider = /* @__PURE__ */ function(_React$Component) {
  _inherits(Slider2, _React$Component);
  var _super = _createSuper(Slider2);
  function Slider2(props) {
    var _this;
    _classCallCheck(this, Slider2);
    _this = _super.call(this, props);
    _defineProperty$1(_assertThisInitialized(_this), "innerSliderRefHandler", function(ref) {
      return _this.innerSlider = ref;
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickPrev", function() {
      return _this.innerSlider.slickPrev();
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickNext", function() {
      return _this.innerSlider.slickNext();
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickGoTo", function(slide) {
      var dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return _this.innerSlider.slickGoTo(slide, dontAnimate);
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickPause", function() {
      return _this.innerSlider.pause("paused");
    });
    _defineProperty$1(_assertThisInitialized(_this), "slickPlay", function() {
      return _this.innerSlider.autoPlay("play");
    });
    _this.state = {
      breakpoint: null
    };
    _this._responsiveMediaHandlers = [];
    return _this;
  }
  _createClass(Slider2, [{
    key: "media",
    value: function media(query, handler) {
      var mql = window.matchMedia(query);
      var listener = function listener2(_ref) {
        var matches = _ref.matches;
        if (matches) {
          handler();
        }
      };
      mql.addListener(listener);
      listener(mql);
      this._responsiveMediaHandlers.push({
        mql,
        query,
        listener
      });
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      if (this.props.responsive) {
        var breakpoints = this.props.responsive.map(function(breakpt) {
          return breakpt.breakpoint;
        });
        breakpoints.sort(function(x2, y2) {
          return x2 - y2;
        });
        breakpoints.forEach(function(breakpoint, index2) {
          var bQuery;
          if (index2 === 0) {
            bQuery = json2mq_1({
              minWidth: 0,
              maxWidth: breakpoint
            });
          } else {
            bQuery = json2mq_1({
              minWidth: breakpoints[index2 - 1] + 1,
              maxWidth: breakpoint
            });
          }
          canUseDOM() && _this2.media(bQuery, function() {
            _this2.setState({
              breakpoint
            });
          });
        });
        var query = json2mq_1({
          minWidth: breakpoints.slice(-1)[0]
        });
        canUseDOM() && this.media(query, function() {
          _this2.setState({
            breakpoint: null
          });
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._responsiveMediaHandlers.forEach(function(obj) {
        obj.mql.removeListener(obj.listener);
      });
    }
  }, {
    key: "render",
    value: function render2() {
      var _this3 = this;
      var settings;
      var newProps;
      if (this.state.breakpoint) {
        newProps = this.props.responsive.filter(function(resp) {
          return resp.breakpoint === _this3.state.breakpoint;
        });
        settings = newProps[0].settings === "unslick" ? "unslick" : _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, defaultProps), this.props), newProps[0].settings);
      } else {
        settings = _objectSpread2$1(_objectSpread2$1({}, defaultProps), this.props);
      }
      if (settings.centerMode) {
        if (settings.slidesToScroll > 1 && false) {
          console.warn("slidesToScroll should be equal to 1 in centerMode, you are using ".concat(settings.slidesToScroll));
        }
        settings.slidesToScroll = 1;
      }
      if (settings.fade) {
        if (settings.slidesToShow > 1 && false) {
          console.warn("slidesToShow should be equal to 1 when fade is true, you're using ".concat(settings.slidesToShow));
        }
        if (settings.slidesToScroll > 1 && false) {
          console.warn("slidesToScroll should be equal to 1 when fade is true, you're using ".concat(settings.slidesToScroll));
        }
        settings.slidesToShow = 1;
        settings.slidesToScroll = 1;
      }
      var children = React.Children.toArray(this.props.children);
      children = children.filter(function(child) {
        if (typeof child === "string") {
          return !!child.trim();
        }
        return !!child;
      });
      if (settings.variableWidth && (settings.rows > 1 || settings.slidesPerRow > 1)) {
        console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1");
        settings.variableWidth = false;
      }
      var newChildren = [];
      var currentWidth = null;
      for (var i2 = 0; i2 < children.length; i2 += settings.rows * settings.slidesPerRow) {
        var newSlide = [];
        for (var j2 = i2; j2 < i2 + settings.rows * settings.slidesPerRow; j2 += settings.slidesPerRow) {
          var row = [];
          for (var k2 = j2; k2 < j2 + settings.slidesPerRow; k2 += 1) {
            if (settings.variableWidth && children[k2].props.style) {
              currentWidth = children[k2].props.style.width;
            }
            if (k2 >= children.length)
              break;
            row.push(/* @__PURE__ */ React.cloneElement(children[k2], {
              key: 100 * i2 + 10 * j2 + k2,
              tabIndex: -1,
              style: {
                width: "".concat(100 / settings.slidesPerRow, "%"),
                display: "inline-block"
              }
            }));
          }
          newSlide.push(
            /* @__PURE__ */ jsx("div", {
              children: row
            }, 10 * i2 + j2)
          );
        }
        if (settings.variableWidth) {
          newChildren.push(
            /* @__PURE__ */ jsx("div", {
              style: {
                width: currentWidth
              },
              children: newSlide
            }, i2)
          );
        } else {
          newChildren.push(
            /* @__PURE__ */ jsx("div", {
              children: newSlide
            }, i2)
          );
        }
      }
      if (settings === "unslick") {
        var className = "regular slider " + (this.props.className || "");
        return /* @__PURE__ */ jsx("div", {
          className,
          children
        });
      } else if (newChildren.length <= settings.slidesToShow) {
        settings.unslick = true;
      }
      return /* @__PURE__ */ jsx(InnerSlider, {
        style: this.props.style,
        ref: this.innerSliderRefHandler,
        ...settings,
        children: newChildren
      });
    }
  }]);
  return Slider2;
}(React.Component);
const genCarouselStyle = (token2) => {
  const {
    componentCls,
    antCls,
    carouselArrowSize,
    carouselDotOffset,
    marginXXS
  } = token2;
  const arrowOffset = -carouselArrowSize * 1.25;
  const carouselDotMargin = marginXXS;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${antCls}-radio-input, input${antCls}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      },
      ".slick-arrow.slick-hidden": {
        display: "none"
      },
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        display: "block",
        width: carouselArrowSize,
        height: carouselArrowSize,
        marginTop: -carouselArrowSize / 2,
        padding: 0,
        color: "transparent",
        fontSize: 0,
        lineHeight: 0,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        "&:hover, &:focus": {
          color: "transparent",
          background: "transparent",
          outline: "none",
          "&::before": {
            opacity: 1
          }
        },
        "&.slick-disabled::before": {
          opacity: 0.25
        }
      },
      ".slick-prev": {
        insetInlineStart: arrowOffset,
        "&::before": {
          content: '"\u2190"'
        }
      },
      ".slick-next": {
        insetInlineEnd: arrowOffset,
        "&::before": {
          content: '"\u2192"'
        }
      },
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: carouselDotOffset
        },
        "&-top": {
          top: carouselDotOffset,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: token2.dotWidth,
          height: token2.dotHeight,
          marginInline: carouselDotMargin,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${token2.motionDurationSlow}`,
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: token2.dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: token2.colorBgContainer,
            border: 0,
            borderRadius: 1,
            outline: "none",
            cursor: "pointer",
            opacity: 0.3,
            transition: `all ${token2.motionDurationSlow}`,
            "&: hover, &:focus": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: -carouselDotMargin,
              content: '""'
            }
          },
          "&.slick-active": {
            width: token2.dotWidthActive,
            "& button": {
              background: token2.colorBgContainer,
              opacity: 1
            },
            "&: hover, &:focus": {
              opacity: 1
            }
          }
        }
      }
    })
  };
};
const genCarouselVerticalStyle = (token2) => {
  const {
    componentCls,
    carouselDotOffset,
    marginXXS
  } = token2;
  const reverseSizeOfDot = {
    width: token2.dotHeight,
    height: token2.dotWidth
  };
  return {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: token2.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-left": {
          insetInlineEnd: "auto",
          insetInlineStart: carouselDotOffset
        },
        "&-right": {
          insetInlineEnd: carouselDotOffset,
          insetInlineStart: "auto"
        },
        li: Object.assign(Object.assign({}, reverseSizeOfDot), {
          margin: `${marginXXS}px 0`,
          verticalAlign: "baseline",
          button: reverseSizeOfDot,
          "&.slick-active": Object.assign(Object.assign({}, reverseSizeOfDot), {
            button: reverseSizeOfDot
          })
        })
      }
    }
  };
};
const genCarouselRtlStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return [{
    [`${componentCls}-rtl`]: {
      direction: "rtl",
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "row-reverse"
        }
      }
    }
  }, {
    [`${componentCls}-vertical`]: {
      ".slick-dots": {
        [`${componentCls}-rtl&`]: {
          flexDirection: "column"
        }
      }
    }
  }];
};
const useStyle$8 = genComponentStyleHook("Carousel", (token2) => {
  const {
    controlHeightLG,
    controlHeightSM
  } = token2;
  const carouselToken = merge(token2, {
    carouselArrowSize: controlHeightLG / 2,
    carouselDotOffset: controlHeightSM / 2
  });
  return [genCarouselStyle(carouselToken), genCarouselVerticalStyle(carouselToken), genCarouselRtlStyle(carouselToken)];
}, {
  dotWidth: 16,
  dotHeight: 3,
  dotWidthActive: 24
});
var __rest$p = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Carousel = /* @__PURE__ */ react.exports.forwardRef((_a, ref) => {
  var {
    dots = true,
    arrows = false,
    draggable = false,
    dotPosition = "bottom",
    vertical = dotPosition === "left" || dotPosition === "right",
    rootClassName
  } = _a, props = __rest$p(_a, ["dots", "arrows", "draggable", "dotPosition", "vertical", "rootClassName"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const slickRef = react.exports.useRef();
  const goTo = function(slide) {
    let dontAnimate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    slickRef.current.slickGoTo(slide, dontAnimate);
  };
  react.exports.useImperativeHandle(ref, () => ({
    goTo,
    autoPlay: slickRef.current.innerSlider.autoPlay,
    innerSlider: slickRef.current.innerSlider,
    prev: slickRef.current.slickPrev,
    next: slickRef.current.slickNext
  }), [slickRef.current]);
  const prevCount = react.exports.useRef(react.exports.Children.count(props.children));
  react.exports.useEffect(() => {
    if (prevCount.current !== react.exports.Children.count(props.children)) {
      goTo(props.initialSlide || 0, false);
      prevCount.current = react.exports.Children.count(props.children);
    }
  }, [props.children]);
  const newProps = Object.assign({
    vertical
  }, props);
  if (newProps.effect === "fade") {
    newProps.fade = true;
  }
  const prefixCls = getPrefixCls("carousel", newProps.prefixCls);
  const dotsClass = "slick-dots";
  const enableDots = !!dots;
  const dsClass = classNames(dotsClass, `${dotsClass}-${dotPosition}`, typeof dots === "boolean" ? false : dots === null || dots === void 0 ? void 0 : dots.className);
  const [wrapSSR, hashId] = useStyle$8(prefixCls);
  const className = classNames(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-vertical`]: newProps.vertical
  }, hashId, rootClassName);
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className,
      children: /* @__PURE__ */ jsx(Slider, {
        ...Object.assign({
          ref: slickRef
        }, newProps, {
          dots: enableDots,
          dotsClass: dsClass,
          arrows,
          draggable
        })
      })
    })
  );
});
const Carousel$1 = Carousel;
const antCheckboxEffect = new Keyframe("antCheckboxEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
});
const genCheckboxStyle = (token2) => {
  const {
    checkboxCls
  } = token2;
  const wrapperCls = `${checkboxCls}-wrapper`;
  return [
    {
      [`${checkboxCls}-group`]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-flex"
      }),
      [wrapperCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        [`& + ${wrapperCls}`]: {
          marginInlineStart: token2.marginXS
        },
        [`&${wrapperCls}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            height: 14
          }
        }
      }),
      [checkboxCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        top: "0.2em",
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        [`${checkboxCls}-input`]: {
          position: "absolute",
          inset: 0,
          zIndex: 1,
          width: "100%",
          height: "100%",
          cursor: "pointer",
          opacity: 0,
          [`&:focus-visible + ${checkboxCls}-inner`]: Object.assign({}, genFocusOutline(token2))
        },
        [`${checkboxCls}-inner`]: {
          boxSizing: "border-box",
          position: "relative",
          top: 0,
          insetInlineStart: 0,
          display: "block",
          width: token2.checkboxSize,
          height: token2.checkboxSize,
          direction: "ltr",
          backgroundColor: token2.colorBgContainer,
          border: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`,
          borderRadius: token2.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${token2.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: token2.checkboxSize / 14 * 5,
            height: token2.checkboxSize / 14 * 8,
            border: `${token2.lineWidthBold}px solid ${token2.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${token2.motionDurationFast} ${token2.motionEaseInBack}, opacity ${token2.motionDurationFast}`
          }
        },
        "& + span": {
          paddingInlineStart: token2.paddingXS,
          paddingInlineEnd: token2.paddingXS
        }
      })
    },
    {
      [checkboxCls]: {
        "&-indeterminate": {
          [`${checkboxCls}-inner`]: {
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: token2.fontSizeLG / 2,
              height: token2.fontSizeLG / 2,
              backgroundColor: token2.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          }
        }
      }
    },
    {
      [`${wrapperCls}:hover ${checkboxCls}:after`]: {
        visibility: "visible"
      },
      [`
        ${wrapperCls}:not(${wrapperCls}-disabled),
        ${checkboxCls}:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          borderColor: token2.colorPrimary
        }
      },
      [`${wrapperCls}:not(${wrapperCls}-disabled)`]: {
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled) ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}-checked:not(${checkboxCls}-disabled):after`]: {
          borderColor: token2.colorPrimaryHover
        }
      }
    },
    {
      [`${checkboxCls}-checked`]: {
        [`${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimary,
          borderColor: token2.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${token2.motionDurationMid} ${token2.motionEaseOutBack} ${token2.motionDurationFast}`
          }
        },
        "&:after": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          borderRadius: token2.borderRadiusSM,
          visibility: "hidden",
          border: `${token2.lineWidthBold}px solid ${token2.colorPrimary}`,
          animationName: antCheckboxEffect,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: "ease-in-out",
          animationFillMode: "backwards",
          content: '""',
          transition: `all ${token2.motionDurationSlow}`
        }
      },
      [`
        ${wrapperCls}-checked:not(${wrapperCls}-disabled),
        ${checkboxCls}-checked:not(${checkboxCls}-disabled)
      `]: {
        [`&:hover ${checkboxCls}-inner`]: {
          backgroundColor: token2.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${checkboxCls}:after`]: {
          borderColor: token2.colorPrimaryHover
        }
      }
    },
    {
      [`${wrapperCls}-disabled`]: {
        cursor: "not-allowed"
      },
      [`${checkboxCls}-disabled`]: {
        [`&, ${checkboxCls}-input`]: {
          cursor: "not-allowed",
          pointerEvents: "none"
        },
        [`${checkboxCls}-inner`]: {
          background: token2.colorBgContainerDisabled,
          borderColor: token2.colorBorder,
          "&:after": {
            borderColor: token2.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: token2.colorTextDisabled
        },
        [`&${checkboxCls}-indeterminate ${checkboxCls}-inner::after`]: {
          background: token2.colorTextDisabled
        }
      }
    }
  ];
};
function getStyle(prefixCls, token2) {
  const checkboxToken = merge(token2, {
    checkboxCls: `.${prefixCls}`,
    checkboxSize: token2.controlInteractiveSize
  });
  return [genCheckboxStyle(checkboxToken)];
}
const useStyle$7 = genComponentStyleHook("Checkbox", (token2, _ref) => {
  let {
    prefixCls
  } = _ref;
  return [getStyle(prefixCls, token2)];
});
var __rest$o = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const GroupContext = /* @__PURE__ */ react.exports.createContext(null);
const InternalCheckboxGroup = (_a, ref) => {
  var {
    defaultValue,
    children,
    options = [],
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    style: style2,
    onChange: onChange2
  } = _a, restProps = __rest$o(_a, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const [value, setValue2] = react.exports.useState(restProps.value || defaultValue || []);
  const [registeredValues, setRegisteredValues] = react.exports.useState([]);
  react.exports.useEffect(() => {
    if ("value" in restProps) {
      setValue2(restProps.value || []);
    }
  }, [restProps.value]);
  const getOptions = () => options.map((option) => {
    if (typeof option === "string" || typeof option === "number") {
      return {
        label: option,
        value: option
      };
    }
    return option;
  });
  const cancelValue = (val) => {
    setRegisteredValues((prevValues) => prevValues.filter((v2) => v2 !== val));
  };
  const registerValue = (val) => {
    setRegisteredValues((prevValues) => [].concat(_toConsumableArray(prevValues), [val]));
  };
  const toggleOption = (option) => {
    const optionIndex = value.indexOf(option.value);
    const newValue = _toConsumableArray(value);
    if (optionIndex === -1) {
      newValue.push(option.value);
    } else {
      newValue.splice(optionIndex, 1);
    }
    if (!("value" in restProps)) {
      setValue2(newValue);
    }
    const opts = getOptions();
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(newValue.filter((val) => registeredValues.includes(val)).sort((a2, b2) => {
      const indexA = opts.findIndex((opt) => opt.value === a2);
      const indexB = opts.findIndex((opt) => opt.value === b2);
      return indexA - indexB;
    }));
  };
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  const groupPrefixCls = `${prefixCls}-group`;
  const [wrapSSR, hashId] = useStyle$7(prefixCls);
  const domProps = omit(restProps, ["value", "disabled"]);
  if (options && options.length > 0) {
    children = getOptions().map((option) => /* @__PURE__ */ jsx(InternalCheckbox$1, {
      prefixCls,
      disabled: "disabled" in option ? option.disabled : restProps.disabled,
      value: option.value,
      checked: value.includes(option.value),
      onChange: option.onChange,
      className: `${groupPrefixCls}-item`,
      style: option.style,
      children: option.label
    }, option.value.toString()));
  }
  const context = {
    toggleOption,
    value,
    disabled: restProps.disabled,
    name: restProps.name,
    registerValue,
    cancelValue
  };
  const classString = classNames(groupPrefixCls, {
    [`${groupPrefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      ...Object.assign({
        className: classString,
        style: style2
      }, domProps, {
        ref
      }),
      children: /* @__PURE__ */ jsx(GroupContext.Provider, {
        value: context,
        children
      })
    })
  );
};
const CheckboxGroup = /* @__PURE__ */ react.exports.forwardRef(InternalCheckboxGroup);
const Group$2 = /* @__PURE__ */ react.exports.memo(CheckboxGroup);
var __rest$n = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const InternalCheckbox = (_a, ref) => {
  var _b;
  var {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    children,
    indeterminate = false,
    style: style2,
    onMouseEnter,
    onMouseLeave,
    skipGroup = false,
    disabled
  } = _a, restProps = __rest$n(_a, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const checkboxGroup = react.exports.useContext(GroupContext);
  const {
    isFormItemInput
  } = react.exports.useContext(FormItemInputContext);
  const contextDisabled = react.exports.useContext(DisabledContext);
  const mergedDisabled = (_b = (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.disabled) || disabled) !== null && _b !== void 0 ? _b : contextDisabled;
  const prevValue = react.exports.useRef(restProps.value);
  react.exports.useEffect(() => {
    checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
  }, []);
  react.exports.useEffect(() => {
    if (skipGroup) {
      return;
    }
    if (restProps.value !== prevValue.current) {
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(prevValue.current);
      checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.registerValue(restProps.value);
      prevValue.current = restProps.value;
    }
    return () => checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.cancelValue(restProps.value);
  }, [restProps.value]);
  const prefixCls = getPrefixCls("checkbox", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$7(prefixCls);
  const checkboxProps = Object.assign({}, restProps);
  if (checkboxGroup && !skipGroup) {
    checkboxProps.onChange = function() {
      if (restProps.onChange) {
        restProps.onChange.apply(restProps, arguments);
      }
      if (checkboxGroup.toggleOption) {
        checkboxGroup.toggleOption({
          label: children,
          value: restProps.value
        });
      }
    };
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.includes(restProps.value);
  }
  const classString = classNames({
    [`${prefixCls}-wrapper`]: true,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-wrapper-checked`]: checkboxProps.checked,
    [`${prefixCls}-wrapper-disabled`]: mergedDisabled,
    [`${prefixCls}-wrapper-in-form-item`]: isFormItemInput
  }, className, rootClassName, hashId);
  const checkboxClass = classNames({
    [`${prefixCls}-indeterminate`]: indeterminate
  }, hashId);
  const ariaChecked = indeterminate ? "mixed" : void 0;
  return wrapSSR(
    /* @__PURE__ */ jsxs("label", {
      className: classString,
      style: style2,
      onMouseEnter,
      onMouseLeave,
      children: [/* @__PURE__ */ jsx(Checkbox$3, {
        ...Object.assign({
          "aria-checked": ariaChecked
        }, checkboxProps, {
          prefixCls,
          className: checkboxClass,
          disabled: mergedDisabled,
          ref
        })
      }), children !== void 0 && /* @__PURE__ */ jsx("span", {
        children
      })]
    })
  );
};
const Checkbox$2 = /* @__PURE__ */ react.exports.forwardRef(InternalCheckbox);
const InternalCheckbox$1 = Checkbox$2;
const Checkbox = InternalCheckbox$1;
Checkbox.Group = Group$2;
Checkbox.__ANT_CHECKBOX = true;
const Checkbox$1 = Checkbox;
const RowContext = /* @__PURE__ */ react.exports.createContext({});
const RowContext$1 = RowContext;
const genGridRowStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      "&-start": {
        justifyContent: "flex-start"
      },
      "&-center": {
        justifyContent: "center"
      },
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around ": {
        justifyContent: "space-around"
      },
      "&-top": {
        alignItems: "flex-start"
      },
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
};
const genGridColStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [componentCls]: {
      position: "relative",
      maxWidth: "100%",
      minHeight: 1
    }
  };
};
const genLoopGridColumnsStyle = (token2, sizeCls) => {
  const {
    componentCls,
    gridColumns
  } = token2;
  const gridColumnsStyle = {};
  for (let i2 = gridColumns; i2 >= 0; i2--) {
    if (i2 === 0) {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
        display: "none"
      };
      gridColumnsStyle[`${componentCls}-push-${i2}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}-pull-${i2}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
        insetInlineStart: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
        insetInlineEnd: "auto"
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
        marginInlineEnd: 0
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
        order: 0
      };
    } else {
      gridColumnsStyle[`${componentCls}${sizeCls}-${i2}`] = {
        display: "block",
        flex: `0 0 ${i2 / gridColumns * 100}%`,
        maxWidth: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-push-${i2}`] = {
        insetInlineStart: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-pull-${i2}`] = {
        insetInlineEnd: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-offset-${i2}`] = {
        marginInlineStart: `${i2 / gridColumns * 100}%`
      };
      gridColumnsStyle[`${componentCls}${sizeCls}-order-${i2}`] = {
        order: i2
      };
    }
  }
  return gridColumnsStyle;
};
const genGridStyle = (token2, sizeCls) => genLoopGridColumnsStyle(token2, sizeCls);
const genGridMediaStyle = (token2, screenSize, sizeCls) => ({
  [`@media (min-width: ${screenSize}px)`]: Object.assign({}, genGridStyle(token2, sizeCls))
});
const useRowStyle = genComponentStyleHook("Grid", (token2) => [genGridRowStyle(token2)]);
const useColStyle = genComponentStyleHook("Grid", (token2) => {
  const gridToken = merge(token2, {
    gridColumns: 24
  });
  const gridMediaSizesMap = {
    "-sm": gridToken.screenSMMin,
    "-md": gridToken.screenMDMin,
    "-lg": gridToken.screenLGMin,
    "-xl": gridToken.screenXLMin,
    "-xxl": gridToken.screenXXLMin
  };
  return [genGridColStyle(gridToken), genGridStyle(gridToken, ""), genGridStyle(gridToken, "-xs"), Object.keys(gridMediaSizesMap).map((key) => genGridMediaStyle(gridToken, gridMediaSizesMap[key], key)).reduce((pre, cur) => Object.assign(Object.assign({}, pre), cur), {})];
});
var __rest$m = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function parseFlex(flex) {
  if (typeof flex === "number") {
    return `${flex} ${flex} auto`;
  }
  if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(flex)) {
    return `0 0 ${flex}`;
  }
  return flex;
}
const sizes = ["xs", "sm", "md", "lg", "xl", "xxl"];
const Col = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const {
    gutter,
    wrap: wrap2,
    supportFlexGap
  } = react.exports.useContext(RowContext$1);
  const {
    prefixCls: customizePrefixCls,
    span,
    order,
    offset: offset2,
    push,
    pull,
    className,
    children,
    flex,
    style: style2
  } = props, others = __rest$m(props, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]);
  const prefixCls = getPrefixCls("col", customizePrefixCls);
  const [wrapSSR, hashId] = useColStyle(prefixCls);
  let sizeClassObj = {};
  sizes.forEach((size) => {
    let sizeProps = {};
    const propSize = props[size];
    if (typeof propSize === "number") {
      sizeProps.span = propSize;
    } else if (typeof propSize === "object") {
      sizeProps = propSize || {};
    }
    delete others[size];
    sizeClassObj = Object.assign(Object.assign({}, sizeClassObj), {
      [`${prefixCls}-${size}-${sizeProps.span}`]: sizeProps.span !== void 0,
      [`${prefixCls}-${size}-order-${sizeProps.order}`]: sizeProps.order || sizeProps.order === 0,
      [`${prefixCls}-${size}-offset-${sizeProps.offset}`]: sizeProps.offset || sizeProps.offset === 0,
      [`${prefixCls}-${size}-push-${sizeProps.push}`]: sizeProps.push || sizeProps.push === 0,
      [`${prefixCls}-${size}-pull-${sizeProps.pull}`]: sizeProps.pull || sizeProps.pull === 0,
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
  });
  const classes = classNames(prefixCls, {
    [`${prefixCls}-${span}`]: span !== void 0,
    [`${prefixCls}-order-${order}`]: order,
    [`${prefixCls}-offset-${offset2}`]: offset2,
    [`${prefixCls}-push-${push}`]: push,
    [`${prefixCls}-pull-${pull}`]: pull
  }, className, sizeClassObj, hashId);
  const mergedStyle = {};
  if (gutter && gutter[0] > 0) {
    const horizontalGutter = gutter[0] / 2;
    mergedStyle.paddingLeft = horizontalGutter;
    mergedStyle.paddingRight = horizontalGutter;
  }
  if (gutter && gutter[1] > 0 && !supportFlexGap) {
    const verticalGutter = gutter[1] / 2;
    mergedStyle.paddingTop = verticalGutter;
    mergedStyle.paddingBottom = verticalGutter;
  }
  if (flex) {
    mergedStyle.flex = parseFlex(flex);
    if (wrap2 === false && !mergedStyle.minWidth) {
      mergedStyle.minWidth = 0;
    }
  }
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      ...Object.assign({}, others, {
        style: Object.assign(Object.assign({}, mergedStyle), style2),
        className: classes,
        ref
      }),
      children
    })
  );
});
const Col$1 = Col;
var __rest$l = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function useMergePropByScreen(oriProp, screen) {
  const [prop, setProp] = react.exports.useState(typeof oriProp === "string" ? oriProp : "");
  const calcMergeAlignOrJustify = () => {
    if (typeof oriProp === "string") {
      setProp(oriProp);
    }
    if (typeof oriProp !== "object") {
      return;
    }
    for (let i2 = 0; i2 < responsiveArray.length; i2++) {
      const breakpoint = responsiveArray[i2];
      if (!screen[breakpoint])
        continue;
      const curVal = oriProp[breakpoint];
      if (curVal !== void 0) {
        setProp(curVal);
        return;
      }
    }
  };
  react.exports.useEffect(() => {
    calcMergeAlignOrJustify();
  }, [JSON.stringify(oriProp), screen]);
  return prop;
}
const Row = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    justify,
    align,
    className,
    style: style2,
    children,
    gutter = 0,
    wrap: wrap2
  } = props, others = __rest$l(props, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const [screens, setScreens] = react.exports.useState({
    xs: true,
    sm: true,
    md: true,
    lg: true,
    xl: true,
    xxl: true
  });
  const [curScreens, setCurScreens] = react.exports.useState({
    xs: false,
    sm: false,
    md: false,
    lg: false,
    xl: false,
    xxl: false
  });
  const mergeAlign = useMergePropByScreen(align, curScreens);
  const mergeJustify = useMergePropByScreen(justify, curScreens);
  const supportFlexGap = useFlexGapSupport();
  const gutterRef = react.exports.useRef(gutter);
  const responsiveObserver = useResponsiveObserver();
  react.exports.useEffect(() => {
    const token2 = responsiveObserver.subscribe((screen) => {
      setCurScreens(screen);
      const currentGutter = gutterRef.current || 0;
      if (!Array.isArray(currentGutter) && typeof currentGutter === "object" || Array.isArray(currentGutter) && (typeof currentGutter[0] === "object" || typeof currentGutter[1] === "object")) {
        setScreens(screen);
      }
    });
    return () => responsiveObserver.unsubscribe(token2);
  }, []);
  const getGutter = () => {
    const results = [void 0, void 0];
    const normalizedGutter = Array.isArray(gutter) ? gutter : [gutter, void 0];
    normalizedGutter.forEach((g2, index2) => {
      if (typeof g2 === "object") {
        for (let i2 = 0; i2 < responsiveArray.length; i2++) {
          const breakpoint = responsiveArray[i2];
          if (screens[breakpoint] && g2[breakpoint] !== void 0) {
            results[index2] = g2[breakpoint];
            break;
          }
        }
      } else {
        results[index2] = g2;
      }
    });
    return results;
  };
  const prefixCls = getPrefixCls("row", customizePrefixCls);
  const [wrapSSR, hashId] = useRowStyle(prefixCls);
  const gutters = getGutter();
  const classes = classNames(prefixCls, {
    [`${prefixCls}-no-wrap`]: wrap2 === false,
    [`${prefixCls}-${mergeJustify}`]: mergeJustify,
    [`${prefixCls}-${mergeAlign}`]: mergeAlign,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, hashId);
  const rowStyle = {};
  const horizontalGutter = gutters[0] != null && gutters[0] > 0 ? gutters[0] / -2 : void 0;
  const verticalGutter = gutters[1] != null && gutters[1] > 0 ? gutters[1] / -2 : void 0;
  if (horizontalGutter) {
    rowStyle.marginLeft = horizontalGutter;
    rowStyle.marginRight = horizontalGutter;
  }
  if (supportFlexGap) {
    [, rowStyle.rowGap] = gutters;
  } else if (verticalGutter) {
    rowStyle.marginTop = verticalGutter;
    rowStyle.marginBottom = verticalGutter;
  }
  const [gutterH, gutterV] = gutters;
  const rowContext = react.exports.useMemo(() => ({
    gutter: [gutterH, gutterV],
    wrap: wrap2,
    supportFlexGap
  }), [gutterH, gutterV, wrap2, supportFlexGap]);
  return wrapSSR(
    /* @__PURE__ */ jsx(RowContext$1.Provider, {
      value: rowContext,
      children: /* @__PURE__ */ jsx("div", {
        ...Object.assign({}, others, {
          className: classes,
          style: Object.assign(Object.assign({}, rowStyle), style2),
          ref
        }),
        children
      })
    })
  );
});
const Row$1 = Row;
const genSharedDividerStyle = (token2) => {
  const {
    componentCls,
    sizePaddingEdgeHorizontal,
    colorSplit,
    lineWidth
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      borderBlockStart: `${lineWidth}px solid ${colorSplit}`,
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        margin: `0 ${token2.dividerVerticalGutterMargin}px`,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${lineWidth}px solid ${colorSplit}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        margin: `${token2.dividerHorizontalGutterMargin}px 0`
      },
      [`&-horizontal${componentCls}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${token2.dividerHorizontalWithTextGutterMargin}px 0`,
        color: token2.colorTextHeading,
        fontWeight: 500,
        fontSize: token2.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${colorSplit}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${lineWidth}px solid transparent`,
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${componentCls}-with-text-left`]: {
        "&::before": {
          width: "5%"
        },
        "&::after": {
          width: "95%"
        }
      },
      [`&-horizontal${componentCls}-with-text-right`]: {
        "&::before": {
          width: "95%"
        },
        "&::after": {
          width: "5%"
        }
      },
      [`${componentCls}-inner-text`]: {
        display: "inline-block",
        padding: "0 1em"
      },
      "&-dashed": {
        background: "none",
        borderColor: colorSplit,
        borderStyle: "dashed",
        borderWidth: `${lineWidth}px 0 0`
      },
      [`&-horizontal${componentCls}-with-text${componentCls}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${componentCls}-dashed`]: {
        borderInlineStart: lineWidth,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${componentCls}-with-text`]: {
        color: token2.colorText,
        fontWeight: "normal",
        fontSize: token2.fontSize
      },
      [`&-horizontal${componentCls}-with-text-left${componentCls}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineStart: sizePaddingEdgeHorizontal
        }
      },
      [`&-horizontal${componentCls}-with-text-right${componentCls}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${componentCls}-inner-text`]: {
          paddingInlineEnd: sizePaddingEdgeHorizontal
        }
      }
    })
  };
};
const useStyle$6 = genComponentStyleHook("Divider", (token2) => {
  const dividerToken = merge(token2, {
    dividerVerticalGutterMargin: token2.marginXS,
    dividerHorizontalWithTextGutterMargin: token2.margin,
    dividerHorizontalGutterMargin: token2.marginLG
  });
  return [genSharedDividerStyle(dividerToken)];
}, {
  sizePaddingEdgeHorizontal: 0
});
var __rest$k = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Divider = (props) => {
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    type: type4 = "horizontal",
    orientation = "center",
    orientationMargin,
    className,
    rootClassName,
    children,
    dashed,
    plain
  } = props, restProps = __rest$k(props, ["prefixCls", "type", "orientation", "orientationMargin", "className", "rootClassName", "children", "dashed", "plain"]);
  const prefixCls = getPrefixCls("divider", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$6(prefixCls);
  const orientationPrefix = orientation.length > 0 ? `-${orientation}` : orientation;
  const hasChildren = !!children;
  const hasCustomMarginLeft = orientation === "left" && orientationMargin != null;
  const hasCustomMarginRight = orientation === "right" && orientationMargin != null;
  const classString = classNames(prefixCls, hashId, `${prefixCls}-${type4}`, {
    [`${prefixCls}-with-text`]: hasChildren,
    [`${prefixCls}-with-text${orientationPrefix}`]: hasChildren,
    [`${prefixCls}-dashed`]: !!dashed,
    [`${prefixCls}-plain`]: !!plain,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-no-default-orientation-margin-left`]: hasCustomMarginLeft,
    [`${prefixCls}-no-default-orientation-margin-right`]: hasCustomMarginRight
  }, className, rootClassName);
  const innerStyle = Object.assign(Object.assign({}, hasCustomMarginLeft && {
    marginLeft: orientationMargin
  }), hasCustomMarginRight && {
    marginRight: orientationMargin
  });
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      ...Object.assign({
        className: classString
      }, restProps, {
        role: "separator"
      }),
      children: children && type4 !== "vertical" && /* @__PURE__ */ jsx("span", {
        className: `${prefixCls}-inner-text`,
        style: innerStyle,
        children
      })
    })
  );
};
const Divider$1 = Divider;
var OrderContext = /* @__PURE__ */ react.exports.createContext(null);
var EMPTY_LIST$1 = [];
function useDom(render2, debug) {
  var _React$useState = react.exports.useState(function() {
    if (!canUseDom()) {
      return null;
    }
    var defaultEle = document.createElement("div");
    return defaultEle;
  }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
  var appendedRef = react.exports.useRef(false);
  var queueCreate = react.exports.useContext(OrderContext);
  var _React$useState3 = react.exports.useState(EMPTY_LIST$1), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
  var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
    setQueue(function(origin) {
      var newQueue = [appendFn].concat(_toConsumableArray(origin));
      return newQueue;
    });
  });
  function append3() {
    if (!ele.parentElement) {
      document.body.appendChild(ele);
    }
    appendedRef.current = true;
  }
  function cleanup2() {
    var _ele$parentElement;
    (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
    appendedRef.current = false;
  }
  useLayoutEffect(function() {
    if (render2) {
      if (queueCreate) {
        queueCreate(append3);
      } else {
        append3();
      }
    } else {
      cleanup2();
    }
    return cleanup2;
  }, [render2]);
  useLayoutEffect(function() {
    if (queue.length) {
      queue.forEach(function(appendFn) {
        return appendFn();
      });
      setQueue(EMPTY_LIST$1);
    }
  }, [queue]);
  return [ele, mergedQueueCreate];
}
var cached;
function getScrollBarSize(fresh) {
  if (typeof document === "undefined") {
    return 0;
  }
  if (fresh || cached === void 0) {
    var inner = document.createElement("div");
    inner.style.width = "100%";
    inner.style.height = "200px";
    var outer = document.createElement("div");
    var outerStyle = outer.style;
    outerStyle.position = "absolute";
    outerStyle.top = "0";
    outerStyle.left = "0";
    outerStyle.pointerEvents = "none";
    outerStyle.visibility = "hidden";
    outerStyle.width = "200px";
    outerStyle.height = "150px";
    outerStyle.overflow = "hidden";
    outer.appendChild(inner);
    document.body.appendChild(outer);
    var widthContained = inner.offsetWidth;
    outer.style.overflow = "scroll";
    var widthScroll = inner.offsetWidth;
    if (widthContained === widthScroll) {
      widthScroll = outer.clientWidth;
    }
    document.body.removeChild(outer);
    cached = widthContained - widthScroll;
  }
  return cached;
}
function isBodyOverflowing() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
var uuid = 0;
function useScrollLocker(lock) {
  var mergedLock = !!lock;
  var _React$useState = react.exports.useState(function() {
    uuid += 1;
    return "".concat(UNIQUE_ID, "_").concat(uuid);
  }), _React$useState2 = _slicedToArray(_React$useState, 1), id2 = _React$useState2[0];
  useLayoutEffect(function() {
    if (mergedLock) {
      var scrollbarSize = getScrollBarSize();
      var isOverflow = isBodyOverflowing();
      updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id2);
    } else {
      removeCSS(id2);
    }
    return function() {
      removeCSS(id2);
    };
  }, [mergedLock, id2]);
}
var inline = false;
function inlineMock(nextInline) {
  if (typeof nextInline === "boolean") {
    inline = nextInline;
  }
  return inline;
}
var getPortalContainer = function getPortalContainer2(getContainer2) {
  if (getContainer2 === false) {
    return false;
  }
  if (!canUseDom() || !getContainer2) {
    return null;
  }
  if (typeof getContainer2 === "string") {
    return document.querySelector(getContainer2);
  }
  if (typeof getContainer2 === "function") {
    return getContainer2();
  }
  return getContainer2;
};
var Portal = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var open2 = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
  props.debug;
  var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
  var _React$useState = react.exports.useState(open2), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
  var mergedRender = shouldRender || open2;
  react.exports.useEffect(function() {
    if (autoDestroy || open2) {
      setShouldRender(open2);
    }
  }, [open2, autoDestroy]);
  var _React$useState3 = react.exports.useState(function() {
    return getPortalContainer(getContainer2);
  }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
  react.exports.useEffect(function() {
    var customizeContainer = getPortalContainer(getContainer2);
    setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
  });
  var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1];
  var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer;
  useScrollLocker(autoLock && open2 && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
  var childRef = null;
  if (children && supportRef(children) && ref) {
    var _ref = children;
    childRef = _ref.ref;
  }
  var mergedRef = useComposeRef(childRef, ref);
  if (!mergedRender || !canUseDom() || innerContainer === void 0) {
    return null;
  }
  var renderInline = mergedContainer === false || inlineMock();
  var reffedChildren = children;
  if (ref) {
    reffedChildren = /* @__PURE__ */ react.exports.cloneElement(children, {
      ref: mergedRef
    });
  }
  return /* @__PURE__ */ jsx(OrderContext.Provider, {
    value: queueCreate,
    children: renderInline ? reffedChildren : /* @__PURE__ */ reactDom.exports.createPortal(reffedChildren, mergedContainer)
  });
});
var DrawerPanel$1 = function DrawerPanel(props) {
  var prefixCls = props.prefixCls, className = props.className, style2 = props.style, children = props.children, containerRef = props.containerRef;
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsx("div", {
      className: classNames("".concat(prefixCls, "-content"), className),
      style: _objectSpread2$1({}, style2),
      "aria-modal": "true",
      role: "dialog",
      ref: containerRef,
      children
    })
  });
};
var DrawerContext = /* @__PURE__ */ react.exports.createContext(null);
function parseWidthHeight(value) {
  if (typeof value === "string" && String(Number(value)) === value) {
    warningOnce(false, "Invalid value type of `width` or `height` which should be number type instead.");
    return Number(value);
  }
  return value;
}
var sentinelStyle = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none",
  position: "absolute"
};
function DrawerPopup(props, ref) {
  var _ref, _pushConfig$distance, _pushConfig, _classNames;
  var prefixCls = props.prefixCls, open2 = props.open, placement = props.placement, inline2 = props.inline, push = props.push, forceRender = props.forceRender, autoFocus = props.autoFocus, keyboard = props.keyboard, rootClassName = props.rootClassName, rootStyle = props.rootStyle, zIndex = props.zIndex, className = props.className, style2 = props.style, motion2 = props.motion, width = props.width, height = props.height, children = props.children, contentWrapperStyle = props.contentWrapperStyle, mask = props.mask, maskClosable = props.maskClosable, maskMotion = props.maskMotion, maskClassName = props.maskClassName, maskStyle = props.maskStyle, afterOpenChange = props.afterOpenChange, onClose = props.onClose;
  var panelRef = react.exports.useRef();
  var sentinelStartRef = react.exports.useRef();
  var sentinelEndRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return panelRef.current;
  });
  var onPanelKeyDown = function onPanelKeyDown2(event) {
    var keyCode = event.keyCode, shiftKey = event.shiftKey;
    switch (keyCode) {
      case KeyCode.TAB: {
        if (keyCode === KeyCode.TAB) {
          if (!shiftKey && document.activeElement === sentinelEndRef.current) {
            var _sentinelStartRef$cur;
            (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus({
              preventScroll: true
            });
          } else if (shiftKey && document.activeElement === sentinelStartRef.current) {
            var _sentinelEndRef$curre;
            (_sentinelEndRef$curre = sentinelEndRef.current) === null || _sentinelEndRef$curre === void 0 ? void 0 : _sentinelEndRef$curre.focus({
              preventScroll: true
            });
          }
        }
        break;
      }
      case KeyCode.ESC: {
        if (onClose && keyboard) {
          event.stopPropagation();
          onClose(event);
        }
        break;
      }
    }
  };
  react.exports.useEffect(function() {
    if (open2 && autoFocus) {
      var _panelRef$current;
      (_panelRef$current = panelRef.current) === null || _panelRef$current === void 0 ? void 0 : _panelRef$current.focus({
        preventScroll: true
      });
    }
  }, [open2]);
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), pushed = _React$useState2[0], setPushed = _React$useState2[1];
  var parentContext = react.exports.useContext(DrawerContext);
  var pushConfig;
  if (push === false) {
    pushConfig = {
      distance: 0
    };
  } else if (push === true) {
    pushConfig = {};
  } else {
    pushConfig = push || {};
  }
  var pushDistance = (_ref = (_pushConfig$distance = (_pushConfig = pushConfig) === null || _pushConfig === void 0 ? void 0 : _pushConfig.distance) !== null && _pushConfig$distance !== void 0 ? _pushConfig$distance : parentContext === null || parentContext === void 0 ? void 0 : parentContext.pushDistance) !== null && _ref !== void 0 ? _ref : 180;
  var mergedContext = react.exports.useMemo(function() {
    return {
      pushDistance,
      push: function push2() {
        setPushed(true);
      },
      pull: function pull() {
        setPushed(false);
      }
    };
  }, [pushDistance]);
  react.exports.useEffect(function() {
    if (open2) {
      var _parentContext$push;
      parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$push = parentContext.push) === null || _parentContext$push === void 0 ? void 0 : _parentContext$push.call(parentContext);
    } else {
      var _parentContext$pull;
      parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$pull = parentContext.pull) === null || _parentContext$pull === void 0 ? void 0 : _parentContext$pull.call(parentContext);
    }
  }, [open2]);
  react.exports.useEffect(function() {
    return function() {
      var _parentContext$pull2;
      parentContext === null || parentContext === void 0 ? void 0 : (_parentContext$pull2 = parentContext.pull) === null || _parentContext$pull2 === void 0 ? void 0 : _parentContext$pull2.call(parentContext);
    };
  }, []);
  var maskNode = mask && /* @__PURE__ */ jsx(CSSMotion, {
    ...maskMotion,
    visible: open2,
    children: function(_ref2, maskRef) {
      var motionMaskClassName = _ref2.className, motionMaskStyle = _ref2.style;
      return /* @__PURE__ */ jsx("div", {
        className: classNames("".concat(prefixCls, "-mask"), motionMaskClassName, maskClassName),
        style: _objectSpread2$1(_objectSpread2$1({}, motionMaskStyle), maskStyle),
        onClick: maskClosable && open2 ? onClose : void 0,
        ref: maskRef
      });
    }
  }, "mask");
  var motionProps = typeof motion2 === "function" ? motion2(placement) : motion2;
  var wrapperStyle = {};
  if (pushed && pushDistance) {
    switch (placement) {
      case "top":
        wrapperStyle.transform = "translateY(".concat(pushDistance, "px)");
        break;
      case "bottom":
        wrapperStyle.transform = "translateY(".concat(-pushDistance, "px)");
        break;
      case "left":
        wrapperStyle.transform = "translateX(".concat(pushDistance, "px)");
        break;
      default:
        wrapperStyle.transform = "translateX(".concat(-pushDistance, "px)");
        break;
    }
  }
  if (placement === "left" || placement === "right") {
    wrapperStyle.width = parseWidthHeight(width);
  } else {
    wrapperStyle.height = parseWidthHeight(height);
  }
  var panelNode = /* @__PURE__ */ jsx(CSSMotion, {
    ...motionProps,
    visible: open2,
    forceRender,
    onVisibleChanged: function onVisibleChanged(nextVisible) {
      afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(nextVisible);
    },
    removeOnLeave: false,
    leavedClassName: "".concat(prefixCls, "-content-wrapper-hidden"),
    children: function(_ref3, motionRef) {
      var motionClassName = _ref3.className, motionStyle = _ref3.style;
      return /* @__PURE__ */ jsx("div", {
        className: classNames("".concat(prefixCls, "-content-wrapper"), motionClassName),
        style: _objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, wrapperStyle), motionStyle), contentWrapperStyle),
        children: /* @__PURE__ */ jsx(DrawerPanel$1, {
          containerRef: motionRef,
          prefixCls,
          className,
          style: style2,
          children
        })
      });
    }
  }, "panel");
  var containerStyle = _objectSpread2$1({}, rootStyle);
  if (zIndex) {
    containerStyle.zIndex = zIndex;
  }
  return /* @__PURE__ */ jsx(DrawerContext.Provider, {
    value: mergedContext,
    children: /* @__PURE__ */ jsxs("div", {
      className: classNames(prefixCls, "".concat(prefixCls, "-").concat(placement), rootClassName, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-open"), open2), _defineProperty$1(_classNames, "".concat(prefixCls, "-inline"), inline2), _classNames)),
      style: containerStyle,
      tabIndex: -1,
      ref: panelRef,
      onKeyDown: onPanelKeyDown,
      children: [maskNode, /* @__PURE__ */ jsx("div", {
        tabIndex: 0,
        ref: sentinelStartRef,
        style: sentinelStyle,
        "aria-hidden": "true",
        "data-sentinel": "start"
      }), panelNode, /* @__PURE__ */ jsx("div", {
        tabIndex: 0,
        ref: sentinelEndRef,
        style: sentinelStyle,
        "aria-hidden": "true",
        "data-sentinel": "end"
      })]
    })
  });
}
var RefDrawerPopup = /* @__PURE__ */ react.exports.forwardRef(DrawerPopup);
var Drawer$1 = function Drawer(props) {
  var _props$open = props.open, open2 = _props$open === void 0 ? false : _props$open, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-drawer" : _props$prefixCls, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$autoFocus = props.autoFocus, autoFocus = _props$autoFocus === void 0 ? true : _props$autoFocus, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$width = props.width, width = _props$width === void 0 ? 378 : _props$width, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getContainer2 = props.getContainer, forceRender = props.forceRender, afterOpenChange = props.afterOpenChange, destroyOnClose = props.destroyOnClose;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
  var panelRef = react.exports.useRef();
  var lastActiveRef = react.exports.useRef();
  useLayoutEffect(function() {
    if (open2) {
      lastActiveRef.current = document.activeElement;
    }
  }, [open2]);
  var internalAfterOpenChange = function internalAfterOpenChange2(nextVisible) {
    var _panelRef$current;
    setAnimatedVisible(nextVisible);
    afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(nextVisible);
    if (!nextVisible && lastActiveRef.current && !((_panelRef$current = panelRef.current) === null || _panelRef$current === void 0 ? void 0 : _panelRef$current.contains(lastActiveRef.current))) {
      var _lastActiveRef$curren;
      (_lastActiveRef$curren = lastActiveRef.current) === null || _lastActiveRef$curren === void 0 ? void 0 : _lastActiveRef$curren.focus();
    }
  };
  if (!forceRender && !animatedVisible && !open2 && destroyOnClose) {
    return null;
  }
  var drawerPopupProps = _objectSpread2$1(_objectSpread2$1({}, props), {}, {
    open: open2,
    prefixCls,
    placement,
    autoFocus,
    keyboard,
    width,
    mask,
    maskClosable,
    inline: getContainer2 === false,
    afterOpenChange: internalAfterOpenChange,
    ref: panelRef
  });
  return /* @__PURE__ */ jsx(Portal, {
    open: open2 || forceRender || animatedVisible,
    autoDestroy: false,
    getContainer: getContainer2,
    autoLock: mask && (open2 || animatedVisible),
    children: /* @__PURE__ */ jsx(RefDrawerPopup, {
      ...drawerPopupProps
    })
  });
};
function DrawerPanel2(props) {
  const {
    prefixCls,
    title,
    footer,
    extra,
    closable = true,
    closeIcon = /* @__PURE__ */ jsx(CloseOutlined$1, {}),
    onClose,
    headerStyle,
    drawerStyle,
    bodyStyle,
    footerStyle,
    children
  } = props;
  const closeIconNode = closable && /* @__PURE__ */ jsx("button", {
    type: "button",
    onClick: onClose,
    "aria-label": "Close",
    className: `${prefixCls}-close`,
    children: closeIcon
  });
  function renderHeader() {
    if (!title && !closable) {
      return null;
    }
    return /* @__PURE__ */ jsxs("div", {
      className: classNames(`${prefixCls}-header`, {
        [`${prefixCls}-header-close-only`]: closable && !title && !extra
      }),
      style: headerStyle,
      children: [/* @__PURE__ */ jsxs("div", {
        className: `${prefixCls}-header-title`,
        children: [closeIconNode, title && /* @__PURE__ */ jsx("div", {
          className: `${prefixCls}-title`,
          children: title
        })]
      }), extra && /* @__PURE__ */ jsx("div", {
        className: `${prefixCls}-extra`,
        children: extra
      })]
    });
  }
  function renderFooter() {
    if (!footer) {
      return null;
    }
    const footerClassName = `${prefixCls}-footer`;
    return /* @__PURE__ */ jsx("div", {
      className: footerClassName,
      style: footerStyle,
      children: footer
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    className: `${prefixCls}-wrapper-body`,
    style: Object.assign({}, drawerStyle),
    children: [renderHeader(), /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-body`,
      style: bodyStyle,
      children
    }), renderFooter()]
  });
}
const genMotionStyle = (token2) => {
  const {
    componentCls,
    motionDurationSlow
  } = token2;
  const sharedPanelMotion = {
    "&-enter, &-appear, &-leave": {
      "&-start": {
        transition: "none"
      },
      "&-active": {
        transition: `all ${motionDurationSlow}`
      }
    }
  };
  return {
    [componentCls]: {
      [`${componentCls}-mask-motion`]: {
        "&-enter, &-appear, &-leave": {
          "&-active": {
            transition: `all ${motionDurationSlow}`
          }
        },
        "&-enter, &-appear": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        }
      },
      [`${componentCls}-panel-motion`]: {
        "&-left": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(-100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(-100%)"
            }
          }
        }],
        "&-right": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(100%)"
            }
          }
        }],
        "&-top": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(-100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(-100%)"
            }
          }
        }],
        "&-bottom": [sharedPanelMotion, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(100%)"
            }
          }
        }]
      }
    }
  };
};
const genMotionStyle$1 = genMotionStyle;
const genDrawerStyle = (token2) => {
  const {
    componentCls,
    zIndexPopup,
    colorBgMask,
    colorBgElevated,
    motionDurationSlow,
    motionDurationMid,
    padding,
    paddingLG,
    fontSizeLG,
    lineHeightLG,
    lineWidth,
    lineType,
    colorSplit,
    marginSM,
    colorIcon,
    colorIconHover,
    colorText,
    fontWeightStrong,
    drawerFooterPaddingVertical,
    drawerFooterPaddingHorizontal
  } = token2;
  const wrapperCls = `${componentCls}-content-wrapper`;
  return {
    [componentCls]: {
      position: "fixed",
      inset: 0,
      zIndex: zIndexPopup,
      pointerEvents: "none",
      "&-pure": {
        position: "relative",
        background: colorBgElevated,
        [`&${componentCls}-left`]: {
          boxShadow: token2.boxShadowDrawerLeft
        },
        [`&${componentCls}-right`]: {
          boxShadow: token2.boxShadowDrawerRight
        },
        [`&${componentCls}-top`]: {
          boxShadow: token2.boxShadowDrawerUp
        },
        [`&${componentCls}-bottom`]: {
          boxShadow: token2.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      [`${componentCls}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: zIndexPopup,
        background: colorBgMask,
        pointerEvents: "auto"
      },
      [wrapperCls]: {
        position: "absolute",
        zIndex: zIndexPopup,
        transition: `all ${motionDurationSlow}`,
        "&-hidden": {
          display: "none"
        }
      },
      [`&-left > ${wrapperCls}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: true,
          value: 0
        },
        boxShadow: token2.boxShadowDrawerLeft
      },
      [`&-right > ${wrapperCls}`]: {
        top: 0,
        right: {
          _skip_check_: true,
          value: 0
        },
        bottom: 0,
        boxShadow: token2.boxShadowDrawerRight
      },
      [`&-top > ${wrapperCls}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerUp
      },
      [`&-bottom > ${wrapperCls}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: token2.boxShadowDrawerDown
      },
      [`${componentCls}-content`]: {
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: colorBgElevated,
        pointerEvents: "auto"
      },
      [`${componentCls}-wrapper-body`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%"
      },
      [`${componentCls}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${padding}px ${paddingLG}px`,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG,
        borderBottom: `${lineWidth}px ${lineType} ${colorSplit}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${componentCls}-extra`]: {
        flex: "none"
      },
      [`${componentCls}-close`]: {
        display: "inline-block",
        marginInlineEnd: marginSM,
        color: colorIcon,
        fontWeight: fontWeightStrong,
        fontSize: fontSizeLG,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        outline: 0,
        cursor: "pointer",
        transition: `color ${motionDurationMid}`,
        textRendering: "auto",
        "&:focus, &:hover": {
          color: colorIconHover,
          textDecoration: "none"
        }
      },
      [`${componentCls}-title`]: {
        flex: 1,
        margin: 0,
        color: colorText,
        fontWeight: token2.fontWeightStrong,
        fontSize: fontSizeLG,
        lineHeight: lineHeightLG
      },
      [`${componentCls}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: paddingLG,
        overflow: "auto"
      },
      [`${componentCls}-footer`]: {
        flexShrink: 0,
        padding: `${drawerFooterPaddingVertical}px ${drawerFooterPaddingHorizontal}px`,
        borderTop: `${lineWidth}px ${lineType} ${colorSplit}`
      },
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
};
const useStyle$5 = genComponentStyleHook("Drawer", (token2) => {
  const drawerToken = merge(token2, {
    drawerFooterPaddingVertical: token2.paddingXS,
    drawerFooterPaddingHorizontal: token2.padding
  });
  return [genDrawerStyle(drawerToken), genMotionStyle$1(drawerToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase
}));
var __rest$j = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const defaultPushState = {
  distance: 180
};
function Drawer2(props) {
  const {
    rootClassName,
    width,
    height,
    size = "default",
    mask = true,
    push = defaultPushState,
    open: open2,
    afterOpenChange,
    onClose,
    prefixCls: customizePrefixCls,
    getContainer: customizeGetContainer,
    visible,
    afterVisibleChange
  } = props, rest = __rest$j(props, ["rootClassName", "width", "height", "size", "mask", "push", "open", "afterOpenChange", "onClose", "prefixCls", "getContainer", "visible", "afterVisibleChange"]);
  const {
    getPopupContainer,
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$5(prefixCls);
  const getContainer2 = customizeGetContainer === void 0 && getPopupContainer ? () => getPopupContainer(document.body) : customizeGetContainer;
  const drawerClassName = classNames({
    "no-mask": !mask,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, rootClassName, hashId);
  const mergedWidth = react.exports.useMemo(() => width !== null && width !== void 0 ? width : size === "large" ? 736 : 378, [width, size]);
  const mergedHeight = react.exports.useMemo(() => height !== null && height !== void 0 ? height : size === "large" ? 736 : 378, [height, size]);
  const maskMotion = {
    motionName: getTransitionName(prefixCls, "mask-motion"),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  };
  const panelMotion = (motionPlacement) => ({
    motionName: getTransitionName(prefixCls, `panel-motion-${motionPlacement}`),
    motionAppear: true,
    motionEnter: true,
    motionLeave: true,
    motionDeadline: 500
  });
  return wrapSSR(
    /* @__PURE__ */ jsx(NoCompactStyle, {
      children: /* @__PURE__ */ jsx(NoFormStyle, {
        status: true,
        override: true,
        children: /* @__PURE__ */ jsx(Drawer$1, {
          ...Object.assign({
            prefixCls,
            onClose,
            maskMotion,
            motion: panelMotion
          }, rest, {
            open: open2 !== null && open2 !== void 0 ? open2 : visible,
            mask,
            push,
            width: mergedWidth,
            height: mergedHeight,
            rootClassName: drawerClassName,
            getContainer: getContainer2,
            afterOpenChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange
          }),
          children: /* @__PURE__ */ jsx(DrawerPanel2, {
            ...Object.assign({
              prefixCls
            }, rest, {
              onClose
            })
          })
        })
      })
    })
  );
}
function PurePanel$2(_a) {
  var {
    prefixCls: customizePrefixCls,
    style: style2,
    className,
    placement = "right"
  } = _a, restProps = __rest$j(_a, ["prefixCls", "style", "className", "placement"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("drawer", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$5(prefixCls);
  return wrapSSR(
    /* @__PURE__ */ jsx("div", {
      className: classNames(prefixCls, `${prefixCls}-pure`, `${prefixCls}-${placement}`, hashId, className),
      style: style2,
      children: /* @__PURE__ */ jsx(DrawerPanel2, {
        ...Object.assign({
          prefixCls
        }, restProps)
      })
    })
  );
}
Drawer2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$2;
function useDebounce(value) {
  const [cacheValue, setCacheValue] = react.exports.useState(value);
  react.exports.useEffect(() => {
    const timeout = setTimeout(() => {
      setCacheValue(value);
    }, value.length ? 0 : 10);
    return () => {
      clearTimeout(timeout);
    };
  }, [value]);
  return cacheValue;
}
const genFormValidateMotionStyle = (token2) => {
  const {
    componentCls
  } = token2;
  const helpCls = `${componentCls}-show-help`;
  const helpItemCls = `${componentCls}-show-help-item`;
  return {
    [helpCls]: {
      transition: `opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      [helpItemCls]: {
        overflow: "hidden",
        transition: `height ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut},
                     transform ${token2.motionDurationSlow} ${token2.motionEaseInOut} !important`,
        [`&${helpItemCls}-appear, &${helpItemCls}-enter`]: {
          transform: `translateY(-5px)`,
          opacity: 0,
          [`&-active`]: {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${helpItemCls}-leave-active`]: {
          transform: `translateY(-5px)`
        }
      }
    }
  };
};
const genFormValidateMotionStyle$1 = genFormValidateMotionStyle;
const resetForm = (token2) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: token2.marginLG,
    padding: 0,
    color: token2.colorTextDescription,
    fontSize: token2.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorBorder}`
  },
  label: {
    fontSize: token2.fontSize
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  "select[multiple], select[size]": {
    height: "auto"
  },
  [`input[type='file']:focus,
  input[type='radio']:focus,
  input[type='checkbox']:focus`]: {
    outline: 0,
    boxShadow: `0 0 0 ${token2.controlOutlineWidth}px ${token2.controlOutline}`
  },
  output: {
    display: "block",
    paddingTop: 15,
    color: token2.colorText,
    fontSize: token2.fontSize,
    lineHeight: token2.lineHeight
  }
});
const genFormSize = (token2, height) => {
  const {
    formItemCls
  } = token2;
  return {
    [formItemCls]: {
      [`${formItemCls}-label > label`]: {
        height
      },
      [`${formItemCls}-control-input`]: {
        minHeight: height
      }
    }
  };
};
const genFormStyle = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    [token2.componentCls]: Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), resetForm(token2)), {
      [`${componentCls}-text`]: {
        display: "inline-block",
        paddingInlineEnd: token2.paddingSM
      },
      "&-small": Object.assign({}, genFormSize(token2, token2.controlHeightSM)),
      "&-large": Object.assign({}, genFormSize(token2, token2.controlHeightLG))
    })
  };
};
const genFormItemStyle = (token2) => {
  const {
    formItemCls,
    iconCls,
    componentCls,
    rootPrefixCls
  } = token2;
  return {
    [formItemCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
      marginBottom: token2.marginLG,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden.${rootPrefixCls}-row`]: {
        display: "none"
      },
      "&-has-warning": {
        [`${formItemCls}-split`]: {
          color: token2.colorError
        }
      },
      "&-has-error": {
        [`${formItemCls}-split`]: {
          color: token2.colorWarning
        }
      },
      [`${formItemCls}-label`]: {
        display: "inline-block",
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: `${token2.lineHeight} - 0.25em`,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: token2.controlHeight,
          color: token2.colorTextHeading,
          fontSize: token2.fontSize,
          [`> ${iconCls}`]: {
            fontSize: token2.fontSize,
            verticalAlign: "top"
          },
          [`&${formItemCls}-required:not(${formItemCls}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: token2.marginXXS,
            color: token2.colorError,
            fontSize: token2.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          [`${formItemCls}-optional`]: {
            display: "inline-block",
            marginInlineStart: token2.marginXXS,
            color: token2.colorTextDescription,
            [`${componentCls}-hide-required-mark &`]: {
              display: "none"
            }
          },
          [`${formItemCls}-tooltip`]: {
            color: token2.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: token2.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: token2.marginXXS / 2,
            marginInlineEnd: token2.marginXS
          },
          [`&${formItemCls}-no-colon::after`]: {
            content: '" "'
          }
        }
      },
      [`${formItemCls}-control`]: {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${rootPrefixCls}-col-'"]):not([class*="' ${rootPrefixCls}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: token2.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      [formItemCls]: {
        "&-explain, &-extra": {
          clear: "both",
          color: token2.colorTextDescription,
          fontSize: token2.fontSize,
          lineHeight: token2.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: token2.controlHeightSM,
          transition: `color ${token2.motionDurationMid} ${token2.motionEaseOut}`
        },
        "&-explain": {
          "&-error": {
            color: token2.colorError
          },
          "&-warning": {
            color: token2.colorWarning
          }
        }
      },
      [`&-with-help ${formItemCls}-explain`]: {
        height: "auto",
        opacity: 1
      },
      [`${formItemCls}-feedback-icon`]: {
        fontSize: token2.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: zoomIn,
        animationDuration: token2.motionDurationMid,
        animationTimingFunction: token2.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: token2.colorSuccess
        },
        "&-error": {
          color: token2.colorError
        },
        "&-warning": {
          color: token2.colorWarning
        },
        "&-validating": {
          color: token2.colorPrimary
        }
      }
    })
  };
};
const genHorizontalStyle = (token2) => {
  const {
    componentCls,
    formItemCls,
    rootPrefixCls
  } = token2;
  return {
    [`${componentCls}-horizontal`]: {
      [`${formItemCls}-label`]: {
        flexGrow: 0
      },
      [`${formItemCls}-control`]: {
        flex: "1 1 0",
        minWidth: 0
      },
      [`${formItemCls}-label.${rootPrefixCls}-col-24 + ${formItemCls}-control`]: {
        minWidth: "unset"
      }
    }
  };
};
const genInlineStyle = (token2) => {
  const {
    componentCls,
    formItemCls
  } = token2;
  return {
    [`${componentCls}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [formItemCls]: {
        flex: "none",
        flexWrap: "nowrap",
        marginInlineEnd: token2.margin,
        marginBottom: 0,
        "&-with-help": {
          marginBottom: token2.marginLG
        },
        [`> ${formItemCls}-label,
        > ${formItemCls}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${formItemCls}-label`]: {
          flex: "none"
        },
        [`${componentCls}-text`]: {
          display: "inline-block"
        },
        [`${formItemCls}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
};
const makeVerticalLayoutLabel = (token2) => ({
  margin: 0,
  padding: `0 0 ${token2.paddingXS}px`,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      display: "none"
    }
  }
});
const makeVerticalLayout = (token2) => {
  const {
    componentCls,
    formItemCls
  } = token2;
  return {
    [`${formItemCls} ${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    [componentCls]: {
      [formItemCls]: {
        flexWrap: "wrap",
        [`${formItemCls}-label,
          ${formItemCls}-control`]: {
          flex: "0 0 100%",
          maxWidth: "100%"
        }
      }
    }
  };
};
const genVerticalStyle = (token2) => {
  const {
    componentCls,
    formItemCls,
    rootPrefixCls
  } = token2;
  return {
    [`${componentCls}-vertical`]: {
      [formItemCls]: {
        "&-row": {
          flexDirection: "column"
        },
        "&-label > label": {
          height: "auto"
        },
        [`${componentCls}-item-control`]: {
          width: "100%"
        }
      }
    },
    [`${componentCls}-vertical ${formItemCls}-label,
      .${rootPrefixCls}-col-24${formItemCls}-label,
      .${rootPrefixCls}-col-xl-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2),
    [`@media (max-width: ${token2.screenXSMax}px)`]: [makeVerticalLayout(token2), {
      [componentCls]: {
        [`.${rootPrefixCls}-col-xs-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    }],
    [`@media (max-width: ${token2.screenSMMax}px)`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-sm-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${token2.screenMDMax}px)`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-md-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    },
    [`@media (max-width: ${token2.screenLGMax}px)`]: {
      [componentCls]: {
        [`.${rootPrefixCls}-col-lg-24${formItemCls}-label`]: makeVerticalLayoutLabel(token2)
      }
    }
  };
};
const useStyle$4 = genComponentStyleHook("Form", (token2, _ref) => {
  let {
    rootPrefixCls
  } = _ref;
  const formToken = merge(token2, {
    formItemCls: `${token2.componentCls}-item`,
    rootPrefixCls
  });
  return [genFormStyle(formToken), genFormItemStyle(formToken), genFormValidateMotionStyle$1(formToken), genHorizontalStyle(formToken), genInlineStyle(formToken), genVerticalStyle(formToken), genCollapseMotion$1(formToken), zoomIn];
});
const EMPTY_LIST = [];
function toErrorEntity(error, prefix, errorStatus) {
  let index2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  return {
    key: typeof error === "string" ? error : `${prefix}-${index2}`,
    error,
    errorStatus
  };
}
function ErrorList(_ref) {
  let {
    help,
    helpStatus,
    errors = EMPTY_LIST,
    warnings = EMPTY_LIST,
    className: rootClassName,
    fieldId,
    onVisibleChanged
  } = _ref;
  const {
    prefixCls
  } = react.exports.useContext(FormItemPrefixContext);
  const baseClassName = `${prefixCls}-item-explain`;
  const [, hashId] = useStyle$4(prefixCls);
  const collapseMotion = react.exports.useMemo(() => initCollapseMotion$1(prefixCls), [prefixCls]);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const fullKeyList = react.exports.useMemo(() => {
    if (help !== void 0 && help !== null) {
      return [toErrorEntity(help, "help", helpStatus)];
    }
    return [].concat(_toConsumableArray(debounceErrors.map((error, index2) => toErrorEntity(error, "error", "error", index2))), _toConsumableArray(debounceWarnings.map((warning3, index2) => toErrorEntity(warning3, "warning", "warning", index2))));
  }, [help, helpStatus, debounceErrors, debounceWarnings]);
  const helpProps = {};
  if (fieldId) {
    helpProps.id = `${fieldId}_help`;
  }
  return /* @__PURE__ */ jsx(CSSMotion, {
    motionDeadline: collapseMotion.motionDeadline,
    motionName: `${prefixCls}-show-help`,
    visible: !!fullKeyList.length,
    onVisibleChanged,
    children: (holderProps) => {
      const {
        className: holderClassName,
        style: holderStyle
      } = holderProps;
      return /* @__PURE__ */ jsx("div", {
        ...Object.assign({}, helpProps, {
          className: classNames(baseClassName, holderClassName, rootClassName, hashId),
          style: holderStyle,
          role: "alert"
        }),
        children: /* @__PURE__ */ jsx(CSSMotionList, {
          ...Object.assign({
            keys: fullKeyList
          }, initCollapseMotion$1(prefixCls), {
            motionName: `${prefixCls}-show-help-item`,
            component: false
          }),
          children: (itemProps) => {
            const {
              key,
              error,
              errorStatus,
              className: itemClassName,
              style: itemStyle
            } = itemProps;
            return /* @__PURE__ */ jsx("div", {
              className: classNames(itemClassName, {
                [`${baseClassName}-${errorStatus}`]: errorStatus
              }),
              style: itemStyle,
              children: error
            }, key);
          }
        })
      });
    }
  });
}
const formItemNameBlackList = ["parentNode"];
const defaultItemNamePrefixCls = "form_item";
function toArray$1(candidate) {
  if (candidate === void 0 || candidate === false)
    return [];
  return Array.isArray(candidate) ? candidate : [candidate];
}
function getFieldId(namePath, formName) {
  if (!namePath.length) {
    return void 0;
  }
  const mergedId = namePath.join("_");
  if (formName) {
    return `${formName}_${mergedId}`;
  }
  const isIllegalName = formItemNameBlackList.includes(mergedId);
  return isIllegalName ? `${defaultItemNamePrefixCls}_${mergedId}` : mergedId;
}
function toNamePathStr(name2) {
  const namePath = toArray$1(name2);
  return namePath.join("_");
}
function useForm$1(form) {
  const [rcForm] = useForm$2();
  const itemsRef = react.exports.useRef({});
  const wrapForm = react.exports.useMemo(() => form !== null && form !== void 0 ? form : Object.assign(Object.assign({}, rcForm), {
    __INTERNAL__: {
      itemRef: (name2) => (node2) => {
        const namePathStr = toNamePathStr(name2);
        if (node2) {
          itemsRef.current[namePathStr] = node2;
        } else {
          delete itemsRef.current[namePathStr];
        }
      }
    },
    scrollToField: function(name2) {
      let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const namePath = toArray$1(name2);
      const fieldId = getFieldId(namePath, wrapForm.__INTERNAL__.name);
      const node2 = fieldId ? document.getElementById(fieldId) : null;
      if (node2) {
        o(node2, Object.assign({
          scrollMode: "if-needed",
          block: "nearest"
        }, options));
      }
    },
    getFieldInstance: (name2) => {
      const namePathStr = toNamePathStr(name2);
      return itemsRef.current[namePathStr];
    }
  }), [form, rcForm]);
  return [wrapForm];
}
var __rest$i = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const InternalForm = (props, ref) => {
  const contextSize = react.exports.useContext(SizeContext$2);
  const contextDisabled = react.exports.useContext(DisabledContext);
  const {
    getPrefixCls,
    direction,
    form: contextForm
  } = react.exports.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className,
    rootClassName,
    size = contextSize,
    disabled = contextDisabled,
    form,
    colon,
    labelAlign,
    labelWrap,
    labelCol,
    wrapperCol,
    hideRequiredMark,
    layout = "horizontal",
    scrollToFirstError,
    requiredMark,
    onFinishFailed,
    name: name2
  } = props, restFormProps = __rest$i(props, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name"]);
  const mergedRequiredMark = react.exports.useMemo(() => {
    if (requiredMark !== void 0) {
      return requiredMark;
    }
    if (contextForm && contextForm.requiredMark !== void 0) {
      return contextForm.requiredMark;
    }
    if (hideRequiredMark) {
      return false;
    }
    return true;
  }, [hideRequiredMark, requiredMark, contextForm]);
  const mergedColon = colon !== null && colon !== void 0 ? colon : contextForm === null || contextForm === void 0 ? void 0 : contextForm.colon;
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$4(prefixCls);
  const formClassName = classNames(prefixCls, {
    [`${prefixCls}-${layout}`]: true,
    [`${prefixCls}-hide-required-mark`]: mergedRequiredMark === false,
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${size}`]: size
  }, hashId, className, rootClassName);
  const [wrapForm] = useForm$1(form);
  const {
    __INTERNAL__
  } = wrapForm;
  __INTERNAL__.name = name2;
  const formContextValue = react.exports.useMemo(() => ({
    name: name2,
    labelAlign,
    labelCol,
    labelWrap,
    wrapperCol,
    vertical: layout === "vertical",
    colon: mergedColon,
    requiredMark: mergedRequiredMark,
    itemRef: __INTERNAL__.itemRef,
    form: wrapForm
  }), [name2, labelAlign, labelCol, wrapperCol, layout, mergedColon, mergedRequiredMark, wrapForm]);
  react.exports.useImperativeHandle(ref, () => wrapForm);
  const scrollToField = (options, fieldName) => {
    if (options) {
      let defaultScrollToFirstError = {
        block: "nearest"
      };
      if (typeof options === "object") {
        defaultScrollToFirstError = options;
      }
      wrapForm.scrollToField(fieldName, defaultScrollToFirstError);
    }
  };
  const onInternalFinishFailed = (errorInfo) => {
    onFinishFailed === null || onFinishFailed === void 0 ? void 0 : onFinishFailed(errorInfo);
    if (errorInfo.errorFields.length) {
      const fieldName = errorInfo.errorFields[0].name;
      if (scrollToFirstError !== void 0) {
        scrollToField(scrollToFirstError, fieldName);
        return;
      }
      if (contextForm && contextForm.scrollToFirstError !== void 0) {
        scrollToField(contextForm.scrollToFirstError, fieldName);
      }
    }
  };
  return wrapSSR(
    /* @__PURE__ */ jsx(DisabledContextProvider, {
      disabled,
      children: /* @__PURE__ */ jsx(SizeContextProvider$1, {
        size,
        children: /* @__PURE__ */ jsx(FormContext.Provider, {
          value: formContextValue,
          children: /* @__PURE__ */ jsx(RefForm, {
            ...Object.assign({
              id: name2
            }, restFormProps, {
              name: name2,
              onFinishFailed: onInternalFinishFailed,
              form: wrapForm,
              className: formClassName
            })
          })
        })
      })
    })
  );
};
const Form$2 = /* @__PURE__ */ react.exports.forwardRef(InternalForm);
const InternalForm$1 = Form$2;
const useFormItemStatus = () => {
  const {
    status
  } = react.exports.useContext(FormItemInputContext);
  return {
    status
  };
};
useFormItemStatus.Context = FormItemInputContext;
const useFormItemStatus$1 = useFormItemStatus;
function useFrameState(defaultValue) {
  const [value, setValue2] = react.exports.useState(defaultValue);
  const frameRef = react.exports.useRef(null);
  const batchRef = react.exports.useRef([]);
  const destroyRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    destroyRef.current = false;
    return () => {
      destroyRef.current = true;
      wrapperRaf.cancel(frameRef.current);
      frameRef.current = null;
    };
  }, []);
  function setFrameValue(updater) {
    if (destroyRef.current) {
      return;
    }
    if (frameRef.current === null) {
      batchRef.current = [];
      frameRef.current = wrapperRaf(() => {
        frameRef.current = null;
        setValue2((prevValue) => {
          let current = prevValue;
          batchRef.current.forEach((func) => {
            current = func(current);
          });
          return current;
        });
      });
    }
    batchRef.current.push(updater);
  }
  return [value, setFrameValue];
}
function useItemRef() {
  const {
    itemRef
  } = react.exports.useContext(FormContext);
  const cacheRef = react.exports.useRef({});
  function getRef(name2, children) {
    const childrenRef = children && typeof children === "object" && children.ref;
    const nameStr = name2.join("_");
    if (cacheRef.current.name !== nameStr || cacheRef.current.originRef !== childrenRef) {
      cacheRef.current.name = nameStr;
      cacheRef.current.originRef = childrenRef;
      cacheRef.current.ref = composeRef(itemRef(name2), childrenRef);
    }
    return cacheRef.current.ref;
  }
  return getRef;
}
const FormItemInput = (props) => {
  const {
    prefixCls,
    status,
    wrapperCol,
    children,
    errors,
    warnings,
    _internalItemRender: formItemRender,
    extra,
    help,
    fieldId,
    marginBottom,
    onErrorVisibleChanged
  } = props;
  const baseClassName = `${prefixCls}-item`;
  const formContext = react.exports.useContext(FormContext);
  const mergedWrapperCol = wrapperCol || formContext.wrapperCol || {};
  const className = classNames(`${baseClassName}-control`, mergedWrapperCol.className);
  const subFormContext = react.exports.useMemo(() => Object.assign({}, formContext), [formContext]);
  delete subFormContext.labelCol;
  delete subFormContext.wrapperCol;
  const inputDom = /* @__PURE__ */ jsx("div", {
    className: `${baseClassName}-control-input`,
    children: /* @__PURE__ */ jsx("div", {
      className: `${baseClassName}-control-input-content`,
      children
    })
  });
  const formItemContext = react.exports.useMemo(() => ({
    prefixCls,
    status
  }), [prefixCls, status]);
  const errorListDom = marginBottom !== null || errors.length || warnings.length ? /* @__PURE__ */ jsxs("div", {
    style: {
      display: "flex",
      flexWrap: "nowrap"
    },
    children: [/* @__PURE__ */ jsx(FormItemPrefixContext.Provider, {
      value: formItemContext,
      children: /* @__PURE__ */ jsx(ErrorList, {
        fieldId,
        errors,
        warnings,
        help,
        helpStatus: status,
        className: `${baseClassName}-explain-connected`,
        onVisibleChanged: onErrorVisibleChanged
      })
    }), !!marginBottom && /* @__PURE__ */ jsx("div", {
      style: {
        width: 0,
        height: marginBottom
      }
    })]
  }) : null;
  const extraProps = {};
  if (fieldId) {
    extraProps.id = `${fieldId}_extra`;
  }
  const extraDom = extra ? /* @__PURE__ */ jsx("div", {
    ...Object.assign({}, extraProps, {
      className: `${baseClassName}-extra`
    }),
    children: extra
  }) : null;
  const dom = formItemRender && formItemRender.mark === "pro_table_render" && formItemRender.render ? formItemRender.render(props, {
    input: inputDom,
    errorList: errorListDom,
    extra: extraDom
  }) : /* @__PURE__ */ jsxs(Fragment, {
    children: [inputDom, errorListDom, extraDom]
  });
  return /* @__PURE__ */ jsx(FormContext.Provider, {
    value: subFormContext,
    children: /* @__PURE__ */ jsx(Col$1, {
      ...Object.assign({}, mergedWrapperCol, {
        className
      }),
      children: dom
    })
  });
};
const FormItemInput$1 = FormItemInput;
var QuestionCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { "tag": "path", "attrs": { "d": "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, "name": "question-circle", "theme": "outlined" };
const QuestionCircleOutlinedSvg = QuestionCircleOutlined$2;
var QuestionCircleOutlined = function QuestionCircleOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: QuestionCircleOutlinedSvg
    })
  });
};
QuestionCircleOutlined.displayName = "QuestionCircleOutlined";
const QuestionCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(QuestionCircleOutlined);
var __rest$h = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function toTooltipProps(tooltip) {
  if (!tooltip) {
    return null;
  }
  if (typeof tooltip === "object" && !/* @__PURE__ */ react.exports.isValidElement(tooltip)) {
    return tooltip;
  }
  return {
    title: tooltip
  };
}
const FormItemLabel = (_ref) => {
  let {
    prefixCls,
    label,
    htmlFor,
    labelCol,
    labelAlign,
    colon,
    required: required4,
    requiredMark,
    tooltip
  } = _ref;
  var _a;
  const [formLocale] = useLocale$1("Form");
  const {
    vertical,
    labelAlign: contextLabelAlign,
    labelCol: contextLabelCol,
    labelWrap,
    colon: contextColon
  } = react.exports.useContext(FormContext);
  if (!label) {
    return null;
  }
  const mergedLabelCol = labelCol || contextLabelCol || {};
  const mergedLabelAlign = labelAlign || contextLabelAlign;
  const labelClsBasic = `${prefixCls}-item-label`;
  const labelColClassName = classNames(labelClsBasic, mergedLabelAlign === "left" && `${labelClsBasic}-left`, mergedLabelCol.className, {
    [`${labelClsBasic}-wrap`]: !!labelWrap
  });
  let labelChildren = label;
  const computedColon = colon === true || contextColon !== false && colon !== false;
  const haveColon = computedColon && !vertical;
  if (haveColon && typeof label === "string" && label.trim() !== "") {
    labelChildren = label.replace(/[:|]\s*$/, "");
  }
  const tooltipProps = toTooltipProps(tooltip);
  if (tooltipProps) {
    const {
      icon = /* @__PURE__ */ jsx(QuestionCircleOutlined$1, {})
    } = tooltipProps, restTooltipProps = __rest$h(tooltipProps, ["icon"]);
    const tooltipNode = /* @__PURE__ */ jsx(Tooltip$1, {
      ...Object.assign({}, restTooltipProps),
      children: /* @__PURE__ */ react.exports.cloneElement(icon, {
        className: `${prefixCls}-item-tooltip`,
        title: ""
      })
    });
    labelChildren = /* @__PURE__ */ jsxs(Fragment, {
      children: [labelChildren, tooltipNode]
    });
  }
  if (requiredMark === "optional" && !required4) {
    labelChildren = /* @__PURE__ */ jsxs(Fragment, {
      children: [labelChildren, /* @__PURE__ */ jsx("span", {
        className: `${prefixCls}-item-optional`,
        title: "",
        children: (formLocale === null || formLocale === void 0 ? void 0 : formLocale.optional) || ((_a = defaultLocale.Form) === null || _a === void 0 ? void 0 : _a.optional)
      })]
    });
  }
  const labelClassName = classNames({
    [`${prefixCls}-item-required`]: required4,
    [`${prefixCls}-item-required-mark-optional`]: requiredMark === "optional",
    [`${prefixCls}-item-no-colon`]: !computedColon
  });
  return /* @__PURE__ */ jsx(Col$1, {
    ...Object.assign({}, mergedLabelCol, {
      className: labelColClassName
    }),
    children: /* @__PURE__ */ jsx("label", {
      htmlFor,
      className: labelClassName,
      title: typeof label === "string" ? label : "",
      children: labelChildren
    })
  });
};
const FormItemLabel$1 = FormItemLabel;
var __rest$g = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const iconMap = {
  success: CheckCircleFilled$1,
  warning: ExclamationCircleFilled$1,
  error: CloseCircleFilled$1,
  validating: LoadingOutlined$1
};
function ItemHolder(props) {
  const {
    prefixCls,
    className,
    rootClassName,
    style: style2,
    help,
    errors,
    warnings,
    validateStatus: validateStatus2,
    meta,
    hasFeedback,
    hidden,
    children,
    fieldId,
    isRequired,
    onSubItemMetaChange
  } = props, restProps = __rest$g(props, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "isRequired", "onSubItemMetaChange"]);
  const itemPrefixCls = `${prefixCls}-item`;
  const {
    requiredMark
  } = react.exports.useContext(FormContext);
  const itemRef = react.exports.useRef(null);
  const debounceErrors = useDebounce(errors);
  const debounceWarnings = useDebounce(warnings);
  const hasHelp = help !== void 0 && help !== null;
  const hasError = !!(hasHelp || errors.length || warnings.length);
  const [marginBottom, setMarginBottom] = react.exports.useState(null);
  useLayoutEffect(() => {
    if (hasError && itemRef.current) {
      const itemStyle = getComputedStyle(itemRef.current);
      setMarginBottom(parseInt(itemStyle.marginBottom, 10));
    }
  }, [hasError]);
  const onErrorVisibleChanged = (nextVisible) => {
    if (!nextVisible) {
      setMarginBottom(null);
    }
  };
  let mergedValidateStatus = "";
  if (validateStatus2 !== void 0) {
    mergedValidateStatus = validateStatus2;
  } else if (meta.validating) {
    mergedValidateStatus = "validating";
  } else if (debounceErrors.length) {
    mergedValidateStatus = "error";
  } else if (debounceWarnings.length) {
    mergedValidateStatus = "warning";
  } else if (meta.touched) {
    mergedValidateStatus = "success";
  }
  const formItemStatusContext = react.exports.useMemo(() => {
    let feedbackIcon;
    if (hasFeedback) {
      const IconNode2 = mergedValidateStatus && iconMap[mergedValidateStatus];
      feedbackIcon = IconNode2 ? /* @__PURE__ */ jsx("span", {
        className: classNames(`${itemPrefixCls}-feedback-icon`, `${itemPrefixCls}-feedback-icon-${mergedValidateStatus}`),
        children: /* @__PURE__ */ jsx(IconNode2, {})
      }) : null;
    }
    return {
      status: mergedValidateStatus,
      hasFeedback,
      feedbackIcon,
      isFormItemInput: true
    };
  }, [mergedValidateStatus, hasFeedback]);
  const itemClassName = classNames(itemPrefixCls, className, rootClassName, {
    [`${itemPrefixCls}-with-help`]: hasHelp || debounceErrors.length || debounceWarnings.length,
    [`${itemPrefixCls}-has-feedback`]: mergedValidateStatus && hasFeedback,
    [`${itemPrefixCls}-has-success`]: mergedValidateStatus === "success",
    [`${itemPrefixCls}-has-warning`]: mergedValidateStatus === "warning",
    [`${itemPrefixCls}-has-error`]: mergedValidateStatus === "error",
    [`${itemPrefixCls}-is-validating`]: mergedValidateStatus === "validating",
    [`${itemPrefixCls}-hidden`]: hidden
  });
  return /* @__PURE__ */ jsxs("div", {
    className: itemClassName,
    style: style2,
    ref: itemRef,
    children: [/* @__PURE__ */ jsxs(Row$1, {
      ...Object.assign({
        className: `${itemPrefixCls}-row`
      }, omit(restProps, ["_internalItemRender", "colon", "dependencies", "extra", "fieldKey", "getValueFromEvent", "getValueProps", "htmlFor", "id", "initialValue", "isListField", "label", "labelAlign", "labelCol", "labelWrap", "messageVariables", "name", "normalize", "noStyle", "preserve", "required", "requiredMark", "rules", "shouldUpdate", "trigger", "tooltip", "validateFirst", "validateTrigger", "valuePropName", "wrapperCol"])),
      children: [/* @__PURE__ */ jsx(FormItemLabel$1, {
        ...Object.assign({
          htmlFor: fieldId,
          required: isRequired,
          requiredMark
        }, props, {
          prefixCls
        })
      }), /* @__PURE__ */ jsx(FormItemInput$1, {
        ...Object.assign({}, props, meta, {
          errors: debounceErrors,
          warnings: debounceWarnings,
          prefixCls,
          status: mergedValidateStatus,
          help,
          marginBottom,
          onErrorVisibleChanged
        }),
        children: /* @__PURE__ */ jsx(NoStyleItemContext.Provider, {
          value: onSubItemMetaChange,
          children: /* @__PURE__ */ jsx(FormItemInputContext.Provider, {
            value: formItemStatusContext,
            children
          })
        })
      })]
    }), !!marginBottom && /* @__PURE__ */ jsx("div", {
      className: `${itemPrefixCls}-margin-offset`,
      style: {
        marginBottom: -marginBottom
      }
    })]
  });
}
const NAME_SPLIT = "__SPLIT__";
const MemoInput = /* @__PURE__ */ react.exports.memo((_ref) => {
  let {
    children
  } = _ref;
  return children;
}, (prev2, next2) => prev2.value === next2.value && prev2.update === next2.update && prev2.childProps.length === next2.childProps.length && prev2.childProps.every((value, index2) => value === next2.childProps[index2]));
function hasValidName(name2) {
  return !(name2 === void 0 || name2 === null);
}
function genEmptyMeta() {
  return {
    errors: [],
    warnings: [],
    touched: false,
    validating: false,
    name: []
  };
}
function InternalFormItem(props) {
  const {
    name: name2,
    noStyle,
    className,
    dependencies,
    prefixCls: customizePrefixCls,
    shouldUpdate,
    rules: rules2,
    children,
    required: required4,
    label,
    messageVariables,
    trigger = "onChange",
    validateTrigger,
    hidden
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const {
    name: formName
  } = react.exports.useContext(FormContext);
  const isRenderProps = typeof children === "function";
  const notifyParentMetaChange = react.exports.useContext(NoStyleItemContext);
  const {
    validateTrigger: contextValidateTrigger
  } = react.exports.useContext(Context$1);
  const mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : contextValidateTrigger;
  const hasName = hasValidName(name2);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$4(prefixCls);
  const listContext = react.exports.useContext(ListContext);
  const fieldKeyPathRef = react.exports.useRef();
  const [subFieldErrors, setSubFieldErrors] = useFrameState({});
  const [meta, setMeta] = useSafeState(() => genEmptyMeta());
  const onMetaChange = (nextMeta) => {
    const keyInfo = listContext === null || listContext === void 0 ? void 0 : listContext.getKey(nextMeta.name);
    setMeta(nextMeta.destroy ? genEmptyMeta() : nextMeta, true);
    if (noStyle && notifyParentMetaChange) {
      let namePath = nextMeta.name;
      if (!nextMeta.destroy) {
        if (keyInfo !== void 0) {
          const [fieldKey, restPath] = keyInfo;
          namePath = [fieldKey].concat(_toConsumableArray(restPath));
          fieldKeyPathRef.current = namePath;
        }
      } else {
        namePath = fieldKeyPathRef.current || namePath;
      }
      notifyParentMetaChange(nextMeta, namePath);
    }
  };
  const onSubItemMetaChange = (subMeta, uniqueKeys) => {
    setSubFieldErrors((prevSubFieldErrors) => {
      const clone2 = Object.assign({}, prevSubFieldErrors);
      const mergedNamePath = [].concat(_toConsumableArray(subMeta.name.slice(0, -1)), _toConsumableArray(uniqueKeys));
      const mergedNameKey = mergedNamePath.join(NAME_SPLIT);
      if (subMeta.destroy) {
        delete clone2[mergedNameKey];
      } else {
        clone2[mergedNameKey] = subMeta;
      }
      return clone2;
    });
  };
  const [mergedErrors, mergedWarnings] = react.exports.useMemo(() => {
    const errorList = _toConsumableArray(meta.errors);
    const warningList = _toConsumableArray(meta.warnings);
    Object.values(subFieldErrors).forEach((subFieldError) => {
      errorList.push.apply(errorList, _toConsumableArray(subFieldError.errors || []));
      warningList.push.apply(warningList, _toConsumableArray(subFieldError.warnings || []));
    });
    return [errorList, warningList];
  }, [subFieldErrors, meta.errors, meta.warnings]);
  const getItemRef = useItemRef();
  function renderLayout(baseChildren, fieldId, isRequired) {
    if (noStyle && !hidden) {
      return baseChildren;
    }
    return /* @__PURE__ */ jsx(ItemHolder, {
      ...Object.assign({
        key: "row"
      }, props, {
        className: classNames(className, hashId),
        prefixCls,
        fieldId,
        isRequired,
        errors: mergedErrors,
        warnings: mergedWarnings,
        meta,
        onSubItemMetaChange
      }),
      children: baseChildren
    });
  }
  if (!hasName && !isRenderProps && !dependencies) {
    return wrapSSR(renderLayout(children));
  }
  let variables = {};
  if (typeof label === "string") {
    variables.label = label;
  } else if (name2) {
    variables.label = String(name2);
  }
  if (messageVariables) {
    variables = Object.assign(Object.assign({}, variables), messageVariables);
  }
  return wrapSSR(
    /* @__PURE__ */ jsx(WrapperField, {
      ...Object.assign({}, props, {
        messageVariables: variables,
        trigger,
        validateTrigger: mergedValidateTrigger,
        onMetaChange
      }),
      children: (control, renderMeta, context) => {
        const mergedName = toArray$1(name2).length && renderMeta ? renderMeta.name : [];
        const fieldId = getFieldId(mergedName, formName);
        const isRequired = required4 !== void 0 ? required4 : !!(rules2 && rules2.some((rule) => {
          if (rule && typeof rule === "object" && rule.required && !rule.warningOnly) {
            return true;
          }
          if (typeof rule === "function") {
            const ruleEntity = rule(context);
            return ruleEntity && ruleEntity.required && !ruleEntity.warningOnly;
          }
          return false;
        }));
        const mergedControl = Object.assign({}, control);
        let childNode = null;
        if (Array.isArray(children) && hasName) {
          childNode = children;
        } else if (isRenderProps && (!(shouldUpdate || dependencies) || hasName))
          ;
        else if (dependencies && !isRenderProps && !hasName)
          ;
        else if (isValidElement(children)) {
          const childProps = Object.assign(Object.assign({}, children.props), mergedControl);
          if (!childProps.id) {
            childProps.id = fieldId;
          }
          if (props.help || mergedErrors.length > 0 || mergedWarnings.length > 0 || props.extra) {
            const describedbyArr = [];
            if (props.help || mergedErrors.length > 0) {
              describedbyArr.push(`${fieldId}_help`);
            }
            if (props.extra) {
              describedbyArr.push(`${fieldId}_extra`);
            }
            childProps["aria-describedby"] = describedbyArr.join(" ");
          }
          if (mergedErrors.length > 0) {
            childProps["aria-invalid"] = "true";
          }
          if (isRequired) {
            childProps["aria-required"] = "true";
          }
          if (supportRef(children)) {
            childProps.ref = getItemRef(mergedName, children);
          }
          const triggers = new Set([].concat(_toConsumableArray(toArray$1(trigger)), _toConsumableArray(toArray$1(mergedValidateTrigger))));
          triggers.forEach((eventName) => {
            childProps[eventName] = function() {
              var _a2, _c2;
              var _a, _b, _c;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              (_a = mergedControl[eventName]) === null || _a === void 0 ? void 0 : (_a2 = _a).call.apply(_a2, [mergedControl].concat(args));
              (_c = (_b = children.props)[eventName]) === null || _c === void 0 ? void 0 : (_c2 = _c).call.apply(_c2, [_b].concat(args));
            };
          });
          const watchingChildProps = [childProps["aria-required"], childProps["aria-invalid"], childProps["aria-describedby"]];
          childNode = /* @__PURE__ */ jsx(MemoInput, {
            value: mergedControl[props.valuePropName || "value"],
            update: children,
            childProps: watchingChildProps,
            children: cloneElement(children, childProps)
          });
        } else if (isRenderProps && (shouldUpdate || dependencies) && !hasName) {
          childNode = children(context);
        } else {
          childNode = children;
        }
        return renderLayout(childNode, fieldId, isRequired);
      }
    })
  );
}
const FormItem = InternalFormItem;
FormItem.useStatus = useFormItemStatus$1;
const Item = FormItem;
var __rest$f = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const FormList = (_a) => {
  var {
    prefixCls: customizePrefixCls,
    children
  } = _a, props = __rest$f(_a, ["prefixCls", "children"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = getPrefixCls("form", customizePrefixCls);
  const contextValue = react.exports.useMemo(() => ({
    prefixCls,
    status: "error"
  }), [prefixCls]);
  return /* @__PURE__ */ jsx(List$1, {
    ...Object.assign({}, props),
    children: (fields, operation, meta) => /* @__PURE__ */ jsx(FormItemPrefixContext.Provider, {
      value: contextValue,
      children: children(fields.map((field) => Object.assign(Object.assign({}, field), {
        fieldKey: field.key
      })), operation, {
        errors: meta.errors,
        warnings: meta.warnings
      })
    })
  });
};
const List2 = FormList;
function useFormInstance() {
  const {
    form
  } = react.exports.useContext(FormContext);
  return form;
}
const Form2 = InternalForm$1;
Form2.Item = Item;
Form2.List = List2;
Form2.ErrorList = ErrorList;
Form2.useForm = useForm$1;
Form2.useFormInstance = useFormInstance;
Form2.useWatch = useWatch;
Form2.Provider = FormProvider2;
Form2.create = () => {
};
const Form$1 = Form2;
var EyeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };
const EyeOutlinedSvg = EyeOutlined$2;
var EyeOutlined = function EyeOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: EyeOutlinedSvg
    })
  });
};
EyeOutlined.displayName = "EyeOutlined";
const EyeOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EyeOutlined);
const Group = (props) => {
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const {
    prefixCls: customizePrefixCls,
    className = ""
  } = props;
  const prefixCls = getPrefixCls("input-group", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input");
  const [wrapSSR, hashId] = useStyle$c(inputPrefixCls);
  const cls = classNames(prefixCls, {
    [`${prefixCls}-lg`]: props.size === "large",
    [`${prefixCls}-sm`]: props.size === "small",
    [`${prefixCls}-compact`]: props.compact,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, hashId, className);
  const formItemContext = react.exports.useContext(FormItemInputContext);
  const groupFormItemContext = react.exports.useMemo(() => Object.assign(Object.assign({}, formItemContext), {
    isFormItemInput: false
  }), [formItemContext]);
  return wrapSSR(
    /* @__PURE__ */ jsx("span", {
      className: cls,
      style: props.style,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      onFocus: props.onFocus,
      onBlur: props.onBlur,
      children: /* @__PURE__ */ jsx(FormItemInputContext.Provider, {
        value: groupFormItemContext,
        children: props.children
      })
    })
  );
};
const Group$1 = Group;
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function hasPrefixSuffix$1(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
function resolveOnChange(target, e2, onChange2, targetValue) {
  if (!onChange2) {
    return;
  }
  var event = e2;
  if (e2.type === "click") {
    var currentTarget = target.cloneNode(true);
    event = Object.create(e2, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = "";
    onChange2(event);
    return;
  }
  if (targetValue !== void 0) {
    event = Object.create(e2, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange2(event);
    return;
  }
  onChange2(event);
}
function triggerFocus$1(element, option) {
  if (!element)
    return;
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}
function fixControlledValue(value) {
  if (typeof value === "undefined" || value === null) {
    return "";
  }
  return String(value);
}
var BaseInput = function BaseInput2(props) {
  var _inputElement$props;
  var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style2 = props.style, affixWrapperClassName = props.affixWrapperClassName, groupClassName = props.groupClassName, wrapperClassName = props.wrapperClassName, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, inputStyle = props.inputStyle, classes = props.classes;
  var containerRef = react.exports.useRef(null);
  var onInputClick = function onInputClick2(e2) {
    var _containerRef$current;
    if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e2.target)) {
      triggerFocus2 === null || triggerFocus2 === void 0 ? void 0 : triggerFocus2();
    }
  };
  var getClearIcon = function getClearIcon2() {
    var _classNames;
    if (!allowClear) {
      return null;
    }
    var needClear = !disabled && !readOnly && value;
    var clearIconCls = "".concat(prefixCls, "-clear-icon");
    var iconNode = _typeof$1(allowClear) === "object" && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : "\u2716";
    return /* @__PURE__ */ jsx("span", {
      onClick: handleReset,
      onMouseDown: function onMouseDown(e2) {
        return e2.preventDefault();
      },
      className: classNames(clearIconCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(clearIconCls, "-hidden"), !needClear), _defineProperty$1(_classNames, "".concat(clearIconCls, "-has-suffix"), !!suffix), _classNames)),
      role: "button",
      tabIndex: -1,
      children: iconNode
    });
  };
  var element = /* @__PURE__ */ react.exports.cloneElement(inputElement, {
    value,
    hidden,
    style: _objectSpread2$1(_objectSpread2$1({}, (_inputElement$props = inputElement.props) === null || _inputElement$props === void 0 ? void 0 : _inputElement$props.style), inputStyle)
  });
  if (hasPrefixSuffix$1(props)) {
    var _classNames2;
    var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
    var affixWrapperCls = classNames(affixWrapperPrefixCls, (_classNames2 = {}, _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-disabled"), disabled), _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-focused"), focused), _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), _defineProperty$1(_classNames2, "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), _classNames2), !hasAddon(props) && className, affixWrapperClassName, classes === null || classes === void 0 ? void 0 : classes.affixWrapper);
    var suffixNode = (suffix || allowClear) && /* @__PURE__ */ jsxs("span", {
      className: "".concat(prefixCls, "-suffix"),
      children: [getClearIcon(), suffix]
    });
    element = /* @__PURE__ */ jsxs("span", {
      className: affixWrapperCls,
      style: style2,
      hidden: !hasAddon(props) && hidden,
      onClick: onInputClick,
      ref: containerRef,
      children: [prefix && /* @__PURE__ */ jsx("span", {
        className: "".concat(prefixCls, "-prefix"),
        children: prefix
      }), /* @__PURE__ */ react.exports.cloneElement(inputElement, {
        style: inputStyle !== null && inputStyle !== void 0 ? inputStyle : null,
        value,
        hidden: null
      }), suffixNode]
    });
  }
  if (hasAddon(props)) {
    var wrapperCls = "".concat(prefixCls, "-group");
    var addonCls = "".concat(wrapperCls, "-addon");
    var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, wrapperClassName, classes === null || classes === void 0 ? void 0 : classes.wrapper);
    var mergedGroupClassName = classNames("".concat(prefixCls, "-group-wrapper"), className, groupClassName, classes === null || classes === void 0 ? void 0 : classes.group);
    return /* @__PURE__ */ jsx("span", {
      className: mergedGroupClassName,
      style: style2,
      hidden,
      children: /* @__PURE__ */ jsxs("span", {
        className: mergedWrapperClassName,
        children: [addonBefore && /* @__PURE__ */ jsx("span", {
          className: addonCls,
          children: addonBefore
        }), /* @__PURE__ */ react.exports.cloneElement(element, {
          style: inputStyle !== null && inputStyle !== void 0 ? inputStyle : null,
          hidden: null
        }), addonAfter && /* @__PURE__ */ jsx("span", {
          className: addonCls,
          children: addonAfter
        })]
      })
    });
  }
  return element;
};
var _excluded$5 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "type", "inputClassName", "classes"];
var Input$3 = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var autoComplete = props.autoComplete, onChange2 = props.onChange, onFocus2 = props.onFocus, onBlur2 = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown2 = props.onKeyDown, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-input" : _props$prefixCls, disabled = props.disabled, htmlSize = props.htmlSize, className = props.className, maxLength = props.maxLength, suffix = props.suffix, showCount = props.showCount, _props$type = props.type, type4 = _props$type === void 0 ? "text" : _props$type, inputClassName = props.inputClassName, classes = props.classes, rest = _objectWithoutProperties(props, _excluded$5);
  var _useMergedState = useMergedState(props.defaultValue, {
    value: props.value
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var _useState = react.exports.useState(false), _useState2 = _slicedToArray(_useState, 2), focused = _useState2[0], setFocused = _useState2[1];
  var inputRef = react.exports.useRef(null);
  var focus = function focus2(option) {
    if (inputRef.current) {
      triggerFocus$1(inputRef.current, option);
    }
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      focus,
      blur: function blur() {
        var _inputRef$current;
        (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 ? void 0 : _inputRef$current.blur();
      },
      setSelectionRange: function setSelectionRange(start, end, direction) {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 ? void 0 : _inputRef$current2.setSelectionRange(start, end, direction);
      },
      select: function select() {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 ? void 0 : _inputRef$current3.select();
      },
      input: inputRef.current
    };
  });
  react.exports.useEffect(function() {
    setFocused(function(prev2) {
      return prev2 && disabled ? false : prev2;
    });
  }, [disabled]);
  var handleChange = function handleChange2(e2) {
    if (props.value === void 0) {
      setValue2(e2.target.value);
    }
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e2, onChange2);
    }
  };
  var handleKeyDown = function handleKeyDown2(e2) {
    if (onPressEnter && e2.key === "Enter") {
      onPressEnter(e2);
    }
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
  };
  var handleFocus = function handleFocus2(e2) {
    setFocused(true);
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e2);
  };
  var handleBlur = function handleBlur2(e2) {
    setFocused(false);
    onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e2);
  };
  var handleReset = function handleReset2(e2) {
    setValue2("");
    focus();
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e2, onChange2);
    }
  };
  var getInputElement = function getInputElement2() {
    var otherProps = omit(props, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      "defaultValue",
      "showCount",
      "affixWrapperClassName",
      "groupClassName",
      "inputClassName",
      "classes",
      "wrapperClassName",
      "htmlSize"
    ]);
    return /* @__PURE__ */ jsx("input", {
      autoComplete,
      ...otherProps,
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      className: classNames(prefixCls, _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled), inputClassName, classes === null || classes === void 0 ? void 0 : classes.input, !hasAddon(props) && !hasPrefixSuffix$1(props) && className),
      ref: inputRef,
      size: htmlSize,
      type: type4
    });
  };
  var getSuffix = function getSuffix2() {
    var hasMaxLength = Number(maxLength) > 0;
    if (suffix || showCount) {
      var val = fixControlledValue(value);
      var valueLength = _toConsumableArray(val).length;
      var dataCount = _typeof$1(showCount) === "object" ? showCount.formatter({
        value: val,
        count: valueLength,
        maxLength
      }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
      return /* @__PURE__ */ jsxs(Fragment, {
        children: [!!showCount && /* @__PURE__ */ jsx("span", {
          className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty$1({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix)),
          children: dataCount
        }), suffix]
      });
    }
    return null;
  };
  return /* @__PURE__ */ jsx(BaseInput, {
    ...rest,
    prefixCls,
    className,
    inputElement: getInputElement(),
    handleReset,
    value: fixControlledValue(value),
    focused,
    triggerFocus: focus,
    suffix: getSuffix(),
    disabled,
    classes
  });
});
function useRemovePasswordTimeout(inputRef, triggerOnMount) {
  const removePasswordTimeoutRef = react.exports.useRef([]);
  const removePasswordTimeout = () => {
    removePasswordTimeoutRef.current.push(setTimeout(() => {
      var _a, _b, _c, _d;
      if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute("type")) === "password" && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute("value"))) {
        (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute("value");
      }
    }));
  };
  react.exports.useEffect(() => {
    if (triggerOnMount) {
      removePasswordTimeout();
    }
    return () => removePasswordTimeoutRef.current.forEach((timer) => {
      if (timer) {
        clearTimeout(timer);
      }
    });
  }, []);
  return removePasswordTimeout;
}
function hasPrefixSuffix(props) {
  return !!(props.prefix || props.suffix || props.allowClear);
}
var __rest$e = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function triggerFocus(element, option) {
  if (!element) {
    return;
  }
  element.focus(option);
  const {
    cursor
  } = option || {};
  if (cursor) {
    const len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
        break;
    }
  }
}
const Input$2 = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    bordered = true,
    status: customStatus,
    size: customSize,
    disabled: customDisabled,
    onBlur: onBlur2,
    onFocus: onFocus2,
    suffix,
    allowClear,
    addonAfter,
    addonBefore,
    className,
    rootClassName,
    onChange: onChange2
  } = props, rest = __rest$e(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "rootClassName", "onChange"]);
  const {
    getPrefixCls,
    direction,
    input
  } = React.useContext(ConfigContext);
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  const inputRef = react.exports.useRef(null);
  const [wrapSSR, hashId] = useStyle$c(prefixCls);
  const {
    compactSize,
    compactItemClassnames
  } = useCompactItemContext(prefixCls, direction);
  const size = React.useContext(SizeContext$2);
  const mergedSize = compactSize || customSize || size;
  const disabled = React.useContext(DisabledContext);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = react.exports.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
  const prevHasPrefixSuffix = react.exports.useRef(inputHasPrefixSuffix);
  react.exports.useEffect(() => {
    if (inputHasPrefixSuffix && !prevHasPrefixSuffix.current)
      ;
    prevHasPrefixSuffix.current = inputHasPrefixSuffix;
  }, [inputHasPrefixSuffix]);
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
  const handleBlur = (e2) => {
    removePasswordTimeout();
    onBlur2 === null || onBlur2 === void 0 ? void 0 : onBlur2(e2);
  };
  const handleFocus = (e2) => {
    removePasswordTimeout();
    onFocus2 === null || onFocus2 === void 0 ? void 0 : onFocus2(e2);
  };
  const handleChange = (e2) => {
    removePasswordTimeout();
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(e2);
  };
  const suffixNode = (hasFeedback || suffix) && /* @__PURE__ */ jsxs(Fragment, {
    children: [suffix, hasFeedback && feedbackIcon]
  });
  let mergedAllowClear;
  if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: /* @__PURE__ */ jsx(CloseCircleFilled$1, {})
    };
  }
  return wrapSSR(
    /* @__PURE__ */ jsx(Input$3, {
      ...Object.assign({
        ref: composeRef(ref, inputRef),
        prefixCls,
        autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
      }, rest, {
        disabled: mergedDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        suffix: suffixNode,
        allowClear: mergedAllowClear,
        className: classNames(className, rootClassName, compactItemClassnames),
        onChange: handleChange,
        addonAfter: addonAfter && /* @__PURE__ */ jsx(NoCompactStyle, {
          children: /* @__PURE__ */ jsx(NoFormStyle, {
            override: true,
            status: true,
            children: addonAfter
          })
        }),
        addonBefore: addonBefore && /* @__PURE__ */ jsx(NoCompactStyle, {
          children: /* @__PURE__ */ jsx(NoFormStyle, {
            override: true,
            status: true,
            children: addonBefore
          })
        }),
        classes: {
          input: classNames({
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large",
            [`${prefixCls}-rtl`]: direction === "rtl",
            [`${prefixCls}-borderless`]: !bordered
          }, !inputHasPrefixSuffix && getStatusClassNames(prefixCls, mergedStatus), hashId),
          affixWrapper: classNames({
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered
          }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus, hasFeedback), hashId),
          wrapper: classNames({
            [`${prefixCls}-group-rtl`]: direction === "rtl"
          }, hashId),
          group: classNames({
            [`${prefixCls}-group-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-group-wrapper-lg`]: mergedSize === "large",
            [`${prefixCls}-group-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-group-wrapper-disabled`]: mergedDisabled
          }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
        }
      })
    })
  );
});
const InternalInput = Input$2;
var EyeInvisibleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };
const EyeInvisibleOutlinedSvg = EyeInvisibleOutlined$2;
var EyeInvisibleOutlined = function EyeInvisibleOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: EyeInvisibleOutlinedSvg
    })
  });
};
EyeInvisibleOutlined.displayName = "EyeInvisibleOutlined";
const EyeInvisibleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EyeInvisibleOutlined);
var __rest$d = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const defaultIconRender = (visible) => visible ? /* @__PURE__ */ jsx(EyeOutlined$1, {}) : /* @__PURE__ */ jsx(EyeInvisibleOutlined$1, {});
const ActionMap = {
  click: "onClick",
  hover: "onMouseOver"
};
const Password = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    visibilityToggle = true
  } = props;
  const visibilityControlled = typeof visibilityToggle === "object" && visibilityToggle.visible !== void 0;
  const [visible, setVisible] = react.exports.useState(() => visibilityControlled ? visibilityToggle.visible : false);
  const inputRef = react.exports.useRef(null);
  react.exports.useEffect(() => {
    if (visibilityControlled) {
      setVisible(visibilityToggle.visible);
    }
  }, [visibilityControlled, visibilityToggle]);
  const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
  const onVisibleChange = () => {
    const {
      disabled
    } = props;
    if (disabled) {
      return;
    }
    if (visible) {
      removePasswordTimeout();
    }
    setVisible((prevState) => {
      var _a;
      const newState = !prevState;
      if (typeof visibilityToggle === "object") {
        (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, newState);
      }
      return newState;
    });
  };
  const getIcon = (prefixCls2) => {
    const {
      action = "click",
      iconRender = defaultIconRender
    } = props;
    const iconTrigger = ActionMap[action] || "";
    const icon = iconRender(visible);
    const iconProps = {
      [iconTrigger]: onVisibleChange,
      className: `${prefixCls2}-icon`,
      key: "passwordIcon",
      onMouseDown: (e2) => {
        e2.preventDefault();
      },
      onMouseUp: (e2) => {
        e2.preventDefault();
      }
    };
    return /* @__PURE__ */ react.exports.cloneElement(/* @__PURE__ */ react.exports.isValidElement(icon) ? icon : /* @__PURE__ */ jsx("span", {
      children: icon
    }), iconProps);
  };
  const {
    className,
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    size
  } = props, restProps = __rest$d(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const prefixCls = getPrefixCls("input-password", customizePrefixCls);
  const suffixIcon = visibilityToggle && getIcon(prefixCls);
  const inputClassName = classNames(prefixCls, className, {
    [`${prefixCls}-${size}`]: !!size
  });
  const omittedProps = Object.assign(Object.assign({}, omit(restProps, ["suffix", "iconRender", "visibilityToggle"])), {
    type: visible ? "text" : "password",
    className: inputClassName,
    prefixCls: inputPrefixCls,
    suffix: suffixIcon
  });
  if (size) {
    omittedProps.size = size;
  }
  return /* @__PURE__ */ jsx(InternalInput, {
    ...Object.assign({
      ref: composeRef(ref, inputRef)
    }, omittedProps)
  });
});
const Password$1 = Password;
var __rest$c = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Search = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    prefixCls: customizePrefixCls,
    inputPrefixCls: customizeInputPrefixCls,
    className,
    size: customizeSize,
    suffix,
    enterButton = false,
    addonAfter,
    loading,
    disabled,
    onSearch: customOnSearch,
    onChange: customOnChange,
    onCompositionStart,
    onCompositionEnd
  } = props, restProps = __rest$c(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const contextSize = react.exports.useContext(SizeContext$2);
  const composedRef = react.exports.useRef(false);
  const prefixCls = getPrefixCls("input-search", customizePrefixCls);
  const inputPrefixCls = getPrefixCls("input", customizeInputPrefixCls);
  const {
    compactSize
  } = useCompactItemContext(prefixCls, direction);
  const size = compactSize || customizeSize || contextSize;
  const inputRef = react.exports.useRef(null);
  const onChange2 = (e2) => {
    if (e2 && e2.target && e2.type === "click" && customOnSearch) {
      customOnSearch(e2.target.value, e2);
    }
    if (customOnChange) {
      customOnChange(e2);
    }
  };
  const onMouseDown = (e2) => {
    var _a;
    if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
      e2.preventDefault();
    }
  };
  const onSearch = (e2) => {
    var _a, _b;
    if (customOnSearch) {
      customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e2);
    }
  };
  const onPressEnter = (e2) => {
    if (composedRef.current || loading) {
      return;
    }
    onSearch(e2);
  };
  const searchIcon = typeof enterButton === "boolean" ? /* @__PURE__ */ jsx(SearchOutlined$1, {}) : null;
  const btnClassName = `${prefixCls}-button`;
  let button;
  const enterButtonAsElement = enterButton || {};
  const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
  if (isAntdButton || enterButtonAsElement.type === "button") {
    button = cloneElement(enterButtonAsElement, Object.assign({
      onMouseDown,
      onClick: (e2) => {
        var _a, _b;
        (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e2);
        onSearch(e2);
      },
      key: "enterButton"
    }, isAntdButton ? {
      className: btnClassName,
      size
    } : {}));
  } else {
    button = /* @__PURE__ */ jsx(Button$1, {
      className: btnClassName,
      type: enterButton ? "primary" : void 0,
      size,
      disabled,
      onMouseDown,
      onClick: onSearch,
      loading,
      icon: searchIcon,
      children: enterButton
    }, "enterButton");
  }
  if (addonAfter) {
    button = [button, cloneElement(addonAfter, {
      key: "addonAfter"
    })];
  }
  const cls = classNames(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl",
    [`${prefixCls}-${size}`]: !!size,
    [`${prefixCls}-with-button`]: !!enterButton
  }, className);
  const handleOnCompositionStart = (e2) => {
    composedRef.current = true;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
  };
  const handleOnCompositionEnd = (e2) => {
    composedRef.current = false;
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
  };
  return /* @__PURE__ */ jsx(InternalInput, {
    ...Object.assign({
      ref: composeRef(inputRef, ref),
      onPressEnter
    }, restProps, {
      size,
      onCompositionStart: handleOnCompositionStart,
      onCompositionEnd: handleOnCompositionEnd,
      prefixCls: inputPrefixCls,
      addonAfter: button,
      suffix,
      onChange: onChange2,
      className: cls,
      disabled
    })
  });
});
const Search$1 = Search;
var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
var SIZING_STYLE = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"];
var computedStyleCache = {};
var hiddenTextarea;
function calculateNodeStyling(node2) {
  var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var nodeRef = node2.getAttribute("id") || node2.getAttribute("data-reactid") || node2.getAttribute("name");
  if (useCache && computedStyleCache[nodeRef]) {
    return computedStyleCache[nodeRef];
  }
  var style2 = window.getComputedStyle(node2);
  var boxSizing = style2.getPropertyValue("box-sizing") || style2.getPropertyValue("-moz-box-sizing") || style2.getPropertyValue("-webkit-box-sizing");
  var paddingSize = parseFloat(style2.getPropertyValue("padding-bottom")) + parseFloat(style2.getPropertyValue("padding-top"));
  var borderSize = parseFloat(style2.getPropertyValue("border-bottom-width")) + parseFloat(style2.getPropertyValue("border-top-width"));
  var sizingStyle = SIZING_STYLE.map(function(name2) {
    return "".concat(name2, ":").concat(style2.getPropertyValue(name2));
  }).join(";");
  var nodeInfo = {
    sizingStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
  if (useCache && nodeRef) {
    computedStyleCache[nodeRef] = nodeInfo;
  }
  return nodeInfo;
}
function calculateAutoSizeStyle(uiTextNode) {
  var useCache = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var minRows = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
  var maxRows = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tab-index", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    document.body.appendChild(hiddenTextarea);
  }
  if (uiTextNode.getAttribute("wrap")) {
    hiddenTextarea.setAttribute("wrap", uiTextNode.getAttribute("wrap"));
  } else {
    hiddenTextarea.removeAttribute("wrap");
  }
  var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache), paddingSize = _calculateNodeStyling.paddingSize, borderSize = _calculateNodeStyling.borderSize, boxSizing = _calculateNodeStyling.boxSizing, sizingStyle = _calculateNodeStyling.sizingStyle;
  hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
  hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || "";
  var minHeight = void 0;
  var maxHeight = void 0;
  var overflowY;
  var height = hiddenTextarea.scrollHeight;
  if (boxSizing === "border-box") {
    height += borderSize;
  } else if (boxSizing === "content-box") {
    height -= paddingSize;
  }
  if (minRows !== null || maxRows !== null) {
    hiddenTextarea.value = " ";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    if (minRows !== null) {
      minHeight = singleRowHeight * minRows;
      if (boxSizing === "border-box") {
        minHeight = minHeight + paddingSize + borderSize;
      }
      height = Math.max(minHeight, height);
    }
    if (maxRows !== null) {
      maxHeight = singleRowHeight * maxRows;
      if (boxSizing === "border-box") {
        maxHeight = maxHeight + paddingSize + borderSize;
      }
      overflowY = height > maxHeight ? "" : "hidden";
      height = Math.min(maxHeight, height);
    }
  }
  var style2 = {
    height,
    overflowY,
    resize: "none"
  };
  if (minHeight) {
    style2.minHeight = minHeight;
  }
  if (maxHeight) {
    style2.maxHeight = maxHeight;
  }
  return style2;
}
var _excluded$4 = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
var RESIZE_START = 0;
var RESIZE_MEASURING = 1;
var RESIZE_STABLE = 2;
var ResizableTextArea = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _ref = props, prefixCls = _ref.prefixCls;
  _ref.onPressEnter;
  var defaultValue = _ref.defaultValue, value = _ref.value, autoSize = _ref.autoSize, onResize2 = _ref.onResize, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, onChange2 = _ref.onChange;
  _ref.onInternalAutoSize;
  var restProps = _objectWithoutProperties(_ref, _excluded$4);
  var _useMergedState = useMergedState(defaultValue, {
    value,
    postState: function postState(val) {
      return val !== null && val !== void 0 ? val : "";
    }
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), mergedValue = _useMergedState2[0], setMergedValue = _useMergedState2[1];
  var onInternalChange = function onInternalChange2(event) {
    setMergedValue(event.target.value);
    onChange2 === null || onChange2 === void 0 ? void 0 : onChange2(event);
  };
  var textareaRef = react.exports.useRef();
  react.exports.useImperativeHandle(ref, function() {
    return {
      textArea: textareaRef.current
    };
  });
  var _React$useMemo = react.exports.useMemo(function() {
    if (autoSize && _typeof$1(autoSize) === "object") {
      return [autoSize.minRows, autoSize.maxRows];
    }
    return [];
  }, [autoSize]), _React$useMemo2 = _slicedToArray(_React$useMemo, 2), minRows = _React$useMemo2[0], maxRows = _React$useMemo2[1];
  var needAutoSize = !!autoSize;
  var fixFirefoxAutoScroll = function fixFirefoxAutoScroll2() {
    try {
      if (document.activeElement === textareaRef.current) {
        var _textareaRef$current = textareaRef.current, selectionStart = _textareaRef$current.selectionStart, selectionEnd = _textareaRef$current.selectionEnd, scrollTop = _textareaRef$current.scrollTop;
        textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
        textareaRef.current.scrollTop = scrollTop;
      }
    } catch (e2) {
    }
  };
  var _React$useState = react.exports.useState(RESIZE_STABLE), _React$useState2 = _slicedToArray(_React$useState, 2), resizeState = _React$useState2[0], setResizeState = _React$useState2[1];
  var _React$useState3 = react.exports.useState(), _React$useState4 = _slicedToArray(_React$useState3, 2), autoSizeStyle = _React$useState4[0], setAutoSizeStyle = _React$useState4[1];
  var startResize = function startResize2() {
    setResizeState(RESIZE_START);
  };
  useLayoutEffect(function() {
    if (needAutoSize) {
      startResize();
    }
  }, [value, minRows, maxRows, needAutoSize]);
  useLayoutEffect(function() {
    if (resizeState === RESIZE_START) {
      setResizeState(RESIZE_MEASURING);
    } else if (resizeState === RESIZE_MEASURING) {
      var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);
      setResizeState(RESIZE_STABLE);
      setAutoSizeStyle(textareaStyles);
    } else {
      fixFirefoxAutoScroll();
    }
  }, [resizeState]);
  var resizeRafRef = react.exports.useRef();
  var cleanRaf = function cleanRaf2() {
    wrapperRaf.cancel(resizeRafRef.current);
  };
  var onInternalResize = function onInternalResize2(size) {
    if (resizeState === RESIZE_STABLE) {
      onResize2 === null || onResize2 === void 0 ? void 0 : onResize2(size);
      if (autoSize) {
        cleanRaf();
        resizeRafRef.current = wrapperRaf(function() {
          startResize();
        });
      }
    }
  };
  react.exports.useEffect(function() {
    return cleanRaf;
  }, []);
  var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
  var mergedStyle = _objectSpread2$1(_objectSpread2$1({}, style2), mergedAutoSizeStyle);
  if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
    mergedStyle.overflowY = "hidden";
    mergedStyle.overflowX = "hidden";
  }
  return /* @__PURE__ */ jsx(RefResizeObserver, {
    onResize: onInternalResize,
    disabled: !(autoSize || onResize2),
    children: /* @__PURE__ */ jsx("textarea", {
      ...restProps,
      ref: textareaRef,
      style: mergedStyle,
      className: classNames(prefixCls, className, _defineProperty$1({}, "".concat(prefixCls, "-disabled"), disabled)),
      disabled,
      value: mergedValue,
      onChange: onInternalChange
    })
  });
});
var _excluded$3 = ["defaultValue", "value", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "classes", "showCount", "className", "style", "disabled"];
function fixEmojiLength(value, maxLength) {
  return _toConsumableArray(value || "").slice(0, maxLength).join("");
}
function setTriggerValue(isCursorInEnd, preValue, triggerValue, maxLength) {
  var newTriggerValue = triggerValue;
  if (isCursorInEnd) {
    newTriggerValue = fixEmojiLength(triggerValue, maxLength);
  } else if (_toConsumableArray(preValue || "").length < triggerValue.length && _toConsumableArray(triggerValue || "").length > maxLength) {
    newTriggerValue = preValue;
  }
  return newTriggerValue;
}
var TextArea$2 = /* @__PURE__ */ React.forwardRef(function(_ref, ref) {
  var defaultValue = _ref.defaultValue, customValue = _ref.value, onChange2 = _ref.onChange, allowClear = _ref.allowClear, maxLength = _ref.maxLength, onCompositionStart = _ref.onCompositionStart, onCompositionEnd = _ref.onCompositionEnd, suffix = _ref.suffix, _ref$prefixCls = _ref.prefixCls, prefixCls = _ref$prefixCls === void 0 ? "rc-textarea" : _ref$prefixCls, classes = _ref.classes, showCount = _ref.showCount, className = _ref.className, style2 = _ref.style, disabled = _ref.disabled, rest = _objectWithoutProperties(_ref, _excluded$3);
  var _useMergedState = useMergedState(defaultValue, {
    value: customValue,
    defaultValue
  }), _useMergedState2 = _slicedToArray(_useMergedState, 2), value = _useMergedState2[0], setValue2 = _useMergedState2[1];
  var resizableTextAreaRef = react.exports.useRef(null);
  var _React$useState = React.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), compositing = _React$useState2[0], setCompositing = _React$useState2[1];
  var oldCompositionValueRef = React.useRef();
  var oldSelectionStartRef = React.useRef(0);
  var focus = function focus2() {
    resizableTextAreaRef.current.textArea.focus();
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      resizableTextArea: resizableTextAreaRef.current,
      focus,
      blur: function blur() {
        resizableTextAreaRef.current.textArea.blur();
      }
    };
  });
  var hasMaxLength = Number(maxLength) > 0;
  var onInternalCompositionStart = function onInternalCompositionStart2(e2) {
    setCompositing(true);
    oldCompositionValueRef.current = value;
    oldSelectionStartRef.current = e2.currentTarget.selectionStart;
    onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e2);
  };
  var onInternalCompositionEnd = function onInternalCompositionEnd2(e2) {
    setCompositing(false);
    var triggerValue = e2.currentTarget.value;
    if (hasMaxLength) {
      var _oldCompositionValueR;
      var isCursorInEnd = oldSelectionStartRef.current >= maxLength + 1 || oldSelectionStartRef.current === ((_oldCompositionValueR = oldCompositionValueRef.current) === null || _oldCompositionValueR === void 0 ? void 0 : _oldCompositionValueR.length);
      triggerValue = setTriggerValue(isCursorInEnd, oldCompositionValueRef.current, triggerValue, maxLength);
    }
    if (triggerValue !== value) {
      setValue2(triggerValue);
      resolveOnChange(e2.currentTarget, e2, onChange2, triggerValue);
    }
    onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e2);
  };
  var handleChange = function handleChange2(e2) {
    var triggerValue = e2.target.value;
    if (!compositing && hasMaxLength) {
      var isCursorInEnd = e2.target.selectionStart >= maxLength + 1 || e2.target.selectionStart === triggerValue.length || !e2.target.selectionStart;
      triggerValue = setTriggerValue(isCursorInEnd, value, triggerValue, maxLength);
    }
    setValue2(triggerValue);
    resolveOnChange(e2.currentTarget, e2, onChange2, triggerValue);
  };
  var handleKeyDown = function handleKeyDown2(e2) {
    var onPressEnter = rest.onPressEnter, onKeyDown2 = rest.onKeyDown;
    if (e2.key === "Enter" && onPressEnter) {
      onPressEnter(e2);
    }
    onKeyDown2 === null || onKeyDown2 === void 0 ? void 0 : onKeyDown2(e2);
  };
  var handleReset = function handleReset2(e2) {
    setValue2("");
    focus();
    resolveOnChange(resizableTextAreaRef.current.textArea, e2, onChange2);
  };
  var val = fixControlledValue(value);
  if (!compositing && hasMaxLength && (customValue === null || customValue === void 0)) {
    val = fixEmojiLength(val, maxLength);
  }
  var textarea = /* @__PURE__ */ jsx(BaseInput, {
    value: val,
    allowClear,
    handleReset,
    suffix,
    prefixCls,
    classes: {
      affixWrapper: classes === null || classes === void 0 ? void 0 : classes.affixWrapper
    },
    disabled,
    style: style2,
    inputStyle: {
      resize: style2 === null || style2 === void 0 ? void 0 : style2.resize
    },
    inputElement: /* @__PURE__ */ jsx(ResizableTextArea, {
      ...rest,
      onKeyDown: handleKeyDown,
      onChange: handleChange,
      onCompositionStart: onInternalCompositionStart,
      onCompositionEnd: onInternalCompositionEnd,
      className: classNames(showCount ? "" : className, classes === null || classes === void 0 ? void 0 : classes.textarea),
      style: !showCount && style2,
      disabled,
      prefixCls,
      ref: resizableTextAreaRef
    })
  });
  if (showCount) {
    var valueLength = _toConsumableArray(val).length;
    var dataCount;
    if (_typeof$1(showCount) === "object") {
      dataCount = showCount.formatter({
        value: val,
        count: valueLength,
        maxLength
      });
    } else {
      dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(maxLength) : "");
    }
    return /* @__PURE__ */ jsxs("div", {
      hidden: rest.hidden,
      className: classNames("".concat(prefixCls, "-show-count"), className, classes === null || classes === void 0 ? void 0 : classes.countWrapper),
      style: style2,
      "data-count": dataCount,
      children: [textarea, /* @__PURE__ */ jsx("span", {
        className: "".concat(prefixCls, "-data-count"),
        children: dataCount
      })]
    });
  }
  return textarea;
});
var __rest$b = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const TextArea = /* @__PURE__ */ react.exports.forwardRef((_a, ref) => {
  var {
    prefixCls: customizePrefixCls,
    bordered = true,
    size: customizeSize,
    disabled: customDisabled,
    status: customStatus,
    allowClear
  } = _a, rest = __rest$b(_a, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const size = react.exports.useContext(SizeContext$2);
  const mergedSize = customizeSize || size;
  const disabled = react.exports.useContext(DisabledContext);
  const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
  const {
    status: contextStatus,
    hasFeedback,
    feedbackIcon
  } = react.exports.useContext(FormItemInputContext);
  const mergedStatus = getMergedStatus(contextStatus, customStatus);
  const innerRef = react.exports.useRef(null);
  react.exports.useImperativeHandle(ref, () => {
    var _a2;
    return {
      resizableTextArea: (_a2 = innerRef.current) === null || _a2 === void 0 ? void 0 : _a2.resizableTextArea,
      focus: (option) => {
        var _a3, _b;
        triggerFocus((_b = (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
      },
      blur: () => {
        var _a3;
        return (_a3 = innerRef.current) === null || _a3 === void 0 ? void 0 : _a3.blur();
      }
    };
  });
  const prefixCls = getPrefixCls("input", customizePrefixCls);
  let mergedAllowClear;
  if (typeof allowClear === "object" && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
    mergedAllowClear = allowClear;
  } else if (allowClear) {
    mergedAllowClear = {
      clearIcon: /* @__PURE__ */ jsx(CloseCircleFilled$1, {})
    };
  }
  const [wrapSSR, hashId] = useStyle$c(prefixCls);
  return wrapSSR(
    /* @__PURE__ */ jsx(TextArea$2, {
      ...Object.assign({}, rest, {
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        classes: {
          affixWrapper: classNames(`${prefixCls}-textarea-affix-wrapper`, {
            [`${prefixCls}-affix-wrapper-rtl`]: direction === "rtl",
            [`${prefixCls}-affix-wrapper-borderless`]: !bordered,
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === "small",
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === "large"
          }, getStatusClassNames(`${prefixCls}-affix-wrapper`, mergedStatus), hashId),
          countWrapper: classNames(`${prefixCls}-textarea`, `${prefixCls}-textarea-show-count`, hashId),
          textarea: classNames({
            [`${prefixCls}-borderless`]: !bordered,
            [`${prefixCls}-sm`]: mergedSize === "small",
            [`${prefixCls}-lg`]: mergedSize === "large"
          }, getStatusClassNames(prefixCls, mergedStatus), hashId)
        },
        prefixCls,
        suffix: hasFeedback && /* @__PURE__ */ jsx("span", {
          className: `${prefixCls}-textarea-suffix`,
          children: feedbackIcon
        }),
        ref: innerRef
      })
    })
  );
});
const TextArea$1 = TextArea;
const Input = InternalInput;
Input.Group = Group$1;
Input.Search = Search$1;
Input.TextArea = TextArea$1;
Input.Password = Password$1;
const Input$1 = Input;
const Layout = Layout$2;
Layout.Header = Header$2;
Layout.Footer = Footer$1;
Layout.Content = Content$1;
Layout.Sider = Sider$2;
const Layout$1 = Layout;
const antSpinMove = new Keyframe("antSpinMove", {
  to: {
    opacity: 1
  }
});
const antRotate = new Keyframe("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
});
const genSpinStyle = (token2) => ({
  [`${token2.componentCls}`]: Object.assign(Object.assign({}, resetComponent(token2)), {
    position: "absolute",
    display: "none",
    color: token2.colorPrimary,
    textAlign: "center",
    verticalAlign: "middle",
    opacity: 0,
    transition: `transform ${token2.motionDurationSlow} ${token2.motionEaseInOutCirc}`,
    "&-spinning": {
      position: "static",
      display: "inline-block",
      opacity: 1
    },
    "&-nested-loading": {
      position: "relative",
      [`> div > ${token2.componentCls}`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        zIndex: 4,
        display: "block",
        width: "100%",
        height: "100%",
        maxHeight: token2.contentHeight,
        [`${token2.componentCls}-dot`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "50%",
          margin: -token2.spinDotSize / 2
        },
        [`${token2.componentCls}-text`]: {
          position: "absolute",
          top: "50%",
          width: "100%",
          paddingTop: (token2.spinDotSize - token2.fontSize) / 2 + 2,
          textShadow: `0 1px 2px ${token2.colorBgContainer}`
        },
        [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
          marginTop: -(token2.spinDotSize / 2) - 10
        },
        "&-sm": {
          [`${token2.componentCls}-dot`]: {
            margin: -token2.spinDotSizeSM / 2
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeSM - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeSM / 2) - 10
          }
        },
        "&-lg": {
          [`${token2.componentCls}-dot`]: {
            margin: -(token2.spinDotSizeLG / 2)
          },
          [`${token2.componentCls}-text`]: {
            paddingTop: (token2.spinDotSizeLG - token2.fontSize) / 2 + 2
          },
          [`&${token2.componentCls}-show-text ${token2.componentCls}-dot`]: {
            marginTop: -(token2.spinDotSizeLG / 2) - 10
          }
        }
      },
      [`${token2.componentCls}-container`]: {
        position: "relative",
        transition: `opacity ${token2.motionDurationSlow}`,
        "&::after": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          height: "100%",
          background: token2.colorBgContainer,
          opacity: 0,
          transition: `all ${token2.motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        }
      },
      [`${token2.componentCls}-blur`]: {
        clear: "both",
        opacity: 0.5,
        userSelect: "none",
        pointerEvents: "none",
        [`&::after`]: {
          opacity: 0.4,
          pointerEvents: "auto"
        }
      }
    },
    [`&-tip`]: {
      color: token2.spinDotDefault
    },
    [`${token2.componentCls}-dot`]: {
      position: "relative",
      display: "inline-block",
      fontSize: token2.spinDotSize,
      width: "1em",
      height: "1em",
      "&-item": {
        position: "absolute",
        display: "block",
        width: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSize - token2.marginXXS / 2) / 2,
        backgroundColor: token2.colorPrimary,
        borderRadius: "100%",
        transform: "scale(0.75)",
        transformOrigin: "50% 50%",
        opacity: 0.3,
        animationName: antSpinMove,
        animationDuration: "1s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear",
        animationDirection: "alternate",
        "&:nth-child(1)": {
          top: 0,
          insetInlineStart: 0
        },
        "&:nth-child(2)": {
          top: 0,
          insetInlineEnd: 0,
          animationDelay: "0.4s"
        },
        "&:nth-child(3)": {
          insetInlineEnd: 0,
          bottom: 0,
          animationDelay: "0.8s"
        },
        "&:nth-child(4)": {
          bottom: 0,
          insetInlineStart: 0,
          animationDelay: "1.2s"
        }
      },
      "&-spin": {
        transform: "rotate(45deg)",
        animationName: antRotate,
        animationDuration: "1.2s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      }
    },
    [`&-sm ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeSM,
      i: {
        width: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2,
        height: (token2.spinDotSizeSM - token2.marginXXS / 2) / 2
      }
    },
    [`&-lg ${token2.componentCls}-dot`]: {
      fontSize: token2.spinDotSizeLG,
      i: {
        width: (token2.spinDotSizeLG - token2.marginXXS) / 2,
        height: (token2.spinDotSizeLG - token2.marginXXS) / 2
      }
    },
    [`&${token2.componentCls}-show-text ${token2.componentCls}-text`]: {
      display: "block"
    }
  })
});
const useStyle$3 = genComponentStyleHook("Spin", (token2) => {
  const spinToken = merge(token2, {
    spinDotDefault: token2.colorTextDescription,
    spinDotSize: token2.controlHeightLG / 2,
    spinDotSizeSM: token2.controlHeightLG * 0.35,
    spinDotSizeLG: token2.controlHeight
  });
  return [genSpinStyle(spinToken)];
}, {
  contentHeight: 400
});
var __rest$a = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
let defaultIndicator = null;
function renderIndicator(prefixCls, props) {
  const {
    indicator
  } = props;
  const dotClassName = `${prefixCls}-dot`;
  if (indicator === null) {
    return null;
  }
  if (isValidElement(indicator)) {
    return cloneElement(indicator, {
      className: classNames(indicator.props.className, dotClassName)
    });
  }
  if (isValidElement(defaultIndicator)) {
    return cloneElement(defaultIndicator, {
      className: classNames(defaultIndicator.props.className, dotClassName)
    });
  }
  return /* @__PURE__ */ jsxs("span", {
    className: classNames(dotClassName, `${prefixCls}-dot-spin`),
    children: [/* @__PURE__ */ jsx("i", {
      className: `${prefixCls}-dot-item`
    }), /* @__PURE__ */ jsx("i", {
      className: `${prefixCls}-dot-item`
    }), /* @__PURE__ */ jsx("i", {
      className: `${prefixCls}-dot-item`
    }), /* @__PURE__ */ jsx("i", {
      className: `${prefixCls}-dot-item`
    })]
  });
}
function shouldDelay(spinning, delay) {
  return !!spinning && !!delay && !isNaN(Number(delay));
}
const Spin = (props) => {
  const {
    spinPrefixCls: prefixCls,
    spinning: customSpinning = true,
    delay = 0,
    className,
    rootClassName,
    size = "default",
    tip,
    wrapperClassName,
    style: style2,
    children,
    hashId
  } = props, restProps = __rest$a(props, ["spinPrefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "hashId"]);
  const [spinning, setSpinning] = react.exports.useState(() => customSpinning && !shouldDelay(customSpinning, delay));
  react.exports.useEffect(() => {
    if (customSpinning) {
      const showSpinning = debounce(delay, () => {
        setSpinning(true);
      });
      showSpinning();
      return () => {
        var _a;
        (_a = showSpinning === null || showSpinning === void 0 ? void 0 : showSpinning.cancel) === null || _a === void 0 ? void 0 : _a.call(showSpinning);
      };
    }
    setSpinning(false);
  }, [delay, customSpinning]);
  const isNestedPattern = react.exports.useMemo(() => typeof children !== "undefined", [children]);
  const {
    direction
  } = react.exports.useContext(ConfigContext);
  const spinClassName = classNames(prefixCls, {
    [`${prefixCls}-sm`]: size === "small",
    [`${prefixCls}-lg`]: size === "large",
    [`${prefixCls}-spinning`]: spinning,
    [`${prefixCls}-show-text`]: !!tip,
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  const containerClassName = classNames(`${prefixCls}-container`, {
    [`${prefixCls}-blur`]: spinning
  });
  const divProps = omit(restProps, ["indicator", "prefixCls"]);
  const spinElement = /* @__PURE__ */ jsxs("div", {
    ...Object.assign({}, divProps, {
      style: style2,
      className: spinClassName,
      "aria-live": "polite",
      "aria-busy": spinning
    }),
    children: [renderIndicator(prefixCls, props), tip ? /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-text`,
      children: tip
    }) : null]
  });
  if (isNestedPattern) {
    return /* @__PURE__ */ jsxs("div", {
      ...Object.assign({}, divProps, {
        className: classNames(`${prefixCls}-nested-loading`, wrapperClassName, hashId)
      }),
      children: [spinning && /* @__PURE__ */ jsx("div", {
        children: spinElement
      }, "loading"), /* @__PURE__ */ jsx("div", {
        className: containerClassName,
        children
      }, "container")]
    });
  }
  return spinElement;
};
const SpinFC = (props) => {
  const {
    prefixCls: customizePrefixCls
  } = props;
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const spinPrefixCls = getPrefixCls("spin", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle$3(spinPrefixCls);
  const spinClassProps = Object.assign(Object.assign({}, props), {
    spinPrefixCls,
    hashId
  });
  return wrapSSR(
    /* @__PURE__ */ jsx(Spin, {
      ...Object.assign({}, spinClassProps)
    })
  );
};
SpinFC.setDefaultIndicator = (indicator) => {
  defaultIndicator = indicator;
};
const Spin$1 = SpinFC;
var Notify = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var prefixCls = props.prefixCls, style2 = props.style, className = props.className, _props$duration = props.duration, duration = _props$duration === void 0 ? 4.5 : _props$duration, eventKey = props.eventKey, content = props.content, closable = props.closable, _props$closeIcon = props.closeIcon, closeIcon = _props$closeIcon === void 0 ? "x" : _props$closeIcon, divProps = props.props, onClick = props.onClick, onNoticeClose = props.onNoticeClose, times = props.times;
  var _React$useState = react.exports.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), hovering = _React$useState2[0], setHovering = _React$useState2[1];
  var onInternalClose = function onInternalClose2() {
    onNoticeClose(eventKey);
  };
  react.exports.useEffect(function() {
    if (!hovering && duration > 0) {
      var timeout = setTimeout(function() {
        onInternalClose();
      }, duration * 1e3);
      return function() {
        clearTimeout(timeout);
      };
    }
  }, [duration, hovering, times]);
  var noticePrefixCls = "".concat(prefixCls, "-notice");
  return /* @__PURE__ */ jsxs("div", {
    ...divProps,
    ref,
    className: classNames(noticePrefixCls, className, _defineProperty$1({}, "".concat(noticePrefixCls, "-closable"), closable)),
    style: style2,
    onMouseEnter: function onMouseEnter() {
      setHovering(true);
    },
    onMouseLeave: function onMouseLeave() {
      setHovering(false);
    },
    onClick,
    children: [/* @__PURE__ */ jsx("div", {
      className: "".concat(noticePrefixCls, "-content"),
      children: content
    }), closable && /* @__PURE__ */ jsx("a", {
      tabIndex: 0,
      className: "".concat(noticePrefixCls, "-close"),
      onClick: function onClick2(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        onInternalClose();
      },
      children: closeIcon
    })]
  });
});
const Notice = Notify;
var Notifications = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-notification" : _props$prefixCls, container = props.container, motion2 = props.motion, maxCount = props.maxCount, className = props.className, style2 = props.style, onAllRemoved = props.onAllRemoved;
  var _React$useState = react.exports.useState([]), _React$useState2 = _slicedToArray(_React$useState, 2), configList = _React$useState2[0], setConfigList = _React$useState2[1];
  var onNoticeClose = function onNoticeClose2(key) {
    var _config$onClose;
    var config = configList.find(function(item) {
      return item.key === key;
    });
    config === null || config === void 0 ? void 0 : (_config$onClose = config.onClose) === null || _config$onClose === void 0 ? void 0 : _config$onClose.call(config);
    setConfigList(function(list) {
      return list.filter(function(item) {
        return item.key !== key;
      });
    });
  };
  react.exports.useImperativeHandle(ref, function() {
    return {
      open: function open2(config) {
        setConfigList(function(list) {
          var clone2 = _toConsumableArray(list);
          var index2 = clone2.findIndex(function(item) {
            return item.key === config.key;
          });
          var innerConfig = _objectSpread2$1({}, config);
          if (index2 >= 0) {
            var _list$index;
            innerConfig.times = (((_list$index = list[index2]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
            clone2[index2] = innerConfig;
          } else {
            innerConfig.times = 0;
            clone2.push(innerConfig);
          }
          if (maxCount > 0 && clone2.length > maxCount) {
            clone2 = clone2.slice(-maxCount);
          }
          return clone2;
        });
      },
      close: function close(key) {
        onNoticeClose(key);
      },
      destroy: function destroy2() {
        setConfigList([]);
      }
    };
  });
  var _React$useState3 = react.exports.useState({}), _React$useState4 = _slicedToArray(_React$useState3, 2), placements2 = _React$useState4[0], setPlacements = _React$useState4[1];
  react.exports.useEffect(function() {
    var nextPlacements = {};
    configList.forEach(function(config) {
      var _config$placement = config.placement, placement = _config$placement === void 0 ? "topRight" : _config$placement;
      if (placement) {
        nextPlacements[placement] = nextPlacements[placement] || [];
        nextPlacements[placement].push(config);
      }
    });
    Object.keys(placements2).forEach(function(placement) {
      nextPlacements[placement] = nextPlacements[placement] || [];
    });
    setPlacements(nextPlacements);
  }, [configList]);
  var onAllNoticeRemoved = function onAllNoticeRemoved2(placement) {
    setPlacements(function(originPlacements) {
      var clone2 = _objectSpread2$1({}, originPlacements);
      var list = clone2[placement] || [];
      if (!list.length) {
        delete clone2[placement];
      }
      return clone2;
    });
  };
  var emptyRef = react.exports.useRef(false);
  react.exports.useEffect(function() {
    if (Object.keys(placements2).length > 0) {
      emptyRef.current = true;
    } else if (emptyRef.current) {
      onAllRemoved === null || onAllRemoved === void 0 ? void 0 : onAllRemoved();
      emptyRef.current = false;
    }
  }, [placements2]);
  if (!container) {
    return null;
  }
  var placementList = Object.keys(placements2);
  return /* @__PURE__ */ reactDom.exports.createPortal(
    /* @__PURE__ */ jsx(Fragment, {
      children: placementList.map(function(placement) {
        var placementConfigList = placements2[placement];
        var keys2 = placementConfigList.map(function(config) {
          return {
            config,
            key: config.key
          };
        });
        var placementMotion = typeof motion2 === "function" ? motion2(placement) : motion2;
        return /* @__PURE__ */ jsx(CSSMotionList, {
          className: classNames(prefixCls, "".concat(prefixCls, "-").concat(placement), className === null || className === void 0 ? void 0 : className(placement)),
          style: style2 === null || style2 === void 0 ? void 0 : style2(placement),
          keys: keys2,
          motionAppear: true,
          ...placementMotion,
          onAllRemoved: function onAllRemoved2() {
            onAllNoticeRemoved(placement);
          },
          children: function(_ref, nodeRef) {
            var config = _ref.config, motionClassName = _ref.className, motionStyle = _ref.style;
            var key = config.key, times = config.times;
            var configClassName = config.className, configStyle = config.style;
            return /* @__PURE__ */ react.exports.createElement(Notice, {
              ...config,
              ref: nodeRef,
              prefixCls,
              className: classNames(motionClassName, configClassName),
              style: _objectSpread2$1(_objectSpread2$1({}, motionStyle), configStyle),
              times,
              key,
              eventKey: key,
              onNoticeClose
            });
          }
        }, placement);
      })
    }),
    container
  );
});
var _excluded$2 = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved"];
var defaultGetContainer = function defaultGetContainer2() {
  return document.body;
};
var uniqueKey = 0;
function mergeConfig() {
  var clone2 = {};
  for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
    objList[_key] = arguments[_key];
  }
  objList.forEach(function(obj) {
    if (obj) {
      Object.keys(obj).forEach(function(key) {
        var val = obj[key];
        if (val !== void 0) {
          clone2[key] = val;
        }
      });
    }
  });
  return clone2;
}
function useNotification$1() {
  var rootConfig = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _rootConfig$getContai = rootConfig.getContainer, getContainer2 = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai, motion2 = rootConfig.motion, prefixCls = rootConfig.prefixCls, maxCount = rootConfig.maxCount, className = rootConfig.className, style2 = rootConfig.style, onAllRemoved = rootConfig.onAllRemoved, shareConfig = _objectWithoutProperties(rootConfig, _excluded$2);
  var _React$useState = react.exports.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), container = _React$useState2[0], setContainer = _React$useState2[1];
  var notificationsRef = react.exports.useRef();
  var contextHolder = /* @__PURE__ */ jsx(Notifications, {
    container,
    ref: notificationsRef,
    prefixCls,
    motion: motion2,
    maxCount,
    className,
    style: style2,
    onAllRemoved
  });
  var _React$useState3 = react.exports.useState([]), _React$useState4 = _slicedToArray(_React$useState3, 2), taskQueue2 = _React$useState4[0], setTaskQueue = _React$useState4[1];
  var api = react.exports.useMemo(function() {
    return {
      open: function open2(config) {
        var mergedConfig = mergeConfig(shareConfig, config);
        if (mergedConfig.key === null || mergedConfig.key === void 0) {
          mergedConfig.key = "rc-notification-".concat(uniqueKey);
          uniqueKey += 1;
        }
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "open",
            config: mergedConfig
          }]);
        });
      },
      close: function close(key) {
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "close",
            key
          }]);
        });
      },
      destroy: function destroy2() {
        setTaskQueue(function(queue) {
          return [].concat(_toConsumableArray(queue), [{
            type: "destroy"
          }]);
        });
      }
    };
  }, []);
  react.exports.useEffect(function() {
    setContainer(getContainer2());
  });
  react.exports.useEffect(function() {
    if (notificationsRef.current && taskQueue2.length) {
      taskQueue2.forEach(function(task) {
        switch (task.type) {
          case "open":
            notificationsRef.current.open(task.config);
            break;
          case "close":
            notificationsRef.current.close(task.key);
            break;
          case "destroy":
            notificationsRef.current.destroy();
            break;
        }
      });
      setTaskQueue([]);
    }
  }, [taskQueue2]);
  return [api, contextHolder];
}
const genMessageStyle = (token2) => {
  const {
    componentCls,
    iconCls,
    boxShadow,
    colorBgElevated,
    colorSuccess,
    colorError,
    colorWarning,
    colorInfo,
    fontSizeLG,
    motionEaseInOutCirc,
    motionDurationSlow,
    marginXS,
    paddingXS,
    borderRadiusLG,
    zIndexPopup,
    messageNoticeContentPadding
  } = token2;
  const messageMoveIn = new Keyframe("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: paddingXS,
      transform: "translateY(0)",
      opacity: 1
    }
  });
  const messageMoveOut = new Keyframe("MessageMoveOut", {
    "0%": {
      maxHeight: token2.height,
      padding: paddingXS,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  return [
    {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "fixed",
        top: marginXS,
        width: "100%",
        pointerEvents: "none",
        zIndex: zIndexPopup,
        [`${componentCls}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
          animationName: messageMoveIn,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${componentCls}-move-up-leave`]: {
          animationName: messageMoveOut,
          animationDuration: motionDurationSlow,
          animationPlayState: "paused",
          animationTimingFunction: motionEaseInOutCirc
        },
        [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      })
    },
    {
      [`${componentCls}-notice`]: {
        padding: paddingXS,
        textAlign: "center",
        [`${componentCls}-custom-content > ${iconCls}`]: {
          verticalAlign: "text-bottom",
          marginInlineEnd: marginXS,
          fontSize: fontSizeLG
        },
        [`${componentCls}-notice-content`]: {
          display: "inline-block",
          padding: messageNoticeContentPadding,
          background: colorBgElevated,
          borderRadius: borderRadiusLG,
          boxShadow,
          pointerEvents: "all"
        },
        [`${componentCls}-success > ${iconCls}`]: {
          color: colorSuccess
        },
        [`${componentCls}-error > ${iconCls}`]: {
          color: colorError
        },
        [`${componentCls}-warning > ${iconCls}`]: {
          color: colorWarning
        },
        [`
        ${componentCls}-info > ${iconCls},
        ${componentCls}-loading > ${iconCls}`]: {
          color: colorInfo
        }
      }
    },
    {
      [`${componentCls}-notice-pure-panel`]: {
        padding: 0,
        textAlign: "start"
      }
    }
  ];
};
const useStyle$2 = genComponentStyleHook("Message", (token2) => {
  const combinedToken = merge(token2, {
    messageNoticeContentPadding: `${(token2.controlHeightLG - token2.fontSize * token2.lineHeight) / 2}px ${token2.paddingSM}px`
  });
  return [genMessageStyle(combinedToken)];
}, (token2) => ({
  height: 150,
  zIndexPopup: token2.zIndexPopupBase + 10
}));
var __rest$9 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const TypeIcon = {
  info: /* @__PURE__ */ jsx(InfoCircleFilled$1, {}),
  success: /* @__PURE__ */ jsx(CheckCircleFilled$1, {}),
  error: /* @__PURE__ */ jsx(CloseCircleFilled$1, {}),
  warning: /* @__PURE__ */ jsx(ExclamationCircleFilled$1, {}),
  loading: /* @__PURE__ */ jsx(LoadingOutlined$1, {})
};
function PureContent$1(_ref) {
  let {
    prefixCls,
    type: type4,
    icon,
    children
  } = _ref;
  return /* @__PURE__ */ jsxs("div", {
    className: classNames(`${prefixCls}-custom-content`, `${prefixCls}-${type4}`),
    children: [icon || TypeIcon[type4], /* @__PURE__ */ jsx("span", {
      children
    })]
  });
}
function PurePanel$1(props) {
  const {
    prefixCls: staticPrefixCls,
    className,
    type: type4,
    icon,
    content
  } = props, restProps = __rest$9(props, ["prefixCls", "className", "type", "icon", "content"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const [, hashId] = useStyle$2(prefixCls);
  return /* @__PURE__ */ jsx(Notice, {
    ...Object.assign({}, restProps, {
      prefixCls,
      className: classNames(className, hashId, `${prefixCls}-notice-pure-panel`),
      eventKey: "pure",
      duration: null,
      content: /* @__PURE__ */ jsx(PureContent$1, {
        prefixCls,
        type: type4,
        icon,
        children: content
      })
    })
  });
}
function getMotion$1(prefixCls, transitionName) {
  return {
    motionName: transitionName !== null && transitionName !== void 0 ? transitionName : `${prefixCls}-move-up`
  };
}
function wrapPromiseFn(openFn) {
  let closeFn;
  const closePromise = new Promise((resolve) => {
    closeFn = openFn(() => {
      resolve(true);
    });
  });
  const result = () => {
    closeFn === null || closeFn === void 0 ? void 0 : closeFn();
  };
  result.then = (filled, rejected) => closePromise.then(filled, rejected);
  result.promise = closePromise;
  return result;
}
var __rest$8 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const DEFAULT_OFFSET$1 = 8;
const DEFAULT_DURATION$1 = 3;
const Holder$1 = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    top,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    duration = DEFAULT_DURATION$1,
    rtl,
    transitionName,
    onAllRemoved
  } = props;
  const {
    getPrefixCls,
    getPopupContainer
  } = react.exports.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("message");
  const [, hashId] = useStyle$2(prefixCls);
  const getStyle2 = () => ({
    left: "50%",
    transform: "translateX(-50%)",
    top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET$1
  });
  const getClassName = () => classNames(hashId, rtl ? `${prefixCls}-rtl` : "");
  const getNotificationMotion = () => getMotion$1(prefixCls, transitionName);
  const mergedCloseIcon = /* @__PURE__ */ jsx("span", {
    className: `${prefixCls}-close-x`,
    children: /* @__PURE__ */ jsx(CloseOutlined$1, {
      className: `${prefixCls}-close-icon`
    })
  });
  const [api, holder] = useNotification$1({
    prefixCls,
    style: getStyle2,
    className: getClassName,
    motion: getNotificationMotion,
    closable: false,
    closeIcon: mergedCloseIcon,
    duration,
    getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
    maxCount,
    onAllRemoved
  });
  react.exports.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
    prefixCls,
    hashId
  }));
  return holder;
});
let keyIndex = 0;
function useInternalMessage(messageConfig) {
  const holderRef = react.exports.useRef(null);
  const wrapAPI = react.exports.useMemo(() => {
    const close = (key) => {
      var _a;
      (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
    };
    const open2 = (config) => {
      if (!holderRef.current) {
        const fakeResult = () => {
        };
        fakeResult.then = () => {
        };
        return fakeResult;
      }
      const {
        open: originOpen,
        prefixCls,
        hashId
      } = holderRef.current;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        content,
        icon,
        type: type4,
        key,
        className,
        onClose
      } = config, restConfig = __rest$8(config, ["content", "icon", "type", "key", "className", "onClose"]);
      let mergedKey = key;
      if (mergedKey === void 0 || mergedKey === null) {
        keyIndex += 1;
        mergedKey = `antd-message-${keyIndex}`;
      }
      return wrapPromiseFn((resolve) => {
        originOpen(Object.assign(Object.assign({}, restConfig), {
          key: mergedKey,
          content: /* @__PURE__ */ jsx(PureContent$1, {
            prefixCls,
            type: type4,
            icon,
            children: content
          }),
          placement: "top",
          className: classNames(type4 && `${noticePrefixCls}-${type4}`, hashId, className),
          onClose: () => {
            onClose === null || onClose === void 0 ? void 0 : onClose();
            resolve();
          }
        }));
        return () => {
          close(mergedKey);
        };
      });
    };
    const destroy2 = (key) => {
      var _a;
      if (key !== void 0) {
        close(key);
      } else {
        (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
      }
    };
    const clone2 = {
      open: open2,
      destroy: destroy2
    };
    const keys2 = ["info", "success", "warning", "error", "loading"];
    keys2.forEach((type4) => {
      const typeOpen2 = (jointContent, duration, onClose) => {
        let config;
        if (jointContent && typeof jointContent === "object" && "content" in jointContent) {
          config = jointContent;
        } else {
          config = {
            content: jointContent
          };
        }
        let mergedDuration;
        let mergedOnClose;
        if (typeof duration === "function") {
          mergedOnClose = duration;
        } else {
          mergedDuration = duration;
          mergedOnClose = onClose;
        }
        const mergedConfig = Object.assign(Object.assign({
          onClose: mergedOnClose,
          duration: mergedDuration
        }, config), {
          type: type4
        });
        return open2(mergedConfig);
      };
      clone2[type4] = typeOpen2;
    });
    return clone2;
  }, []);
  return [
    wrapAPI,
    /* @__PURE__ */ jsx(Holder$1, {
      ...Object.assign({
        key: "message-holder"
      }, messageConfig, {
        ref: holderRef
      })
    })
  ];
}
function useMessage(messageConfig) {
  return useInternalMessage(messageConfig);
}
let message = null;
let act$1 = (callback) => callback();
let taskQueue$1 = [];
let defaultGlobalConfig$1 = {};
function getGlobalContext$1() {
  const {
    prefixCls: globalPrefixCls2,
    getContainer: globalGetContainer,
    duration,
    rtl,
    maxCount,
    top
  } = defaultGlobalConfig$1;
  const mergedPrefixCls = globalPrefixCls2 !== null && globalPrefixCls2 !== void 0 ? globalPrefixCls2 : globalConfig().getPrefixCls("message");
  const mergedContainer = (globalGetContainer === null || globalGetContainer === void 0 ? void 0 : globalGetContainer()) || document.body;
  return {
    prefixCls: mergedPrefixCls,
    container: mergedContainer,
    duration,
    rtl,
    maxCount,
    top
  };
}
const GlobalHolder$1 = /* @__PURE__ */ react.exports.forwardRef((_2, ref) => {
  const initializeMessageConfig = () => {
    const {
      prefixCls,
      container,
      maxCount,
      duration,
      rtl,
      top
    } = getGlobalContext$1();
    return {
      prefixCls,
      getContainer: () => container,
      maxCount,
      duration,
      rtl,
      top
    };
  };
  const [messageConfig, setMessageConfig] = react.exports.useState(initializeMessageConfig);
  const [api, holder] = useInternalMessage(messageConfig);
  const global2 = globalConfig();
  const rootPrefixCls = global2.getRootPrefixCls();
  const rootIconPrefixCls = global2.getIconPrefixCls();
  const sync = () => {
    setMessageConfig(initializeMessageConfig);
  };
  react.exports.useEffect(sync, []);
  react.exports.useImperativeHandle(ref, () => {
    const instance = Object.assign({}, api);
    Object.keys(instance).forEach((method4) => {
      instance[method4] = function() {
        sync();
        return api[method4].apply(api, arguments);
      };
    });
    return {
      instance,
      sync
    };
  });
  return /* @__PURE__ */ jsx(ConfigProvider$1, {
    prefixCls: rootPrefixCls,
    iconPrefixCls: rootIconPrefixCls,
    children: holder
  });
});
function flushNotice$1() {
  if (!message) {
    const holderFragment = document.createDocumentFragment();
    const newMessage = {
      fragment: holderFragment
    };
    message = newMessage;
    act$1(() => {
      render(
        /* @__PURE__ */ jsx(GlobalHolder$1, {
          ref: (node2) => {
            const {
              instance,
              sync
            } = node2 || {};
            Promise.resolve().then(() => {
              if (!newMessage.instance && instance) {
                newMessage.instance = instance;
                newMessage.sync = sync;
                flushNotice$1();
              }
            });
          }
        }),
        holderFragment
      );
    });
    return;
  }
  if (!message.instance) {
    return;
  }
  taskQueue$1.forEach((task) => {
    const {
      type: type4,
      skipped
    } = task;
    if (!skipped) {
      switch (type4) {
        case "open": {
          act$1(() => {
            const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig$1), task.config));
            closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
            task.setCloseFn(closeFn);
          });
          break;
        }
        case "destroy":
          act$1(() => {
            message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);
          });
          break;
        default: {
          act$1(() => {
            var _message$instance;
            const closeFn = (_message$instance = message.instance)[type4].apply(_message$instance, _toConsumableArray(task.args));
            closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
            task.setCloseFn(closeFn);
          });
        }
      }
    }
  });
  taskQueue$1 = [];
}
function setMessageGlobalConfig(config) {
  defaultGlobalConfig$1 = Object.assign(Object.assign({}, defaultGlobalConfig$1), config);
  act$1(() => {
    var _a;
    (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);
  });
}
function open$1(config) {
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: "open",
      config,
      resolve,
      setCloseFn: (fn2) => {
        closeFn = fn2;
      }
    };
    taskQueue$1.push(task);
    return () => {
      if (closeFn) {
        act$1(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushNotice$1();
  return result;
}
function typeOpen(type4, args) {
  const result = wrapPromiseFn((resolve) => {
    let closeFn;
    const task = {
      type: type4,
      args,
      resolve,
      setCloseFn: (fn2) => {
        closeFn = fn2;
      }
    };
    taskQueue$1.push(task);
    return () => {
      if (closeFn) {
        act$1(() => {
          closeFn();
        });
      } else {
        task.skipped = true;
      }
    };
  });
  flushNotice$1();
  return result;
}
function destroy$1(key) {
  taskQueue$1.push({
    type: "destroy",
    key
  });
  flushNotice$1();
}
const methods$1 = ["success", "info", "warning", "error", "loading"];
const baseStaticMethods$1 = {
  open: open$1,
  destroy: destroy$1,
  config: setMessageGlobalConfig,
  useMessage,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel$1
};
const staticMethods$1 = baseStaticMethods$1;
methods$1.forEach((type4) => {
  staticMethods$1[type4] = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return typeOpen(type4, args);
  };
});
const message$1 = staticMethods$1;
const genNotificationPlacementStyle = (token2) => {
  const {
    componentCls,
    width,
    notificationMarginEdge
  } = token2;
  const notificationTopFadeIn = new Keyframe("antNotificationTopFadeIn", {
    "0%": {
      marginTop: "-100%",
      opacity: 0
    },
    "100%": {
      marginTop: 0,
      opacity: 1
    }
  });
  const notificationBottomFadeIn = new Keyframe("antNotificationBottomFadeIn", {
    "0%": {
      marginBottom: "-100%",
      opacity: 0
    },
    "100%": {
      marginBottom: 0,
      opacity: 1
    }
  });
  const notificationLeftFadeIn = new Keyframe("antNotificationLeftFadeIn", {
    "0%": {
      right: {
        _skip_check_: true,
        value: width
      },
      opacity: 0
    },
    "100%": {
      right: {
        _skip_check_: true,
        value: 0
      },
      opacity: 1
    }
  });
  return {
    [`&${componentCls}-top, &${componentCls}-bottom`]: {
      marginInline: 0
    },
    [`&${componentCls}-top`]: {
      [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
        animationName: notificationTopFadeIn
      }
    },
    [`&${componentCls}-bottom`]: {
      [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
        animationName: notificationBottomFadeIn
      }
    },
    [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
      marginInlineEnd: 0,
      marginInlineStart: notificationMarginEdge,
      [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
        animationName: notificationLeftFadeIn
      }
    }
  };
};
const genNotificationPlacementStyle$1 = genNotificationPlacementStyle;
const genNotificationStyle = (token2) => {
  const {
    iconCls,
    componentCls,
    boxShadow,
    fontSizeLG,
    notificationMarginBottom,
    borderRadiusLG,
    colorSuccess,
    colorInfo,
    colorWarning,
    colorError,
    colorTextHeading,
    notificationBg,
    notificationPadding,
    notificationMarginEdge,
    motionDurationMid,
    motionEaseInOut,
    fontSize,
    lineHeight,
    width,
    notificationIconSize
  } = token2;
  const noticeCls = `${componentCls}-notice`;
  const notificationFadeIn = new Keyframe("antNotificationFadeIn", {
    "0%": {
      left: {
        _skip_check_: true,
        value: width
      },
      opacity: 0
    },
    "100%": {
      left: {
        _skip_check_: true,
        value: 0
      },
      opacity: 1
    }
  });
  const notificationFadeOut = new Keyframe("antNotificationFadeOut", {
    "0%": {
      maxHeight: token2.animationMaxHeight,
      marginBottom: notificationMarginBottom,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "fixed",
        zIndex: token2.zIndexPopup,
        marginInlineEnd: notificationMarginEdge,
        [`${componentCls}-hook-holder`]: {
          position: "relative"
        },
        [`&${componentCls}-top, &${componentCls}-bottom`]: {
          [`${componentCls}-notice`]: {
            marginInline: "auto auto"
          }
        },
        [`&${componentCls}-topLeft, &${componentCls}-bottomLeft`]: {
          [`${componentCls}-notice`]: {
            marginInlineEnd: "auto",
            marginInlineStart: 0
          }
        },
        [`${componentCls}-fade-enter, ${componentCls}-fade-appear`]: {
          animationDuration: token2.motionDurationMid,
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-leave`]: {
          animationTimingFunction: motionEaseInOut,
          animationFillMode: "both",
          animationDuration: motionDurationMid,
          animationPlayState: "paused"
        },
        [`${componentCls}-fade-enter${componentCls}-fade-enter-active, ${componentCls}-fade-appear${componentCls}-fade-appear-active`]: {
          animationName: notificationFadeIn,
          animationPlayState: "running"
        },
        [`${componentCls}-fade-leave${componentCls}-fade-leave-active`]: {
          animationName: notificationFadeOut,
          animationPlayState: "running"
        }
      }), genNotificationPlacementStyle$1(token2)), {
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-notice-btn`]: {
            float: "left"
          }
        }
      })
    },
    {
      [noticeCls]: {
        position: "relative",
        width,
        maxWidth: `calc(100vw - ${notificationMarginEdge * 2}px)`,
        marginBottom: notificationMarginBottom,
        marginInlineStart: "auto",
        padding: notificationPadding,
        overflow: "hidden",
        lineHeight,
        wordWrap: "break-word",
        background: notificationBg,
        borderRadius: borderRadiusLG,
        boxShadow,
        [`${componentCls}-close-icon`]: {
          fontSize,
          cursor: "pointer"
        },
        [`${noticeCls}-message`]: {
          marginBottom: token2.marginXS,
          color: colorTextHeading,
          fontSize: fontSizeLG,
          lineHeight: token2.lineHeightLG
        },
        [`${noticeCls}-description`]: {
          fontSize
        },
        [`&${noticeCls}-closable ${noticeCls}-message`]: {
          paddingInlineEnd: token2.paddingLG
        },
        [`${noticeCls}-with-icon ${noticeCls}-message`]: {
          marginBottom: token2.marginXS,
          marginInlineStart: token2.marginSM + notificationIconSize,
          fontSize: fontSizeLG
        },
        [`${noticeCls}-with-icon ${noticeCls}-description`]: {
          marginInlineStart: token2.marginSM + notificationIconSize,
          fontSize
        },
        [`${noticeCls}-icon`]: {
          position: "absolute",
          fontSize: notificationIconSize,
          lineHeight: 0,
          [`&-success${iconCls}`]: {
            color: colorSuccess
          },
          [`&-info${iconCls}`]: {
            color: colorInfo
          },
          [`&-warning${iconCls}`]: {
            color: colorWarning
          },
          [`&-error${iconCls}`]: {
            color: colorError
          }
        },
        [`${noticeCls}-close`]: {
          position: "absolute",
          top: token2.notificationPaddingVertical,
          insetInlineEnd: token2.notificationPaddingHorizontal,
          color: token2.colorIcon,
          outline: "none",
          width: token2.notificationCloseButtonSize,
          height: token2.notificationCloseButtonSize,
          borderRadius: token2.borderRadiusSM,
          transition: `background-color ${token2.motionDurationMid}, color ${token2.motionDurationMid}`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          "&:hover": {
            color: token2.colorIconHover,
            backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent
          }
        },
        [`${noticeCls}-btn`]: {
          float: "right",
          marginTop: token2.marginSM
        }
      }
    },
    {
      [`${noticeCls}-pure-panel`]: {
        margin: 0
      }
    }
  ];
};
const useStyle$1 = genComponentStyleHook("Notification", (token2) => {
  const notificationPaddingVertical = token2.paddingMD;
  const notificationPaddingHorizontal = token2.paddingLG;
  const notificationToken = merge(token2, {
    notificationBg: token2.colorBgElevated,
    notificationPaddingVertical,
    notificationPaddingHorizontal,
    notificationPadding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`,
    notificationMarginBottom: token2.margin,
    notificationMarginEdge: token2.marginLG,
    animationMaxHeight: 150,
    notificationIconSize: token2.fontSizeLG * token2.lineHeightLG,
    notificationCloseButtonSize: token2.controlHeightLG * 0.55
  });
  return [genNotificationStyle(notificationToken)];
}, (token2) => ({
  zIndexPopup: token2.zIndexPopupBase + 50,
  width: 384
}));
var __rest$7 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function getCloseIcon(prefixCls, closeIcon) {
  return closeIcon || /* @__PURE__ */ jsx("span", {
    className: `${prefixCls}-close-x`,
    children: /* @__PURE__ */ jsx(CloseOutlined$1, {
      className: `${prefixCls}-close-icon`
    })
  });
}
const typeToIcon = {
  success: CheckCircleFilled$1,
  info: InfoCircleFilled$1,
  error: CloseCircleFilled$1,
  warning: ExclamationCircleFilled$1
};
function PureContent(_ref) {
  let {
    prefixCls,
    icon,
    type: type4,
    message: message2,
    description,
    btn
  } = _ref;
  let iconNode = null;
  if (icon) {
    iconNode = /* @__PURE__ */ jsx("span", {
      className: `${prefixCls}-icon`,
      children: icon
    });
  } else if (type4) {
    iconNode = /* @__PURE__ */ react.exports.createElement(typeToIcon[type4] || null, {
      className: classNames(`${prefixCls}-icon`, `${prefixCls}-icon-${type4}`)
    });
  }
  return /* @__PURE__ */ jsxs("div", {
    className: classNames({
      [`${prefixCls}-with-icon`]: iconNode
    }),
    role: "alert",
    children: [iconNode, /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-message`,
      children: message2
    }), /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-description`,
      children: description
    }), btn && /* @__PURE__ */ jsx("div", {
      className: `${prefixCls}-btn`,
      children: btn
    })]
  });
}
function PurePanel(props) {
  const {
    prefixCls: staticPrefixCls,
    className,
    icon,
    type: type4,
    message: message2,
    description,
    btn,
    closable = true,
    closeIcon
  } = props, restProps = __rest$7(props, ["prefixCls", "className", "icon", "type", "message", "description", "btn", "closable", "closeIcon"]);
  const {
    getPrefixCls
  } = react.exports.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const noticePrefixCls = `${prefixCls}-notice`;
  const [, hashId] = useStyle$1(prefixCls);
  return /* @__PURE__ */ jsx(Notice, {
    ...Object.assign({}, restProps, {
      prefixCls,
      className: classNames(className, hashId, `${noticePrefixCls}-pure-panel`),
      eventKey: "pure",
      duration: null,
      closable,
      closeIcon: getCloseIcon(prefixCls, closeIcon),
      content: /* @__PURE__ */ jsx(PureContent, {
        prefixCls: noticePrefixCls,
        icon,
        type: type4,
        message: message2,
        description,
        btn
      })
    })
  });
}
function getPlacementStyle(placement, top, bottom) {
  let style2;
  switch (placement) {
    case "top":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top,
        bottom: "auto"
      };
      break;
    case "topLeft":
      style2 = {
        left: 0,
        top,
        bottom: "auto"
      };
      break;
    case "topRight":
      style2 = {
        right: 0,
        top,
        bottom: "auto"
      };
      break;
    case "bottom":
      style2 = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom
      };
      break;
    case "bottomLeft":
      style2 = {
        left: 0,
        top: "auto",
        bottom
      };
      break;
    default:
      style2 = {
        right: 0,
        top: "auto",
        bottom
      };
      break;
  }
  return style2;
}
function getMotion(prefixCls) {
  return {
    motionName: `${prefixCls}-fade`
  };
}
var __rest$6 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const DEFAULT_OFFSET = 24;
const DEFAULT_DURATION = 4.5;
const Holder = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    top,
    bottom,
    prefixCls: staticPrefixCls,
    getContainer: staticGetContainer,
    maxCount,
    rtl,
    onAllRemoved
  } = props;
  const {
    getPrefixCls,
    getPopupContainer
  } = react.exports.useContext(ConfigContext);
  const prefixCls = staticPrefixCls || getPrefixCls("notification");
  const getStyle2 = (placement) => getPlacementStyle(placement, top !== null && top !== void 0 ? top : DEFAULT_OFFSET, bottom !== null && bottom !== void 0 ? bottom : DEFAULT_OFFSET);
  const [, hashId] = useStyle$1(prefixCls);
  const getClassName = () => classNames(hashId, {
    [`${prefixCls}-rtl`]: rtl
  });
  const getNotificationMotion = () => getMotion(prefixCls);
  const [api, holder] = useNotification$1({
    prefixCls,
    style: getStyle2,
    className: getClassName,
    motion: getNotificationMotion,
    closable: true,
    closeIcon: getCloseIcon(prefixCls),
    duration: DEFAULT_DURATION,
    getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
    maxCount,
    onAllRemoved
  });
  react.exports.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
    prefixCls,
    hashId
  }));
  return holder;
});
function useInternalNotification(notificationConfig) {
  const holderRef = react.exports.useRef(null);
  const wrapAPI = react.exports.useMemo(() => {
    const open2 = (config) => {
      if (!holderRef.current) {
        return;
      }
      const {
        open: originOpen,
        prefixCls,
        hashId
      } = holderRef.current;
      const noticePrefixCls = `${prefixCls}-notice`;
      const {
        message: message2,
        description,
        icon,
        type: type4,
        btn,
        className
      } = config, restConfig = __rest$6(config, ["message", "description", "icon", "type", "btn", "className"]);
      return originOpen(Object.assign(Object.assign({
        placement: "topRight"
      }, restConfig), {
        content: /* @__PURE__ */ jsx(PureContent, {
          prefixCls: noticePrefixCls,
          icon,
          type: type4,
          message: message2,
          description,
          btn
        }),
        className: classNames(type4 && `${noticePrefixCls}-${type4}`, hashId, className)
      }));
    };
    const destroy2 = (key) => {
      var _a, _b;
      if (key !== void 0) {
        (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
      } else {
        (_b = holderRef.current) === null || _b === void 0 ? void 0 : _b.destroy();
      }
    };
    const clone2 = {
      open: open2,
      destroy: destroy2
    };
    const keys2 = ["success", "info", "warning", "error"];
    keys2.forEach((type4) => {
      clone2[type4] = (config) => open2(Object.assign(Object.assign({}, config), {
        type: type4
      }));
    });
    return clone2;
  }, []);
  return [
    wrapAPI,
    /* @__PURE__ */ jsx(Holder, {
      ...Object.assign({
        key: "notification-holder"
      }, notificationConfig, {
        ref: holderRef
      })
    })
  ];
}
function useNotification(notificationConfig) {
  return useInternalNotification(notificationConfig);
}
let notification = null;
let act = (callback) => callback();
let taskQueue = [];
let defaultGlobalConfig = {};
function getGlobalContext() {
  const {
    prefixCls: globalPrefixCls2,
    getContainer: globalGetContainer,
    rtl,
    maxCount,
    top,
    bottom
  } = defaultGlobalConfig;
  const mergedPrefixCls = globalPrefixCls2 !== null && globalPrefixCls2 !== void 0 ? globalPrefixCls2 : globalConfig().getPrefixCls("notification");
  const mergedContainer = (globalGetContainer === null || globalGetContainer === void 0 ? void 0 : globalGetContainer()) || document.body;
  return {
    prefixCls: mergedPrefixCls,
    container: mergedContainer,
    rtl,
    maxCount,
    top,
    bottom
  };
}
const GlobalHolder = /* @__PURE__ */ react.exports.forwardRef((_2, ref) => {
  const [prefixCls, setPrefixCls] = react.exports.useState();
  const [container, setContainer] = react.exports.useState();
  const [maxCount, setMaxCount] = react.exports.useState();
  const [rtl, setRTL] = react.exports.useState();
  const [top, setTop] = react.exports.useState();
  const [bottom, setBottom] = react.exports.useState();
  const [api, holder] = useInternalNotification({
    prefixCls,
    getContainer: () => container,
    maxCount,
    rtl,
    top,
    bottom
  });
  const global2 = globalConfig();
  const rootPrefixCls = global2.getRootPrefixCls();
  const rootIconPrefixCls = global2.getIconPrefixCls();
  const sync = () => {
    const {
      prefixCls: nextGlobalPrefixCls,
      container: nextGlobalContainer,
      maxCount: nextGlobalMaxCount,
      rtl: nextGlobalRTL,
      top: nextTop,
      bottom: nextBottom
    } = getGlobalContext();
    setPrefixCls(nextGlobalPrefixCls);
    setContainer(nextGlobalContainer);
    setMaxCount(nextGlobalMaxCount);
    setRTL(nextGlobalRTL);
    setTop(nextTop);
    setBottom(nextBottom);
  };
  react.exports.useEffect(sync, []);
  react.exports.useImperativeHandle(ref, () => {
    const instance = Object.assign({}, api);
    Object.keys(instance).forEach((method4) => {
      instance[method4] = function() {
        sync();
        return api[method4].apply(api, arguments);
      };
    });
    return {
      instance,
      sync
    };
  });
  return /* @__PURE__ */ jsx(ConfigProvider$1, {
    prefixCls: rootPrefixCls,
    iconPrefixCls: rootIconPrefixCls,
    children: holder
  });
});
function flushNotice() {
  if (!notification) {
    const holderFragment = document.createDocumentFragment();
    const newNotification = {
      fragment: holderFragment
    };
    notification = newNotification;
    act(() => {
      render(
        /* @__PURE__ */ jsx(GlobalHolder, {
          ref: (node2) => {
            const {
              instance,
              sync
            } = node2 || {};
            Promise.resolve().then(() => {
              if (!newNotification.instance && instance) {
                newNotification.instance = instance;
                newNotification.sync = sync;
                flushNotice();
              }
            });
          }
        }),
        holderFragment
      );
    });
    return;
  }
  if (!notification.instance) {
    return;
  }
  taskQueue.forEach((task) => {
    switch (task.type) {
      case "open": {
        act(() => {
          notification.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
        });
        break;
      }
      case "destroy":
        act(() => {
          notification === null || notification === void 0 ? void 0 : notification.instance.destroy(task.key);
        });
        break;
    }
  });
  taskQueue = [];
}
function setNotificationGlobalConfig(config) {
  defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);
  act(() => {
    var _a;
    (_a = notification === null || notification === void 0 ? void 0 : notification.sync) === null || _a === void 0 ? void 0 : _a.call(notification);
  });
}
function open(config) {
  taskQueue.push({
    type: "open",
    config
  });
  flushNotice();
}
function destroy(key) {
  taskQueue.push({
    type: "destroy",
    key
  });
  flushNotice();
}
const methods = ["success", "info", "warning", "error"];
const baseStaticMethods = {
  open,
  destroy,
  config: setNotificationGlobalConfig,
  useNotification,
  _InternalPanelDoNotUseOrYouWillBeFired: PurePanel
};
const staticMethods = baseStaticMethods;
methods.forEach((type4) => {
  staticMethods[type4] = (config) => open(Object.assign(Object.assign({}, config), {
    type: type4
  }));
});
const notification$1 = staticMethods;
var __rest$5 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const inlineStyle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
};
const TransButton = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const onKeyDown2 = (event) => {
    const {
      keyCode
    } = event;
    if (keyCode === KeyCode.ENTER) {
      event.preventDefault();
    }
  };
  const onKeyUp2 = (event) => {
    const {
      keyCode
    } = event;
    const {
      onClick
    } = props;
    if (keyCode === KeyCode.ENTER && onClick) {
      onClick();
    }
  };
  const {
    style: style2,
    noStyle,
    disabled
  } = props, restProps = __rest$5(props, ["style", "noStyle", "disabled"]);
  let mergedStyle = {};
  if (!noStyle) {
    mergedStyle = Object.assign({}, inlineStyle);
  }
  if (disabled) {
    mergedStyle.pointerEvents = "none";
  }
  mergedStyle = Object.assign(Object.assign({}, mergedStyle), style2);
  return /* @__PURE__ */ jsx("div", {
    ...Object.assign({
      role: "button",
      tabIndex: 0,
      ref
    }, restProps, {
      onKeyDown: onKeyDown2,
      onKeyUp: onKeyUp2,
      style: mergedStyle
    })
  });
});
const TransButton$1 = TransButton;
var CopyOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, "name": "copy", "theme": "outlined" };
const CopyOutlinedSvg = CopyOutlined$2;
var CopyOutlined = function CopyOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: CopyOutlinedSvg
    })
  });
};
CopyOutlined.displayName = "CopyOutlined";
const CopyOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(CopyOutlined);
var EditOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, "name": "edit", "theme": "outlined" };
const EditOutlinedSvg = EditOutlined$2;
var EditOutlined = function EditOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: EditOutlinedSvg
    })
  });
};
EditOutlined.displayName = "EditOutlined";
const EditOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EditOutlined);
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i2 = 0; i2 < selection.rangeCount; i2++) {
    ranges.push(selection.getRangeAt(i2));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range3) {
        selection.addRange(range3);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(message2) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message2.replace(/#{\s*key\s*}/g, copyKey);
}
function copy(text, options) {
  var debug, message2, reselectPrevious, range3, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range3 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text;
    mark.ariaHidden = "true";
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format2, text);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range3.selectNodeContents(mark);
    selection.addRange(range3);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message2 = format("message" in options ? options.message : defaultMessage);
      window.prompt(message2, text);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range3);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy;
var EnterOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, "name": "enter", "theme": "outlined" };
const EnterOutlinedSvg = EnterOutlined$2;
var EnterOutlined = function EnterOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon$1, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: EnterOutlinedSvg
    })
  });
};
EnterOutlined.displayName = "EnterOutlined";
const EnterOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(EnterOutlined);
const getTitleStyle = (fontSize, lineHeight, color, token2) => {
  const {
    sizeMarginHeadingVerticalEnd,
    fontWeightStrong
  } = token2;
  return {
    marginBottom: sizeMarginHeadingVerticalEnd,
    color,
    fontWeight: fontWeightStrong,
    fontSize,
    lineHeight
  };
};
const getTitleStyles = (token2) => {
  const headings = [1, 2, 3, 4, 5];
  const styles = {};
  headings.forEach((headingLevel) => {
    styles[`
      h${headingLevel}&,
      div&-h${headingLevel},
      div&-h${headingLevel} > textarea,
      h${headingLevel}
    `] = getTitleStyle(token2[`fontSizeHeading${headingLevel}`], token2[`lineHeightHeading${headingLevel}`], token2.colorTextHeading, token2);
  });
  return styles;
};
const getLinkStyles = (token2) => {
  const {
    componentCls
  } = token2;
  return {
    "a&, a": Object.assign(Object.assign({}, operationUnit(token2)), {
      textDecoration: token2.linkDecoration,
      "&:active, &:hover": {
        textDecoration: token2.linkHoverDecoration
      },
      [`&[disabled], &${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: token2.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
};
const getResetStyles = (token2) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: token2.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    backgroundColor: gold[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: token2.fontFamilyCode,
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
});
const getEditableStyles = (token2) => {
  const {
    componentCls
  } = token2;
  const inputToken = initInputToken(token2);
  const inputShift = inputToken.inputPaddingVertical + 1;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: -token2.paddingSM,
        marginTop: -inputShift,
        marginBottom: `calc(1em - ${inputShift}px)`
      },
      [`${componentCls}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: token2.marginXS + 2,
        insetBlockEnd: token2.marginXS,
        color: token2.colorTextDescription,
        fontWeight: "normal",
        fontSize: token2.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        MozTransition: "none",
        height: "1em"
      }
    }
  };
};
const getCopyableStyles = (token2) => ({
  "&-copy-success": {
    [`
    &,
    &:hover,
    &:focus`]: {
      color: token2.colorSuccess
    }
  }
});
const getEllipsisStyles = () => ({
  [`
  a&-ellipsis,
  span&-ellipsis
  `]: {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-single-line": {
    whiteSpace: "nowrap"
  },
  "&-ellipsis-single-line": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    "a&, span&": {
      verticalAlign: "bottom"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
});
const genTypographyStyle = (token2) => {
  const {
    componentCls,
    sizeMarginHeadingVerticalStart
  } = token2;
  return {
    [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token2.colorText,
      wordBreak: "break-word",
      lineHeight: token2.lineHeight,
      [`&${componentCls}-secondary`]: {
        color: token2.colorTextDescription
      },
      [`&${componentCls}-success`]: {
        color: token2.colorSuccess
      },
      [`&${componentCls}-warning`]: {
        color: token2.colorWarning
      },
      [`&${componentCls}-danger`]: {
        color: token2.colorError,
        "a&:active, a&:focus": {
          color: token2.colorErrorActive
        },
        "a&:hover": {
          color: token2.colorErrorHover
        }
      },
      [`&${componentCls}-disabled`]: {
        color: token2.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      [`
        div&,
        p
      `]: {
        marginBottom: "1em"
      }
    }, getTitleStyles(token2)), {
      [`
      & + h1${componentCls},
      & + h2${componentCls},
      & + h3${componentCls},
      & + h4${componentCls},
      & + h5${componentCls}
      `]: {
        marginTop: sizeMarginHeadingVerticalStart
      },
      [`
      div,
      ul,
      li,
      p,
      h1,
      h2,
      h3,
      h4,
      h5`]: {
        [`
        + h1,
        + h2,
        + h3,
        + h4,
        + h5
        `]: {
          marginTop: sizeMarginHeadingVerticalStart
        }
      }
    }), getResetStyles(token2)), getLinkStyles(token2)), {
      [`
        ${componentCls}-expand,
        ${componentCls}-edit,
        ${componentCls}-copy
      `]: Object.assign(Object.assign({}, operationUnit(token2)), {
        marginInlineStart: token2.marginXXS
      })
    }), getEditableStyles(token2)), getCopyableStyles(token2)), getEllipsisStyles()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
};
const useStyle = genComponentStyleHook("Typography", (token2) => [genTypographyStyle(token2)], {
  sizeMarginHeadingVerticalStart: "1.2em",
  sizeMarginHeadingVerticalEnd: "0.5em"
});
const Editable = (_ref) => {
  let {
    prefixCls,
    "aria-label": ariaLabel,
    className,
    style: style2,
    direction,
    maxLength,
    autoSize = true,
    value,
    onSave,
    onCancel,
    onEnd,
    component,
    enterIcon = /* @__PURE__ */ jsx(EnterOutlined$1, {})
  } = _ref;
  const ref = react.exports.useRef(null);
  const inComposition = react.exports.useRef(false);
  const lastKeyCode = react.exports.useRef();
  const [current, setCurrent] = react.exports.useState(value);
  react.exports.useEffect(() => {
    setCurrent(value);
  }, [value]);
  react.exports.useEffect(() => {
    if (ref.current && ref.current.resizableTextArea) {
      const {
        textArea
      } = ref.current.resizableTextArea;
      textArea.focus();
      const {
        length: length2
      } = textArea.value;
      textArea.setSelectionRange(length2, length2);
    }
  }, []);
  const onChange2 = (_ref2) => {
    let {
      target
    } = _ref2;
    setCurrent(target.value.replace(/[\n\r]/g, ""));
  };
  const onCompositionStart = () => {
    inComposition.current = true;
  };
  const onCompositionEnd = () => {
    inComposition.current = false;
  };
  const onKeyDown2 = (_ref3) => {
    let {
      keyCode
    } = _ref3;
    if (inComposition.current)
      return;
    lastKeyCode.current = keyCode;
  };
  const confirmChange = () => {
    onSave(current.trim());
  };
  const onKeyUp2 = (_ref4) => {
    let {
      keyCode,
      ctrlKey,
      altKey,
      metaKey,
      shiftKey
    } = _ref4;
    if (lastKeyCode.current === keyCode && !inComposition.current && !ctrlKey && !altKey && !metaKey && !shiftKey) {
      if (keyCode === KeyCode.ENTER) {
        confirmChange();
        onEnd === null || onEnd === void 0 ? void 0 : onEnd();
      } else if (keyCode === KeyCode.ESC) {
        onCancel();
      }
    }
  };
  const onBlur2 = () => {
    confirmChange();
  };
  const textClassName = component ? `${prefixCls}-${component}` : "";
  const [wrapSSR, hashId] = useStyle(prefixCls);
  const textAreaClassName = classNames(prefixCls, `${prefixCls}-edit-content`, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, textClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsxs("div", {
      className: textAreaClassName,
      style: style2,
      children: [/* @__PURE__ */ jsx(TextArea$1, {
        ref,
        maxLength,
        value: current,
        onChange: onChange2,
        onKeyDown: onKeyDown2,
        onKeyUp: onKeyUp2,
        onCompositionStart,
        onCompositionEnd,
        onBlur: onBlur2,
        "aria-label": ariaLabel,
        rows: 1,
        autoSize
      }), enterIcon !== null ? cloneElement(enterIcon, {
        className: `${prefixCls}-edit-content-confirm`
      }) : null]
    })
  );
};
const Editable$1 = Editable;
function useMergedConfig(propConfig, templateConfig) {
  return react.exports.useMemo(() => {
    const support = !!propConfig;
    return [support, Object.assign(Object.assign({}, templateConfig), support && typeof propConfig === "object" ? propConfig : null)];
  }, [propConfig]);
}
const useUpdatedEffect = (callback, conditions) => {
  const mountRef = react.exports.useRef(false);
  react.exports.useEffect(() => {
    if (mountRef.current) {
      callback();
    } else {
      mountRef.current = true;
    }
  }, conditions);
};
const useUpdatedEffect$1 = useUpdatedEffect;
var __rest$4 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Typography$2 = /* @__PURE__ */ react.exports.forwardRef((_a, ref) => {
  var {
    prefixCls: customizePrefixCls,
    component: Component2 = "article",
    className,
    rootClassName,
    setContentRef,
    children,
    direction: typographyDirection
  } = _a, restProps = __rest$4(_a, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction"]);
  const {
    getPrefixCls,
    direction: contextDirection
  } = react.exports.useContext(ConfigContext);
  const direction = typographyDirection !== null && typographyDirection !== void 0 ? typographyDirection : contextDirection;
  let mergedRef = ref;
  if (setContentRef) {
    mergedRef = composeRef(ref, setContentRef);
  }
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const [wrapSSR, hashId] = useStyle(prefixCls);
  const componentClassName = classNames(prefixCls, {
    [`${prefixCls}-rtl`]: direction === "rtl"
  }, className, rootClassName, hashId);
  return wrapSSR(
    /* @__PURE__ */ jsx(Component2, {
      ...Object.assign({
        className: componentClassName,
        ref: mergedRef
      }, restProps),
      children
    })
  );
});
const OriginTypography = Typography$2;
function cuttable(node2) {
  const type4 = typeof node2;
  return type4 === "string" || type4 === "number";
}
function getNodesLen(nodeList) {
  let totalLen = 0;
  nodeList.forEach((node2) => {
    if (cuttable(node2)) {
      totalLen += String(node2).length;
    } else {
      totalLen += 1;
    }
  });
  return totalLen;
}
function sliceNodes(nodeList, len) {
  let currLen = 0;
  const currentNodeList = [];
  for (let i2 = 0; i2 < nodeList.length; i2 += 1) {
    if (currLen === len) {
      return currentNodeList;
    }
    const node2 = nodeList[i2];
    const canCut = cuttable(node2);
    const nodeLen = canCut ? String(node2).length : 1;
    const nextLen = currLen + nodeLen;
    if (nextLen > len) {
      const restLen = len - currLen;
      currentNodeList.push(String(node2).slice(0, restLen));
      return currentNodeList;
    }
    currentNodeList.push(node2);
    currLen = nextLen;
  }
  return nodeList;
}
const NONE = 0;
const PREPARE = 1;
const WALKING = 2;
const DONE_WITH_ELLIPSIS = 3;
const DONE_WITHOUT_ELLIPSIS = 4;
const Ellipsis = (_ref) => {
  let {
    enabledMeasure,
    children,
    text,
    width,
    fontSize,
    rows,
    onEllipsis
  } = _ref;
  const [[startLen, midLen, endLen], setCutLength] = react.exports.useState([0, 0, 0]);
  const [walkingState, setWalkingState] = react.exports.useState(NONE);
  const [singleRowHeight, setSingleRowHeight] = react.exports.useState(0);
  const singleRowRef = react.exports.useRef(null);
  const midRowRef = react.exports.useRef(null);
  const nodeList = react.exports.useMemo(() => toArray$3(text), [text]);
  const totalLen = react.exports.useMemo(() => getNodesLen(nodeList), [nodeList]);
  const mergedChildren = react.exports.useMemo(() => {
    if (!enabledMeasure || walkingState !== DONE_WITH_ELLIPSIS) {
      return children(nodeList, false);
    }
    return children(sliceNodes(nodeList, midLen), midLen < totalLen);
  }, [enabledMeasure, walkingState, children, nodeList, midLen, totalLen]);
  useLayoutEffect(() => {
    if (enabledMeasure && width && fontSize && totalLen) {
      setWalkingState(PREPARE);
      setCutLength([0, Math.ceil(totalLen / 2), totalLen]);
    }
  }, [enabledMeasure, width, fontSize, text, totalLen, rows]);
  useLayoutEffect(() => {
    var _a;
    if (walkingState === PREPARE) {
      setSingleRowHeight(((_a = singleRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0);
    }
  }, [walkingState]);
  useLayoutEffect(() => {
    var _a, _b;
    if (singleRowHeight) {
      if (walkingState === PREPARE) {
        const midHeight = ((_a = midRowRef.current) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
        const maxHeight = rows * singleRowHeight;
        if (midHeight <= maxHeight) {
          setWalkingState(DONE_WITHOUT_ELLIPSIS);
          onEllipsis(false);
        } else {
          setWalkingState(WALKING);
        }
      } else if (walkingState === WALKING) {
        if (startLen !== endLen) {
          const midHeight = ((_b = midRowRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || 0;
          const maxHeight = rows * singleRowHeight;
          let nextStartLen = startLen;
          let nextEndLen = endLen;
          if (startLen === endLen - 1) {
            nextEndLen = startLen;
          } else if (midHeight <= maxHeight) {
            nextStartLen = midLen;
          } else {
            nextEndLen = midLen;
          }
          const nextMidLen = Math.ceil((nextStartLen + nextEndLen) / 2);
          setCutLength([nextStartLen, nextMidLen, nextEndLen]);
        } else {
          setWalkingState(DONE_WITH_ELLIPSIS);
          onEllipsis(true);
        }
      }
    }
  }, [walkingState, startLen, endLen, rows, singleRowHeight]);
  const measureStyle = {
    width,
    whiteSpace: "normal",
    margin: 0,
    padding: 0
  };
  const renderMeasure = (content, ref, style2) => /* @__PURE__ */ jsx("span", {
    "aria-hidden": true,
    ref,
    style: Object.assign({
      position: "fixed",
      display: "block",
      left: 0,
      top: 0,
      zIndex: -9999,
      visibility: "hidden",
      pointerEvents: "none",
      fontSize: Math.floor(fontSize / 2) * 2
    }, style2),
    children: content
  });
  const renderMeasureSlice = (len, ref) => {
    const sliceNodeList = sliceNodes(nodeList, len);
    return renderMeasure(children(sliceNodeList, true), ref, measureStyle);
  };
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [mergedChildren, enabledMeasure && walkingState !== DONE_WITH_ELLIPSIS && walkingState !== DONE_WITHOUT_ELLIPSIS && /* @__PURE__ */ jsxs(Fragment, {
      children: [renderMeasure("lg", singleRowRef, {
        wordBreak: "keep-all",
        whiteSpace: "nowrap"
      }), walkingState === PREPARE ? renderMeasure(children(nodeList, false), midRowRef, measureStyle) : renderMeasureSlice(midLen, midRowRef)]
    })]
  });
};
const Ellipsis$1 = Ellipsis;
const EllipsisTooltip = (_ref) => {
  let {
    enabledEllipsis,
    isEllipsis,
    children,
    tooltipProps
  } = _ref;
  if (!(tooltipProps === null || tooltipProps === void 0 ? void 0 : tooltipProps.title) || !enabledEllipsis) {
    return children;
  }
  return /* @__PURE__ */ jsx(Tooltip$1, {
    ...Object.assign({
      open: isEllipsis ? void 0 : false
    }, tooltipProps),
    children
  });
};
const EllipsisTooltip$1 = EllipsisTooltip;
var __rest$3 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
function wrapperDecorations(_ref, content) {
  let {
    mark,
    code,
    underline,
    delete: del,
    strong,
    keyboard,
    italic
  } = _ref;
  let currentContent = content;
  function wrap2(tag, needed) {
    if (!needed) {
      return;
    }
    currentContent = /* @__PURE__ */ react.exports.createElement(tag, {}, currentContent);
  }
  wrap2("strong", strong);
  wrap2("u", underline);
  wrap2("del", del);
  wrap2("code", code);
  wrap2("mark", mark);
  wrap2("kbd", keyboard);
  wrap2("i", italic);
  return currentContent;
}
function getNode(dom, defaultNode, needDom) {
  if (dom === true || dom === void 0) {
    return defaultNode;
  }
  return dom || needDom && defaultNode;
}
function toList(val) {
  if (val === false) {
    return [false, false];
  }
  return Array.isArray(val) ? val : [val];
}
const ELLIPSIS_STR = "...";
const Base = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  var _a, _b, _c;
  const {
    prefixCls: customizePrefixCls,
    className,
    style: style2,
    type: type4,
    disabled,
    children,
    ellipsis,
    editable,
    copyable,
    component,
    title
  } = props, restProps = __rest$3(props, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]);
  const {
    getPrefixCls,
    direction
  } = react.exports.useContext(ConfigContext);
  const [textLocale] = useLocale$1("Text");
  const typographyRef = react.exports.useRef(null);
  const editIconRef = react.exports.useRef(null);
  const prefixCls = getPrefixCls("typography", customizePrefixCls);
  const textProps = omit(restProps, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]);
  const [enableEdit, editConfig] = useMergedConfig(editable);
  const [editing, setEditing] = useMergedState(false, {
    value: editConfig.editing
  });
  const {
    triggerType = ["icon"]
  } = editConfig;
  const triggerEdit = (edit) => {
    var _a2;
    if (edit) {
      (_a2 = editConfig.onStart) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
    }
    setEditing(edit);
  };
  useUpdatedEffect$1(() => {
    var _a2;
    if (!editing) {
      (_a2 = editIconRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }
  }, [editing]);
  const onEditClick = (e2) => {
    e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
    triggerEdit(true);
  };
  const onEditChange = (value) => {
    var _a2;
    (_a2 = editConfig.onChange) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig, value);
    triggerEdit(false);
  };
  const onEditCancel = () => {
    var _a2;
    (_a2 = editConfig.onCancel) === null || _a2 === void 0 ? void 0 : _a2.call(editConfig);
    triggerEdit(false);
  };
  const [enableCopy, copyConfig] = useMergedConfig(copyable);
  const [copied, setCopied] = react.exports.useState(false);
  const copyIdRef = react.exports.useRef();
  const copyOptions = {};
  if (copyConfig.format) {
    copyOptions.format = copyConfig.format;
  }
  const cleanCopyId = () => {
    window.clearTimeout(copyIdRef.current);
  };
  const onCopyClick = (e2) => {
    var _a2;
    e2 === null || e2 === void 0 ? void 0 : e2.preventDefault();
    e2 === null || e2 === void 0 ? void 0 : e2.stopPropagation();
    copyToClipboard(copyConfig.text || String(children) || "", copyOptions);
    setCopied(true);
    cleanCopyId();
    copyIdRef.current = window.setTimeout(() => {
      setCopied(false);
    }, 3e3);
    (_a2 = copyConfig.onCopy) === null || _a2 === void 0 ? void 0 : _a2.call(copyConfig, e2);
  };
  react.exports.useEffect(() => cleanCopyId, []);
  const [isLineClampSupport, setIsLineClampSupport] = react.exports.useState(false);
  const [isTextOverflowSupport, setIsTextOverflowSupport] = react.exports.useState(false);
  const [expanded, setExpanded] = react.exports.useState(false);
  const [isJsEllipsis, setIsJsEllipsis] = react.exports.useState(false);
  const [isNativeEllipsis, setIsNativeEllipsis] = react.exports.useState(false);
  const [isNativeVisible, setIsNativeVisible] = react.exports.useState(true);
  const [enableEllipsis, ellipsisConfig] = useMergedConfig(ellipsis, {
    expandable: false
  });
  const mergedEnableEllipsis = enableEllipsis && !expanded;
  const {
    rows = 1
  } = ellipsisConfig;
  const needMeasureEllipsis = react.exports.useMemo(() => !mergedEnableEllipsis || ellipsisConfig.suffix !== void 0 || ellipsisConfig.onEllipsis || ellipsisConfig.expandable || enableEdit || enableCopy, [mergedEnableEllipsis, ellipsisConfig, enableEdit, enableCopy]);
  useLayoutEffect(() => {
    if (enableEllipsis && !needMeasureEllipsis) {
      setIsLineClampSupport(isStyleSupport("webkitLineClamp"));
      setIsTextOverflowSupport(isStyleSupport("textOverflow"));
    }
  }, [needMeasureEllipsis, enableEllipsis]);
  const cssEllipsis = react.exports.useMemo(() => {
    if (needMeasureEllipsis) {
      return false;
    }
    if (rows === 1) {
      return isTextOverflowSupport;
    }
    return isLineClampSupport;
  }, [needMeasureEllipsis, isTextOverflowSupport, isLineClampSupport]);
  const isMergedEllipsis = mergedEnableEllipsis && (cssEllipsis ? isNativeEllipsis : isJsEllipsis);
  const cssTextOverflow = mergedEnableEllipsis && rows === 1 && cssEllipsis;
  const cssLineClamp = mergedEnableEllipsis && rows > 1 && cssEllipsis;
  const onExpandClick = (e2) => {
    var _a2;
    setExpanded(true);
    (_a2 = ellipsisConfig.onExpand) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, e2);
  };
  const [ellipsisWidth, setEllipsisWidth] = react.exports.useState(0);
  const [ellipsisFontSize, setEllipsisFontSize] = react.exports.useState(0);
  const onResize2 = (_ref2, element) => {
    let {
      offsetWidth
    } = _ref2;
    var _a2;
    setEllipsisWidth(offsetWidth);
    setEllipsisFontSize(parseInt((_a2 = window.getComputedStyle) === null || _a2 === void 0 ? void 0 : _a2.call(window, element).fontSize, 10) || 0);
  };
  const onJsEllipsis = (jsEllipsis) => {
    var _a2;
    setIsJsEllipsis(jsEllipsis);
    if (isJsEllipsis !== jsEllipsis) {
      (_a2 = ellipsisConfig.onEllipsis) === null || _a2 === void 0 ? void 0 : _a2.call(ellipsisConfig, jsEllipsis);
    }
  };
  react.exports.useEffect(() => {
    const textEle = typographyRef.current;
    if (enableEllipsis && cssEllipsis && textEle) {
      const currentEllipsis = cssLineClamp ? textEle.offsetHeight < textEle.scrollHeight : textEle.offsetWidth < textEle.scrollWidth;
      if (isNativeEllipsis !== currentEllipsis) {
        setIsNativeEllipsis(currentEllipsis);
      }
    }
  }, [enableEllipsis, cssEllipsis, children, cssLineClamp, isNativeVisible]);
  react.exports.useEffect(() => {
    const textEle = typographyRef.current;
    if (typeof IntersectionObserver === "undefined" || !textEle || !cssEllipsis || !mergedEnableEllipsis) {
      return;
    }
    const observer = new IntersectionObserver(() => {
      setIsNativeVisible(!!textEle.offsetParent);
    });
    observer.observe(textEle);
    return () => {
      observer.disconnect();
    };
  }, [cssEllipsis, mergedEnableEllipsis]);
  let tooltipProps = {};
  if (ellipsisConfig.tooltip === true) {
    tooltipProps = {
      title: (_a = editConfig.text) !== null && _a !== void 0 ? _a : children
    };
  } else if (/* @__PURE__ */ react.exports.isValidElement(ellipsisConfig.tooltip)) {
    tooltipProps = {
      title: ellipsisConfig.tooltip
    };
  } else if (typeof ellipsisConfig.tooltip === "object") {
    tooltipProps = Object.assign({
      title: (_b = editConfig.text) !== null && _b !== void 0 ? _b : children
    }, ellipsisConfig.tooltip);
  } else {
    tooltipProps = {
      title: ellipsisConfig.tooltip
    };
  }
  const topAriaLabel = react.exports.useMemo(() => {
    const isValid = (val) => ["string", "number"].includes(typeof val);
    if (!enableEllipsis || cssEllipsis) {
      return void 0;
    }
    if (isValid(editConfig.text)) {
      return editConfig.text;
    }
    if (isValid(children)) {
      return children;
    }
    if (isValid(title)) {
      return title;
    }
    if (isValid(tooltipProps.title)) {
      return tooltipProps.title;
    }
    return void 0;
  }, [enableEllipsis, cssEllipsis, title, tooltipProps.title, isMergedEllipsis]);
  if (editing) {
    return /* @__PURE__ */ jsx(Editable$1, {
      value: (_c = editConfig.text) !== null && _c !== void 0 ? _c : typeof children === "string" ? children : "",
      onSave: onEditChange,
      onCancel: onEditCancel,
      onEnd: editConfig.onEnd,
      prefixCls,
      className,
      style: style2,
      direction,
      component,
      maxLength: editConfig.maxLength,
      autoSize: editConfig.autoSize,
      enterIcon: editConfig.enterIcon
    });
  }
  const renderExpand = () => {
    const {
      expandable,
      symbol
    } = ellipsisConfig;
    if (!expandable)
      return null;
    let expandContent;
    if (symbol) {
      expandContent = symbol;
    } else {
      expandContent = textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand;
    }
    return /* @__PURE__ */ jsx("a", {
      className: `${prefixCls}-expand`,
      onClick: onExpandClick,
      "aria-label": textLocale === null || textLocale === void 0 ? void 0 : textLocale.expand,
      children: expandContent
    }, "expand");
  };
  const renderEdit = () => {
    if (!enableEdit)
      return;
    const {
      icon,
      tooltip
    } = editConfig;
    const editTitle = toArray$3(tooltip)[0] || (textLocale === null || textLocale === void 0 ? void 0 : textLocale.edit);
    const ariaLabel = typeof editTitle === "string" ? editTitle : "";
    return triggerType.includes("icon") ? /* @__PURE__ */ jsx(Tooltip$1, {
      title: tooltip === false ? "" : editTitle,
      children: /* @__PURE__ */ jsx(TransButton$1, {
        ref: editIconRef,
        className: `${prefixCls}-edit`,
        onClick: onEditClick,
        "aria-label": ariaLabel,
        children: icon || /* @__PURE__ */ jsx(EditOutlined$1, {
          role: "button"
        })
      })
    }, "edit") : null;
  };
  const renderCopy = () => {
    if (!enableCopy)
      return;
    const {
      tooltips,
      icon
    } = copyConfig;
    const tooltipNodes = toList(tooltips);
    const iconNodes = toList(icon);
    const copyTitle = copied ? getNode(tooltipNodes[1], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied) : getNode(tooltipNodes[0], textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy);
    const systemStr = copied ? textLocale === null || textLocale === void 0 ? void 0 : textLocale.copied : textLocale === null || textLocale === void 0 ? void 0 : textLocale.copy;
    const ariaLabel = typeof copyTitle === "string" ? copyTitle : systemStr;
    return /* @__PURE__ */ jsx(Tooltip$1, {
      title: copyTitle,
      children: /* @__PURE__ */ jsx(TransButton$1, {
        className: classNames(`${prefixCls}-copy`, copied && `${prefixCls}-copy-success`),
        onClick: onCopyClick,
        "aria-label": ariaLabel,
        children: copied ? getNode(
          iconNodes[1],
          /* @__PURE__ */ jsx(CheckOutlined$1, {}),
          true
        ) : getNode(
          iconNodes[0],
          /* @__PURE__ */ jsx(CopyOutlined$1, {}),
          true
        )
      })
    }, "copy");
  };
  const renderOperations = (renderExpanded) => [renderExpanded && renderExpand(), renderEdit(), renderCopy()];
  const renderEllipsis = (needEllipsis) => [needEllipsis && /* @__PURE__ */ jsx("span", {
    "aria-hidden": true,
    children: ELLIPSIS_STR
  }, "ellipsis"), ellipsisConfig.suffix, renderOperations(needEllipsis)];
  return /* @__PURE__ */ jsx(RefResizeObserver, {
    onResize: onResize2,
    disabled: !mergedEnableEllipsis || cssEllipsis,
    children: (resizeRef) => /* @__PURE__ */ jsx(EllipsisTooltip$1, {
      tooltipProps,
      enabledEllipsis: mergedEnableEllipsis,
      isEllipsis: isMergedEllipsis,
      children: /* @__PURE__ */ jsx(OriginTypography, {
        ...Object.assign({
          className: classNames({
            [`${prefixCls}-${type4}`]: type4,
            [`${prefixCls}-disabled`]: disabled,
            [`${prefixCls}-ellipsis`]: enableEllipsis,
            [`${prefixCls}-single-line`]: mergedEnableEllipsis && rows === 1,
            [`${prefixCls}-ellipsis-single-line`]: cssTextOverflow,
            [`${prefixCls}-ellipsis-multiple-line`]: cssLineClamp
          }, className),
          prefixCls: customizePrefixCls,
          style: Object.assign(Object.assign({}, style2), {
            WebkitLineClamp: cssLineClamp ? rows : void 0
          }),
          component,
          ref: composeRef(resizeRef, typographyRef, ref),
          direction,
          onClick: triggerType.includes("text") ? onEditClick : void 0,
          "aria-label": topAriaLabel === null || topAriaLabel === void 0 ? void 0 : topAriaLabel.toString(),
          title
        }, textProps),
        children: /* @__PURE__ */ jsx(Ellipsis$1, {
          enabledMeasure: mergedEnableEllipsis && !cssEllipsis,
          text: children,
          rows,
          width: ellipsisWidth,
          fontSize: ellipsisFontSize,
          onEllipsis: onJsEllipsis,
          children: (node2, needEllipsis) => {
            let renderNode = node2;
            if (node2.length && needEllipsis && topAriaLabel) {
              renderNode = /* @__PURE__ */ jsx("span", {
                "aria-hidden": true,
                children: renderNode
              }, "show-content");
            }
            const wrappedContext = wrapperDecorations(
              props,
              /* @__PURE__ */ jsxs(Fragment, {
                children: [renderNode, renderEllipsis(needEllipsis)]
              })
            );
            return wrappedContext;
          }
        })
      })
    })
  });
});
const Base$1 = Base;
var __rest$2 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Link = /* @__PURE__ */ react.exports.forwardRef((_a, ref) => {
  var {
    ellipsis,
    rel
  } = _a, restProps = __rest$2(_a, ["ellipsis", "rel"]);
  const mergedProps = Object.assign(Object.assign({}, restProps), {
    rel: rel === void 0 && restProps.target === "_blank" ? "noopener noreferrer" : rel
  });
  delete mergedProps.navigate;
  return /* @__PURE__ */ jsx(Base$1, {
    ...Object.assign({}, mergedProps, {
      ref,
      ellipsis: !!ellipsis,
      component: "a"
    })
  });
});
const Link$1 = Link;
const Paragraph = /* @__PURE__ */ react.exports.forwardRef((props, ref) => /* @__PURE__ */ jsx(Base$1, {
  ...Object.assign({
    ref
  }, props, {
    component: "div"
  })
}));
const Paragraph$1 = Paragraph;
var __rest$1 = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const Text$4 = (_a, ref) => {
  var {
    ellipsis
  } = _a, restProps = __rest$1(_a, ["ellipsis"]);
  const mergedEllipsis = react.exports.useMemo(() => {
    if (ellipsis && typeof ellipsis === "object") {
      return omit(ellipsis, ["expandable", "rows"]);
    }
    return ellipsis;
  }, [ellipsis]);
  return /* @__PURE__ */ jsx(Base$1, {
    ...Object.assign({
      ref
    }, restProps, {
      ellipsis: mergedEllipsis,
      component: "span"
    })
  });
};
const Text$5 = /* @__PURE__ */ react.exports.forwardRef(Text$4);
var __rest = globalThis && globalThis.__rest || function(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
};
const TITLE_ELE_LIST = [1, 2, 3, 4, 5];
const Title$5 = /* @__PURE__ */ react.exports.forwardRef((props, ref) => {
  const {
    level = 1
  } = props, restProps = __rest(props, ["level"]);
  let component;
  if (TITLE_ELE_LIST.includes(level)) {
    component = `h${level}`;
  } else {
    component = "h1";
  }
  return /* @__PURE__ */ jsx(Base$1, {
    ...Object.assign({
      ref
    }, restProps, {
      component
    })
  });
});
const Title$6 = Title$5;
const Typography = OriginTypography;
Typography.Text = Text$5;
Typography.Link = Link$1;
Typography.Title = Title$6;
Typography.Paragraph = Paragraph$1;
const Typography$1 = Typography;
var DollarCircleOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372zm47.7-395.2l-25.4-5.9V348.6c38 5.2 61.5 29 65.5 58.2.5 4 3.9 6.9 7.9 6.9h44.9c4.7 0 8.4-4.1 8-8.8-6.1-62.3-57.4-102.3-125.9-109.2V263c0-4.4-3.6-8-8-8h-28.1c-4.4 0-8 3.6-8 8v33c-70.8 6.9-126.2 46-126.2 119 0 67.6 49.8 100.2 102.1 112.7l24.7 6.3v142.7c-44.2-5.9-69-29.5-74.1-61.3-.6-3.8-4-6.6-7.9-6.6H363c-4.7 0-8.4 4-8 8.7 4.5 55 46.2 105.6 135.2 112.1V761c0 4.4 3.6 8 8 8h28.4c4.4 0 8-3.6 8-8.1l-.2-31.7c78.3-6.9 134.3-48.8 134.3-124-.1-69.4-44.2-100.4-109-116.4zm-68.6-16.2c-5.6-1.6-10.3-3.1-15-5-33.8-12.2-49.5-31.9-49.5-57.3 0-36.3 27.5-57 64.5-61.7v124zM534.3 677V543.3c3.1.9 5.9 1.6 8.8 2.2 47.3 14.4 63.2 34.4 63.2 65.1 0 39.1-29.4 62.6-72 66.4z" } }] }, "name": "dollar-circle", "theme": "outlined" };
const DollarCircleOutlinedSvg = DollarCircleOutlined$2;
var FormOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M904 512h-56c-4.4 0-8 3.6-8 8v320H184V184h320c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V520c0-4.4-3.6-8-8-8z" } }, { "tag": "path", "attrs": { "d": "M355.9 534.9L354 653.8c-.1 8.9 7.1 16.2 16 16.2h.4l118-2.9c2-.1 4-.9 5.4-2.3l415.9-415c3.1-3.1 3.1-8.2 0-11.3L785.4 114.3c-1.6-1.6-3.6-2.3-5.7-2.3s-4.1.8-5.7 2.3l-415.8 415a8.3 8.3 0 00-2.3 5.6zm63.5 23.6L779.7 199l45.2 45.1-360.5 359.7-45.7 1.1.7-46.4z" } }] }, "name": "form", "theme": "outlined" };
const FormOutlinedSvg = FormOutlined$2;
var HomeOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M946.5 505L560.1 118.8l-25.9-25.9a31.5 31.5 0 00-44.4 0L77.5 505a63.9 63.9 0 00-18.8 46c.4 35.2 29.7 63.3 64.9 63.3h42.5V940h691.8V614.3h43.4c17.1 0 33.2-6.7 45.3-18.8a63.6 63.6 0 0018.7-45.3c0-17-6.7-33.1-18.8-45.2zM568 868H456V664h112v204zm217.9-325.7V868H632V640c0-22.1-17.9-40-40-40H432c-22.1 0-40 17.9-40 40v228H238.1V542.3h-96l370-369.7 23.1 23.1L882 542.3h-96.1z" } }] }, "name": "home", "theme": "outlined" };
const HomeOutlinedSvg = HomeOutlined$2;
var LockOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M832 464h-68V240c0-70.7-57.3-128-128-128H388c-70.7 0-128 57.3-128 128v224h-68c-17.7 0-32 14.3-32 32v384c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V496c0-17.7-14.3-32-32-32zM332 240c0-30.9 25.1-56 56-56h248c30.9 0 56 25.1 56 56v224H332V240zm460 600H232V536h560v304zM484 701v53c0 4.4 3.6 8 8 8h40c4.4 0 8-3.6 8-8v-53a48.01 48.01 0 10-56 0z" } }] }, "name": "lock", "theme": "outlined" };
const LockOutlinedSvg = LockOutlined$2;
var LogoutOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M868 732h-70.3c-4.8 0-9.3 2.1-12.3 5.8-7 8.5-14.5 16.7-22.4 24.5a353.84 353.84 0 01-112.7 75.9A352.8 352.8 0 01512.4 866c-47.9 0-94.3-9.4-137.9-27.8a353.84 353.84 0 01-112.7-75.9 353.28 353.28 0 01-76-112.5C167.3 606.2 158 559.9 158 512s9.4-94.2 27.8-137.8c17.8-42.1 43.4-80 76-112.5s70.5-58.1 112.7-75.9c43.6-18.4 90-27.8 137.9-27.8 47.9 0 94.3 9.3 137.9 27.8 42.2 17.8 80.1 43.4 112.7 75.9 7.9 7.9 15.3 16.1 22.4 24.5 3 3.7 7.6 5.8 12.3 5.8H868c6.3 0 10.2-7 6.7-12.3C798 160.5 663.8 81.6 511.3 82 271.7 82.6 79.6 277.1 82 516.4 84.4 751.9 276.2 942 512.4 942c152.1 0 285.7-78.8 362.3-197.7 3.4-5.3-.4-12.3-6.7-12.3zm88.9-226.3L815 393.7c-5.3-4.2-13-.4-13 6.3v76H488c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h314v76c0 6.7 7.8 10.5 13 6.3l141.9-112a8 8 0 000-12.6z" } }] }, "name": "logout", "theme": "outlined" };
const LogoutOutlinedSvg = LogoutOutlined$2;
var MinusOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M872 474H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h720c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, "name": "minus", "theme": "outlined" };
const MinusOutlinedSvg = MinusOutlined$2;
var UserOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M858.5 763.6a374 374 0 00-80.6-119.5 375.63 375.63 0 00-119.5-80.6c-.4-.2-.8-.3-1.2-.5C719.5 518 760 444.7 760 362c0-137-111-248-248-248S264 225 264 362c0 82.7 40.5 156 102.8 201.1-.4.2-.8.3-1.2.5-44.8 18.9-85 46-119.5 80.6a375.63 375.63 0 00-80.6 119.5A371.7 371.7 0 00136 901.8a8 8 0 008 8.2h60c4.4 0 7.9-3.5 8-7.8 2-77.2 33-149.5 87.8-204.3 56.7-56.7 132-87.9 212.2-87.9s155.5 31.2 212.2 87.9C779 752.7 810 825 812 902.2c.1 4.4 3.6 7.8 8 7.8h60a8 8 0 008-8.2c-1-47.8-10.9-94.3-29.5-138.2zM512 534c-45.9 0-89.1-17.9-121.6-50.4S340 407.9 340 362c0-45.9 17.9-89.1 50.4-121.6S466.1 190 512 190s89.1 17.9 121.6 50.4S684 316.1 684 362c0 45.9-17.9 89.1-50.4 121.6S557.9 534 512 534z" } }] }, "name": "user", "theme": "outlined" };
const UserOutlinedSvg = UserOutlined$2;
const FeedbackContext = react.exports.createContext();
const FeedBackProvider = ({
  children
}) => {
  const [messageApi, messageContextHolder] = message$1.useMessage();
  const [notificationApi, notificationContextHolder] = notification$1.useNotification();
  const showSuccessMessage = (content, duration = 1.5) => {
    messageApi.open({
      type: "success",
      content,
      duration
    });
  };
  const showWarningMessage = (content, duration = 1.5) => {
    messageApi.open({
      type: "warning",
      content,
      duration
    });
  };
  const showErrorMessage = (content, duration = 1.5) => {
    messageApi.open({
      type: "error",
      content,
      duration
    });
  };
  const showNotification = (title, content, placement = "topRight", duration = 1.5, icon = null) => {
    notificationApi.info({
      message: title,
      description: content,
      placement,
      duration,
      icon
    });
  };
  return /* @__PURE__ */ jsxs(FeedbackContext.Provider, {
    value: {
      showSuccessMessage,
      showWarningMessage,
      showErrorMessage,
      showNotification
    },
    children: [/* @__PURE__ */ jsx("div", {
      children: messageContextHolder
    }, "messageContextHolder"), /* @__PURE__ */ jsx("div", {
      children: notificationContextHolder
    }, "notificationContextHolder"), children]
  });
};
var IconContext = /* @__PURE__ */ react.exports.createContext({});
const Context = IconContext;
var hueStep = 2;
var saturationStep = 0.16;
var saturationStep2 = 0.05;
var brightnessStep1 = 0.05;
var brightnessStep2 = 0.15;
var lightColorCount = 5;
var darkColorCount = 4;
var darkColorMap = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function toHsv(_ref) {
  var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
  var hsv = rgbToHsv(r2, g2, b2);
  return {
    h: hsv.h * 360,
    s: hsv.s,
    v: hsv.v
  };
}
function toHex(_ref2) {
  var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
  return "#".concat(rgbToHex(r2, g2, b2, false));
}
function mix(rgb1, rgb2, amount) {
  var p2 = amount / 100;
  var rgb = {
    r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p2 + rgb1.b
  };
  return rgb;
}
function getHue(hsv, i2, light) {
  var hue;
  if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
    hue = light ? Math.round(hsv.h) - hueStep * i2 : Math.round(hsv.h) + hueStep * i2;
  } else {
    hue = light ? Math.round(hsv.h) + hueStep * i2 : Math.round(hsv.h) - hueStep * i2;
  }
  if (hue < 0) {
    hue += 360;
  } else if (hue >= 360) {
    hue -= 360;
  }
  return hue;
}
function getSaturation(hsv, i2, light) {
  if (hsv.h === 0 && hsv.s === 0) {
    return hsv.s;
  }
  var saturation;
  if (light) {
    saturation = hsv.s - saturationStep * i2;
  } else if (i2 === darkColorCount) {
    saturation = hsv.s + saturationStep;
  } else {
    saturation = hsv.s + saturationStep2 * i2;
  }
  if (saturation > 1) {
    saturation = 1;
  }
  if (light && i2 === lightColorCount && saturation > 0.1) {
    saturation = 0.1;
  }
  if (saturation < 0.06) {
    saturation = 0.06;
  }
  return Number(saturation.toFixed(2));
}
function getValue(hsv, i2, light) {
  var value;
  if (light) {
    value = hsv.v + brightnessStep1 * i2;
  } else {
    value = hsv.v - brightnessStep2 * i2;
  }
  if (value > 1) {
    value = 1;
  }
  return Number(value.toFixed(2));
}
function generate$1(color) {
  var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var patterns = [];
  var pColor = inputToRGB(color);
  for (var i2 = lightColorCount; i2 > 0; i2 -= 1) {
    var hsv = toHsv(pColor);
    var colorString = toHex(inputToRGB({
      h: getHue(hsv, i2, true),
      s: getSaturation(hsv, i2, true),
      v: getValue(hsv, i2, true)
    }));
    patterns.push(colorString);
  }
  patterns.push(toHex(pColor));
  for (var _i = 1; _i <= darkColorCount; _i += 1) {
    var _hsv = toHsv(pColor);
    var _colorString = toHex(inputToRGB({
      h: getHue(_hsv, _i),
      s: getSaturation(_hsv, _i),
      v: getValue(_hsv, _i)
    }));
    patterns.push(_colorString);
  }
  if (opts.theme === "dark") {
    return darkColorMap.map(function(_ref3) {
      var index2 = _ref3.index, opacity = _ref3.opacity;
      var darkColorString = toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
      return darkColorString;
    });
  }
  return patterns;
}
var presetPrimaryColors = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
};
var presetPalettes = {};
var presetDarkPalettes = {};
Object.keys(presetPrimaryColors).forEach(function(key) {
  presetPalettes[key] = generate$1(presetPrimaryColors[key]);
  presetPalettes[key].primary = presetPalettes[key][5];
  presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
    theme: "dark",
    backgroundColor: "#141414"
  });
  presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
});
function warning2(valid, message2) {
  warningOnce(valid, "[@ant-design/icons] ".concat(message2));
}
function isIconDefinition(target) {
  return _typeof$1(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof$1(target.icon) === "object" || typeof target.icon === "function");
}
function normalizeAttrs() {
  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(attrs).reduce(function(acc, key) {
    var val = attrs[key];
    switch (key) {
      case "class":
        acc.className = val;
        delete acc.class;
        break;
      default:
        acc[key] = val;
    }
    return acc;
  }, {});
}
function generate(node2, key, rootProps) {
  if (!rootProps) {
    return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$1({
      key
    }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
      return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2$1(_objectSpread2$1({
    key
  }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
    return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
  }));
}
function getSecondaryColor(primaryColor) {
  return generate$1(primaryColor)[0];
}
function normalizeTwoToneColors(twoToneColor) {
  if (!twoToneColor) {
    return [];
  }
  return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
}
var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
var useInsertStyles2 = function useInsertStyles3() {
  var styleStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : iconStyles;
  var _useContext = react.exports.useContext(Context), csp = _useContext.csp;
  react.exports.useEffect(function() {
    updateCSS(styleStr, "@ant-design-icons", {
      prepend: true,
      csp
    });
  }, []);
};
var _excluded$1 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
var twoToneColorPalette = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: false
};
function setTwoToneColors(_ref) {
  var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
  twoToneColorPalette.primaryColor = primaryColor;
  twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
  twoToneColorPalette.calculated = !!secondaryColor;
}
function getTwoToneColors() {
  return _objectSpread2$1({}, twoToneColorPalette);
}
var IconBase2 = function IconBase3(props) {
  var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$1);
  var colors = twoToneColorPalette;
  if (primaryColor) {
    colors = {
      primaryColor,
      secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
    };
  }
  useInsertStyles2();
  warning2(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
  if (!isIconDefinition(icon)) {
    return null;
  }
  var target = icon;
  if (target && typeof target.icon === "function") {
    target = _objectSpread2$1(_objectSpread2$1({}, target), {}, {
      icon: target.icon(colors.primaryColor, colors.secondaryColor)
    });
  }
  return generate(target.icon, "svg-".concat(target.name), _objectSpread2$1({
    className,
    onClick,
    style: style2,
    "data-icon": target.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, restProps));
};
IconBase2.displayName = "IconReact";
IconBase2.getTwoToneColors = getTwoToneColors;
IconBase2.setTwoToneColors = setTwoToneColors;
const ReactIcon = IconBase2;
function setTwoToneColor(twoToneColor) {
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return ReactIcon.setTwoToneColors({
    primaryColor,
    secondaryColor
  });
}
function getTwoToneColor() {
  var colors = ReactIcon.getTwoToneColors();
  if (!colors.calculated) {
    return colors.primaryColor;
  }
  return [colors.primaryColor, colors.secondaryColor];
}
var _excluded = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
setTwoToneColor("#1890ff");
var Icon = /* @__PURE__ */ react.exports.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded);
  var _React$useContext = react.exports.useContext(Context), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
  var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty$1(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty$1(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
  var iconTabIndex = tabIndex;
  if (iconTabIndex === void 0 && onClick) {
    iconTabIndex = -1;
  }
  var svgStyle = rotate ? {
    msTransform: "rotate(".concat(rotate, "deg)"),
    transform: "rotate(".concat(rotate, "deg)")
  } : void 0;
  var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
  return /* @__PURE__ */ jsx("span", {
    ..._objectSpread2$1(_objectSpread2$1({
      role: "img",
      "aria-label": icon.name
    }, restProps), {}, {
      ref,
      tabIndex: iconTabIndex,
      onClick,
      className: classString
    }),
    children: /* @__PURE__ */ jsx(ReactIcon, {
      icon,
      primaryColor,
      secondaryColor,
      style: svgStyle
    })
  });
});
Icon.displayName = "AntdIcon";
Icon.getTwoToneColor = getTwoToneColor;
Icon.setTwoToneColor = setTwoToneColor;
const AntdIcon = Icon;
var DollarCircleOutlined = function DollarCircleOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: DollarCircleOutlinedSvg
    })
  });
};
DollarCircleOutlined.displayName = "DollarCircleOutlined";
const DollarCircleOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(DollarCircleOutlined);
var FormOutlined = function FormOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: FormOutlinedSvg
    })
  });
};
FormOutlined.displayName = "FormOutlined";
const FormOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(FormOutlined);
var HomeOutlined = function HomeOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: HomeOutlinedSvg
    })
  });
};
HomeOutlined.displayName = "HomeOutlined";
const HomeOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(HomeOutlined);
var LockOutlined = function LockOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: LockOutlinedSvg
    })
  });
};
LockOutlined.displayName = "LockOutlined";
const LockOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LockOutlined);
var LogoutOutlined = function LogoutOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: LogoutOutlinedSvg
    })
  });
};
LogoutOutlined.displayName = "LogoutOutlined";
const LogoutOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(LogoutOutlined);
var MinusOutlined = function MinusOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: MinusOutlinedSvg
    })
  });
};
MinusOutlined.displayName = "MinusOutlined";
const MinusOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(MinusOutlined);
var PlusOutlined2 = function PlusOutlined3(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: PlusOutlinedSvg
    })
  });
};
PlusOutlined2.displayName = "PlusOutlined";
const PlusOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(PlusOutlined2);
var UserOutlined = function UserOutlined2(props, ref) {
  return /* @__PURE__ */ jsx(AntdIcon, {
    ..._objectSpread2$1(_objectSpread2$1({}, props), {}, {
      ref,
      icon: UserOutlinedSvg
    })
  });
};
UserOutlined.displayName = "UserOutlined";
const UserOutlined$1 = /* @__PURE__ */ react.exports.forwardRef(UserOutlined);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function(str) {
  const out = [];
  let p2 = 0;
  for (let i2 = 0; i2 < str.length; i2++) {
    let c2 = str.charCodeAt(i2);
    if (c2 < 128) {
      out[p2++] = c2;
    } else if (c2 < 2048) {
      out[p2++] = c2 >> 6 | 192;
      out[p2++] = c2 & 63 | 128;
    } else if ((c2 & 64512) === 55296 && i2 + 1 < str.length && (str.charCodeAt(i2 + 1) & 64512) === 56320) {
      c2 = 65536 + ((c2 & 1023) << 10) + (str.charCodeAt(++i2) & 1023);
      out[p2++] = c2 >> 18 | 240;
      out[p2++] = c2 >> 12 & 63 | 128;
      out[p2++] = c2 >> 6 & 63 | 128;
      out[p2++] = c2 & 63 | 128;
    } else {
      out[p2++] = c2 >> 12 | 224;
      out[p2++] = c2 >> 6 & 63 | 128;
      out[p2++] = c2 & 63 | 128;
    }
  }
  return out;
};
const byteArrayToString = function(bytes) {
  const out = [];
  let pos = 0, c2 = 0;
  while (pos < bytes.length) {
    const c1 = bytes[pos++];
    if (c1 < 128) {
      out[c2++] = String.fromCharCode(c1);
    } else if (c1 > 191 && c1 < 224) {
      const c22 = bytes[pos++];
      out[c2++] = String.fromCharCode((c1 & 31) << 6 | c22 & 63);
    } else if (c1 > 239 && c1 < 365) {
      const c22 = bytes[pos++];
      const c3 = bytes[pos++];
      const c4 = bytes[pos++];
      const u2 = ((c1 & 7) << 18 | (c22 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
      out[c2++] = String.fromCharCode(55296 + (u2 >> 10));
      out[c2++] = String.fromCharCode(56320 + (u2 & 1023));
    } else {
      const c22 = bytes[pos++];
      const c3 = bytes[pos++];
      out[c2++] = String.fromCharCode((c1 & 15) << 12 | (c22 & 63) << 6 | c3 & 63);
    }
  }
  return out.join("");
};
const base64 = {
  byteToCharMap_: null,
  charToByteMap_: null,
  byteToCharMapWebSafe_: null,
  charToByteMapWebSafe_: null,
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  HAS_NATIVE_SUPPORT: typeof atob === "function",
  encodeByteArray(input, webSafe) {
    if (!Array.isArray(input)) {
      throw Error("encodeByteArray takes an array as a parameter");
    }
    this.init_();
    const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
    const output = [];
    for (let i2 = 0; i2 < input.length; i2 += 3) {
      const byte1 = input[i2];
      const haveByte2 = i2 + 1 < input.length;
      const byte2 = haveByte2 ? input[i2 + 1] : 0;
      const haveByte3 = i2 + 2 < input.length;
      const byte3 = haveByte3 ? input[i2 + 2] : 0;
      const outByte1 = byte1 >> 2;
      const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
      let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
      let outByte4 = byte3 & 63;
      if (!haveByte3) {
        outByte4 = 64;
        if (!haveByte2) {
          outByte3 = 64;
        }
      }
      output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
    }
    return output.join("");
  },
  encodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return btoa(input);
    }
    return this.encodeByteArray(stringToByteArray$1(input), webSafe);
  },
  decodeString(input, webSafe) {
    if (this.HAS_NATIVE_SUPPORT && !webSafe) {
      return atob(input);
    }
    return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
  },
  decodeStringToByteArray(input, webSafe) {
    this.init_();
    const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
    const output = [];
    for (let i2 = 0; i2 < input.length; ) {
      const byte1 = charToByteMap[input.charAt(i2++)];
      const haveByte2 = i2 < input.length;
      const byte2 = haveByte2 ? charToByteMap[input.charAt(i2)] : 0;
      ++i2;
      const haveByte3 = i2 < input.length;
      const byte3 = haveByte3 ? charToByteMap[input.charAt(i2)] : 64;
      ++i2;
      const haveByte4 = i2 < input.length;
      const byte4 = haveByte4 ? charToByteMap[input.charAt(i2)] : 64;
      ++i2;
      if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
        throw Error();
      }
      const outByte1 = byte1 << 2 | byte2 >> 4;
      output.push(outByte1);
      if (byte3 !== 64) {
        const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
        output.push(outByte2);
        if (byte4 !== 64) {
          const outByte3 = byte3 << 6 & 192 | byte4;
          output.push(outByte3);
        }
      }
    }
    return output;
  },
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {};
      this.charToByteMap_ = {};
      this.byteToCharMapWebSafe_ = {};
      this.charToByteMapWebSafe_ = {};
      for (let i2 = 0; i2 < this.ENCODED_VALS.length; i2++) {
        this.byteToCharMap_[i2] = this.ENCODED_VALS.charAt(i2);
        this.charToByteMap_[this.byteToCharMap_[i2]] = i2;
        this.byteToCharMapWebSafe_[i2] = this.ENCODED_VALS_WEBSAFE.charAt(i2);
        this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i2]] = i2;
        if (i2 >= this.ENCODED_VALS_BASE.length) {
          this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i2)] = i2;
          this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i2)] = i2;
        }
      }
    }
  }
};
const base64Encode = function(str) {
  const utf8Bytes = stringToByteArray$1(str);
  return base64.encodeByteArray(utf8Bytes, true);
};
const base64urlEncodeWithoutPadding = function(str) {
  return base64Encode(str).replace(/\./g, "");
};
const base64Decode = function(str) {
  try {
    return base64.decodeString(str, true);
  } catch (e2) {
    console.error("base64Decode failed: ", e2);
  }
  return null;
};
function isIndexedDBAvailable() {
  try {
    return typeof indexedDB === "object";
  } catch (e2) {
    return false;
  }
}
function validateIndexedDBOpenable() {
  return new Promise((resolve, reject) => {
    try {
      let preExist = true;
      const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
      const request = self.indexedDB.open(DB_CHECK_NAME);
      request.onsuccess = () => {
        request.result.close();
        if (!preExist) {
          self.indexedDB.deleteDatabase(DB_CHECK_NAME);
        }
        resolve(true);
      };
      request.onupgradeneeded = () => {
        preExist = false;
      };
      request.onerror = () => {
        var _a;
        reject(((_a = request.error) === null || _a === void 0 ? void 0 : _a.message) || "");
      };
    } catch (error) {
      reject(error);
    }
  });
}
function areCookiesEnabled() {
  if (typeof navigator === "undefined" || !navigator.cookieEnabled) {
    return false;
  }
  return true;
}
function getGlobal() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__;
const getDefaultsFromEnvVariable = () => {
  if (typeof process === "undefined" || typeof process.env === "undefined") {
    return;
  }
  const defaultsJsonString = {}.__FIREBASE_DEFAULTS__;
  if (defaultsJsonString) {
    return JSON.parse(defaultsJsonString);
  }
};
const getDefaultsFromCookie = () => {
  if (typeof document === "undefined") {
    return;
  }
  let match;
  try {
    match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch (e2) {
    return;
  }
  const decoded = match && base64Decode(match[1]);
  return decoded && JSON.parse(decoded);
};
const getDefaults = () => {
  try {
    return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
  } catch (e2) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e2}`);
    return;
  }
};
const getDefaultAppConfig = () => {
  var _a;
  return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
  constructor() {
    this.reject = () => {
    };
    this.resolve = () => {
    };
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
  wrapCallback(callback) {
    return (error, value) => {
      if (error) {
        this.reject(error);
      } else {
        this.resolve(value);
      }
      if (typeof callback === "function") {
        this.promise.catch(() => {
        });
        if (callback.length === 1) {
          callback(error);
        } else {
          callback(error, value);
        }
      }
    };
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_NAME = "FirebaseError";
class FirebaseError extends Error {
  constructor(code, message2, customData) {
    super(message2);
    this.code = code;
    this.customData = customData;
    this.name = ERROR_NAME;
    Object.setPrototypeOf(this, FirebaseError.prototype);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ErrorFactory.prototype.create);
    }
  }
}
class ErrorFactory {
  constructor(service, serviceName, errors) {
    this.service = service;
    this.serviceName = serviceName;
    this.errors = errors;
  }
  create(code, ...data) {
    const customData = data[0] || {};
    const fullCode = `${this.service}/${code}`;
    const template = this.errors[code];
    const message2 = template ? replaceTemplate(template, customData) : "Error";
    const fullMessage = `${this.serviceName}: ${message2} (${fullCode}).`;
    const error = new FirebaseError(fullCode, fullMessage, customData);
    return error;
  }
}
function replaceTemplate(template, data) {
  return template.replace(PATTERN, (_2, key) => {
    const value = data[key];
    return value != null ? String(value) : `<${key}?>`;
  });
}
const PATTERN = /\{\$([^}]+)}/g;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b2);
  for (const k2 of aKeys) {
    if (!bKeys.includes(k2)) {
      return false;
    }
    const aProp = a2[k2];
    const bProp = b2[k2];
    if (isObject(aProp) && isObject(bProp)) {
      if (!deepEqual(aProp, bProp)) {
        return false;
      }
    } else if (aProp !== bProp) {
      return false;
    }
  }
  for (const k2 of bKeys) {
    if (!aKeys.includes(k2)) {
      return false;
    }
  }
  return true;
}
function isObject(thing) {
  return thing !== null && typeof thing === "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(service) {
  if (service && service._delegate) {
    return service._delegate;
  } else {
    return service;
  }
}
class Component {
  constructor(name2, instanceFactory, type4) {
    this.name = name2;
    this.instanceFactory = instanceFactory;
    this.type = type4;
    this.multipleInstances = false;
    this.serviceProps = {};
    this.instantiationMode = "LAZY";
    this.onInstanceCreated = null;
  }
  setInstantiationMode(mode) {
    this.instantiationMode = mode;
    return this;
  }
  setMultipleInstances(multipleInstances) {
    this.multipleInstances = multipleInstances;
    return this;
  }
  setServiceProps(props) {
    this.serviceProps = props;
    return this;
  }
  setInstanceCreatedCallback(callback) {
    this.onInstanceCreated = callback;
    return this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Provider {
  constructor(name2, container) {
    this.name = name2;
    this.container = container;
    this.component = null;
    this.instances = /* @__PURE__ */ new Map();
    this.instancesDeferred = /* @__PURE__ */ new Map();
    this.instancesOptions = /* @__PURE__ */ new Map();
    this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  get(identifier2) {
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier2);
    if (!this.instancesDeferred.has(normalizedIdentifier)) {
      const deferred = new Deferred();
      this.instancesDeferred.set(normalizedIdentifier, deferred);
      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
        try {
          const instance = this.getOrInitializeService({
            instanceIdentifier: normalizedIdentifier
          });
          if (instance) {
            deferred.resolve(instance);
          }
        } catch (e2) {
        }
      }
    }
    return this.instancesDeferred.get(normalizedIdentifier).promise;
  }
  getImmediate(options) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
    const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
      try {
        return this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
      } catch (e2) {
        if (optional) {
          return null;
        } else {
          throw e2;
        }
      }
    } else {
      if (optional) {
        return null;
      } else {
        throw Error(`Service ${this.name} is not available`);
      }
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(component) {
    if (component.name !== this.name) {
      throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
    }
    if (this.component) {
      throw Error(`Component for ${this.name} has already been provided`);
    }
    this.component = component;
    if (!this.shouldAutoInitialize()) {
      return;
    }
    if (isComponentEager(component)) {
      try {
        this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
      } catch (e2) {
      }
    }
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      try {
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier
        });
        instanceDeferred.resolve(instance);
      } catch (e2) {
      }
    }
  }
  clearInstance(identifier2 = DEFAULT_ENTRY_NAME$1) {
    this.instancesDeferred.delete(identifier2);
    this.instancesOptions.delete(identifier2);
    this.instances.delete(identifier2);
  }
  async delete() {
    const services = Array.from(this.instances.values());
    await Promise.all([
      ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
      ...services.filter((service) => "_delete" in service).map((service) => service._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(identifier2 = DEFAULT_ENTRY_NAME$1) {
    return this.instances.has(identifier2);
  }
  getOptions(identifier2 = DEFAULT_ENTRY_NAME$1) {
    return this.instancesOptions.get(identifier2) || {};
  }
  initialize(opts = {}) {
    const { options = {} } = opts;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
    if (this.isInitialized(normalizedIdentifier)) {
      throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
    }
    if (!this.isComponentSet()) {
      throw Error(`Component ${this.name} has not been registered yet`);
    }
    const instance = this.getOrInitializeService({
      instanceIdentifier: normalizedIdentifier,
      options
    });
    for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
      const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
      if (normalizedIdentifier === normalizedDeferredIdentifier) {
        instanceDeferred.resolve(instance);
      }
    }
    return instance;
  }
  onInit(callback, identifier2) {
    var _a;
    const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier2);
    const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set();
    existingCallbacks.add(callback);
    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
    const existingInstance = this.instances.get(normalizedIdentifier);
    if (existingInstance) {
      callback(existingInstance, normalizedIdentifier);
    }
    return () => {
      existingCallbacks.delete(callback);
    };
  }
  invokeOnInitCallbacks(instance, identifier2) {
    const callbacks = this.onInitCallbacks.get(identifier2);
    if (!callbacks) {
      return;
    }
    for (const callback of callbacks) {
      try {
        callback(instance, identifier2);
      } catch (_a) {
      }
    }
  }
  getOrInitializeService({ instanceIdentifier, options = {} }) {
    let instance = this.instances.get(instanceIdentifier);
    if (!instance && this.component) {
      instance = this.component.instanceFactory(this.container, {
        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
        options
      });
      this.instances.set(instanceIdentifier, instance);
      this.instancesOptions.set(instanceIdentifier, options);
      this.invokeOnInitCallbacks(instance, instanceIdentifier);
      if (this.component.onInstanceCreated) {
        try {
          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
        } catch (_a) {
        }
      }
    }
    return instance || null;
  }
  normalizeInstanceIdentifier(identifier2 = DEFAULT_ENTRY_NAME$1) {
    if (this.component) {
      return this.component.multipleInstances ? identifier2 : DEFAULT_ENTRY_NAME$1;
    } else {
      return identifier2;
    }
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function normalizeIdentifierForFactory(identifier2) {
  return identifier2 === DEFAULT_ENTRY_NAME$1 ? void 0 : identifier2;
}
function isComponentEager(component) {
  return component.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ComponentContainer {
  constructor(name2) {
    this.name = name2;
    this.providers = /* @__PURE__ */ new Map();
  }
  addComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
    }
    provider.setComponent(component);
  }
  addOrOverwriteComponent(component) {
    const provider = this.getProvider(component.name);
    if (provider.isComponentSet()) {
      this.providers.delete(component.name);
    }
    this.addComponent(component);
  }
  getProvider(name2) {
    if (this.providers.has(name2)) {
      return this.providers.get(name2);
    }
    const provider = new Provider(name2, this);
    this.providers.set(name2, provider);
    return provider;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["DEBUG"] = 0] = "DEBUG";
  LogLevel2[LogLevel2["VERBOSE"] = 1] = "VERBOSE";
  LogLevel2[LogLevel2["INFO"] = 2] = "INFO";
  LogLevel2[LogLevel2["WARN"] = 3] = "WARN";
  LogLevel2[LogLevel2["ERROR"] = 4] = "ERROR";
  LogLevel2[LogLevel2["SILENT"] = 5] = "SILENT";
})(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
  "debug": LogLevel.DEBUG,
  "verbose": LogLevel.VERBOSE,
  "info": LogLevel.INFO,
  "warn": LogLevel.WARN,
  "error": LogLevel.ERROR,
  "silent": LogLevel.SILENT
};
const defaultLogLevel = LogLevel.INFO;
const ConsoleMethod = {
  [LogLevel.DEBUG]: "log",
  [LogLevel.VERBOSE]: "log",
  [LogLevel.INFO]: "info",
  [LogLevel.WARN]: "warn",
  [LogLevel.ERROR]: "error"
};
const defaultLogHandler = (instance, logType, ...args) => {
  if (logType < instance.logLevel) {
    return;
  }
  const now = new Date().toISOString();
  const method4 = ConsoleMethod[logType];
  if (method4) {
    console[method4](`[${now}]  ${instance.name}:`, ...args);
  } else {
    throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
  }
};
class Logger {
  constructor(name2) {
    this.name = name2;
    this._logLevel = defaultLogLevel;
    this._logHandler = defaultLogHandler;
    this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(val) {
    if (!(val in LogLevel)) {
      throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
    }
    this._logLevel = val;
  }
  setLogLevel(val) {
    this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(val) {
    if (typeof val !== "function") {
      throw new TypeError("Value assigned to `logHandler` must be a function");
    }
    this._logHandler = val;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(val) {
    this._userLogHandler = val;
  }
  debug(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...args);
    this._logHandler(this, LogLevel.DEBUG, ...args);
  }
  log(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...args);
    this._logHandler(this, LogLevel.VERBOSE, ...args);
  }
  info(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...args);
    this._logHandler(this, LogLevel.INFO, ...args);
  }
  warn(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...args);
    this._logHandler(this, LogLevel.WARN, ...args);
  }
  error(...args) {
    this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...args);
    this._logHandler(this, LogLevel.ERROR, ...args);
  }
}
const instanceOfAny = (object4, constructors) => constructors.some((c2) => object4 instanceof c2);
let idbProxyableTypes;
let cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const cursorRequestMap = /* @__PURE__ */ new WeakMap();
const transactionDoneMap = /* @__PURE__ */ new WeakMap();
const transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
const transformCache = /* @__PURE__ */ new WeakMap();
const reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise2 = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise2.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise2, request);
  return promise2;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
let idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
const unwrap = (value) => reverseTransformCache.get(value);
function openDB(name2, version2, { blocked, upgrade, blocking, terminated } = {}) {
  const request = indexedDB.open(name2, version2);
  const openPromise = wrap(request);
  if (upgrade) {
    request.addEventListener("upgradeneeded", (event) => {
      upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));
    });
  }
  if (blocked)
    request.addEventListener("blocked", () => blocked());
  openPromise.then((db2) => {
    if (terminated)
      db2.addEventListener("close", () => terminated());
    if (blocking)
      db2.addEventListener("versionchange", () => blocking());
  }).catch(() => {
  });
  return openPromise;
}
function deleteDB(name2, { blocked } = {}) {
  const request = indexedDB.deleteDatabase(name2);
  if (blocked)
    request.addEventListener("blocked", () => blocked());
  return wrap(request).then(() => void 0);
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
const writeMethods = ["put", "add", "delete", "clear"];
const cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (!(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))) {
    return;
  }
  const method4 = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method4);
  return method4;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
  constructor(container) {
    this.container = container;
  }
  getPlatformInfoString() {
    const providers = this.container.getProviders();
    return providers.map((provider) => {
      if (isVersionServiceProvider(provider)) {
        const service = provider.getImmediate();
        return `${service.library}/${service.version}`;
      } else {
        return null;
      }
    }).filter((logString) => logString).join(" ");
  }
}
function isVersionServiceProvider(provider) {
  const component = provider.getComponent();
  return (component === null || component === void 0 ? void 0 : component.type) === "VERSION";
}
const name$o = "@firebase/app";
const version$1$1 = "0.9.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger("@firebase/app");
const name$n = "@firebase/app-compat";
const name$m = "@firebase/analytics-compat";
const name$l = "@firebase/analytics";
const name$k = "@firebase/app-check-compat";
const name$j = "@firebase/app-check";
const name$i = "@firebase/auth";
const name$h = "@firebase/auth-compat";
const name$g = "@firebase/database";
const name$f = "@firebase/database-compat";
const name$e = "@firebase/functions";
const name$d = "@firebase/functions-compat";
const name$c = "@firebase/installations";
const name$b = "@firebase/installations-compat";
const name$a = "@firebase/messaging";
const name$9 = "@firebase/messaging-compat";
const name$8 = "@firebase/performance";
const name$7 = "@firebase/performance-compat";
const name$6 = "@firebase/remote-config";
const name$5 = "@firebase/remote-config-compat";
const name$4 = "@firebase/storage";
const name$3 = "@firebase/storage-compat";
const name$2$1 = "@firebase/firestore";
const name$1$1 = "@firebase/firestore-compat";
const name$p = "firebase";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = "[DEFAULT]";
const PLATFORM_LOG_STRING = {
  [name$o]: "fire-core",
  [name$n]: "fire-core-compat",
  [name$l]: "fire-analytics",
  [name$m]: "fire-analytics-compat",
  [name$j]: "fire-app-check",
  [name$k]: "fire-app-check-compat",
  [name$i]: "fire-auth",
  [name$h]: "fire-auth-compat",
  [name$g]: "fire-rtdb",
  [name$f]: "fire-rtdb-compat",
  [name$e]: "fire-fn",
  [name$d]: "fire-fn-compat",
  [name$c]: "fire-iid",
  [name$b]: "fire-iid-compat",
  [name$a]: "fire-fcm",
  [name$9]: "fire-fcm-compat",
  [name$8]: "fire-perf",
  [name$7]: "fire-perf-compat",
  [name$6]: "fire-rc",
  [name$5]: "fire-rc-compat",
  [name$4]: "fire-gcs",
  [name$3]: "fire-gcs-compat",
  [name$2$1]: "fire-fst",
  [name$1$1]: "fire-fst-compat",
  "fire-js": "fire-js",
  [name$p]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _apps = /* @__PURE__ */ new Map();
const _components = /* @__PURE__ */ new Map();
function _addComponent(app, component) {
  try {
    app.container.addComponent(component);
  } catch (e2) {
    logger.debug(`Component ${component.name} failed to register with FirebaseApp ${app.name}`, e2);
  }
}
function _registerComponent(component) {
  const componentName = component.name;
  if (_components.has(componentName)) {
    logger.debug(`There were multiple attempts to register component ${componentName}.`);
    return false;
  }
  _components.set(componentName, component);
  for (const app of _apps.values()) {
    _addComponent(app, component);
  }
  return true;
}
function _getProvider(app, name2) {
  const heartbeatController = app.container.getProvider("heartbeat").getImmediate({ optional: true });
  if (heartbeatController) {
    void heartbeatController.triggerHeartbeat();
  }
  return app.container.getProvider(name2);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["bad-app-name"]: "Illegal App name: '{$appName}",
  ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
  ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
  ["no-options"]: "Need to provide options, when not being deployed to hosting via source.",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  ["invalid-log-argument"]: "First argument to `onLog` must be null or a function.",
  ["idb-open"]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-get"]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-set"]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-delete"]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
};
const ERROR_FACTORY$2 = new ErrorFactory("app", "Firebase", ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
  constructor(options, config, container) {
    this._isDeleted = false;
    this._options = Object.assign({}, options);
    this._config = Object.assign({}, config);
    this._name = config.name;
    this._automaticDataCollectionEnabled = config.automaticDataCollectionEnabled;
    this._container = container;
    this.container.addComponent(new Component("app", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    this.checkDestroyed();
    return this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(val) {
    this.checkDestroyed();
    this._automaticDataCollectionEnabled = val;
  }
  get name() {
    this.checkDestroyed();
    return this._name;
  }
  get options() {
    this.checkDestroyed();
    return this._options;
  }
  get config() {
    this.checkDestroyed();
    return this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(val) {
    this._isDeleted = val;
  }
  checkDestroyed() {
    if (this.isDeleted) {
      throw ERROR_FACTORY$2.create("app-deleted", { appName: this._name });
    }
  }
}
function initializeApp(_options, rawConfig = {}) {
  let options = _options;
  if (typeof rawConfig !== "object") {
    const name3 = rawConfig;
    rawConfig = { name: name3 };
  }
  const config = Object.assign({ name: DEFAULT_ENTRY_NAME, automaticDataCollectionEnabled: false }, rawConfig);
  const name2 = config.name;
  if (typeof name2 !== "string" || !name2) {
    throw ERROR_FACTORY$2.create("bad-app-name", {
      appName: String(name2)
    });
  }
  options || (options = getDefaultAppConfig());
  if (!options) {
    throw ERROR_FACTORY$2.create("no-options");
  }
  const existingApp = _apps.get(name2);
  if (existingApp) {
    if (deepEqual(options, existingApp.options) && deepEqual(config, existingApp.config)) {
      return existingApp;
    } else {
      throw ERROR_FACTORY$2.create("duplicate-app", { appName: name2 });
    }
  }
  const container = new ComponentContainer(name2);
  for (const component of _components.values()) {
    container.addComponent(component);
  }
  const newApp = new FirebaseAppImpl(options, config, container);
  _apps.set(name2, newApp);
  return newApp;
}
function getApp(name2 = DEFAULT_ENTRY_NAME) {
  const app = _apps.get(name2);
  if (!app && name2 === DEFAULT_ENTRY_NAME) {
    return initializeApp();
  }
  if (!app) {
    throw ERROR_FACTORY$2.create("no-app", { appName: name2 });
  }
  return app;
}
function registerVersion(libraryKeyOrName, version2, variant) {
  var _a;
  let library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
  if (variant) {
    library += `-${variant}`;
  }
  const libraryMismatch = library.match(/\s|\//);
  const versionMismatch = version2.match(/\s|\//);
  if (libraryMismatch || versionMismatch) {
    const warning3 = [
      `Unable to register library "${library}" with version "${version2}":`
    ];
    if (libraryMismatch) {
      warning3.push(`library name "${library}" contains illegal characters (whitespace or "/")`);
    }
    if (libraryMismatch && versionMismatch) {
      warning3.push("and");
    }
    if (versionMismatch) {
      warning3.push(`version name "${version2}" contains illegal characters (whitespace or "/")`);
    }
    logger.warn(warning3.join(" "));
    return;
  }
  _registerComponent(new Component(`${library}-version`, () => ({ library, version: version2 }), "VERSION"));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = "firebase-heartbeat-database";
const DB_VERSION = 1;
const STORE_NAME = "firebase-heartbeat-store";
let dbPromise$2 = null;
function getDbPromise$2() {
  if (!dbPromise$2) {
    dbPromise$2 = openDB(DB_NAME, DB_VERSION, {
      upgrade: (db2, oldVersion) => {
        switch (oldVersion) {
          case 0:
            db2.createObjectStore(STORE_NAME);
        }
      }
    }).catch((e2) => {
      throw ERROR_FACTORY$2.create("idb-open", {
        originalErrorMessage: e2.message
      });
    });
  }
  return dbPromise$2;
}
async function readHeartbeatsFromIndexedDB(app) {
  try {
    const db2 = await getDbPromise$2();
    return db2.transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(app));
  } catch (e2) {
    if (e2 instanceof FirebaseError) {
      logger.warn(e2.message);
    } else {
      const idbGetError = ERROR_FACTORY$2.create("idb-get", {
        originalErrorMessage: e2 === null || e2 === void 0 ? void 0 : e2.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
async function writeHeartbeatsToIndexedDB(app, heartbeatObject) {
  try {
    const db2 = await getDbPromise$2();
    const tx = db2.transaction(STORE_NAME, "readwrite");
    const objectStore = tx.objectStore(STORE_NAME);
    await objectStore.put(heartbeatObject, computeKey(app));
    return tx.done;
  } catch (e2) {
    if (e2 instanceof FirebaseError) {
      logger.warn(e2.message);
    } else {
      const idbGetError = ERROR_FACTORY$2.create("idb-set", {
        originalErrorMessage: e2 === null || e2 === void 0 ? void 0 : e2.message
      });
      logger.warn(idbGetError.message);
    }
  }
}
function computeKey(app) {
  return `${app.name}!${app.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024;
const STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;
class HeartbeatServiceImpl {
  constructor(container) {
    this.container = container;
    this._heartbeatsCache = null;
    const app = this.container.getProvider("app").getImmediate();
    this._storage = new HeartbeatStorageImpl(app);
    this._heartbeatsCachePromise = this._storage.read().then((result) => {
      this._heartbeatsCache = result;
      return result;
    });
  }
  async triggerHeartbeat() {
    const platformLogger = this.container.getProvider("platform-logger").getImmediate();
    const agent = platformLogger.getPlatformInfoString();
    const date4 = getUTCDateString();
    if (this._heartbeatsCache === null) {
      this._heartbeatsCache = await this._heartbeatsCachePromise;
    }
    if (this._heartbeatsCache.lastSentHeartbeatDate === date4 || this._heartbeatsCache.heartbeats.some((singleDateHeartbeat) => singleDateHeartbeat.date === date4)) {
      return;
    } else {
      this._heartbeatsCache.heartbeats.push({ date: date4, agent });
    }
    this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((singleDateHeartbeat) => {
      const hbTimestamp = new Date(singleDateHeartbeat.date).valueOf();
      const now = Date.now();
      return now - hbTimestamp <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS;
    });
    return this._storage.overwrite(this._heartbeatsCache);
  }
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null) {
      await this._heartbeatsCachePromise;
    }
    if (this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0) {
      return "";
    }
    const date4 = getUTCDateString();
    const { heartbeatsToSend, unsentEntries } = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats);
    const headerString = base64urlEncodeWithoutPadding(JSON.stringify({ version: 2, heartbeats: heartbeatsToSend }));
    this._heartbeatsCache.lastSentHeartbeatDate = date4;
    if (unsentEntries.length > 0) {
      this._heartbeatsCache.heartbeats = unsentEntries;
      await this._storage.overwrite(this._heartbeatsCache);
    } else {
      this._heartbeatsCache.heartbeats = [];
      void this._storage.overwrite(this._heartbeatsCache);
    }
    return headerString;
  }
}
function getUTCDateString() {
  const today = new Date();
  return today.toISOString().substring(0, 10);
}
function extractHeartbeatsForHeader(heartbeatsCache, maxSize = MAX_HEADER_BYTES) {
  const heartbeatsToSend = [];
  let unsentEntries = heartbeatsCache.slice();
  for (const singleDateHeartbeat of heartbeatsCache) {
    const heartbeatEntry = heartbeatsToSend.find((hb2) => hb2.agent === singleDateHeartbeat.agent);
    if (!heartbeatEntry) {
      heartbeatsToSend.push({
        agent: singleDateHeartbeat.agent,
        dates: [singleDateHeartbeat.date]
      });
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatsToSend.pop();
        break;
      }
    } else {
      heartbeatEntry.dates.push(singleDateHeartbeat.date);
      if (countBytes(heartbeatsToSend) > maxSize) {
        heartbeatEntry.dates.pop();
        break;
      }
    }
    unsentEntries = unsentEntries.slice(1);
  }
  return {
    heartbeatsToSend,
    unsentEntries
  };
}
class HeartbeatStorageImpl {
  constructor(app) {
    this.app = app;
    this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    if (!isIndexedDBAvailable()) {
      return false;
    } else {
      return validateIndexedDBOpenable().then(() => true).catch(() => false);
    }
  }
  async read() {
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return { heartbeats: [] };
    } else {
      const idbHeartbeatObject = await readHeartbeatsFromIndexedDB(this.app);
      return idbHeartbeatObject || { heartbeats: [] };
    }
  }
  async overwrite(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: heartbeatsObject.heartbeats
      });
    }
  }
  async add(heartbeatsObject) {
    var _a;
    const canUseIndexedDB = await this._canUseIndexedDBPromise;
    if (!canUseIndexedDB) {
      return;
    } else {
      const existingHeartbeatsObject = await this.read();
      return writeHeartbeatsToIndexedDB(this.app, {
        lastSentHeartbeatDate: (_a = heartbeatsObject.lastSentHeartbeatDate) !== null && _a !== void 0 ? _a : existingHeartbeatsObject.lastSentHeartbeatDate,
        heartbeats: [
          ...existingHeartbeatsObject.heartbeats,
          ...heartbeatsObject.heartbeats
        ]
      });
    }
  }
}
function countBytes(heartbeatsCache) {
  return base64urlEncodeWithoutPadding(
    JSON.stringify({ version: 2, heartbeats: heartbeatsCache })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(variant) {
  _registerComponent(new Component("platform-logger", (container) => new PlatformLoggerServiceImpl(container), "PRIVATE"));
  _registerComponent(new Component("heartbeat", (container) => new HeartbeatServiceImpl(container), "PRIVATE"));
  registerVersion(name$o, version$1$1, variant);
  registerVersion(name$o, version$1$1, "esm2017");
  registerVersion("fire-js", "");
}
registerCoreComponents("");
var name$2 = "firebase";
var version$2 = "9.15.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(name$2, version$2, "app");
const name$1 = "@firebase/installations";
const version$1 = "0.6.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PENDING_TIMEOUT_MS = 1e4;
const PACKAGE_VERSION = `w:${version$1}`;
const INTERNAL_AUTH_VERSION = "FIS_v2";
const INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
const TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
const SERVICE = "installations";
const SERVICE_NAME = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_DESCRIPTION_MAP = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["not-registered"]: "Firebase Installation is not registered.",
  ["installation-not-found"]: "Firebase Installation not found.",
  ["request-failed"]: '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
  ["app-offline"]: "Could not process request. Application offline.",
  ["delete-pending-registration"]: "Can't delete installation while there is a pending registration request."
};
const ERROR_FACTORY$1 = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error) {
  return error instanceof FirebaseError && error.code.includes("request-failed");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getInstallationsEndpoint({ projectId }) {
  return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
async function getErrorFromResponse(requestName, response) {
  const responseJson = await response.json();
  const errorData = responseJson.error;
  return ERROR_FACTORY$1.create("request-failed", {
    requestName,
    serverCode: errorData.code,
    serverMessage: errorData.message,
    serverStatus: errorData.status
  });
}
function getHeaders$1({ apiKey }) {
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, { refreshToken }) {
  const headers = getHeaders$1(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
async function retryIfServerError(fn2) {
  const result = await fn2();
  if (result.status >= 500 && result.status < 600) {
    return fn2();
  }
  return result;
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {
  const endpoint = getInstallationsEndpoint(appConfig);
  const headers = getHeaders$1(appConfig);
  const heartbeatService = heartbeatServiceProvider.getImmediate({
    optional: true
  });
  if (heartbeatService) {
    const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();
    if (heartbeatsHeader) {
      headers.append("x-firebase-client", heartbeatsHeader);
    }
  }
  const body = {
    fid,
    authVersion: INTERNAL_AUTH_VERSION,
    appId: appConfig.appId,
    sdkVersion: PACKAGE_VERSION
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const registeredInstallationEntry = {
      fid: responseValue.fid || fid,
      registrationStatus: 2,
      refreshToken: responseValue.refreshToken,
      authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
    };
    return registeredInstallationEntry;
  } else {
    throw await getErrorFromResponse("Create Installation", response);
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function sleep(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function bufferToBase64UrlSafe(array4) {
  const b64 = btoa(String.fromCharCode(...array4));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
const INVALID_FID = "";
function generateFid() {
  try {
    const fidByteArray = new Uint8Array(17);
    const crypto = self.crypto || self.msCrypto;
    crypto.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    const fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  const b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getKey$1(appConfig) {
  return `${appConfig.appName}!${appConfig.appId}`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fidChangeCallbacks = /* @__PURE__ */ new Map();
function fidChanged(appConfig, fid) {
  const key = getKey$1(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function callFidChangeCallbacks(key, fid) {
  const callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  for (const callback of callbacks) {
    callback(fid);
  }
}
function broadcastFidChange(key, fid) {
  const channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
let broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = (e2) => {
      callFidChangeCallbacks(e2.data.key, e2.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DATABASE_NAME$1 = "firebase-installations-database";
const DATABASE_VERSION$1 = 1;
const OBJECT_STORE_NAME$1 = "firebase-installations-store";
let dbPromise$1 = null;
function getDbPromise$1() {
  if (!dbPromise$1) {
    dbPromise$1 = openDB(DATABASE_NAME$1, DATABASE_VERSION$1, {
      upgrade: (db2, oldVersion) => {
        switch (oldVersion) {
          case 0:
            db2.createObjectStore(OBJECT_STORE_NAME$1);
        }
      }
    });
  }
  return dbPromise$1;
}
async function set(appConfig, value) {
  const key = getKey$1(appConfig);
  const db2 = await getDbPromise$1();
  const tx = db2.transaction(OBJECT_STORE_NAME$1, "readwrite");
  const objectStore = tx.objectStore(OBJECT_STORE_NAME$1);
  const oldValue = await objectStore.get(key);
  await objectStore.put(value, key);
  await tx.done;
  if (!oldValue || oldValue.fid !== value.fid) {
    fidChanged(appConfig, value.fid);
  }
  return value;
}
async function remove(appConfig) {
  const key = getKey$1(appConfig);
  const db2 = await getDbPromise$1();
  const tx = db2.transaction(OBJECT_STORE_NAME$1, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME$1).delete(key);
  await tx.done;
}
async function update(appConfig, updateFn) {
  const key = getKey$1(appConfig);
  const db2 = await getDbPromise$1();
  const tx = db2.transaction(OBJECT_STORE_NAME$1, "readwrite");
  const store2 = tx.objectStore(OBJECT_STORE_NAME$1);
  const oldValue = await store2.get(key);
  const newValue = updateFn(oldValue);
  if (newValue === void 0) {
    await store2.delete(key);
  } else {
    await store2.put(newValue, key);
  }
  await tx.done;
  if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
    fidChanged(appConfig, newValue.fid);
  }
  return newValue;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getInstallationEntry(installations) {
  let registrationPromise;
  const installationEntry = await update(installations.appConfig, (oldEntry) => {
    const installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
    const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry2);
    registrationPromise = entryWithPromise.registrationPromise;
    return entryWithPromise.installationEntry;
  });
  if (installationEntry.fid === INVALID_FID) {
    return { installationEntry: await registrationPromise };
  }
  return {
    installationEntry,
    registrationPromise
  };
}
function updateOrCreateInstallationEntry(oldEntry) {
  const entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(installations, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      const registrationPromiseWithError = Promise.reject(ERROR_FACTORY$1.create("app-offline"));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    const inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    const registrationPromise = registerInstallation(installations, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(installations)
    };
  } else {
    return { installationEntry };
  }
}
async function registerInstallation(installations, installationEntry) {
  try {
    const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);
    return set(installations.appConfig, registeredInstallationEntry);
  } catch (e2) {
    if (isServerError(e2) && e2.customData.serverCode === 409) {
      await remove(installations.appConfig);
    } else {
      await set(installations.appConfig, {
        fid: installationEntry.fid,
        registrationStatus: 0
      });
    }
    throw e2;
  }
}
async function waitUntilFidRegistration(installations) {
  let entry = await updateInstallationRequest(installations.appConfig);
  while (entry.registrationStatus === 1) {
    await sleep(100);
    entry = await updateInstallationRequest(installations.appConfig);
  }
  if (entry.registrationStatus === 0) {
    const { installationEntry, registrationPromise } = await getInstallationEntry(installations);
    if (registrationPromise) {
      return registrationPromise;
    } else {
      return installationEntry;
    }
  }
  return entry;
}
function updateInstallationRequest(appConfig) {
  return update(appConfig, (oldEntry) => {
    if (!oldEntry) {
      throw ERROR_FACTORY$1.create("installation-not-found");
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {
  const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
  const headers = getHeadersWithAuth(appConfig, installationEntry);
  const heartbeatService = heartbeatServiceProvider.getImmediate({
    optional: true
  });
  if (heartbeatService) {
    const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();
    if (heartbeatsHeader) {
      headers.append("x-firebase-client", heartbeatsHeader);
    }
  }
  const body = {
    installation: {
      sdkVersion: PACKAGE_VERSION,
      appId: appConfig.appId
    }
  };
  const request = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  const response = await retryIfServerError(() => fetch(endpoint, request));
  if (response.ok) {
    const responseValue = await response.json();
    const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
    return completedAuthToken;
  } else {
    throw await getErrorFromResponse("Generate Auth Token", response);
  }
}
function getGenerateAuthTokenEndpoint(appConfig, { fid }) {
  return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function refreshAuthToken(installations, forceRefresh = false) {
  let tokenPromise;
  const entry = await update(installations.appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY$1.create("not-registered");
    }
    const oldAuthToken = oldEntry.authToken;
    if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
      return oldEntry;
    } else if (oldAuthToken.requestStatus === 1) {
      tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);
      return oldEntry;
    } else {
      if (!navigator.onLine) {
        throw ERROR_FACTORY$1.create("app-offline");
      }
      const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
      tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);
      return inProgressEntry;
    }
  });
  const authToken = tokenPromise ? await tokenPromise : entry.authToken;
  return authToken;
}
async function waitUntilAuthTokenRequest(installations, forceRefresh) {
  let entry = await updateAuthTokenRequest(installations.appConfig);
  while (entry.authToken.requestStatus === 1) {
    await sleep(100);
    entry = await updateAuthTokenRequest(installations.appConfig);
  }
  const authToken = entry.authToken;
  if (authToken.requestStatus === 0) {
    return refreshAuthToken(installations, forceRefresh);
  } else {
    return authToken;
  }
}
function updateAuthTokenRequest(appConfig) {
  return update(appConfig, (oldEntry) => {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY$1.create("not-registered");
    }
    const oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 } });
    }
    return oldEntry;
  });
}
async function fetchAuthTokenFromServer(installations, installationEntry) {
  try {
    const authToken = await generateAuthTokenRequest(installations, installationEntry);
    const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });
    await set(installations.appConfig, updatedInstallationEntry);
    return authToken;
  } catch (e2) {
    if (isServerError(e2) && (e2.customData.serverCode === 401 || e2.customData.serverCode === 404)) {
      await remove(installations.appConfig);
    } else {
      const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 } });
      await set(installations.appConfig, updatedInstallationEntry);
    }
    throw e2;
  }
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  const now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  const inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getId(installations) {
  const installationsImpl = installations;
  const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);
  if (registrationPromise) {
    registrationPromise.catch(console.error);
  } else {
    refreshAuthToken(installationsImpl).catch(console.error);
  }
  return installationEntry.fid;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getToken$2(installations, forceRefresh = false) {
  const installationsImpl = installations;
  await completeInstallationRegistration(installationsImpl);
  const authToken = await refreshAuthToken(installationsImpl, forceRefresh);
  return authToken.token;
}
async function completeInstallationRegistration(installations) {
  const { registrationPromise } = await getInstallationEntry(installations);
  if (registrationPromise) {
    await registrationPromise;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function extractAppConfig$1(app) {
  if (!app || !app.options) {
    throw getMissingValueError$1("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError$1("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  for (const keyName of configKeys) {
    if (!app.options[keyName]) {
      throw getMissingValueError$1(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError$1(valueName) {
  return ERROR_FACTORY$1.create("missing-app-config-values", {
    valueName
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const INSTALLATIONS_NAME = "installations";
const INSTALLATIONS_NAME_INTERNAL = "installations-internal";
const publicFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const appConfig = extractAppConfig$1(app);
  const heartbeatServiceProvider = _getProvider(app, "heartbeat");
  const installationsImpl = {
    app,
    appConfig,
    heartbeatServiceProvider,
    _delete: () => Promise.resolve()
  };
  return installationsImpl;
};
const internalFactory = (container) => {
  const app = container.getProvider("app").getImmediate();
  const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();
  const installationsInternal = {
    getId: () => getId(installations),
    getToken: (forceRefresh) => getToken$2(installations, forceRefresh)
  };
  return installationsInternal;
};
function registerInstallations() {
  _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, "PUBLIC"));
  _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, "PRIVATE"));
}
registerInstallations();
registerVersion(name$1, version$1);
registerVersion(name$1, version$1, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_SW_PATH = "/firebase-messaging-sw.js";
const DEFAULT_SW_SCOPE = "/firebase-cloud-messaging-push-scope";
const DEFAULT_VAPID_KEY = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
const ENDPOINT = "https://fcmregistrations.googleapis.com/v1";
const CONSOLE_CAMPAIGN_ID = "google.c.a.c_id";
const CONSOLE_CAMPAIGN_NAME = "google.c.a.c_l";
const CONSOLE_CAMPAIGN_TIME = "google.c.a.ts";
const CONSOLE_CAMPAIGN_ANALYTICS_ENABLED = "google.c.a.e";
var MessageType$1;
(function(MessageType2) {
  MessageType2[MessageType2["DATA_MESSAGE"] = 1] = "DATA_MESSAGE";
  MessageType2[MessageType2["DISPLAY_NOTIFICATION"] = 3] = "DISPLAY_NOTIFICATION";
})(MessageType$1 || (MessageType$1 = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var MessageType;
(function(MessageType2) {
  MessageType2["PUSH_RECEIVED"] = "push-received";
  MessageType2["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType || (MessageType = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function arrayToBase64(array4) {
  const uint8Array = new Uint8Array(array4);
  const base64String = btoa(String.fromCharCode(...uint8Array));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray(base64String) {
  const padding = "=".repeat((4 - base64String.length % 4) % 4);
  const base642 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  const rawData = atob(base642);
  const outputArray = new Uint8Array(rawData.length);
  for (let i2 = 0; i2 < rawData.length; ++i2) {
    outputArray[i2] = rawData.charCodeAt(i2);
  }
  return outputArray;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OLD_DB_NAME = "fcm_token_details_db";
const OLD_DB_VERSION = 5;
const OLD_OBJECT_STORE_NAME = "fcm_token_object_Store";
async function migrateOldDatabase(senderId) {
  if ("databases" in indexedDB) {
    const databases = await indexedDB.databases();
    const dbNames = databases.map((db3) => db3.name);
    if (!dbNames.includes(OLD_DB_NAME)) {
      return null;
    }
  }
  let tokenDetails = null;
  const db2 = await openDB(OLD_DB_NAME, OLD_DB_VERSION, {
    upgrade: async (db3, oldVersion, newVersion, upgradeTransaction) => {
      var _a;
      if (oldVersion < 2) {
        return;
      }
      if (!db3.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {
        return;
      }
      const objectStore = upgradeTransaction.objectStore(OLD_OBJECT_STORE_NAME);
      const value = await objectStore.index("fcmSenderId").get(senderId);
      await objectStore.clear();
      if (!value) {
        return;
      }
      if (oldVersion === 2) {
        const oldDetails = value;
        if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
          return;
        }
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: (_a = oldDetails.createTime) !== null && _a !== void 0 ? _a : Date.now(),
          subscriptionOptions: {
            auth: oldDetails.auth,
            p256dh: oldDetails.p256dh,
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase64(oldDetails.vapidKey)
          }
        };
      } else if (oldVersion === 3) {
        const oldDetails = value;
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: oldDetails.createTime,
          subscriptionOptions: {
            auth: arrayToBase64(oldDetails.auth),
            p256dh: arrayToBase64(oldDetails.p256dh),
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: arrayToBase64(oldDetails.vapidKey)
          }
        };
      } else if (oldVersion === 4) {
        const oldDetails = value;
        tokenDetails = {
          token: oldDetails.fcmToken,
          createTime: oldDetails.createTime,
          subscriptionOptions: {
            auth: arrayToBase64(oldDetails.auth),
            p256dh: arrayToBase64(oldDetails.p256dh),
            endpoint: oldDetails.endpoint,
            swScope: oldDetails.swScope,
            vapidKey: arrayToBase64(oldDetails.vapidKey)
          }
        };
      }
    }
  });
  db2.close();
  await deleteDB(OLD_DB_NAME);
  await deleteDB("fcm_vapid_details_db");
  await deleteDB("undefined");
  return checkTokenDetails(tokenDetails) ? tokenDetails : null;
}
function checkTokenDetails(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  const { subscriptionOptions } = tokenDetails;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DATABASE_NAME = "firebase-messaging-database";
const DATABASE_VERSION = 1;
const OBJECT_STORE_NAME = "firebase-messaging-store";
let dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, {
      upgrade: (upgradeDb, oldVersion) => {
        switch (oldVersion) {
          case 0:
            upgradeDb.createObjectStore(OBJECT_STORE_NAME);
        }
      }
    });
  }
  return dbPromise;
}
async function dbGet(firebaseDependencies) {
  const key = getKey2(firebaseDependencies);
  const db2 = await getDbPromise();
  const tokenDetails = await db2.transaction(OBJECT_STORE_NAME).objectStore(OBJECT_STORE_NAME).get(key);
  if (tokenDetails) {
    return tokenDetails;
  } else {
    const oldTokenDetails = await migrateOldDatabase(firebaseDependencies.appConfig.senderId);
    if (oldTokenDetails) {
      await dbSet(firebaseDependencies, oldTokenDetails);
      return oldTokenDetails;
    }
  }
}
async function dbSet(firebaseDependencies, tokenDetails) {
  const key = getKey2(firebaseDependencies);
  const db2 = await getDbPromise();
  const tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME).put(tokenDetails, key);
  await tx.done;
  return tokenDetails;
}
async function dbRemove(firebaseDependencies) {
  const key = getKey2(firebaseDependencies);
  const db2 = await getDbPromise();
  const tx = db2.transaction(OBJECT_STORE_NAME, "readwrite");
  await tx.objectStore(OBJECT_STORE_NAME).delete(key);
  await tx.done;
}
function getKey2({ appConfig }) {
  return appConfig.appId;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_MAP = {
  ["missing-app-config-values"]: 'Missing App configuration value: "{$valueName}"',
  ["only-available-in-window"]: "This method is available in a Window context.",
  ["only-available-in-sw"]: "This method is available in a service worker context.",
  ["permission-default"]: "The notification permission was not granted and dismissed instead.",
  ["permission-blocked"]: "The notification permission was not granted and blocked instead.",
  ["unsupported-browser"]: "This browser doesn't support the API's required to use the Firebase SDK.",
  ["indexed-db-unsupported"]: "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
  ["failed-service-worker-registration"]: "We are unable to register the default service worker. {$browserErrorMessage}",
  ["token-subscribe-failed"]: "A problem occurred while subscribing the user to FCM: {$errorInfo}",
  ["token-subscribe-no-token"]: "FCM returned no token when subscribing the user to push.",
  ["token-unsubscribe-failed"]: "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
  ["token-update-failed"]: "A problem occurred while updating the user from FCM: {$errorInfo}",
  ["token-update-no-token"]: "FCM returned no token when updating the user to push.",
  ["use-sw-after-get-token"]: "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
  ["invalid-sw-registration"]: "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
  ["invalid-bg-handler"]: "The input to setBackgroundMessageHandler() must be a function.",
  ["invalid-vapid-key"]: "The public VAPID key must be a string.",
  ["use-vapid-key-after-get-token"]: "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
};
const ERROR_FACTORY = new ErrorFactory("messaging", "Messaging", ERROR_MAP);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function requestGetToken(firebaseDependencies, subscriptionOptions) {
  const headers = await getHeaders(firebaseDependencies);
  const body = getBody(subscriptionOptions);
  const subscribeOptions = {
    method: "POST",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(getEndpoint(firebaseDependencies.appConfig), subscribeOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY.create("token-subscribe-failed", {
      errorInfo: err === null || err === void 0 ? void 0 : err.toString()
    });
  }
  if (responseData.error) {
    const message2 = responseData.error.message;
    throw ERROR_FACTORY.create("token-subscribe-failed", {
      errorInfo: message2
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY.create("token-subscribe-no-token");
  }
  return responseData.token;
}
async function requestUpdateToken(firebaseDependencies, tokenDetails) {
  const headers = await getHeaders(firebaseDependencies);
  const body = getBody(tokenDetails.subscriptionOptions);
  const updateOptions = {
    method: "PATCH",
    headers,
    body: JSON.stringify(body)
  };
  let responseData;
  try {
    const response = await fetch(`${getEndpoint(firebaseDependencies.appConfig)}/${tokenDetails.token}`, updateOptions);
    responseData = await response.json();
  } catch (err) {
    throw ERROR_FACTORY.create("token-update-failed", {
      errorInfo: err === null || err === void 0 ? void 0 : err.toString()
    });
  }
  if (responseData.error) {
    const message2 = responseData.error.message;
    throw ERROR_FACTORY.create("token-update-failed", {
      errorInfo: message2
    });
  }
  if (!responseData.token) {
    throw ERROR_FACTORY.create("token-update-no-token");
  }
  return responseData.token;
}
async function requestDeleteToken(firebaseDependencies, token2) {
  const headers = await getHeaders(firebaseDependencies);
  const unsubscribeOptions = {
    method: "DELETE",
    headers
  };
  try {
    const response = await fetch(`${getEndpoint(firebaseDependencies.appConfig)}/${token2}`, unsubscribeOptions);
    const responseData = await response.json();
    if (responseData.error) {
      const message2 = responseData.error.message;
      throw ERROR_FACTORY.create("token-unsubscribe-failed", {
        errorInfo: message2
      });
    }
  } catch (err) {
    throw ERROR_FACTORY.create("token-unsubscribe-failed", {
      errorInfo: err === null || err === void 0 ? void 0 : err.toString()
    });
  }
}
function getEndpoint({ projectId }) {
  return `${ENDPOINT}/projects/${projectId}/registrations`;
}
async function getHeaders({ appConfig, installations }) {
  const authToken = await installations.getToken();
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": appConfig.apiKey,
    "x-goog-firebase-installations-auth": `FIS ${authToken}`
  });
}
function getBody({ p256dh, auth, endpoint, vapidKey }) {
  const body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1e3;
async function getTokenInternal(messaging2) {
  const pushSubscription = await getPushSubscription(messaging2.swRegistration, messaging2.vapidKey);
  const subscriptionOptions = {
    vapidKey: messaging2.vapidKey,
    swScope: messaging2.swRegistration.scope,
    endpoint: pushSubscription.endpoint,
    auth: arrayToBase64(pushSubscription.getKey("auth")),
    p256dh: arrayToBase64(pushSubscription.getKey("p256dh"))
  };
  const tokenDetails = await dbGet(messaging2.firebaseDependencies);
  if (!tokenDetails) {
    return getNewToken(messaging2.firebaseDependencies, subscriptionOptions);
  } else if (!isTokenValid(tokenDetails.subscriptionOptions, subscriptionOptions)) {
    try {
      await requestDeleteToken(messaging2.firebaseDependencies, tokenDetails.token);
    } catch (e2) {
      console.warn(e2);
    }
    return getNewToken(messaging2.firebaseDependencies, subscriptionOptions);
  } else if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS) {
    return updateToken(messaging2, {
      token: tokenDetails.token,
      createTime: Date.now(),
      subscriptionOptions
    });
  } else {
    return tokenDetails.token;
  }
}
async function deleteTokenInternal(messaging2) {
  const tokenDetails = await dbGet(messaging2.firebaseDependencies);
  if (tokenDetails) {
    await requestDeleteToken(messaging2.firebaseDependencies, tokenDetails.token);
    await dbRemove(messaging2.firebaseDependencies);
  }
  const pushSubscription = await messaging2.swRegistration.pushManager.getSubscription();
  if (pushSubscription) {
    return pushSubscription.unsubscribe();
  }
  return true;
}
async function updateToken(messaging2, tokenDetails) {
  try {
    const updatedToken = await requestUpdateToken(messaging2.firebaseDependencies, tokenDetails);
    const updatedTokenDetails = Object.assign(Object.assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
    await dbSet(messaging2.firebaseDependencies, updatedTokenDetails);
    return updatedToken;
  } catch (e2) {
    await deleteTokenInternal(messaging2);
    throw e2;
  }
}
async function getNewToken(firebaseDependencies, subscriptionOptions) {
  const token2 = await requestGetToken(firebaseDependencies, subscriptionOptions);
  const tokenDetails = {
    token: token2,
    createTime: Date.now(),
    subscriptionOptions
  };
  await dbSet(firebaseDependencies, tokenDetails);
  return tokenDetails.token;
}
async function getPushSubscription(swRegistration, vapidKey) {
  const subscription = await swRegistration.pushManager.getSubscription();
  if (subscription) {
    return subscription;
  }
  return swRegistration.pushManager.subscribe({
    userVisibleOnly: true,
    applicationServerKey: base64ToArray(vapidKey)
  });
}
function isTokenValid(dbOptions, currentOptions) {
  const isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  const isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  const isAuthEqual = currentOptions.auth === dbOptions.auth;
  const isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function externalizePayload(internalPayload) {
  const payload = {
    from: internalPayload.from,
    collapseKey: internalPayload.collapse_key,
    messageId: internalPayload.fcmMessageId
  };
  propagateNotificationPayload(payload, internalPayload);
  propagateDataPayload(payload, internalPayload);
  propagateFcmOptions(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  const title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  const body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  const image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
  const icon = messagePayloadInternal.notification.icon;
  if (!!icon) {
    payload.notification.icon = icon;
  }
}
function propagateDataPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions(payload, messagePayloadInternal) {
  var _a, _b, _c, _d, _e;
  if (!messagePayloadInternal.fcmOptions && !((_a = messagePayloadInternal.notification) === null || _a === void 0 ? void 0 : _a.click_action)) {
    return;
  }
  payload.fcmOptions = {};
  const link = (_c = (_b = messagePayloadInternal.fcmOptions) === null || _b === void 0 ? void 0 : _b.link) !== null && _c !== void 0 ? _c : (_d = messagePayloadInternal.notification) === null || _d === void 0 ? void 0 : _d.click_action;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  const analyticsLabel = (_e = messagePayloadInternal.fcmOptions) === null || _e === void 0 ? void 0 : _e.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isConsoleMessage(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID in data;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
_mergeStrings("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
_mergeStrings("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");
function _mergeStrings(s1, s2) {
  const resultArray = [];
  for (let i2 = 0; i2 < s1.length; i2++) {
    resultArray.push(s1.charAt(i2));
    if (i2 < s2.length) {
      resultArray.push(s2.charAt(i2));
    }
  }
  return resultArray.join("");
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function extractAppConfig(app) {
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  const configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  const { options } = app;
  for (const keyName of configKeys) {
    if (!options[keyName]) {
      throw getMissingValueError(keyName);
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY.create("missing-app-config-values", {
    valueName
  });
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MessagingService {
  constructor(app, installations, analyticsProvider) {
    this.deliveryMetricsExportedToBigQueryEnabled = false;
    this.onBackgroundMessageHandler = null;
    this.onMessageHandler = null;
    this.logEvents = [];
    this.isLogServiceStarted = false;
    const appConfig = extractAppConfig(app);
    this.firebaseDependencies = {
      app,
      appConfig,
      installations,
      analyticsProvider
    };
  }
  _delete() {
    return Promise.resolve();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function registerDefaultSw(messaging2) {
  try {
    messaging2.swRegistration = await navigator.serviceWorker.register(DEFAULT_SW_PATH, {
      scope: DEFAULT_SW_SCOPE
    });
    messaging2.swRegistration.update().catch(() => {
    });
  } catch (e2) {
    throw ERROR_FACTORY.create("failed-service-worker-registration", {
      browserErrorMessage: e2 === null || e2 === void 0 ? void 0 : e2.message
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function updateSwReg(messaging2, swRegistration) {
  if (!swRegistration && !messaging2.swRegistration) {
    await registerDefaultSw(messaging2);
  }
  if (!swRegistration && !!messaging2.swRegistration) {
    return;
  }
  if (!(swRegistration instanceof ServiceWorkerRegistration)) {
    throw ERROR_FACTORY.create("invalid-sw-registration");
  }
  messaging2.swRegistration = swRegistration;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function updateVapidKey(messaging2, vapidKey) {
  if (!!vapidKey) {
    messaging2.vapidKey = vapidKey;
  } else if (!messaging2.vapidKey) {
    messaging2.vapidKey = DEFAULT_VAPID_KEY;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getToken$1(messaging2, options) {
  if (!navigator) {
    throw ERROR_FACTORY.create("only-available-in-window");
  }
  if (Notification.permission === "default") {
    await Notification.requestPermission();
  }
  if (Notification.permission !== "granted") {
    throw ERROR_FACTORY.create("permission-blocked");
  }
  await updateVapidKey(messaging2, options === null || options === void 0 ? void 0 : options.vapidKey);
  await updateSwReg(messaging2, options === null || options === void 0 ? void 0 : options.serviceWorkerRegistration);
  return getTokenInternal(messaging2);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function logToScion(messaging2, messageType, data) {
  const eventType = getEventType(messageType);
  const analytics = await messaging2.firebaseDependencies.analyticsProvider.get();
  analytics.logEvent(eventType, {
    message_id: data[CONSOLE_CAMPAIGN_ID],
    message_name: data[CONSOLE_CAMPAIGN_NAME],
    message_time: data[CONSOLE_CAMPAIGN_TIME],
    message_device_time: Math.floor(Date.now() / 1e3)
  });
}
function getEventType(messageType) {
  switch (messageType) {
    case MessageType.NOTIFICATION_CLICKED:
      return "notification_open";
    case MessageType.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function messageEventListener(messaging2, event) {
  const internalPayload = event.data;
  if (!internalPayload.isFirebaseMessaging) {
    return;
  }
  if (messaging2.onMessageHandler && internalPayload.messageType === MessageType.PUSH_RECEIVED) {
    if (typeof messaging2.onMessageHandler === "function") {
      messaging2.onMessageHandler(externalizePayload(internalPayload));
    } else {
      messaging2.onMessageHandler.next(externalizePayload(internalPayload));
    }
  }
  const dataPayload = internalPayload.data;
  if (isConsoleMessage(dataPayload) && dataPayload[CONSOLE_CAMPAIGN_ANALYTICS_ENABLED] === "1") {
    await logToScion(messaging2, internalPayload.messageType, dataPayload);
  }
}
const name = "@firebase/messaging";
const version = "0.12.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WindowMessagingFactory = (container) => {
  const messaging2 = new MessagingService(container.getProvider("app").getImmediate(), container.getProvider("installations-internal").getImmediate(), container.getProvider("analytics-internal"));
  navigator.serviceWorker.addEventListener("message", (e2) => messageEventListener(messaging2, e2));
  return messaging2;
};
const WindowMessagingInternalFactory = (container) => {
  const messaging2 = container.getProvider("messaging").getImmediate();
  const messagingInternal = {
    getToken: (options) => getToken$1(messaging2, options)
  };
  return messagingInternal;
};
function registerMessagingInWindow() {
  _registerComponent(new Component("messaging", WindowMessagingFactory, "PUBLIC"));
  _registerComponent(new Component("messaging-internal", WindowMessagingInternalFactory, "PRIVATE"));
  registerVersion(name, version);
  registerVersion(name, version, "esm2017");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function isWindowSupported() {
  try {
    await validateIndexedDBOpenable();
  } catch (e2) {
    return false;
  }
  return typeof window !== "undefined" && isIndexedDBAvailable() && areCookiesEnabled() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function onMessage$1(messaging2, nextOrObserver) {
  if (!navigator) {
    throw ERROR_FACTORY.create("only-available-in-window");
  }
  messaging2.onMessageHandler = nextOrObserver;
  return () => {
    messaging2.onMessageHandler = null;
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getMessagingInWindow(app = getApp()) {
  isWindowSupported().then((isSupported) => {
    if (!isSupported) {
      throw ERROR_FACTORY.create("unsupported-browser");
    }
  }, (_2) => {
    throw ERROR_FACTORY.create("indexed-db-unsupported");
  });
  return _getProvider(getModularInstance(app), "messaging").getImmediate();
}
async function getToken(messaging2, options) {
  messaging2 = getModularInstance(messaging2);
  return getToken$1(messaging2, options);
}
function onMessage(messaging2, nextOrObserver) {
  messaging2 = getModularInstance(messaging2);
  return onMessage$1(messaging2, nextOrObserver);
}
registerMessagingInWindow();
const firebaseConfig = {
  apiKey: "AIzaSyC0L3o1uFlJ3wBAuzG1bXHf-chsTtAGGAk",
  authDomain: "hr-self-services.firebaseapp.com",
  projectId: "hr-self-services",
  storageBucket: "hr-self-services.appspot.com",
  messagingSenderId: "83495502259",
  appId: "1:83495502259:web:e58381aa5186589dc20bc6",
  measurementId: "G-13NVHJR69Y"
};
if (firebaseConfig.apiKey) {
  const app = initializeApp(firebaseConfig);
  getMessagingInWindow(app);
}
const requestNotificationPermission = () => {
  console.log("Requesting permission...");
  Notification.requestPermission().then((permission) => {
    if (permission === "granted") {
      const messaging2 = getMessagingInWindow();
      console.log("Notification permission granted.");
      const { VITE_APP_VAPID_KEY } = { "VITE_APP_VAPID_KEY": "BN44P6-z9WK-N2AxgZXAQlVijA4gysDbSdIUYHq735_C8RwP6r8QDaaTK_wWO_jgkIJLbJ4d_lewB0VhgKiN9hQ", "BASE_URL": "/", "MODE": "development", "DEV": false, "PROD": true };
      getToken(messaging2, { vapidKey: VITE_APP_VAPID_KEY }).then((currentToken) => {
        if (currentToken)
          console.log("currentToken ", currentToken);
        else
          console.log("No registration token available. Request permission to generate one.");
      }).catch((err) => {
        console.log("An error occurred while retrieving token. ", err);
      });
    } else
      console.log("Do not have permission");
  });
};
requestNotificationPermission();
const messaging = getMessagingInWindow();
const onMessageListener = () => new Promise((resolve) => {
  onMessage(messaging, (payload) => {
    console.log("payload", payload);
    resolve(payload);
  });
});
const FirebaseNotification = () => {
  const [notification2, setNotification] = react.exports.useState({
    title: "",
    body: ""
  });
  const ToastDisplay = ({
    title,
    body
  }) => /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx("h4", {
      children: title
    }), /* @__PURE__ */ jsx("p", {
      children: body
    })]
  });
  onMessageListener().then((payload) => {
    var _a, _b, _c, _d;
    setNotification({
      title: (_a = payload == null ? void 0 : payload.notification) == null ? void 0 : _a.title,
      body: (_b = payload == null ? void 0 : payload.notification) == null ? void 0 : _b.body
    });
    Q.info(/* @__PURE__ */ jsx(ToastDisplay, {
      title: (_c = payload == null ? void 0 : payload.notification) == null ? void 0 : _c.title,
      body: (_d = payload == null ? void 0 : payload.notification) == null ? void 0 : _d.body
    }));
  }).catch((err) => console.log("failed: ", err));
};
const PrimaryButton = ({
  title,
  onClick,
  htmlType = "submit",
  size = "large",
  style: style2 = "",
  className = "btn-block m-t-15",
  disabled = false
}) => {
  const {
    useToken: useToken2
  } = theme;
  useToken2();
  return /* @__PURE__ */ jsx(Button$1, {
    type: "primary",
    htmlType,
    className,
    size,
    onClick,
    disabled,
    children: title
  });
};
const buildMenuItem = (key, label, component, hoverColor, children, type4) => {
  return {
    key,
    icon: component,
    children,
    label,
    type: type4,
    style: {
      "&:hover": {
        color: "black"
      }
    }
  };
};
const regexNumberValidation = new RegExp(/^[0-9]+$/);
const useForm = (initialForm2 = {}, formValidators = {}) => {
  const [formState, setFormState] = react.exports.useState(initialForm2);
  const [formValidation, setFormValidation] = react.exports.useState({});
  react.exports.useEffect(() => {
    createValidators();
  }, [formState]);
  const isFormValid = react.exports.useMemo(() => {
    for (const formValue of Object.keys(formValidation)) {
      if (formValidation[formValue] !== null)
        return false;
    }
    return true;
  }, [formValidation]);
  const onInputChange = ({ target }) => {
    const { name: name2, value } = target;
    setFormState({
      ...formState,
      [name2]: value
    });
  };
  const onResetForm = () => {
    setFormState(initialForm2);
  };
  const createValidators = () => {
    const formCheckedValues = {};
    for (const formField of Object.keys(formValidators)) {
      const [fn2, errorMessage = "Este campo es requerido"] = formValidators[formField];
      formCheckedValues[`${formField}Valid`] = fn2(formState[formField]) ? null : errorMessage;
    }
    setFormValidation(formCheckedValues);
  };
  return {
    ...formState,
    ...formValidation,
    formState,
    onInputChange,
    onResetForm,
    isFormValid
  };
};
const useCheckAuth = () => {
  const user = useSelector((state) => state.auth);
  const { status, authenticationType, employeeCode, displayName } = user;
  const dispatch = useDispatch();
  react.exports.useEffect(() => {
    const authUser = JSON.parse(localStorage.getItem("authUser"));
    const logged = !!authUser;
    if (!logged) {
      dispatch(onLogout());
    } else {
      dispatch(onLogin(authUser));
    }
  }, []);
  return {
    status
  };
};
const useAuthStore = () => {
  const authState = useSelector((state) => state.auth);
  const {
    username,
    employeeCode,
    displayName,
    status,
    errorMessage,
    authenticationType,
    id: id2,
    email: email2
  } = authState;
  const dispatch = useDispatch();
  const startLogin = async (credentials) => {
    dispatch(onCheckingCredentials());
    let resp = {};
    resp = await new Promise((resolve, reject) => {
      return resolve({
        statusCode: 200,
        isSuccessStatusCode: true,
        data: {
          id: 1,
          email: "",
          displayName: "",
          username: ""
        }
      });
    });
    console.log(resp);
    if (resp) {
      if (!resp.isSuccessStatusCode) {
        dispatch(onLogout({ errorMessage: resp.errorMessage }));
      } else {
        localStorage.setItem("authUser", JSON.stringify(resp.data));
        dispatch(onLogin(resp.data));
      }
    } else
      dispatch(onLogout({ errorMessage: "Error de autenticacion" }));
  };
  const startLogout = async () => {
    try {
      localStorage.clear();
      dispatch(onLogout());
    } catch (error) {
    }
  };
  const startSetDisplayName = (displayName2) => {
    dispatch(onSetDisplayName(displayName2));
  };
  return {
    username,
    employeeCode,
    displayName,
    status,
    errorMessage,
    authenticationType,
    id: id2,
    email: email2,
    startLogin,
    startLogout,
    startSetDisplayName
  };
};
const { useToken } = theme;
const useTheme = () => {
  const { token: token2 } = useToken();
  return {
    ...token2
  };
};
const useCounter = (initialValue = 10) => {
  const [counter, setCounter] = react.exports.useState(initialValue);
  const increment = (step = 1) => {
    setCounter((current) => current + step);
  };
  const decrement = (step = 1) => {
    setCounter((current) => current - step);
  };
  const reset = () => {
    setCounter(initialValue);
  };
  const refresh = (value) => {
    if (value.length > 0)
      setCounter(parseInt(value));
  };
  return {
    counter,
    increment,
    decrement,
    reset,
    refresh
  };
};
const createNavMenuItem = (id2, label, icon, path2, children) => {
  const {
    colorInfo
  } = useTheme();
  return buildMenuItem(id2, label, /* @__PURE__ */ jsx(NavLink, {
    className: ({
      isActive: isActive2
    }) => `nav-item nav-link ${isActive2 ? "active" : ""}`,
    to: path2,
    children: icon
  }), colorInfo, children);
};
Object.defineProperty(String.prototype, "capitalize", {
  value: function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  },
  enumerable: false
});
const dateLocalizer = {
  name: "es",
  weekdays: "Domingo_Lunes_Martes_Miercoles_Jueves_Viernes_Sabado".split("_"),
  weekdaysShort: "Dom_Lun_Mar_Mie_Jue_Vie_Sab".split("_"),
  weekdaysMin: "Do_Lu_Ma_Mi_Ju_Vi_Sa".split("_"),
  weekStart: 1,
  months: "Enero_Febrero_Marzo_Abril_Mayo_Junio_Julio_Agosto_Septiembre_Octubre_Noviembre_Diciembte".split("_"),
  monthsShort: "Ene_Feb_Mar_Abr_May_Jun_Jul_Ago_Sep_Oct_Nov_Dic".split("_"),
  ordinal: (n2) => `${n2}\xBA`,
  formats: {
    LTS: "h:mm:ss A",
    LT: "h:mm A",
    L: "dd-MM-YYYY",
    LL: "MMMM D, YYYY",
    LLL: "MMMM D, YYYY h:mm A",
    LLLL: "dddd, MMMM D, YYYY h:mm A",
    l: "D/M/YYYY",
    ll: "D MMM, YYYY",
    lll: "D MMM, YYYY h:mm A",
    llll: "ddd, MMM D, YYYY h:mm A"
  },
  relativeTime: {
    future: "en %s",
    past: "hace %s",
    s: "unos segundos",
    m: "un minuto",
    mm: "%d minutos",
    h: "una hora",
    hh: "%d horas",
    d: "un dia",
    dd: "%d dias",
    M: "un mes",
    MM: "%d meses",
    y: "un a\xF1o",
    yy: "%d a\xF1os"
  },
  meridiem: (hour, minute, isLowercase) => {
    return hour > 12 ? "PM" : "AM";
  }
};
const loginTypeByUser = {
  placeHolder: "Usuario",
  name: "usuario",
  type: "text"
};
const initialForm = {
  user: "",
  password: "",
  authenticationType: null,
  remember: true
};
const LoginPage = () => {
  const {
    employeeCode,
    status,
    errorMessage,
    authenticationType,
    startLogin
  } = useAuthStore();
  useDispatch();
  const [formSubmitted, setFormSubmitted] = react.exports.useState(false);
  const [loginType, setLoginType] = react.exports.useState(loginTypeByUser);
  const [form] = Form$1.useForm();
  const isAuthenticating = react.exports.useMemo(() => status === "checking", [status]);
  const onSubmit = ({
    user,
    password,
    authenticationType: authenticationType2
  }) => {
    setFormSubmitted(true);
    startLogin({
      user,
      password
    });
  };
  return /* @__PURE__ */ jsx(AuthLayout, {
    title: "LOGIN",
    classname: "login",
    children: /* @__PURE__ */ jsxs(Form$1, {
      form,
      initialValues: initialForm,
      onFinish: onSubmit,
      autoComplete: "off",
      className: "login-form ",
      children: [/* @__PURE__ */ jsx(Form$1.Item, {
        name: "user",
        preserve: true,
        rules: [{
          pattern: loginType.type === "number" ? regexNumberValidation : null,
          message: loginType.typeMessage
        }, {
          required: true,
          message: `Digite su ${loginType.name}!`
        }],
        children: /* @__PURE__ */ jsx(Input$1, {
          prefix: /* @__PURE__ */ jsx(UserOutlined$1, {
            className: "site-form-item-icon",
            style: {
              color: "rgba(0,0,0,.25)"
            }
          }),
          placeholder: loginType.placeHolder,
          allowClear: true
        })
      }), /* @__PURE__ */ jsx(Form$1.Item, {
        name: "password",
        rules: [{
          message: "La contrasena debe tener al menos 6 caracteres",
          min: 6
        }, {
          required: true,
          message: "Digite su contrasena!"
        }],
        children: /* @__PURE__ */ jsx(Input$1.Password, {
          prefix: /* @__PURE__ */ jsx(LockOutlined$1, {
            className: "site-form-item-icon",
            style: {
              color: "rgba(0,0,0,.25)"
            }
          }),
          allowClear: true,
          placeholder: "Contrasena"
        })
      }), /* @__PURE__ */ jsx(Form$1.Item, {
        style: {
          display: !!errorMessage ? "" : "none"
        },
        children: /* @__PURE__ */ jsx(Space$1, {
          direction: "vertical",
          style: {
            width: "100%"
          },
          children: /* @__PURE__ */ jsx(Alert$1, {
            message: errorMessage,
            type: "error",
            showIcon: true
          })
        })
      }), /* @__PURE__ */ jsx(Form$1.Item, {
        children: /* @__PURE__ */ jsx(PrimaryButton, {
          className: "login-form-button",
          disabled: isAuthenticating,
          title: "Iniciar Sesion"
        })
      }), /* @__PURE__ */ jsxs(Form$1.Item, {
        children: [/* @__PURE__ */ jsx(Form$1.Item, {
          name: "remember",
          valuePropName: "checked",
          noStyle: true,
          children: /* @__PURE__ */ jsx(Checkbox$1, {
            children: "Recordarme"
          })
        }), /* @__PURE__ */ jsx(Link$2, {
          className: "login-form-forgot",
          to: "/forgotpassword",
          children: "Olvide mi contrasena"
        })]
      })]
    })
  });
};
const AuthLayout = ({
  classname,
  children
}) => {
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsx(Layout$1, {
      className: "page-layout",
      style: {
        height: "100vh"
      },
      children: /* @__PURE__ */ jsx(Content$1, {
        className: "layout-children",
        children: /* @__PURE__ */ jsx("div", {
          className: "container",
          children: /* @__PURE__ */ jsxs("div", {
            className: "login-form-wrap",
            children: [/* @__PURE__ */ jsx("div", {
              className: "login-form-title",
              children: /* @__PURE__ */ jsx("img", {
                style: {
                  marginRight: "auto",
                  width: "150px",
                  marginBottom: "1em"
                },
                height: 70,
                alt: "Logo",
                src: ""
              })
            }), /* @__PURE__ */ jsx("h1", {
              className: "login-form-title",
              children: "LOGIN"
            }), children]
          })
        })
      })
    })
  });
};
const AuthRoutes = () => {
  return /* @__PURE__ */ jsxs(Routes, {
    children: [/* @__PURE__ */ jsx(Route, {
      path: "login",
      element: /* @__PURE__ */ jsx(LoginPage, {})
    }), /* @__PURE__ */ jsx(Route, {
      path: "/*",
      element: /* @__PURE__ */ jsx(Navigate, {
        to: "/auth/login"
      })
    })]
  });
};
var strategyUtil = {};
var valueUtil = {};
Object.defineProperty(valueUtil, "__esModule", {
  value: true
});
valueUtil.fillFieldNames = fillFieldNames;
valueUtil.getAllKeys = getAllKeys;
valueUtil.isCheckDisabled = isCheckDisabled;
valueUtil.isNil = isNil;
valueUtil.toArray = toArray;
function toArray(value) {
  if (Array.isArray(value)) {
    return value;
  }
  return value !== void 0 ? [value] : [];
}
function fillFieldNames(fieldNames) {
  var _ref = fieldNames || {}, label = _ref.label, value = _ref.value, children = _ref.children;
  var mergedValue = value || "value";
  return {
    _title: label ? [label] : ["title", "label"],
    value: mergedValue,
    key: mergedValue,
    children: children || "children"
  };
}
function isCheckDisabled(node2) {
  return !node2 || node2.disabled || node2.disableCheckbox || node2.checkable === false;
}
function getAllKeys(treeData, fieldNames) {
  var keys2 = [];
  function dig(list) {
    list.forEach(function(item) {
      var children = item[fieldNames.children];
      if (children) {
        keys2.push(item[fieldNames.value]);
        dig(children);
      }
    });
  }
  dig(treeData);
  return keys2;
}
function isNil(val) {
  return val === null || val === void 0;
}
Object.defineProperty(strategyUtil, "__esModule", {
  value: true
});
strategyUtil.SHOW_PARENT = strategyUtil.SHOW_CHILD = strategyUtil.SHOW_ALL = void 0;
strategyUtil.formatStrategyValues = formatStrategyValues;
var _valueUtil = valueUtil;
var SHOW_ALL = "SHOW_ALL";
strategyUtil.SHOW_ALL = SHOW_ALL;
var SHOW_PARENT = "SHOW_PARENT";
strategyUtil.SHOW_PARENT = SHOW_PARENT;
var SHOW_CHILD = "SHOW_CHILD";
strategyUtil.SHOW_CHILD = SHOW_CHILD;
function formatStrategyValues(values, strategy, keyEntities, fieldNames) {
  var valueSet = new Set(values);
  if (strategy === SHOW_CHILD) {
    return values.filter(function(key) {
      var entity = keyEntities[key];
      if (entity && entity.children && entity.children.some(function(_ref) {
        var node2 = _ref.node;
        return valueSet.has(node2[fieldNames.value]);
      }) && entity.children.every(function(_ref2) {
        var node2 = _ref2.node;
        return (0, _valueUtil.isCheckDisabled)(node2) || valueSet.has(node2[fieldNames.value]);
      })) {
        return false;
      }
      return true;
    });
  }
  if (strategy === SHOW_PARENT) {
    return values.filter(function(key) {
      var entity = keyEntities[key];
      var parent = entity ? entity.parent : null;
      if (parent && !(0, _valueUtil.isCheckDisabled)(parent.node) && valueSet.has(parent.key)) {
        return false;
      }
      return true;
    });
  }
  return values;
}
const {
  Text: Text$3,
  Title: Title$4
} = Typography$1;
const ProductInfo = ({
  title,
  description,
  unitPrice,
  quantity
}) => {
  return /* @__PURE__ */ jsxs(Row$1, {
    children: [/* @__PURE__ */ jsx(Col$1, {
      xs: {
        span: 4
      },
      style: {
        marginTop: "0.5em"
      },
      children: /* @__PURE__ */ jsx(Row$1, {
        align: {
          xs: "middle"
        },
        justify: {
          xs: "center"
        },
        children: /* @__PURE__ */ jsx(Col$1, {
          children: /* @__PURE__ */ jsx(Avatar$1, {
            shape: "square",
            icon: /* @__PURE__ */ jsx(UserOutlined$1, {})
          })
        })
      })
    }), /* @__PURE__ */ jsxs(Col$1, {
      xs: {
        span: 14
      },
      children: [/* @__PURE__ */ jsx(Title$4, {
        style: {
          margin: 0
        },
        level: 5,
        children: title
      }), /* @__PURE__ */ jsxs(Text$3, {
        style: {
          margin: 0
        },
        children: [quantity, " x Set"]
      })]
    }), /* @__PURE__ */ jsx(Col$1, {
      xs: {
        span: 6
      },
      style: {
        marginTop: "0.5em"
      },
      children: /* @__PURE__ */ jsxs(Title$4, {
        level: 5,
        children: ["$", unitPrice]
      })
    })]
  });
};
var less = { exports: {} };
/**
 * Less - Leaner CSS v4.1.3
 * http://lesscss.org
 * 
 * Copyright (c) 2009-2022, Alexis Sellier <self@cloudhead.net>
 * Licensed under the Apache-2.0 License.
 *
 * @license Apache-2.0
 */
(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    function defaultOptions() {
      return {
        javascriptEnabled: false,
        depends: false,
        compress: false,
        lint: false,
        paths: [],
        color: true,
        strictImports: false,
        insecure: false,
        rootpath: "",
        rewriteUrls: false,
        math: 1,
        strictUnits: false,
        globalVars: null,
        modifyVars: null,
        urlArgs: ""
      };
    }
    function extractId(href) {
      return href.replace(/^[a-z-]+:\/+?[^\/]+/, "").replace(/[\?\&]livereload=\w+/, "").replace(/^\//, "").replace(/\.[a-zA-Z]+$/, "").replace(/[^\.\w-]+/g, "-").replace(/\./g, ":");
    }
    function addDataAttr(options2, tag) {
      if (!tag) {
        return;
      }
      for (var opt in tag.dataset) {
        if (tag.dataset.hasOwnProperty(opt)) {
          if (opt === "env" || opt === "dumpLineNumbers" || opt === "rootpath" || opt === "errorReporting") {
            options2[opt] = tag.dataset[opt];
          } else {
            try {
              options2[opt] = JSON.parse(tag.dataset[opt]);
            } catch (_2) {
            }
          }
        }
      }
    }
    var browser2 = {
      createCSS: function(document2, styles, sheet) {
        var href = sheet.href || "";
        var id2 = "less:" + (sheet.title || extractId(href));
        var oldStyleNode = document2.getElementById(id2);
        var keepOldStyleNode = false;
        var styleNode = document2.createElement("style");
        styleNode.setAttribute("type", "text/css");
        if (sheet.media) {
          styleNode.setAttribute("media", sheet.media);
        }
        styleNode.id = id2;
        if (!styleNode.styleSheet) {
          styleNode.appendChild(document2.createTextNode(styles));
          keepOldStyleNode = oldStyleNode !== null && oldStyleNode.childNodes.length > 0 && styleNode.childNodes.length > 0 && oldStyleNode.firstChild.nodeValue === styleNode.firstChild.nodeValue;
        }
        var head2 = document2.getElementsByTagName("head")[0];
        if (oldStyleNode === null || keepOldStyleNode === false) {
          var nextEl = sheet && sheet.nextSibling || null;
          if (nextEl) {
            nextEl.parentNode.insertBefore(styleNode, nextEl);
          } else {
            head2.appendChild(styleNode);
          }
        }
        if (oldStyleNode && keepOldStyleNode === false) {
          oldStyleNode.parentNode.removeChild(oldStyleNode);
        }
        if (styleNode.styleSheet) {
          try {
            styleNode.styleSheet.cssText = styles;
          } catch (e2) {
            throw new Error("Couldn't reassign styleSheet.cssText.");
          }
        }
      },
      currentScript: function(window2) {
        var document2 = window2.document;
        return document2.currentScript || function() {
          var scripts = document2.getElementsByTagName("script");
          return scripts[scripts.length - 1];
        }();
      }
    };
    var addDefaultOptions = function(window2, options2) {
      addDataAttr(options2, browser2.currentScript(window2));
      if (options2.isFileProtocol === void 0) {
        options2.isFileProtocol = /^(file|(chrome|safari)(-extension)?|resource|qrc|app):/.test(window2.location.protocol);
      }
      options2.async = options2.async || false;
      options2.fileAsync = options2.fileAsync || false;
      options2.poll = options2.poll || (options2.isFileProtocol ? 1e3 : 1500);
      options2.env = options2.env || (window2.location.hostname == "127.0.0.1" || window2.location.hostname == "0.0.0.0" || window2.location.hostname == "localhost" || window2.location.port && window2.location.port.length > 0 || options2.isFileProtocol ? "development" : "production");
      var dumpLineNumbers = /!dumpLineNumbers:(comments|mediaquery|all)/.exec(window2.location.hash);
      if (dumpLineNumbers) {
        options2.dumpLineNumbers = dumpLineNumbers[1];
      }
      if (options2.useFileCache === void 0) {
        options2.useFileCache = true;
      }
      if (options2.onReady === void 0) {
        options2.onReady = true;
      }
      if (options2.relativeUrls) {
        options2.rewriteUrls = "all";
      }
    };
    var logger$1 = {
      error: function(msg) {
        this._fireEvent("error", msg);
      },
      warn: function(msg) {
        this._fireEvent("warn", msg);
      },
      info: function(msg) {
        this._fireEvent("info", msg);
      },
      debug: function(msg) {
        this._fireEvent("debug", msg);
      },
      addListener: function(listener) {
        this._listeners.push(listener);
      },
      removeListener: function(listener) {
        for (var i2 = 0; i2 < this._listeners.length; i2++) {
          if (this._listeners[i2] === listener) {
            this._listeners.splice(i2, 1);
            return;
          }
        }
      },
      _fireEvent: function(type4, msg) {
        for (var i2 = 0; i2 < this._listeners.length; i2++) {
          var logFunction = this._listeners[i2][type4];
          if (logFunction) {
            logFunction(msg);
          }
        }
      },
      _listeners: []
    };
    var Environment = function() {
      function Environment2(externalEnvironment, fileManagers) {
        this.fileManagers = fileManagers || [];
        externalEnvironment = externalEnvironment || {};
        var optionalFunctions = ["encodeBase64", "mimeLookup", "charsetLookup", "getSourceMapGenerator"];
        var requiredFunctions = [];
        var functions2 = requiredFunctions.concat(optionalFunctions);
        for (var i2 = 0; i2 < functions2.length; i2++) {
          var propName = functions2[i2];
          var environmentFunc = externalEnvironment[propName];
          if (environmentFunc) {
            this[propName] = environmentFunc.bind(externalEnvironment);
          } else if (i2 < requiredFunctions.length) {
            this.warn("missing required function in environment - " + propName);
          }
        }
      }
      Environment2.prototype.getFileManager = function(filename, currentDirectory, options2, environment, isSync) {
        if (!filename) {
          logger$1.warn("getFileManager called with no filename.. Please report this issue. continuing.");
        }
        if (currentDirectory == null) {
          logger$1.warn("getFileManager called with null directory.. Please report this issue. continuing.");
        }
        var fileManagers = this.fileManagers;
        if (options2.pluginManager) {
          fileManagers = [].concat(fileManagers).concat(options2.pluginManager.getFileManagers());
        }
        for (var i2 = fileManagers.length - 1; i2 >= 0; i2--) {
          var fileManager = fileManagers[i2];
          if (fileManager[isSync ? "supportsSync" : "supports"](filename, currentDirectory, options2, environment)) {
            return fileManager;
          }
        }
        return null;
      };
      Environment2.prototype.addFileManager = function(fileManager) {
        this.fileManagers.push(fileManager);
      };
      Environment2.prototype.clearFileManagers = function() {
        this.fileManagers = [];
      };
      return Environment2;
    }();
    var colors = {
      "aliceblue": "#f0f8ff",
      "antiquewhite": "#faebd7",
      "aqua": "#00ffff",
      "aquamarine": "#7fffd4",
      "azure": "#f0ffff",
      "beige": "#f5f5dc",
      "bisque": "#ffe4c4",
      "black": "#000000",
      "blanchedalmond": "#ffebcd",
      "blue": "#0000ff",
      "blueviolet": "#8a2be2",
      "brown": "#a52a2a",
      "burlywood": "#deb887",
      "cadetblue": "#5f9ea0",
      "chartreuse": "#7fff00",
      "chocolate": "#d2691e",
      "coral": "#ff7f50",
      "cornflowerblue": "#6495ed",
      "cornsilk": "#fff8dc",
      "crimson": "#dc143c",
      "cyan": "#00ffff",
      "darkblue": "#00008b",
      "darkcyan": "#008b8b",
      "darkgoldenrod": "#b8860b",
      "darkgray": "#a9a9a9",
      "darkgrey": "#a9a9a9",
      "darkgreen": "#006400",
      "darkkhaki": "#bdb76b",
      "darkmagenta": "#8b008b",
      "darkolivegreen": "#556b2f",
      "darkorange": "#ff8c00",
      "darkorchid": "#9932cc",
      "darkred": "#8b0000",
      "darksalmon": "#e9967a",
      "darkseagreen": "#8fbc8f",
      "darkslateblue": "#483d8b",
      "darkslategray": "#2f4f4f",
      "darkslategrey": "#2f4f4f",
      "darkturquoise": "#00ced1",
      "darkviolet": "#9400d3",
      "deeppink": "#ff1493",
      "deepskyblue": "#00bfff",
      "dimgray": "#696969",
      "dimgrey": "#696969",
      "dodgerblue": "#1e90ff",
      "firebrick": "#b22222",
      "floralwhite": "#fffaf0",
      "forestgreen": "#228b22",
      "fuchsia": "#ff00ff",
      "gainsboro": "#dcdcdc",
      "ghostwhite": "#f8f8ff",
      "gold": "#ffd700",
      "goldenrod": "#daa520",
      "gray": "#808080",
      "grey": "#808080",
      "green": "#008000",
      "greenyellow": "#adff2f",
      "honeydew": "#f0fff0",
      "hotpink": "#ff69b4",
      "indianred": "#cd5c5c",
      "indigo": "#4b0082",
      "ivory": "#fffff0",
      "khaki": "#f0e68c",
      "lavender": "#e6e6fa",
      "lavenderblush": "#fff0f5",
      "lawngreen": "#7cfc00",
      "lemonchiffon": "#fffacd",
      "lightblue": "#add8e6",
      "lightcoral": "#f08080",
      "lightcyan": "#e0ffff",
      "lightgoldenrodyellow": "#fafad2",
      "lightgray": "#d3d3d3",
      "lightgrey": "#d3d3d3",
      "lightgreen": "#90ee90",
      "lightpink": "#ffb6c1",
      "lightsalmon": "#ffa07a",
      "lightseagreen": "#20b2aa",
      "lightskyblue": "#87cefa",
      "lightslategray": "#778899",
      "lightslategrey": "#778899",
      "lightsteelblue": "#b0c4de",
      "lightyellow": "#ffffe0",
      "lime": "#00ff00",
      "limegreen": "#32cd32",
      "linen": "#faf0e6",
      "magenta": "#ff00ff",
      "maroon": "#800000",
      "mediumaquamarine": "#66cdaa",
      "mediumblue": "#0000cd",
      "mediumorchid": "#ba55d3",
      "mediumpurple": "#9370d8",
      "mediumseagreen": "#3cb371",
      "mediumslateblue": "#7b68ee",
      "mediumspringgreen": "#00fa9a",
      "mediumturquoise": "#48d1cc",
      "mediumvioletred": "#c71585",
      "midnightblue": "#191970",
      "mintcream": "#f5fffa",
      "mistyrose": "#ffe4e1",
      "moccasin": "#ffe4b5",
      "navajowhite": "#ffdead",
      "navy": "#000080",
      "oldlace": "#fdf5e6",
      "olive": "#808000",
      "olivedrab": "#6b8e23",
      "orange": "#ffa500",
      "orangered": "#ff4500",
      "orchid": "#da70d6",
      "palegoldenrod": "#eee8aa",
      "palegreen": "#98fb98",
      "paleturquoise": "#afeeee",
      "palevioletred": "#d87093",
      "papayawhip": "#ffefd5",
      "peachpuff": "#ffdab9",
      "peru": "#cd853f",
      "pink": "#ffc0cb",
      "plum": "#dda0dd",
      "powderblue": "#b0e0e6",
      "purple": "#800080",
      "rebeccapurple": "#663399",
      "red": "#ff0000",
      "rosybrown": "#bc8f8f",
      "royalblue": "#4169e1",
      "saddlebrown": "#8b4513",
      "salmon": "#fa8072",
      "sandybrown": "#f4a460",
      "seagreen": "#2e8b57",
      "seashell": "#fff5ee",
      "sienna": "#a0522d",
      "silver": "#c0c0c0",
      "skyblue": "#87ceeb",
      "slateblue": "#6a5acd",
      "slategray": "#708090",
      "slategrey": "#708090",
      "snow": "#fffafa",
      "springgreen": "#00ff7f",
      "steelblue": "#4682b4",
      "tan": "#d2b48c",
      "teal": "#008080",
      "thistle": "#d8bfd8",
      "tomato": "#ff6347",
      "turquoise": "#40e0d0",
      "violet": "#ee82ee",
      "wheat": "#f5deb3",
      "white": "#ffffff",
      "whitesmoke": "#f5f5f5",
      "yellow": "#ffff00",
      "yellowgreen": "#9acd32"
    };
    var unitConversions = {
      length: {
        "m": 1,
        "cm": 0.01,
        "mm": 1e-3,
        "in": 0.0254,
        "px": 0.0254 / 96,
        "pt": 0.0254 / 72,
        "pc": 0.0254 / 72 * 12
      },
      duration: {
        "s": 1,
        "ms": 1e-3
      },
      angle: {
        "rad": 1 / (2 * Math.PI),
        "deg": 1 / 360,
        "grad": 1 / 400,
        "turn": 1
      }
    };
    var data = { colors, unitConversions };
    var Node = function() {
      function Node2() {
        this.parent = null;
        this.visibilityBlocks = void 0;
        this.nodeVisible = void 0;
        this.rootNode = null;
        this.parsed = null;
      }
      Object.defineProperty(Node2.prototype, "currentFileInfo", {
        get: function() {
          return this.fileInfo();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node2.prototype, "index", {
        get: function() {
          return this.getIndex();
        },
        enumerable: false,
        configurable: true
      });
      Node2.prototype.setParent = function(nodes, parent) {
        function set2(node2) {
          if (node2 && node2 instanceof Node2) {
            node2.parent = parent;
          }
        }
        if (Array.isArray(nodes)) {
          nodes.forEach(set2);
        } else {
          set2(nodes);
        }
      };
      Node2.prototype.getIndex = function() {
        return this._index || this.parent && this.parent.getIndex() || 0;
      };
      Node2.prototype.fileInfo = function() {
        return this._fileInfo || this.parent && this.parent.fileInfo() || {};
      };
      Node2.prototype.isRulesetLike = function() {
        return false;
      };
      Node2.prototype.toCSS = function(context) {
        var strs = [];
        this.genCSS(context, {
          add: function(chunk, fileInfo, index2) {
            strs.push(chunk);
          },
          isEmpty: function() {
            return strs.length === 0;
          }
        });
        return strs.join("");
      };
      Node2.prototype.genCSS = function(context, output) {
        output.add(this.value);
      };
      Node2.prototype.accept = function(visitor) {
        this.value = visitor.visit(this.value);
      };
      Node2.prototype.eval = function() {
        return this;
      };
      Node2.prototype._operate = function(context, op, a2, b2) {
        switch (op) {
          case "+":
            return a2 + b2;
          case "-":
            return a2 - b2;
          case "*":
            return a2 * b2;
          case "/":
            return a2 / b2;
        }
      };
      Node2.prototype.fround = function(context, value) {
        var precision = context && context.numPrecision;
        return precision ? Number((value + 2e-16).toFixed(precision)) : value;
      };
      Node2.compare = function(a2, b2) {
        if (a2.compare && !(b2.type === "Quoted" || b2.type === "Anonymous")) {
          return a2.compare(b2);
        } else if (b2.compare) {
          return -b2.compare(a2);
        } else if (a2.type !== b2.type) {
          return void 0;
        }
        a2 = a2.value;
        b2 = b2.value;
        if (!Array.isArray(a2)) {
          return a2 === b2 ? 0 : void 0;
        }
        if (a2.length !== b2.length) {
          return void 0;
        }
        for (var i2 = 0; i2 < a2.length; i2++) {
          if (Node2.compare(a2[i2], b2[i2]) !== 0) {
            return void 0;
          }
        }
        return 0;
      };
      Node2.numericCompare = function(a2, b2) {
        return a2 < b2 ? -1 : a2 === b2 ? 0 : a2 > b2 ? 1 : void 0;
      };
      Node2.prototype.blocksVisibility = function() {
        if (this.visibilityBlocks == null) {
          this.visibilityBlocks = 0;
        }
        return this.visibilityBlocks !== 0;
      };
      Node2.prototype.addVisibilityBlock = function() {
        if (this.visibilityBlocks == null) {
          this.visibilityBlocks = 0;
        }
        this.visibilityBlocks = this.visibilityBlocks + 1;
      };
      Node2.prototype.removeVisibilityBlock = function() {
        if (this.visibilityBlocks == null) {
          this.visibilityBlocks = 0;
        }
        this.visibilityBlocks = this.visibilityBlocks - 1;
      };
      Node2.prototype.ensureVisibility = function() {
        this.nodeVisible = true;
      };
      Node2.prototype.ensureInvisibility = function() {
        this.nodeVisible = false;
      };
      Node2.prototype.isVisible = function() {
        return this.nodeVisible;
      };
      Node2.prototype.visibilityInfo = function() {
        return {
          visibilityBlocks: this.visibilityBlocks,
          nodeVisible: this.nodeVisible
        };
      };
      Node2.prototype.copyVisibilityInfo = function(info) {
        if (!info) {
          return;
        }
        this.visibilityBlocks = info.visibilityBlocks;
        this.nodeVisible = info.nodeVisible;
      };
      return Node2;
    }();
    var Color = function(rgb, a2, originalForm) {
      var self2 = this;
      if (Array.isArray(rgb)) {
        this.rgb = rgb;
      } else if (rgb.length >= 6) {
        this.rgb = [];
        rgb.match(/.{2}/g).map(function(c2, i2) {
          if (i2 < 3) {
            self2.rgb.push(parseInt(c2, 16));
          } else {
            self2.alpha = parseInt(c2, 16) / 255;
          }
        });
      } else {
        this.rgb = [];
        rgb.split("").map(function(c2, i2) {
          if (i2 < 3) {
            self2.rgb.push(parseInt(c2 + c2, 16));
          } else {
            self2.alpha = parseInt(c2 + c2, 16) / 255;
          }
        });
      }
      this.alpha = this.alpha || (typeof a2 === "number" ? a2 : 1);
      if (typeof originalForm !== "undefined") {
        this.value = originalForm;
      }
    };
    Color.prototype = Object.assign(new Node(), {
      type: "Color",
      luma: function() {
        var r2 = this.rgb[0] / 255, g2 = this.rgb[1] / 255, b2 = this.rgb[2] / 255;
        r2 = r2 <= 0.03928 ? r2 / 12.92 : Math.pow((r2 + 0.055) / 1.055, 2.4);
        g2 = g2 <= 0.03928 ? g2 / 12.92 : Math.pow((g2 + 0.055) / 1.055, 2.4);
        b2 = b2 <= 0.03928 ? b2 / 12.92 : Math.pow((b2 + 0.055) / 1.055, 2.4);
        return 0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2;
      },
      genCSS: function(context, output) {
        output.add(this.toCSS(context));
      },
      toCSS: function(context, doNotCompress) {
        var compress = context && context.compress && !doNotCompress;
        var color2;
        var alpha;
        var colorFunction;
        var args = [];
        alpha = this.fround(context, this.alpha);
        if (this.value) {
          if (this.value.indexOf("rgb") === 0) {
            if (alpha < 1) {
              colorFunction = "rgba";
            }
          } else if (this.value.indexOf("hsl") === 0) {
            if (alpha < 1) {
              colorFunction = "hsla";
            } else {
              colorFunction = "hsl";
            }
          } else {
            return this.value;
          }
        } else {
          if (alpha < 1) {
            colorFunction = "rgba";
          }
        }
        switch (colorFunction) {
          case "rgba":
            args = this.rgb.map(function(c2) {
              return clamp$1(Math.round(c2), 255);
            }).concat(clamp$1(alpha, 1));
            break;
          case "hsla":
            args.push(clamp$1(alpha, 1));
          case "hsl":
            color2 = this.toHSL();
            args = [
              this.fround(context, color2.h),
              this.fround(context, color2.s * 100) + "%",
              this.fround(context, color2.l * 100) + "%"
            ].concat(args);
        }
        if (colorFunction) {
          return colorFunction + "(" + args.join("," + (compress ? "" : " ")) + ")";
        }
        color2 = this.toRGB();
        if (compress) {
          var splitcolor = color2.split("");
          if (splitcolor[1] === splitcolor[2] && splitcolor[3] === splitcolor[4] && splitcolor[5] === splitcolor[6]) {
            color2 = "#" + splitcolor[1] + splitcolor[3] + splitcolor[5];
          }
        }
        return color2;
      },
      operate: function(context, op, other) {
        var rgb = new Array(3);
        var alpha = this.alpha * (1 - other.alpha) + other.alpha;
        for (var c2 = 0; c2 < 3; c2++) {
          rgb[c2] = this._operate(context, op, this.rgb[c2], other.rgb[c2]);
        }
        return new Color(rgb, alpha);
      },
      toRGB: function() {
        return toHex2(this.rgb);
      },
      toHSL: function() {
        var r2 = this.rgb[0] / 255, g2 = this.rgb[1] / 255, b2 = this.rgb[2] / 255, a2 = this.alpha;
        var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2);
        var h2;
        var s2;
        var l2 = (max + min) / 2;
        var d2 = max - min;
        if (max === min) {
          h2 = s2 = 0;
        } else {
          s2 = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2 * 360, s: s2, l: l2, a: a2 };
      },
      toHSV: function() {
        var r2 = this.rgb[0] / 255, g2 = this.rgb[1] / 255, b2 = this.rgb[2] / 255, a2 = this.alpha;
        var max = Math.max(r2, g2, b2), min = Math.min(r2, g2, b2);
        var h2;
        var s2;
        var v2 = max;
        var d2 = max - min;
        if (max === 0) {
          s2 = 0;
        } else {
          s2 = d2 / max;
        }
        if (max === min) {
          h2 = 0;
        } else {
          switch (max) {
            case r2:
              h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
              break;
            case g2:
              h2 = (b2 - r2) / d2 + 2;
              break;
            case b2:
              h2 = (r2 - g2) / d2 + 4;
              break;
          }
          h2 /= 6;
        }
        return { h: h2 * 360, s: s2, v: v2, a: a2 };
      },
      toARGB: function() {
        return toHex2([this.alpha * 255].concat(this.rgb));
      },
      compare: function(x2) {
        return x2.rgb && x2.rgb[0] === this.rgb[0] && x2.rgb[1] === this.rgb[1] && x2.rgb[2] === this.rgb[2] && x2.alpha === this.alpha ? 0 : void 0;
      }
    });
    Color.fromKeyword = function(keyword) {
      var c2;
      var key2 = keyword.toLowerCase();
      if (colors.hasOwnProperty(key2)) {
        c2 = new Color(colors[key2].slice(1));
      } else if (key2 === "transparent") {
        c2 = new Color([0, 0, 0], 0);
      }
      if (c2) {
        c2.value = keyword;
        return c2;
      }
    };
    function clamp$1(v2, max) {
      return Math.min(Math.max(v2, 0), max);
    }
    function toHex2(v2) {
      return "#" + v2.map(function(c2) {
        c2 = clamp$1(Math.round(c2), 255);
        return (c2 < 16 ? "0" : "") + c2.toString(16);
      }).join("");
    }
    var Paren = function(node2) {
      this.value = node2;
    };
    Paren.prototype = Object.assign(new Node(), {
      type: "Paren",
      genCSS: function(context, output) {
        output.add("(");
        this.value.genCSS(context, output);
        output.add(")");
      },
      eval: function(context) {
        return new Paren(this.value.eval(context));
      }
    });
    var _noSpaceCombinators = {
      "": true,
      " ": true,
      "|": true
    };
    var Combinator = function(value) {
      if (value === " ") {
        this.value = " ";
        this.emptyOrWhitespace = true;
      } else {
        this.value = value ? value.trim() : "";
        this.emptyOrWhitespace = this.value === "";
      }
    };
    Combinator.prototype = Object.assign(new Node(), {
      type: "Combinator",
      genCSS: function(context, output) {
        var spaceOrEmpty = context.compress || _noSpaceCombinators[this.value] ? "" : " ";
        output.add(spaceOrEmpty + this.value + spaceOrEmpty);
      }
    });
    var Element2 = function(combinator, value, isVariable, index2, currentFileInfo, visibilityInfo) {
      this.combinator = combinator instanceof Combinator ? combinator : new Combinator(combinator);
      if (typeof value === "string") {
        this.value = value.trim();
      } else if (value) {
        this.value = value;
      } else {
        this.value = "";
      }
      this.isVariable = isVariable;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.copyVisibilityInfo(visibilityInfo);
      this.setParent(this.combinator, this);
    };
    Element2.prototype = Object.assign(new Node(), {
      type: "Element",
      accept: function(visitor) {
        var value = this.value;
        this.combinator = visitor.visit(this.combinator);
        if (typeof value === "object") {
          this.value = visitor.visit(value);
        }
      },
      eval: function(context) {
        return new Element2(this.combinator, this.value.eval ? this.value.eval(context) : this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      },
      clone: function() {
        return new Element2(this.combinator, this.value, this.isVariable, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      },
      genCSS: function(context, output) {
        output.add(this.toCSS(context), this.fileInfo(), this.getIndex());
      },
      toCSS: function(context) {
        context = context || {};
        var value = this.value;
        var firstSelector = context.firstSelector;
        if (value instanceof Paren) {
          context.firstSelector = true;
        }
        value = value.toCSS ? value.toCSS(context) : value;
        context.firstSelector = firstSelector;
        if (value === "" && this.combinator.value.charAt(0) === "&") {
          return "";
        } else {
          return this.combinator.toCSS(context) + value;
        }
      }
    });
    var Math$1 = {
      ALWAYS: 0,
      PARENS_DIVISION: 1,
      PARENS: 2
    };
    var RewriteUrls = {
      OFF: 0,
      LOCAL: 1,
      ALL: 2
    };
    function getType(payload) {
      return Object.prototype.toString.call(payload).slice(8, -1);
    }
    function isPlainObject2(payload) {
      if (getType(payload) !== "Object")
        return false;
      return payload.constructor === Object && Object.getPrototypeOf(payload) === Object.prototype;
    }
    function isArray2(payload) {
      return getType(payload) === "Array";
    }
    /*! *****************************************************************************
    	    Copyright (c) Microsoft Corporation. All rights reserved.
    	    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    	    this file except in compliance with the License. You may obtain a copy of the
    	    License at http://www.apache.org/licenses/LICENSE-2.0
    
    	    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    	    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    	    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    	    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    	    See the Apache Version 2.0 License for specific language governing permissions
    	    and limitations under the License.
    	    ***************************************************************************** */
    function __spreadArrays() {
      for (var s2 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
        s2 += arguments[i2].length;
      for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il2; i2++)
        for (var a2 = arguments[i2], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
          r2[k2] = a2[j2];
      return r2;
    }
    function assignProp(carry, key2, newVal, originalObject, includeNonenumerable) {
      var propType = {}.propertyIsEnumerable.call(originalObject, key2) ? "enumerable" : "nonenumerable";
      if (propType === "enumerable")
        carry[key2] = newVal;
      if (includeNonenumerable && propType === "nonenumerable") {
        Object.defineProperty(carry, key2, {
          value: newVal,
          enumerable: false,
          writable: true,
          configurable: true
        });
      }
    }
    function copy2(target, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      if (isArray2(target))
        return target.map(function(i2) {
          return copy2(i2, options2);
        });
      if (!isPlainObject2(target))
        return target;
      var props = Object.getOwnPropertyNames(target);
      var symbols = Object.getOwnPropertySymbols(target);
      return __spreadArrays(props, symbols).reduce(function(carry, key2) {
        if (isArray2(options2.props) && !options2.props.includes(key2)) {
          return carry;
        }
        var val = target[key2];
        var newVal = copy2(val, options2);
        assignProp(carry, key2, newVal, target, options2.nonenumerable);
        return carry;
      }, {});
    }
    function getLocation(index2, inputStream) {
      var n2 = index2 + 1;
      var line2 = null;
      var column2 = -1;
      while (--n2 >= 0 && inputStream.charAt(n2) !== "\n") {
        column2++;
      }
      if (typeof index2 === "number") {
        line2 = (inputStream.slice(0, index2).match(/\n/g) || "").length;
      }
      return {
        line: line2,
        column: column2
      };
    }
    function copyArray(arr) {
      var i2;
      var length2 = arr.length;
      var copy3 = new Array(length2);
      for (i2 = 0; i2 < length2; i2++) {
        copy3[i2] = arr[i2];
      }
      return copy3;
    }
    function clone2(obj) {
      var cloned = {};
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          cloned[prop] = obj[prop];
        }
      }
      return cloned;
    }
    function defaults2(obj1, obj2) {
      var newObj = obj2 || {};
      if (!obj2._defaults) {
        newObj = {};
        var defaults_1 = copy2(obj1);
        newObj._defaults = defaults_1;
        var cloned = obj2 ? copy2(obj2) : {};
        Object.assign(newObj, defaults_1, cloned);
      }
      return newObj;
    }
    function copyOptions(obj1, obj2) {
      if (obj2 && obj2._defaults) {
        return obj2;
      }
      var opts = defaults2(obj1, obj2);
      if (opts.strictMath) {
        opts.math = Math$1.PARENS;
      }
      if (opts.relativeUrls) {
        opts.rewriteUrls = RewriteUrls.ALL;
      }
      if (typeof opts.math === "string") {
        switch (opts.math.toLowerCase()) {
          case "always":
            opts.math = Math$1.ALWAYS;
            break;
          case "parens-division":
            opts.math = Math$1.PARENS_DIVISION;
            break;
          case "strict":
          case "parens":
            opts.math = Math$1.PARENS;
            break;
          default:
            opts.math = Math$1.PARENS;
        }
      }
      if (typeof opts.rewriteUrls === "string") {
        switch (opts.rewriteUrls.toLowerCase()) {
          case "off":
            opts.rewriteUrls = RewriteUrls.OFF;
            break;
          case "local":
            opts.rewriteUrls = RewriteUrls.LOCAL;
            break;
          case "all":
            opts.rewriteUrls = RewriteUrls.ALL;
            break;
        }
      }
      return opts;
    }
    function merge3(obj1, obj2) {
      for (var prop in obj2) {
        if (obj2.hasOwnProperty(prop)) {
          obj1[prop] = obj2[prop];
        }
      }
      return obj1;
    }
    function flattenArray(arr, result) {
      if (result === void 0) {
        result = [];
      }
      for (var i2 = 0, length_1 = arr.length; i2 < length_1; i2++) {
        var value = arr[i2];
        if (Array.isArray(value)) {
          flattenArray(value, result);
        } else {
          if (value !== void 0) {
            result.push(value);
          }
        }
      }
      return result;
    }
    var utils2 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getLocation,
      copyArray,
      clone: clone2,
      defaults: defaults2,
      copyOptions,
      merge: merge3,
      flattenArray
    });
    var anonymousFunc = /(<anonymous>|Function):(\d+):(\d+)/;
    var LessError = function(e2, fileContentMap, currentFilename) {
      Error.call(this);
      var filename = e2.filename || currentFilename;
      this.message = e2.message;
      this.stack = e2.stack;
      if (fileContentMap && filename) {
        var input = fileContentMap.contents[filename];
        var loc = getLocation(e2.index, input);
        var line2 = loc.line;
        var col = loc.column;
        var callLine = e2.call && getLocation(e2.call, input).line;
        var lines = input ? input.split("\n") : "";
        this.type = e2.type || "Syntax";
        this.filename = filename;
        this.index = e2.index;
        this.line = typeof line2 === "number" ? line2 + 1 : null;
        this.column = col;
        if (!this.line && this.stack) {
          var found = this.stack.match(anonymousFunc);
          var func = new Function("a", "throw new Error()");
          var lineAdjust = 0;
          try {
            func();
          } catch (e3) {
            var match = e3.stack.match(anonymousFunc);
            var line2 = parseInt(match[2]);
            lineAdjust = 1 - line2;
          }
          if (found) {
            if (found[2]) {
              this.line = parseInt(found[2]) + lineAdjust;
            }
            if (found[3]) {
              this.column = parseInt(found[3]);
            }
          }
        }
        this.callLine = callLine + 1;
        this.callExtract = lines[callLine];
        this.extract = [
          lines[this.line - 2],
          lines[this.line - 1],
          lines[this.line]
        ];
      }
    };
    if (typeof Object.create === "undefined") {
      var F2 = function() {
      };
      F2.prototype = Error.prototype;
      LessError.prototype = new F2();
    } else {
      LessError.prototype = Object.create(Error.prototype);
    }
    LessError.prototype.constructor = LessError;
    LessError.prototype.toString = function(options2) {
      options2 = options2 || {};
      var message2 = "";
      var extract = this.extract || [];
      var error = [];
      var stylize = function(str) {
        return str;
      };
      if (options2.stylize) {
        var type4 = typeof options2.stylize;
        if (type4 !== "function") {
          throw Error("options.stylize should be a function, got a " + type4 + "!");
        }
        stylize = options2.stylize;
      }
      if (this.line !== null) {
        if (typeof extract[0] === "string") {
          error.push(stylize(this.line - 1 + " " + extract[0], "grey"));
        }
        if (typeof extract[1] === "string") {
          var errorTxt = this.line + " ";
          if (extract[1]) {
            errorTxt += extract[1].slice(0, this.column) + stylize(stylize(stylize(extract[1].substr(this.column, 1), "bold") + extract[1].slice(this.column + 1), "red"), "inverse");
          }
          error.push(errorTxt);
        }
        if (typeof extract[2] === "string") {
          error.push(stylize(this.line + 1 + " " + extract[2], "grey"));
        }
        error = error.join("\n") + stylize("", "reset") + "\n";
      }
      message2 += stylize(this.type + "Error: " + this.message, "red");
      if (this.filename) {
        message2 += stylize(" in ", "red") + this.filename;
      }
      if (this.line) {
        message2 += stylize(" on line " + this.line + ", column " + (this.column + 1) + ":", "grey");
      }
      message2 += "\n" + error;
      if (this.callLine) {
        message2 += stylize("from ", "red") + (this.filename || "") + "/n";
        message2 += stylize(this.callLine, "grey") + " " + this.callExtract + "/n";
      }
      return message2;
    };
    var Selector = function(elements, extendList, condition, index2, currentFileInfo, visibilityInfo) {
      this.extendList = extendList;
      this.condition = condition;
      this.evaldCondition = !condition;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.elements = this.getElements(elements);
      this.mixinElements_ = void 0;
      this.copyVisibilityInfo(visibilityInfo);
      this.setParent(this.elements, this);
    };
    Selector.prototype = Object.assign(new Node(), {
      type: "Selector",
      accept: function(visitor) {
        if (this.elements) {
          this.elements = visitor.visitArray(this.elements);
        }
        if (this.extendList) {
          this.extendList = visitor.visitArray(this.extendList);
        }
        if (this.condition) {
          this.condition = visitor.visit(this.condition);
        }
      },
      createDerived: function(elements, extendList, evaldCondition) {
        elements = this.getElements(elements);
        var newSelector = new Selector(elements, extendList || this.extendList, null, this.getIndex(), this.fileInfo(), this.visibilityInfo());
        newSelector.evaldCondition = evaldCondition != null ? evaldCondition : this.evaldCondition;
        newSelector.mediaEmpty = this.mediaEmpty;
        return newSelector;
      },
      getElements: function(els) {
        if (!els) {
          return [new Element2("", "&", false, this._index, this._fileInfo)];
        }
        if (typeof els === "string") {
          this.parse.parseNode(els, ["selector"], this._index, this._fileInfo, function(err, result) {
            if (err) {
              throw new LessError({
                index: err.index,
                message: err.message
              }, this.parse.imports, this._fileInfo.filename);
            }
            els = result[0].elements;
          });
        }
        return els;
      },
      createEmptySelectors: function() {
        var el2 = new Element2("", "&", false, this._index, this._fileInfo), sels = [new Selector([el2], null, null, this._index, this._fileInfo)];
        sels[0].mediaEmpty = true;
        return sels;
      },
      match: function(other) {
        var elements = this.elements;
        var len = elements.length;
        var olen;
        var i2;
        other = other.mixinElements();
        olen = other.length;
        if (olen === 0 || len < olen) {
          return 0;
        } else {
          for (i2 = 0; i2 < olen; i2++) {
            if (elements[i2].value !== other[i2]) {
              return 0;
            }
          }
        }
        return olen;
      },
      mixinElements: function() {
        if (this.mixinElements_) {
          return this.mixinElements_;
        }
        var elements = this.elements.map(function(v2) {
          return v2.combinator.value + (v2.value.value || v2.value);
        }).join("").match(/[,&#\*\.\w-]([\w-]|(\\.))*/g);
        if (elements) {
          if (elements[0] === "&") {
            elements.shift();
          }
        } else {
          elements = [];
        }
        return this.mixinElements_ = elements;
      },
      isJustParentSelector: function() {
        return !this.mediaEmpty && this.elements.length === 1 && this.elements[0].value === "&" && (this.elements[0].combinator.value === " " || this.elements[0].combinator.value === "");
      },
      eval: function(context) {
        var evaldCondition = this.condition && this.condition.eval(context);
        var elements = this.elements;
        var extendList = this.extendList;
        elements = elements && elements.map(function(e2) {
          return e2.eval(context);
        });
        extendList = extendList && extendList.map(function(extend2) {
          return extend2.eval(context);
        });
        return this.createDerived(elements, extendList, evaldCondition);
      },
      genCSS: function(context, output) {
        var i2, element;
        if ((!context || !context.firstSelector) && this.elements[0].combinator.value === "") {
          output.add(" ", this.fileInfo(), this.getIndex());
        }
        for (i2 = 0; i2 < this.elements.length; i2++) {
          element = this.elements[i2];
          element.genCSS(context, output);
        }
      },
      getIsOutput: function() {
        return this.evaldCondition;
      }
    });
    var Value = function(value) {
      if (!value) {
        throw new Error("Value requires an array argument");
      }
      if (!Array.isArray(value)) {
        this.value = [value];
      } else {
        this.value = value;
      }
    };
    Value.prototype = Object.assign(new Node(), {
      type: "Value",
      accept: function(visitor) {
        if (this.value) {
          this.value = visitor.visitArray(this.value);
        }
      },
      eval: function(context) {
        if (this.value.length === 1) {
          return this.value[0].eval(context);
        } else {
          return new Value(this.value.map(function(v2) {
            return v2.eval(context);
          }));
        }
      },
      genCSS: function(context, output) {
        var i2;
        for (i2 = 0; i2 < this.value.length; i2++) {
          this.value[i2].genCSS(context, output);
          if (i2 + 1 < this.value.length) {
            output.add(context && context.compress ? "," : ", ");
          }
        }
      }
    });
    var Keyword = function(value) {
      this.value = value;
    };
    Keyword.prototype = Object.assign(new Node(), {
      type: "Keyword",
      genCSS: function(context, output) {
        if (this.value === "%") {
          throw { type: "Syntax", message: "Invalid % without number" };
        }
        output.add(this.value);
      }
    });
    Keyword.True = new Keyword("true");
    Keyword.False = new Keyword("false");
    var Anonymous = function(value, index2, currentFileInfo, mapLines, rulesetLike, visibilityInfo) {
      this.value = value;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.mapLines = mapLines;
      this.rulesetLike = typeof rulesetLike === "undefined" ? false : rulesetLike;
      this.allowRoot = true;
      this.copyVisibilityInfo(visibilityInfo);
    };
    Anonymous.prototype = Object.assign(new Node(), {
      type: "Anonymous",
      eval: function() {
        return new Anonymous(this.value, this._index, this._fileInfo, this.mapLines, this.rulesetLike, this.visibilityInfo());
      },
      compare: function(other) {
        return other.toCSS && this.toCSS() === other.toCSS() ? 0 : void 0;
      },
      isRulesetLike: function() {
        return this.rulesetLike;
      },
      genCSS: function(context, output) {
        this.nodeVisible = Boolean(this.value);
        if (this.nodeVisible) {
          output.add(this.value, this._fileInfo, this._index, this.mapLines);
        }
      }
    });
    var MATH$1 = Math$1;
    function evalName(context, name2) {
      var value = "";
      var i2;
      var n2 = name2.length;
      var output = { add: function(s2) {
        value += s2;
      } };
      for (i2 = 0; i2 < n2; i2++) {
        name2[i2].eval(context).genCSS(context, output);
      }
      return value;
    }
    var Declaration = function(name2, value, important, merge4, index2, currentFileInfo, inline2, variable) {
      this.name = name2;
      this.value = value instanceof Node ? value : new Value([value ? new Anonymous(value) : null]);
      this.important = important ? " " + important.trim() : "";
      this.merge = merge4;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.inline = inline2 || false;
      this.variable = variable !== void 0 ? variable : name2.charAt && name2.charAt(0) === "@";
      this.allowRoot = true;
      this.setParent(this.value, this);
    };
    Declaration.prototype = Object.assign(new Node(), {
      type: "Declaration",
      genCSS: function(context, output) {
        output.add(this.name + (context.compress ? ":" : ": "), this.fileInfo(), this.getIndex());
        try {
          this.value.genCSS(context, output);
        } catch (e2) {
          e2.index = this._index;
          e2.filename = this._fileInfo.filename;
          throw e2;
        }
        output.add(this.important + (this.inline || context.lastRule && context.compress ? "" : ";"), this._fileInfo, this._index);
      },
      eval: function(context) {
        var mathBypass = false, prevMath, name2 = this.name, evaldValue, variable = this.variable;
        if (typeof name2 !== "string") {
          name2 = name2.length === 1 && name2[0] instanceof Keyword ? name2[0].value : evalName(context, name2);
          variable = false;
        }
        if (name2 === "font" && context.math === MATH$1.ALWAYS) {
          mathBypass = true;
          prevMath = context.math;
          context.math = MATH$1.PARENS_DIVISION;
        }
        try {
          context.importantScope.push({});
          evaldValue = this.value.eval(context);
          if (!this.variable && evaldValue.type === "DetachedRuleset") {
            throw {
              message: "Rulesets cannot be evaluated on a property.",
              index: this.getIndex(),
              filename: this.fileInfo().filename
            };
          }
          var important = this.important;
          var importantResult = context.importantScope.pop();
          if (!important && importantResult.important) {
            important = importantResult.important;
          }
          return new Declaration(name2, evaldValue, important, this.merge, this.getIndex(), this.fileInfo(), this.inline, variable);
        } catch (e2) {
          if (typeof e2.index !== "number") {
            e2.index = this.getIndex();
            e2.filename = this.fileInfo().filename;
          }
          throw e2;
        } finally {
          if (mathBypass) {
            context.math = prevMath;
          }
        }
      },
      makeImportant: function() {
        return new Declaration(this.name, this.value, "!important", this.merge, this.getIndex(), this.fileInfo(), this.inline);
      }
    });
    function asComment(ctx) {
      return "/* line " + ctx.debugInfo.lineNumber + ", " + ctx.debugInfo.fileName + " */\n";
    }
    function asMediaQuery(ctx) {
      var filenameWithProtocol = ctx.debugInfo.fileName;
      if (!/^[a-z]+:\/\//i.test(filenameWithProtocol)) {
        filenameWithProtocol = "file://" + filenameWithProtocol;
      }
      return "@media -sass-debug-info{filename{font-family:" + filenameWithProtocol.replace(/([.:\/\\])/g, function(a2) {
        if (a2 == "\\") {
          a2 = "/";
        }
        return "\\" + a2;
      }) + "}line{font-family:\\00003" + ctx.debugInfo.lineNumber + "}}\n";
    }
    function debugInfo(context, ctx, lineSeparator) {
      var result = "";
      if (context.dumpLineNumbers && !context.compress) {
        switch (context.dumpLineNumbers) {
          case "comments":
            result = asComment(ctx);
            break;
          case "mediaquery":
            result = asMediaQuery(ctx);
            break;
          case "all":
            result = asComment(ctx) + (lineSeparator || "") + asMediaQuery(ctx);
            break;
        }
      }
      return result;
    }
    var Comment = function(value, isLineComment, index2, currentFileInfo) {
      this.value = value;
      this.isLineComment = isLineComment;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.allowRoot = true;
    };
    Comment.prototype = Object.assign(new Node(), {
      type: "Comment",
      genCSS: function(context, output) {
        if (this.debugInfo) {
          output.add(debugInfo(context, this), this.fileInfo(), this.getIndex());
        }
        output.add(this.value);
      },
      isSilent: function(context) {
        var isCompressed = context.compress && this.value[2] !== "!";
        return this.isLineComment || isCompressed;
      }
    });
    var contexts = {};
    var copyFromOriginal = function copyFromOriginal2(original, destination, propertiesToCopy) {
      if (!original) {
        return;
      }
      for (var i2 = 0; i2 < propertiesToCopy.length; i2++) {
        if (original.hasOwnProperty(propertiesToCopy[i2])) {
          destination[propertiesToCopy[i2]] = original[propertiesToCopy[i2]];
        }
      }
    };
    var parseCopyProperties = [
      "paths",
      "rewriteUrls",
      "rootpath",
      "strictImports",
      "insecure",
      "dumpLineNumbers",
      "compress",
      "syncImport",
      "chunkInput",
      "mime",
      "useFileCache",
      "processImports",
      "pluginManager"
    ];
    contexts.Parse = function(options2) {
      copyFromOriginal(options2, this, parseCopyProperties);
      if (typeof this.paths === "string") {
        this.paths = [this.paths];
      }
    };
    var evalCopyProperties = [
      "paths",
      "compress",
      "math",
      "strictUnits",
      "sourceMap",
      "importMultiple",
      "urlArgs",
      "javascriptEnabled",
      "pluginManager",
      "importantScope",
      "rewriteUrls"
    ];
    contexts.Eval = function(options2, frames) {
      copyFromOriginal(options2, this, evalCopyProperties);
      if (typeof this.paths === "string") {
        this.paths = [this.paths];
      }
      this.frames = frames || [];
      this.importantScope = this.importantScope || [];
    };
    contexts.Eval.prototype.enterCalc = function() {
      if (!this.calcStack) {
        this.calcStack = [];
      }
      this.calcStack.push(true);
      this.inCalc = true;
    };
    contexts.Eval.prototype.exitCalc = function() {
      this.calcStack.pop();
      if (!this.calcStack.length) {
        this.inCalc = false;
      }
    };
    contexts.Eval.prototype.inParenthesis = function() {
      if (!this.parensStack) {
        this.parensStack = [];
      }
      this.parensStack.push(true);
    };
    contexts.Eval.prototype.outOfParenthesis = function() {
      this.parensStack.pop();
    };
    contexts.Eval.prototype.inCalc = false;
    contexts.Eval.prototype.mathOn = true;
    contexts.Eval.prototype.isMathOn = function(op) {
      if (!this.mathOn) {
        return false;
      }
      if (op === "/" && this.math !== Math$1.ALWAYS && (!this.parensStack || !this.parensStack.length)) {
        return false;
      }
      if (this.math > Math$1.PARENS_DIVISION) {
        return this.parensStack && this.parensStack.length;
      }
      return true;
    };
    contexts.Eval.prototype.pathRequiresRewrite = function(path2) {
      var isRelative = this.rewriteUrls === RewriteUrls.LOCAL ? isPathLocalRelative : isPathRelative;
      return isRelative(path2);
    };
    contexts.Eval.prototype.rewritePath = function(path2, rootpath) {
      var newPath;
      rootpath = rootpath || "";
      newPath = this.normalizePath(rootpath + path2);
      if (isPathLocalRelative(path2) && isPathRelative(rootpath) && isPathLocalRelative(newPath) === false) {
        newPath = "./" + newPath;
      }
      return newPath;
    };
    contexts.Eval.prototype.normalizePath = function(path2) {
      var segments = path2.split("/").reverse();
      var segment;
      path2 = [];
      while (segments.length !== 0) {
        segment = segments.pop();
        switch (segment) {
          case ".":
            break;
          case "..":
            if (path2.length === 0 || path2[path2.length - 1] === "..") {
              path2.push(segment);
            } else {
              path2.pop();
            }
            break;
          default:
            path2.push(segment);
            break;
        }
      }
      return path2.join("/");
    };
    function isPathRelative(path2) {
      return !/^(?:[a-z-]+:|\/|#)/i.test(path2);
    }
    function isPathLocalRelative(path2) {
      return path2.charAt(0) === ".";
    }
    function makeRegistry(base) {
      return {
        _data: {},
        add: function(name2, func) {
          name2 = name2.toLowerCase();
          if (this._data.hasOwnProperty(name2))
            ;
          this._data[name2] = func;
        },
        addMultiple: function(functions2) {
          var _this = this;
          Object.keys(functions2).forEach(function(name2) {
            _this.add(name2, functions2[name2]);
          });
        },
        get: function(name2) {
          return this._data[name2] || base && base.get(name2);
        },
        getLocalFunctions: function() {
          return this._data;
        },
        inherit: function() {
          return makeRegistry(this);
        },
        create: function(base2) {
          return makeRegistry(base2);
        }
      };
    }
    var functionRegistry = makeRegistry(null);
    var defaultFunc = {
      eval: function() {
        var v2 = this.value_;
        var e2 = this.error_;
        if (e2) {
          throw e2;
        }
        if (v2 != null) {
          return v2 ? Keyword.True : Keyword.False;
        }
      },
      value: function(v2) {
        this.value_ = v2;
      },
      error: function(e2) {
        this.error_ = e2;
      },
      reset: function() {
        this.value_ = this.error_ = null;
      }
    };
    var Ruleset = function(selectors, rules2, strictImports, visibilityInfo) {
      this.selectors = selectors;
      this.rules = rules2;
      this._lookups = {};
      this._variables = null;
      this._properties = null;
      this.strictImports = strictImports;
      this.copyVisibilityInfo(visibilityInfo);
      this.allowRoot = true;
      this.setParent(this.selectors, this);
      this.setParent(this.rules, this);
    };
    Ruleset.prototype = Object.assign(new Node(), {
      type: "Ruleset",
      isRuleset: true,
      isRulesetLike: function() {
        return true;
      },
      accept: function(visitor) {
        if (this.paths) {
          this.paths = visitor.visitArray(this.paths, true);
        } else if (this.selectors) {
          this.selectors = visitor.visitArray(this.selectors);
        }
        if (this.rules && this.rules.length) {
          this.rules = visitor.visitArray(this.rules);
        }
      },
      eval: function(context) {
        var selectors;
        var selCnt;
        var selector;
        var i2;
        var hasVariable;
        var hasOnePassingSelector = false;
        if (this.selectors && (selCnt = this.selectors.length)) {
          selectors = new Array(selCnt);
          defaultFunc.error({
            type: "Syntax",
            message: "it is currently only allowed in parametric mixin guards,"
          });
          for (i2 = 0; i2 < selCnt; i2++) {
            selector = this.selectors[i2].eval(context);
            for (var j2 = 0; j2 < selector.elements.length; j2++) {
              if (selector.elements[j2].isVariable) {
                hasVariable = true;
                break;
              }
            }
            selectors[i2] = selector;
            if (selector.evaldCondition) {
              hasOnePassingSelector = true;
            }
          }
          if (hasVariable) {
            var toParseSelectors = new Array(selCnt);
            for (i2 = 0; i2 < selCnt; i2++) {
              selector = selectors[i2];
              toParseSelectors[i2] = selector.toCSS(context);
            }
            this.parse.parseNode(toParseSelectors.join(","), ["selectors"], selectors[0].getIndex(), selectors[0].fileInfo(), function(err, result) {
              if (result) {
                selectors = flattenArray(result);
              }
            });
          }
          defaultFunc.reset();
        } else {
          hasOnePassingSelector = true;
        }
        var rules2 = this.rules ? copyArray(this.rules) : null;
        var ruleset2 = new Ruleset(selectors, rules2, this.strictImports, this.visibilityInfo());
        var rule;
        var subRule;
        ruleset2.originalRuleset = this;
        ruleset2.root = this.root;
        ruleset2.firstRoot = this.firstRoot;
        ruleset2.allowImports = this.allowImports;
        if (this.debugInfo) {
          ruleset2.debugInfo = this.debugInfo;
        }
        if (!hasOnePassingSelector) {
          rules2.length = 0;
        }
        ruleset2.functionRegistry = function(frames) {
          var i3 = 0;
          var n2 = frames.length;
          var found;
          for (; i3 !== n2; ++i3) {
            found = frames[i3].functionRegistry;
            if (found) {
              return found;
            }
          }
          return functionRegistry;
        }(context.frames).inherit();
        var ctxFrames = context.frames;
        ctxFrames.unshift(ruleset2);
        var ctxSelectors = context.selectors;
        if (!ctxSelectors) {
          context.selectors = ctxSelectors = [];
        }
        ctxSelectors.unshift(this.selectors);
        if (ruleset2.root || ruleset2.allowImports || !ruleset2.strictImports) {
          ruleset2.evalImports(context);
        }
        var rsRules = ruleset2.rules;
        for (i2 = 0; rule = rsRules[i2]; i2++) {
          if (rule.evalFirst) {
            rsRules[i2] = rule.eval(context);
          }
        }
        var mediaBlockCount = context.mediaBlocks && context.mediaBlocks.length || 0;
        for (i2 = 0; rule = rsRules[i2]; i2++) {
          if (rule.type === "MixinCall") {
            rules2 = rule.eval(context).filter(function(r2) {
              if (r2 instanceof Declaration && r2.variable) {
                return !ruleset2.variable(r2.name);
              }
              return true;
            });
            rsRules.splice.apply(rsRules, [i2, 1].concat(rules2));
            i2 += rules2.length - 1;
            ruleset2.resetCache();
          } else if (rule.type === "VariableCall") {
            rules2 = rule.eval(context).rules.filter(function(r2) {
              if (r2 instanceof Declaration && r2.variable) {
                return false;
              }
              return true;
            });
            rsRules.splice.apply(rsRules, [i2, 1].concat(rules2));
            i2 += rules2.length - 1;
            ruleset2.resetCache();
          }
        }
        for (i2 = 0; rule = rsRules[i2]; i2++) {
          if (!rule.evalFirst) {
            rsRules[i2] = rule = rule.eval ? rule.eval(context) : rule;
          }
        }
        for (i2 = 0; rule = rsRules[i2]; i2++) {
          if (rule instanceof Ruleset && rule.selectors && rule.selectors.length === 1) {
            if (rule.selectors[0] && rule.selectors[0].isJustParentSelector()) {
              rsRules.splice(i2--, 1);
              for (var j2 = 0; subRule = rule.rules[j2]; j2++) {
                if (subRule instanceof Node) {
                  subRule.copyVisibilityInfo(rule.visibilityInfo());
                  if (!(subRule instanceof Declaration) || !subRule.variable) {
                    rsRules.splice(++i2, 0, subRule);
                  }
                }
              }
            }
          }
        }
        ctxFrames.shift();
        ctxSelectors.shift();
        if (context.mediaBlocks) {
          for (i2 = mediaBlockCount; i2 < context.mediaBlocks.length; i2++) {
            context.mediaBlocks[i2].bubbleSelectors(selectors);
          }
        }
        return ruleset2;
      },
      evalImports: function(context) {
        var rules2 = this.rules;
        var i2;
        var importRules;
        if (!rules2) {
          return;
        }
        for (i2 = 0; i2 < rules2.length; i2++) {
          if (rules2[i2].type === "Import") {
            importRules = rules2[i2].eval(context);
            if (importRules && (importRules.length || importRules.length === 0)) {
              rules2.splice.apply(rules2, [i2, 1].concat(importRules));
              i2 += importRules.length - 1;
            } else {
              rules2.splice(i2, 1, importRules);
            }
            this.resetCache();
          }
        }
      },
      makeImportant: function() {
        var result = new Ruleset(this.selectors, this.rules.map(function(r2) {
          if (r2.makeImportant) {
            return r2.makeImportant();
          } else {
            return r2;
          }
        }), this.strictImports, this.visibilityInfo());
        return result;
      },
      matchArgs: function(args) {
        return !args || args.length === 0;
      },
      matchCondition: function(args, context) {
        var lastSelector = this.selectors[this.selectors.length - 1];
        if (!lastSelector.evaldCondition) {
          return false;
        }
        if (lastSelector.condition && !lastSelector.condition.eval(new contexts.Eval(context, context.frames))) {
          return false;
        }
        return true;
      },
      resetCache: function() {
        this._rulesets = null;
        this._variables = null;
        this._properties = null;
        this._lookups = {};
      },
      variables: function() {
        if (!this._variables) {
          this._variables = !this.rules ? {} : this.rules.reduce(function(hash, r2) {
            if (r2 instanceof Declaration && r2.variable === true) {
              hash[r2.name] = r2;
            }
            if (r2.type === "Import" && r2.root && r2.root.variables) {
              var vars = r2.root.variables();
              for (var name_1 in vars) {
                if (vars.hasOwnProperty(name_1)) {
                  hash[name_1] = r2.root.variable(name_1);
                }
              }
            }
            return hash;
          }, {});
        }
        return this._variables;
      },
      properties: function() {
        if (!this._properties) {
          this._properties = !this.rules ? {} : this.rules.reduce(function(hash, r2) {
            if (r2 instanceof Declaration && r2.variable !== true) {
              var name_2 = r2.name.length === 1 && r2.name[0] instanceof Keyword ? r2.name[0].value : r2.name;
              if (!hash["$" + name_2]) {
                hash["$" + name_2] = [r2];
              } else {
                hash["$" + name_2].push(r2);
              }
            }
            return hash;
          }, {});
        }
        return this._properties;
      },
      variable: function(name2) {
        var decl = this.variables()[name2];
        if (decl) {
          return this.parseValue(decl);
        }
      },
      property: function(name2) {
        var decl = this.properties()[name2];
        if (decl) {
          return this.parseValue(decl);
        }
      },
      lastDeclaration: function() {
        for (var i2 = this.rules.length; i2 > 0; i2--) {
          var decl = this.rules[i2 - 1];
          if (decl instanceof Declaration) {
            return this.parseValue(decl);
          }
        }
      },
      parseValue: function(toParse) {
        var self2 = this;
        function transformDeclaration(decl) {
          if (decl.value instanceof Anonymous && !decl.parsed) {
            if (typeof decl.value.value === "string") {
              this.parse.parseNode(decl.value.value, ["value", "important"], decl.value.getIndex(), decl.fileInfo(), function(err, result) {
                if (err) {
                  decl.parsed = true;
                }
                if (result) {
                  decl.value = result[0];
                  decl.important = result[1] || "";
                  decl.parsed = true;
                }
              });
            } else {
              decl.parsed = true;
            }
            return decl;
          } else {
            return decl;
          }
        }
        if (!Array.isArray(toParse)) {
          return transformDeclaration.call(self2, toParse);
        } else {
          var nodes_1 = [];
          toParse.forEach(function(n2) {
            nodes_1.push(transformDeclaration.call(self2, n2));
          });
          return nodes_1;
        }
      },
      rulesets: function() {
        if (!this.rules) {
          return [];
        }
        var filtRules = [];
        var rules2 = this.rules;
        var i2;
        var rule;
        for (i2 = 0; rule = rules2[i2]; i2++) {
          if (rule.isRuleset) {
            filtRules.push(rule);
          }
        }
        return filtRules;
      },
      prependRule: function(rule) {
        var rules2 = this.rules;
        if (rules2) {
          rules2.unshift(rule);
        } else {
          this.rules = [rule];
        }
        this.setParent(rule, this);
      },
      find: function(selector, self2, filter3) {
        self2 = self2 || this;
        var rules2 = [];
        var match;
        var foundMixins;
        var key2 = selector.toCSS();
        if (key2 in this._lookups) {
          return this._lookups[key2];
        }
        this.rulesets().forEach(function(rule) {
          if (rule !== self2) {
            for (var j2 = 0; j2 < rule.selectors.length; j2++) {
              match = selector.match(rule.selectors[j2]);
              if (match) {
                if (selector.elements.length > match) {
                  if (!filter3 || filter3(rule)) {
                    foundMixins = rule.find(new Selector(selector.elements.slice(match)), self2, filter3);
                    for (var i2 = 0; i2 < foundMixins.length; ++i2) {
                      foundMixins[i2].path.push(rule);
                    }
                    Array.prototype.push.apply(rules2, foundMixins);
                  }
                } else {
                  rules2.push({ rule, path: [] });
                }
                break;
              }
            }
          }
        });
        this._lookups[key2] = rules2;
        return rules2;
      },
      genCSS: function(context, output) {
        var i2;
        var j2;
        var charsetRuleNodes = [];
        var ruleNodes = [];
        var debugInfo$1;
        var rule;
        var path2;
        context.tabLevel = context.tabLevel || 0;
        if (!this.root) {
          context.tabLevel++;
        }
        var tabRuleStr = context.compress ? "" : Array(context.tabLevel + 1).join("  ");
        var tabSetStr = context.compress ? "" : Array(context.tabLevel).join("  ");
        var sep;
        var charsetNodeIndex = 0;
        var importNodeIndex = 0;
        for (i2 = 0; rule = this.rules[i2]; i2++) {
          if (rule instanceof Comment) {
            if (importNodeIndex === i2) {
              importNodeIndex++;
            }
            ruleNodes.push(rule);
          } else if (rule.isCharset && rule.isCharset()) {
            ruleNodes.splice(charsetNodeIndex, 0, rule);
            charsetNodeIndex++;
            importNodeIndex++;
          } else if (rule.type === "Import") {
            ruleNodes.splice(importNodeIndex, 0, rule);
            importNodeIndex++;
          } else {
            ruleNodes.push(rule);
          }
        }
        ruleNodes = charsetRuleNodes.concat(ruleNodes);
        if (!this.root) {
          debugInfo$1 = debugInfo(context, this, tabSetStr);
          if (debugInfo$1) {
            output.add(debugInfo$1);
            output.add(tabSetStr);
          }
          var paths = this.paths;
          var pathCnt = paths.length;
          var pathSubCnt = void 0;
          sep = context.compress ? "," : ",\n" + tabSetStr;
          for (i2 = 0; i2 < pathCnt; i2++) {
            path2 = paths[i2];
            if (!(pathSubCnt = path2.length)) {
              continue;
            }
            if (i2 > 0) {
              output.add(sep);
            }
            context.firstSelector = true;
            path2[0].genCSS(context, output);
            context.firstSelector = false;
            for (j2 = 1; j2 < pathSubCnt; j2++) {
              path2[j2].genCSS(context, output);
            }
          }
          output.add((context.compress ? "{" : " {\n") + tabRuleStr);
        }
        for (i2 = 0; rule = ruleNodes[i2]; i2++) {
          if (i2 + 1 === ruleNodes.length) {
            context.lastRule = true;
          }
          var currentLastRule = context.lastRule;
          if (rule.isRulesetLike(rule)) {
            context.lastRule = false;
          }
          if (rule.genCSS) {
            rule.genCSS(context, output);
          } else if (rule.value) {
            output.add(rule.value.toString());
          }
          context.lastRule = currentLastRule;
          if (!context.lastRule && rule.isVisible()) {
            output.add(context.compress ? "" : "\n" + tabRuleStr);
          } else {
            context.lastRule = false;
          }
        }
        if (!this.root) {
          output.add(context.compress ? "}" : "\n" + tabSetStr + "}");
          context.tabLevel--;
        }
        if (!output.isEmpty() && !context.compress && this.firstRoot) {
          output.add("\n");
        }
      },
      joinSelectors: function(paths, context, selectors) {
        for (var s2 = 0; s2 < selectors.length; s2++) {
          this.joinSelector(paths, context, selectors[s2]);
        }
      },
      joinSelector: function(paths, context, selector) {
        function createParenthesis(elementsToPak, originalElement) {
          var replacementParen, j2;
          if (elementsToPak.length === 0) {
            replacementParen = new Paren(elementsToPak[0]);
          } else {
            var insideParent = new Array(elementsToPak.length);
            for (j2 = 0; j2 < elementsToPak.length; j2++) {
              insideParent[j2] = new Element2(null, elementsToPak[j2], originalElement.isVariable, originalElement._index, originalElement._fileInfo);
            }
            replacementParen = new Paren(new Selector(insideParent));
          }
          return replacementParen;
        }
        function createSelector(containedElement, originalElement) {
          var element, selector2;
          element = new Element2(null, containedElement, originalElement.isVariable, originalElement._index, originalElement._fileInfo);
          selector2 = new Selector([element]);
          return selector2;
        }
        function addReplacementIntoPath(beginningPath, addPath, replacedElement, originalSelector) {
          var newSelectorPath, lastSelector, newJoinedSelector;
          newSelectorPath = [];
          if (beginningPath.length > 0) {
            newSelectorPath = copyArray(beginningPath);
            lastSelector = newSelectorPath.pop();
            newJoinedSelector = originalSelector.createDerived(copyArray(lastSelector.elements));
          } else {
            newJoinedSelector = originalSelector.createDerived([]);
          }
          if (addPath.length > 0) {
            var combinator = replacedElement.combinator;
            var parentEl = addPath[0].elements[0];
            if (combinator.emptyOrWhitespace && !parentEl.combinator.emptyOrWhitespace) {
              combinator = parentEl.combinator;
            }
            newJoinedSelector.elements.push(new Element2(combinator, parentEl.value, replacedElement.isVariable, replacedElement._index, replacedElement._fileInfo));
            newJoinedSelector.elements = newJoinedSelector.elements.concat(addPath[0].elements.slice(1));
          }
          if (newJoinedSelector.elements.length !== 0) {
            newSelectorPath.push(newJoinedSelector);
          }
          if (addPath.length > 1) {
            var restOfPath = addPath.slice(1);
            restOfPath = restOfPath.map(function(selector2) {
              return selector2.createDerived(selector2.elements, []);
            });
            newSelectorPath = newSelectorPath.concat(restOfPath);
          }
          return newSelectorPath;
        }
        function addAllReplacementsIntoPath(beginningPath, addPaths, replacedElement, originalSelector, result) {
          var j2;
          for (j2 = 0; j2 < beginningPath.length; j2++) {
            var newSelectorPath = addReplacementIntoPath(beginningPath[j2], addPaths, replacedElement, originalSelector);
            result.push(newSelectorPath);
          }
          return result;
        }
        function mergeElementsOnToSelectors(elements, selectors) {
          var i3, sel;
          if (elements.length === 0) {
            return;
          }
          if (selectors.length === 0) {
            selectors.push([new Selector(elements)]);
            return;
          }
          for (i3 = 0; sel = selectors[i3]; i3++) {
            if (sel.length > 0) {
              sel[sel.length - 1] = sel[sel.length - 1].createDerived(sel[sel.length - 1].elements.concat(elements));
            } else {
              sel.push(new Selector(elements));
            }
          }
        }
        function replaceParentSelector(paths2, context2, inSelector) {
          var i3, j2, k2, currentElements, newSelectors, selectorsMultiplied, sel, el2, hadParentSelector2 = false, length2, lastSelector;
          function findNestedSelector(element) {
            var maybeSelector;
            if (!(element.value instanceof Paren)) {
              return null;
            }
            maybeSelector = element.value.value;
            if (!(maybeSelector instanceof Selector)) {
              return null;
            }
            return maybeSelector;
          }
          currentElements = [];
          newSelectors = [
            []
          ];
          for (i3 = 0; el2 = inSelector.elements[i3]; i3++) {
            if (el2.value !== "&") {
              var nestedSelector = findNestedSelector(el2);
              if (nestedSelector != null) {
                mergeElementsOnToSelectors(currentElements, newSelectors);
                var nestedPaths = [];
                var replaced = void 0;
                var replacedNewSelectors = [];
                replaced = replaceParentSelector(nestedPaths, context2, nestedSelector);
                hadParentSelector2 = hadParentSelector2 || replaced;
                for (k2 = 0; k2 < nestedPaths.length; k2++) {
                  var replacementSelector = createSelector(createParenthesis(nestedPaths[k2], el2), el2);
                  addAllReplacementsIntoPath(newSelectors, [replacementSelector], el2, inSelector, replacedNewSelectors);
                }
                newSelectors = replacedNewSelectors;
                currentElements = [];
              } else {
                currentElements.push(el2);
              }
            } else {
              hadParentSelector2 = true;
              selectorsMultiplied = [];
              mergeElementsOnToSelectors(currentElements, newSelectors);
              for (j2 = 0; j2 < newSelectors.length; j2++) {
                sel = newSelectors[j2];
                if (context2.length === 0) {
                  if (sel.length > 0) {
                    sel[0].elements.push(new Element2(el2.combinator, "", el2.isVariable, el2._index, el2._fileInfo));
                  }
                  selectorsMultiplied.push(sel);
                } else {
                  for (k2 = 0; k2 < context2.length; k2++) {
                    var newSelectorPath = addReplacementIntoPath(sel, context2[k2], el2, inSelector);
                    selectorsMultiplied.push(newSelectorPath);
                  }
                }
              }
              newSelectors = selectorsMultiplied;
              currentElements = [];
            }
          }
          mergeElementsOnToSelectors(currentElements, newSelectors);
          for (i3 = 0; i3 < newSelectors.length; i3++) {
            length2 = newSelectors[i3].length;
            if (length2 > 0) {
              paths2.push(newSelectors[i3]);
              lastSelector = newSelectors[i3][length2 - 1];
              newSelectors[i3][length2 - 1] = lastSelector.createDerived(lastSelector.elements, inSelector.extendList);
            }
          }
          return hadParentSelector2;
        }
        function deriveSelector(visibilityInfo, deriveFrom) {
          var newSelector = deriveFrom.createDerived(deriveFrom.elements, deriveFrom.extendList, deriveFrom.evaldCondition);
          newSelector.copyVisibilityInfo(visibilityInfo);
          return newSelector;
        }
        var i2, newPaths, hadParentSelector;
        newPaths = [];
        hadParentSelector = replaceParentSelector(newPaths, context, selector);
        if (!hadParentSelector) {
          if (context.length > 0) {
            newPaths = [];
            for (i2 = 0; i2 < context.length; i2++) {
              var concatenated = context[i2].map(deriveSelector.bind(this, selector.visibilityInfo()));
              concatenated.push(selector);
              newPaths.push(concatenated);
            }
          } else {
            newPaths = [[selector]];
          }
        }
        for (i2 = 0; i2 < newPaths.length; i2++) {
          paths.push(newPaths[i2]);
        }
      }
    });
    var AtRule = function(name2, value, rules2, index2, currentFileInfo, debugInfo2, isRooted, visibilityInfo) {
      var i2;
      this.name = name2;
      this.value = value instanceof Node ? value : value ? new Anonymous(value) : value;
      if (rules2) {
        if (Array.isArray(rules2)) {
          this.rules = rules2;
        } else {
          this.rules = [rules2];
          this.rules[0].selectors = new Selector([], null, null, index2, currentFileInfo).createEmptySelectors();
        }
        for (i2 = 0; i2 < this.rules.length; i2++) {
          this.rules[i2].allowImports = true;
        }
        this.setParent(this.rules, this);
      }
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.debugInfo = debugInfo2;
      this.isRooted = isRooted || false;
      this.copyVisibilityInfo(visibilityInfo);
      this.allowRoot = true;
    };
    AtRule.prototype = Object.assign(new Node(), {
      type: "AtRule",
      accept: function(visitor) {
        var value = this.value, rules2 = this.rules;
        if (rules2) {
          this.rules = visitor.visitArray(rules2);
        }
        if (value) {
          this.value = visitor.visit(value);
        }
      },
      isRulesetLike: function() {
        return this.rules || !this.isCharset();
      },
      isCharset: function() {
        return "@charset" === this.name;
      },
      genCSS: function(context, output) {
        var value = this.value, rules2 = this.rules;
        output.add(this.name, this.fileInfo(), this.getIndex());
        if (value) {
          output.add(" ");
          value.genCSS(context, output);
        }
        if (rules2) {
          this.outputRuleset(context, output, rules2);
        } else {
          output.add(";");
        }
      },
      eval: function(context) {
        var mediaPathBackup, mediaBlocksBackup, value = this.value, rules2 = this.rules;
        mediaPathBackup = context.mediaPath;
        mediaBlocksBackup = context.mediaBlocks;
        context.mediaPath = [];
        context.mediaBlocks = [];
        if (value) {
          value = value.eval(context);
        }
        if (rules2) {
          rules2 = [rules2[0].eval(context)];
          rules2[0].root = true;
        }
        context.mediaPath = mediaPathBackup;
        context.mediaBlocks = mediaBlocksBackup;
        return new AtRule(this.name, value, rules2, this.getIndex(), this.fileInfo(), this.debugInfo, this.isRooted, this.visibilityInfo());
      },
      variable: function(name2) {
        if (this.rules) {
          return Ruleset.prototype.variable.call(this.rules[0], name2);
        }
      },
      find: function() {
        if (this.rules) {
          return Ruleset.prototype.find.apply(this.rules[0], arguments);
        }
      },
      rulesets: function() {
        if (this.rules) {
          return Ruleset.prototype.rulesets.apply(this.rules[0]);
        }
      },
      outputRuleset: function(context, output, rules2) {
        var ruleCnt = rules2.length;
        var i2;
        context.tabLevel = (context.tabLevel | 0) + 1;
        if (context.compress) {
          output.add("{");
          for (i2 = 0; i2 < ruleCnt; i2++) {
            rules2[i2].genCSS(context, output);
          }
          output.add("}");
          context.tabLevel--;
          return;
        }
        var tabSetStr = "\n" + Array(context.tabLevel).join("  "), tabRuleStr = tabSetStr + "  ";
        if (!ruleCnt) {
          output.add(" {" + tabSetStr + "}");
        } else {
          output.add(" {" + tabRuleStr);
          rules2[0].genCSS(context, output);
          for (i2 = 1; i2 < ruleCnt; i2++) {
            output.add(tabRuleStr);
            rules2[i2].genCSS(context, output);
          }
          output.add(tabSetStr + "}");
        }
        context.tabLevel--;
      }
    });
    var DetachedRuleset = function(ruleset2, frames) {
      this.ruleset = ruleset2;
      this.frames = frames;
      this.setParent(this.ruleset, this);
    };
    DetachedRuleset.prototype = Object.assign(new Node(), {
      type: "DetachedRuleset",
      evalFirst: true,
      accept: function(visitor) {
        this.ruleset = visitor.visit(this.ruleset);
      },
      eval: function(context) {
        var frames = this.frames || copyArray(context.frames);
        return new DetachedRuleset(this.ruleset, frames);
      },
      callEval: function(context) {
        return this.ruleset.eval(this.frames ? new contexts.Eval(context, this.frames.concat(context.frames)) : context);
      }
    });
    var Unit = function(numerator, denominator, backupUnit) {
      this.numerator = numerator ? copyArray(numerator).sort() : [];
      this.denominator = denominator ? copyArray(denominator).sort() : [];
      if (backupUnit) {
        this.backupUnit = backupUnit;
      } else if (numerator && numerator.length) {
        this.backupUnit = numerator[0];
      }
    };
    Unit.prototype = Object.assign(new Node(), {
      type: "Unit",
      clone: function() {
        return new Unit(copyArray(this.numerator), copyArray(this.denominator), this.backupUnit);
      },
      genCSS: function(context, output) {
        var strictUnits = context && context.strictUnits;
        if (this.numerator.length === 1) {
          output.add(this.numerator[0]);
        } else if (!strictUnits && this.backupUnit) {
          output.add(this.backupUnit);
        } else if (!strictUnits && this.denominator.length) {
          output.add(this.denominator[0]);
        }
      },
      toString: function() {
        var i2, returnStr = this.numerator.join("*");
        for (i2 = 0; i2 < this.denominator.length; i2++) {
          returnStr += "/" + this.denominator[i2];
        }
        return returnStr;
      },
      compare: function(other) {
        return this.is(other.toString()) ? 0 : void 0;
      },
      is: function(unitString) {
        return this.toString().toUpperCase() === unitString.toUpperCase();
      },
      isLength: function() {
        return RegExp("^(px|em|ex|ch|rem|in|cm|mm|pc|pt|ex|vw|vh|vmin|vmax)$", "gi").test(this.toCSS());
      },
      isEmpty: function() {
        return this.numerator.length === 0 && this.denominator.length === 0;
      },
      isSingular: function() {
        return this.numerator.length <= 1 && this.denominator.length === 0;
      },
      map: function(callback) {
        var i2;
        for (i2 = 0; i2 < this.numerator.length; i2++) {
          this.numerator[i2] = callback(this.numerator[i2], false);
        }
        for (i2 = 0; i2 < this.denominator.length; i2++) {
          this.denominator[i2] = callback(this.denominator[i2], true);
        }
      },
      usedUnits: function() {
        var group;
        var result = {};
        var mapUnit;
        var groupName;
        mapUnit = function(atomicUnit) {
          if (group.hasOwnProperty(atomicUnit) && !result[groupName]) {
            result[groupName] = atomicUnit;
          }
          return atomicUnit;
        };
        for (groupName in unitConversions) {
          if (unitConversions.hasOwnProperty(groupName)) {
            group = unitConversions[groupName];
            this.map(mapUnit);
          }
        }
        return result;
      },
      cancel: function() {
        var counter = {};
        var atomicUnit;
        var i2;
        for (i2 = 0; i2 < this.numerator.length; i2++) {
          atomicUnit = this.numerator[i2];
          counter[atomicUnit] = (counter[atomicUnit] || 0) + 1;
        }
        for (i2 = 0; i2 < this.denominator.length; i2++) {
          atomicUnit = this.denominator[i2];
          counter[atomicUnit] = (counter[atomicUnit] || 0) - 1;
        }
        this.numerator = [];
        this.denominator = [];
        for (atomicUnit in counter) {
          if (counter.hasOwnProperty(atomicUnit)) {
            var count = counter[atomicUnit];
            if (count > 0) {
              for (i2 = 0; i2 < count; i2++) {
                this.numerator.push(atomicUnit);
              }
            } else if (count < 0) {
              for (i2 = 0; i2 < -count; i2++) {
                this.denominator.push(atomicUnit);
              }
            }
          }
        }
        this.numerator.sort();
        this.denominator.sort();
      }
    });
    var Dimension = function(value, unit) {
      this.value = parseFloat(value);
      if (isNaN(this.value)) {
        throw new Error("Dimension is not a number.");
      }
      this.unit = unit && unit instanceof Unit ? unit : new Unit(unit ? [unit] : void 0);
      this.setParent(this.unit, this);
    };
    Dimension.prototype = Object.assign(new Node(), {
      type: "Dimension",
      accept: function(visitor) {
        this.unit = visitor.visit(this.unit);
      },
      eval: function(context) {
        return this;
      },
      toColor: function() {
        return new Color([this.value, this.value, this.value]);
      },
      genCSS: function(context, output) {
        if (context && context.strictUnits && !this.unit.isSingular()) {
          throw new Error("Multiple units in dimension. Correct the units or use the unit function. Bad unit: " + this.unit.toString());
        }
        var value = this.fround(context, this.value);
        var strValue = String(value);
        if (value !== 0 && value < 1e-6 && value > -1e-6) {
          strValue = value.toFixed(20).replace(/0+$/, "");
        }
        if (context && context.compress) {
          if (value === 0 && this.unit.isLength()) {
            output.add(strValue);
            return;
          }
          if (value > 0 && value < 1) {
            strValue = strValue.substr(1);
          }
        }
        output.add(strValue);
        this.unit.genCSS(context, output);
      },
      operate: function(context, op, other) {
        var value = this._operate(context, op, this.value, other.value);
        var unit = this.unit.clone();
        if (op === "+" || op === "-") {
          if (unit.numerator.length === 0 && unit.denominator.length === 0) {
            unit = other.unit.clone();
            if (this.unit.backupUnit) {
              unit.backupUnit = this.unit.backupUnit;
            }
          } else if (other.unit.numerator.length === 0 && unit.denominator.length === 0)
            ;
          else {
            other = other.convertTo(this.unit.usedUnits());
            if (context.strictUnits && other.unit.toString() !== unit.toString()) {
              throw new Error("Incompatible units. Change the units or use the unit function. " + ("Bad units: '" + unit.toString() + "' and '" + other.unit.toString() + "'."));
            }
            value = this._operate(context, op, this.value, other.value);
          }
        } else if (op === "*") {
          unit.numerator = unit.numerator.concat(other.unit.numerator).sort();
          unit.denominator = unit.denominator.concat(other.unit.denominator).sort();
          unit.cancel();
        } else if (op === "/") {
          unit.numerator = unit.numerator.concat(other.unit.denominator).sort();
          unit.denominator = unit.denominator.concat(other.unit.numerator).sort();
          unit.cancel();
        }
        return new Dimension(value, unit);
      },
      compare: function(other) {
        var a2, b2;
        if (!(other instanceof Dimension)) {
          return void 0;
        }
        if (this.unit.isEmpty() || other.unit.isEmpty()) {
          a2 = this;
          b2 = other;
        } else {
          a2 = this.unify();
          b2 = other.unify();
          if (a2.unit.compare(b2.unit) !== 0) {
            return void 0;
          }
        }
        return Node.numericCompare(a2.value, b2.value);
      },
      unify: function() {
        return this.convertTo({ length: "px", duration: "s", angle: "rad" });
      },
      convertTo: function(conversions) {
        var value = this.value;
        var unit = this.unit.clone();
        var i2;
        var groupName;
        var group;
        var targetUnit;
        var derivedConversions = {};
        var applyUnit;
        if (typeof conversions === "string") {
          for (i2 in unitConversions) {
            if (unitConversions[i2].hasOwnProperty(conversions)) {
              derivedConversions = {};
              derivedConversions[i2] = conversions;
            }
          }
          conversions = derivedConversions;
        }
        applyUnit = function(atomicUnit, denominator) {
          if (group.hasOwnProperty(atomicUnit)) {
            if (denominator) {
              value = value / (group[atomicUnit] / group[targetUnit]);
            } else {
              value = value * (group[atomicUnit] / group[targetUnit]);
            }
            return targetUnit;
          }
          return atomicUnit;
        };
        for (groupName in conversions) {
          if (conversions.hasOwnProperty(groupName)) {
            targetUnit = conversions[groupName];
            group = unitConversions[groupName];
            unit.map(applyUnit);
          }
        }
        unit.cancel();
        return new Dimension(value, unit);
      }
    });
    var MATH = Math$1;
    var Operation = function(op, operands, isSpaced) {
      this.op = op.trim();
      this.operands = operands;
      this.isSpaced = isSpaced;
    };
    Operation.prototype = Object.assign(new Node(), {
      type: "Operation",
      accept: function(visitor) {
        this.operands = visitor.visitArray(this.operands);
      },
      eval: function(context) {
        var a2 = this.operands[0].eval(context), b2 = this.operands[1].eval(context), op;
        if (context.isMathOn(this.op)) {
          op = this.op === "./" ? "/" : this.op;
          if (a2 instanceof Dimension && b2 instanceof Color) {
            a2 = a2.toColor();
          }
          if (b2 instanceof Dimension && a2 instanceof Color) {
            b2 = b2.toColor();
          }
          if (!a2.operate || !b2.operate) {
            if ((a2 instanceof Operation || b2 instanceof Operation) && a2.op === "/" && context.math === MATH.PARENS_DIVISION) {
              return new Operation(this.op, [a2, b2], this.isSpaced);
            }
            throw {
              type: "Operation",
              message: "Operation on an invalid type"
            };
          }
          return a2.operate(context, op, b2);
        } else {
          return new Operation(this.op, [a2, b2], this.isSpaced);
        }
      },
      genCSS: function(context, output) {
        this.operands[0].genCSS(context, output);
        if (this.isSpaced) {
          output.add(" ");
        }
        output.add(this.op);
        if (this.isSpaced) {
          output.add(" ");
        }
        this.operands[1].genCSS(context, output);
      }
    });
    /*! *****************************************************************************
    	    Copyright (c) Microsoft Corporation.
    
    	    Permission to use, copy, modify, and/or distribute this software for any
    	    purpose with or without fee is hereby granted.
    
    	    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    	    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    	    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    	    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    	    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    	    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    	    PERFORMANCE OF THIS SOFTWARE.
    	    ***************************************************************************** */
    function __spreadArray2(to, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i2);
            ar[i2] = from2[i2];
          }
        }
      return to.concat(ar || from2);
    }
    var Expression = function(value, noSpacing) {
      this.value = value;
      this.noSpacing = noSpacing;
      if (!value) {
        throw new Error("Expression requires an array parameter");
      }
    };
    Expression.prototype = Object.assign(new Node(), {
      type: "Expression",
      accept: function(visitor) {
        this.value = visitor.visitArray(this.value);
      },
      eval: function(context) {
        var returnValue;
        var mathOn = context.isMathOn();
        var inParenthesis = this.parens;
        var doubleParen = false;
        if (inParenthesis) {
          context.inParenthesis();
        }
        if (this.value.length > 1) {
          returnValue = new Expression(this.value.map(function(e2) {
            if (!e2.eval) {
              return e2;
            }
            return e2.eval(context);
          }), this.noSpacing);
        } else if (this.value.length === 1) {
          if (this.value[0].parens && !this.value[0].parensInOp && !context.inCalc) {
            doubleParen = true;
          }
          returnValue = this.value[0].eval(context);
        } else {
          returnValue = this;
        }
        if (inParenthesis) {
          context.outOfParenthesis();
        }
        if (this.parens && this.parensInOp && !mathOn && !doubleParen && !(returnValue instanceof Dimension)) {
          returnValue = new Paren(returnValue);
        }
        return returnValue;
      },
      genCSS: function(context, output) {
        for (var i2 = 0; i2 < this.value.length; i2++) {
          this.value[i2].genCSS(context, output);
          if (!this.noSpacing && i2 + 1 < this.value.length) {
            output.add(" ");
          }
        }
      },
      throwAwayComments: function() {
        this.value = this.value.filter(function(v2) {
          return !(v2 instanceof Comment);
        });
      }
    });
    var functionCaller = function() {
      function functionCaller2(name2, context, index2, currentFileInfo) {
        this.name = name2.toLowerCase();
        this.index = index2;
        this.context = context;
        this.currentFileInfo = currentFileInfo;
        this.func = context.frames[0].functionRegistry.get(this.name);
      }
      functionCaller2.prototype.isValid = function() {
        return Boolean(this.func);
      };
      functionCaller2.prototype.call = function(args) {
        var _this = this;
        if (!Array.isArray(args)) {
          args = [args];
        }
        var evalArgs = this.func.evalArgs;
        if (evalArgs !== false) {
          args = args.map(function(a2) {
            return a2.eval(_this.context);
          });
        }
        var commentFilter = function(item) {
          return !(item.type === "Comment");
        };
        args = args.filter(commentFilter).map(function(item) {
          if (item.type === "Expression") {
            var subNodes = item.value.filter(commentFilter);
            if (subNodes.length === 1) {
              if (item.parens && subNodes[0].op === "/") {
                return item;
              }
              return subNodes[0];
            } else {
              return new Expression(subNodes);
            }
          }
          return item;
        });
        if (evalArgs === false) {
          return this.func.apply(this, __spreadArray2([this.context], args));
        }
        return this.func.apply(this, args);
      };
      return functionCaller2;
    }();
    var Call = function(name2, args, index2, currentFileInfo) {
      this.name = name2;
      this.args = args;
      this.calc = name2 === "calc";
      this._index = index2;
      this._fileInfo = currentFileInfo;
    };
    Call.prototype = Object.assign(new Node(), {
      type: "Call",
      accept: function(visitor) {
        if (this.args) {
          this.args = visitor.visitArray(this.args);
        }
      },
      eval: function(context) {
        var _this = this;
        var currentMathContext = context.mathOn;
        context.mathOn = !this.calc;
        if (this.calc || context.inCalc) {
          context.enterCalc();
        }
        var exitCalc = function() {
          if (_this.calc || context.inCalc) {
            context.exitCalc();
          }
          context.mathOn = currentMathContext;
        };
        var result;
        var funcCaller = new functionCaller(this.name, context, this.getIndex(), this.fileInfo());
        if (funcCaller.isValid()) {
          try {
            result = funcCaller.call(this.args);
            exitCalc();
          } catch (e2) {
            if (e2.hasOwnProperty("line") && e2.hasOwnProperty("column")) {
              throw e2;
            }
            throw {
              type: e2.type || "Runtime",
              message: "Error evaluating function `" + this.name + "`" + (e2.message ? ": " + e2.message : ""),
              index: this.getIndex(),
              filename: this.fileInfo().filename,
              line: e2.lineNumber,
              column: e2.columnNumber
            };
          }
        }
        if (result !== null && result !== void 0) {
          if (!(result instanceof Node)) {
            if (!result || result === true) {
              result = new Anonymous(null);
            } else {
              result = new Anonymous(result.toString());
            }
          }
          result._index = this._index;
          result._fileInfo = this._fileInfo;
          return result;
        }
        var args = this.args.map(function(a2) {
          return a2.eval(context);
        });
        exitCalc();
        return new Call(this.name, args, this.getIndex(), this.fileInfo());
      },
      genCSS: function(context, output) {
        output.add(this.name + "(", this.fileInfo(), this.getIndex());
        for (var i2 = 0; i2 < this.args.length; i2++) {
          this.args[i2].genCSS(context, output);
          if (i2 + 1 < this.args.length) {
            output.add(", ");
          }
        }
        output.add(")");
      }
    });
    var Variable = function(name2, index2, currentFileInfo) {
      this.name = name2;
      this._index = index2;
      this._fileInfo = currentFileInfo;
    };
    Variable.prototype = Object.assign(new Node(), {
      type: "Variable",
      eval: function(context) {
        var variable, name2 = this.name;
        if (name2.indexOf("@@") === 0) {
          name2 = "@" + new Variable(name2.slice(1), this.getIndex(), this.fileInfo()).eval(context).value;
        }
        if (this.evaluating) {
          throw {
            type: "Name",
            message: "Recursive variable definition for " + name2,
            filename: this.fileInfo().filename,
            index: this.getIndex()
          };
        }
        this.evaluating = true;
        variable = this.find(context.frames, function(frame) {
          var v2 = frame.variable(name2);
          if (v2) {
            if (v2.important) {
              var importantScope = context.importantScope[context.importantScope.length - 1];
              importantScope.important = v2.important;
            }
            if (context.inCalc) {
              return new Call("_SELF", [v2.value]).eval(context);
            } else {
              return v2.value.eval(context);
            }
          }
        });
        if (variable) {
          this.evaluating = false;
          return variable;
        } else {
          throw {
            type: "Name",
            message: "variable " + name2 + " is undefined",
            filename: this.fileInfo().filename,
            index: this.getIndex()
          };
        }
      },
      find: function(obj, fun) {
        for (var i2 = 0, r2 = void 0; i2 < obj.length; i2++) {
          r2 = fun.call(obj, obj[i2]);
          if (r2) {
            return r2;
          }
        }
        return null;
      }
    });
    var Property = function(name2, index2, currentFileInfo) {
      this.name = name2;
      this._index = index2;
      this._fileInfo = currentFileInfo;
    };
    Property.prototype = Object.assign(new Node(), {
      type: "Property",
      eval: function(context) {
        var property;
        var name2 = this.name;
        var mergeRules = context.pluginManager.less.visitors.ToCSSVisitor.prototype._mergeRules;
        if (this.evaluating) {
          throw {
            type: "Name",
            message: "Recursive property reference for " + name2,
            filename: this.fileInfo().filename,
            index: this.getIndex()
          };
        }
        this.evaluating = true;
        property = this.find(context.frames, function(frame) {
          var v2;
          var vArr = frame.property(name2);
          if (vArr) {
            for (var i2 = 0; i2 < vArr.length; i2++) {
              v2 = vArr[i2];
              vArr[i2] = new Declaration(v2.name, v2.value, v2.important, v2.merge, v2.index, v2.currentFileInfo, v2.inline, v2.variable);
            }
            mergeRules(vArr);
            v2 = vArr[vArr.length - 1];
            if (v2.important) {
              var importantScope = context.importantScope[context.importantScope.length - 1];
              importantScope.important = v2.important;
            }
            v2 = v2.value.eval(context);
            return v2;
          }
        });
        if (property) {
          this.evaluating = false;
          return property;
        } else {
          throw {
            type: "Name",
            message: "Property '" + name2 + "' is undefined",
            filename: this.currentFileInfo.filename,
            index: this.index
          };
        }
      },
      find: function(obj, fun) {
        for (var i2 = 0, r2 = void 0; i2 < obj.length; i2++) {
          r2 = fun.call(obj, obj[i2]);
          if (r2) {
            return r2;
          }
        }
        return null;
      }
    });
    var Attribute = function(key2, op, value, cif) {
      this.key = key2;
      this.op = op;
      this.value = value;
      this.cif = cif;
    };
    Attribute.prototype = Object.assign(new Node(), {
      type: "Attribute",
      eval: function(context) {
        return new Attribute(this.key.eval ? this.key.eval(context) : this.key, this.op, this.value && this.value.eval ? this.value.eval(context) : this.value, this.cif);
      },
      genCSS: function(context, output) {
        output.add(this.toCSS(context));
      },
      toCSS: function(context) {
        var value = this.key.toCSS ? this.key.toCSS(context) : this.key;
        if (this.op) {
          value += this.op;
          value += this.value.toCSS ? this.value.toCSS(context) : this.value;
        }
        if (this.cif) {
          value = value + " " + this.cif;
        }
        return "[" + value + "]";
      }
    });
    var Quoted = function(str, content, escaped, index2, currentFileInfo) {
      this.escaped = escaped == null ? true : escaped;
      this.value = content || "";
      this.quote = str.charAt(0);
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.variableRegex = /@\{([\w-]+)\}/g;
      this.propRegex = /\$\{([\w-]+)\}/g;
      this.allowRoot = escaped;
    };
    Quoted.prototype = Object.assign(new Node(), {
      type: "Quoted",
      genCSS: function(context, output) {
        if (!this.escaped) {
          output.add(this.quote, this.fileInfo(), this.getIndex());
        }
        output.add(this.value);
        if (!this.escaped) {
          output.add(this.quote);
        }
      },
      containsVariables: function() {
        return this.value.match(this.variableRegex);
      },
      eval: function(context) {
        var that = this;
        var value = this.value;
        var variableReplacement = function(_2, name2) {
          var v2 = new Variable("@" + name2, that.getIndex(), that.fileInfo()).eval(context, true);
          return v2 instanceof Quoted ? v2.value : v2.toCSS();
        };
        var propertyReplacement = function(_2, name2) {
          var v2 = new Property("$" + name2, that.getIndex(), that.fileInfo()).eval(context, true);
          return v2 instanceof Quoted ? v2.value : v2.toCSS();
        };
        function iterativeReplace(value2, regexp4, replacementFnc) {
          var evaluatedValue = value2;
          do {
            value2 = evaluatedValue.toString();
            evaluatedValue = value2.replace(regexp4, replacementFnc);
          } while (value2 !== evaluatedValue);
          return evaluatedValue;
        }
        value = iterativeReplace(value, this.variableRegex, variableReplacement);
        value = iterativeReplace(value, this.propRegex, propertyReplacement);
        return new Quoted(this.quote + value + this.quote, value, this.escaped, this.getIndex(), this.fileInfo());
      },
      compare: function(other) {
        if (other.type === "Quoted" && !this.escaped && !other.escaped) {
          return Node.numericCompare(this.value, other.value);
        } else {
          return other.toCSS && this.toCSS() === other.toCSS() ? 0 : void 0;
        }
      }
    });
    function escapePath(path2) {
      return path2.replace(/[\(\)'"\s]/g, function(match) {
        return "\\" + match;
      });
    }
    var URL2 = function(val, index2, currentFileInfo, isEvald) {
      this.value = val;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.isEvald = isEvald;
    };
    URL2.prototype = Object.assign(new Node(), {
      type: "Url",
      accept: function(visitor) {
        this.value = visitor.visit(this.value);
      },
      genCSS: function(context, output) {
        output.add("url(");
        this.value.genCSS(context, output);
        output.add(")");
      },
      eval: function(context) {
        var val = this.value.eval(context);
        var rootpath;
        if (!this.isEvald) {
          rootpath = this.fileInfo() && this.fileInfo().rootpath;
          if (typeof rootpath === "string" && typeof val.value === "string" && context.pathRequiresRewrite(val.value)) {
            if (!val.quote) {
              rootpath = escapePath(rootpath);
            }
            val.value = context.rewritePath(val.value, rootpath);
          } else {
            val.value = context.normalizePath(val.value);
          }
          if (context.urlArgs) {
            if (!val.value.match(/^\s*data:/)) {
              var delimiter2 = val.value.indexOf("?") === -1 ? "?" : "&";
              var urlArgs = delimiter2 + context.urlArgs;
              if (val.value.indexOf("#") !== -1) {
                val.value = val.value.replace("#", urlArgs + "#");
              } else {
                val.value += urlArgs;
              }
            }
          }
        }
        return new URL2(val, this.getIndex(), this.fileInfo(), true);
      }
    });
    var Media = function(value, features, index2, currentFileInfo, visibilityInfo) {
      this._index = index2;
      this._fileInfo = currentFileInfo;
      var selectors = new Selector([], null, null, this._index, this._fileInfo).createEmptySelectors();
      this.features = new Value(features);
      this.rules = [new Ruleset(selectors, value)];
      this.rules[0].allowImports = true;
      this.copyVisibilityInfo(visibilityInfo);
      this.allowRoot = true;
      this.setParent(selectors, this);
      this.setParent(this.features, this);
      this.setParent(this.rules, this);
    };
    Media.prototype = Object.assign(new AtRule(), {
      type: "Media",
      isRulesetLike: function() {
        return true;
      },
      accept: function(visitor) {
        if (this.features) {
          this.features = visitor.visit(this.features);
        }
        if (this.rules) {
          this.rules = visitor.visitArray(this.rules);
        }
      },
      genCSS: function(context, output) {
        output.add("@media ", this._fileInfo, this._index);
        this.features.genCSS(context, output);
        this.outputRuleset(context, output, this.rules);
      },
      eval: function(context) {
        if (!context.mediaBlocks) {
          context.mediaBlocks = [];
          context.mediaPath = [];
        }
        var media = new Media(null, [], this._index, this._fileInfo, this.visibilityInfo());
        if (this.debugInfo) {
          this.rules[0].debugInfo = this.debugInfo;
          media.debugInfo = this.debugInfo;
        }
        media.features = this.features.eval(context);
        context.mediaPath.push(media);
        context.mediaBlocks.push(media);
        this.rules[0].functionRegistry = context.frames[0].functionRegistry.inherit();
        context.frames.unshift(this.rules[0]);
        media.rules = [this.rules[0].eval(context)];
        context.frames.shift();
        context.mediaPath.pop();
        return context.mediaPath.length === 0 ? media.evalTop(context) : media.evalNested(context);
      },
      evalTop: function(context) {
        var result = this;
        if (context.mediaBlocks.length > 1) {
          var selectors = new Selector([], null, null, this.getIndex(), this.fileInfo()).createEmptySelectors();
          result = new Ruleset(selectors, context.mediaBlocks);
          result.multiMedia = true;
          result.copyVisibilityInfo(this.visibilityInfo());
          this.setParent(result, this);
        }
        delete context.mediaBlocks;
        delete context.mediaPath;
        return result;
      },
      evalNested: function(context) {
        var i2;
        var value;
        var path2 = context.mediaPath.concat([this]);
        for (i2 = 0; i2 < path2.length; i2++) {
          value = path2[i2].features instanceof Value ? path2[i2].features.value : path2[i2].features;
          path2[i2] = Array.isArray(value) ? value : [value];
        }
        this.features = new Value(this.permute(path2).map(function(path3) {
          path3 = path3.map(function(fragment) {
            return fragment.toCSS ? fragment : new Anonymous(fragment);
          });
          for (i2 = path3.length - 1; i2 > 0; i2--) {
            path3.splice(i2, 0, new Anonymous("and"));
          }
          return new Expression(path3);
        }));
        this.setParent(this.features, this);
        return new Ruleset([], []);
      },
      permute: function(arr) {
        if (arr.length === 0) {
          return [];
        } else if (arr.length === 1) {
          return arr[0];
        } else {
          var result = [];
          var rest = this.permute(arr.slice(1));
          for (var i2 = 0; i2 < rest.length; i2++) {
            for (var j2 = 0; j2 < arr[0].length; j2++) {
              result.push([arr[0][j2]].concat(rest[i2]));
            }
          }
          return result;
        }
      },
      bubbleSelectors: function(selectors) {
        if (!selectors) {
          return;
        }
        this.rules = [new Ruleset(copyArray(selectors), [this.rules[0]])];
        this.setParent(this.rules, this);
      }
    });
    var Import = function(path2, features, options2, index2, currentFileInfo, visibilityInfo) {
      this.options = options2;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.path = path2;
      this.features = features;
      this.allowRoot = true;
      if (this.options.less !== void 0 || this.options.inline) {
        this.css = !this.options.less || this.options.inline;
      } else {
        var pathValue = this.getPath();
        if (pathValue && /[#\.\&\?]css([\?;].*)?$/.test(pathValue)) {
          this.css = true;
        }
      }
      this.copyVisibilityInfo(visibilityInfo);
      this.setParent(this.features, this);
      this.setParent(this.path, this);
    };
    Import.prototype = Object.assign(new Node(), {
      type: "Import",
      accept: function(visitor) {
        if (this.features) {
          this.features = visitor.visit(this.features);
        }
        this.path = visitor.visit(this.path);
        if (!this.options.isPlugin && !this.options.inline && this.root) {
          this.root = visitor.visit(this.root);
        }
      },
      genCSS: function(context, output) {
        if (this.css && this.path._fileInfo.reference === void 0) {
          output.add("@import ", this._fileInfo, this._index);
          this.path.genCSS(context, output);
          if (this.features) {
            output.add(" ");
            this.features.genCSS(context, output);
          }
          output.add(";");
        }
      },
      getPath: function() {
        return this.path instanceof URL2 ? this.path.value.value : this.path.value;
      },
      isVariableImport: function() {
        var path2 = this.path;
        if (path2 instanceof URL2) {
          path2 = path2.value;
        }
        if (path2 instanceof Quoted) {
          return path2.containsVariables();
        }
        return true;
      },
      evalForImport: function(context) {
        var path2 = this.path;
        if (path2 instanceof URL2) {
          path2 = path2.value;
        }
        return new Import(path2.eval(context), this.features, this.options, this._index, this._fileInfo, this.visibilityInfo());
      },
      evalPath: function(context) {
        var path2 = this.path.eval(context);
        var fileInfo = this._fileInfo;
        if (!(path2 instanceof URL2)) {
          var pathValue = path2.value;
          if (fileInfo && pathValue && context.pathRequiresRewrite(pathValue)) {
            path2.value = context.rewritePath(pathValue, fileInfo.rootpath);
          } else {
            path2.value = context.normalizePath(path2.value);
          }
        }
        return path2;
      },
      eval: function(context) {
        var result = this.doEval(context);
        if (this.options.reference || this.blocksVisibility()) {
          if (result.length || result.length === 0) {
            result.forEach(function(node2) {
              node2.addVisibilityBlock();
            });
          } else {
            result.addVisibilityBlock();
          }
        }
        return result;
      },
      doEval: function(context) {
        var ruleset2;
        var registry;
        var features = this.features && this.features.eval(context);
        if (this.options.isPlugin) {
          if (this.root && this.root.eval) {
            try {
              this.root.eval(context);
            } catch (e2) {
              e2.message = "Plugin error during evaluation";
              throw new LessError(e2, this.root.imports, this.root.filename);
            }
          }
          registry = context.frames[0] && context.frames[0].functionRegistry;
          if (registry && this.root && this.root.functions) {
            registry.addMultiple(this.root.functions);
          }
          return [];
        }
        if (this.skip) {
          if (typeof this.skip === "function") {
            this.skip = this.skip();
          }
          if (this.skip) {
            return [];
          }
        }
        if (this.options.inline) {
          var contents = new Anonymous(this.root, 0, {
            filename: this.importedFilename,
            reference: this.path._fileInfo && this.path._fileInfo.reference
          }, true, true);
          return this.features ? new Media([contents], this.features.value) : [contents];
        } else if (this.css) {
          var newImport = new Import(this.evalPath(context), features, this.options, this._index);
          if (!newImport.css && this.error) {
            throw this.error;
          }
          return newImport;
        } else if (this.root) {
          ruleset2 = new Ruleset(null, copyArray(this.root.rules));
          ruleset2.evalImports(context);
          return this.features ? new Media(ruleset2.rules, this.features.value) : ruleset2.rules;
        } else {
          return [];
        }
      }
    });
    var JsEvalNode = function() {
    };
    JsEvalNode.prototype = Object.assign(new Node(), {
      evaluateJavaScript: function(expression, context) {
        var result;
        var that = this;
        var evalContext = {};
        if (!context.javascriptEnabled) {
          throw {
            message: "Inline JavaScript is not enabled. Is it set in your options?",
            filename: this.fileInfo().filename,
            index: this.getIndex()
          };
        }
        expression = expression.replace(/@\{([\w-]+)\}/g, function(_2, name2) {
          return that.jsify(new Variable("@" + name2, that.getIndex(), that.fileInfo()).eval(context));
        });
        try {
          expression = new Function("return (" + expression + ")");
        } catch (e2) {
          throw {
            message: "JavaScript evaluation error: " + e2.message + " from `" + expression + "`",
            filename: this.fileInfo().filename,
            index: this.getIndex()
          };
        }
        var variables = context.frames[0].variables();
        for (var k2 in variables) {
          if (variables.hasOwnProperty(k2)) {
            evalContext[k2.slice(1)] = {
              value: variables[k2].value,
              toJS: function() {
                return this.value.eval(context).toCSS();
              }
            };
          }
        }
        try {
          result = expression.call(evalContext);
        } catch (e2) {
          throw {
            message: "JavaScript evaluation error: '" + e2.name + ": " + e2.message.replace(/["]/g, "'") + "'",
            filename: this.fileInfo().filename,
            index: this.getIndex()
          };
        }
        return result;
      },
      jsify: function(obj) {
        if (Array.isArray(obj.value) && obj.value.length > 1) {
          return "[" + obj.value.map(function(v2) {
            return v2.toCSS();
          }).join(", ") + "]";
        } else {
          return obj.toCSS();
        }
      }
    });
    var JavaScript = function(string4, escaped, index2, currentFileInfo) {
      this.escaped = escaped;
      this.expression = string4;
      this._index = index2;
      this._fileInfo = currentFileInfo;
    };
    JavaScript.prototype = Object.assign(new JsEvalNode(), {
      type: "JavaScript",
      eval: function(context) {
        var result = this.evaluateJavaScript(this.expression, context);
        var type4 = typeof result;
        if (type4 === "number" && !isNaN(result)) {
          return new Dimension(result);
        } else if (type4 === "string") {
          return new Quoted('"' + result + '"', result, this.escaped, this._index);
        } else if (Array.isArray(result)) {
          return new Anonymous(result.join(", "));
        } else {
          return new Anonymous(result);
        }
      }
    });
    var Assignment = function(key2, val) {
      this.key = key2;
      this.value = val;
    };
    Assignment.prototype = Object.assign(new Node(), {
      type: "Assignment",
      accept: function(visitor) {
        this.value = visitor.visit(this.value);
      },
      eval: function(context) {
        if (this.value.eval) {
          return new Assignment(this.key, this.value.eval(context));
        }
        return this;
      },
      genCSS: function(context, output) {
        output.add(this.key + "=");
        if (this.value.genCSS) {
          this.value.genCSS(context, output);
        } else {
          output.add(this.value);
        }
      }
    });
    var Condition = function(op, l2, r2, i2, negate) {
      this.op = op.trim();
      this.lvalue = l2;
      this.rvalue = r2;
      this._index = i2;
      this.negate = negate;
    };
    Condition.prototype = Object.assign(new Node(), {
      type: "Condition",
      accept: function(visitor) {
        this.lvalue = visitor.visit(this.lvalue);
        this.rvalue = visitor.visit(this.rvalue);
      },
      eval: function(context) {
        var result = function(op, a2, b2) {
          switch (op) {
            case "and":
              return a2 && b2;
            case "or":
              return a2 || b2;
            default:
              switch (Node.compare(a2, b2)) {
                case -1:
                  return op === "<" || op === "=<" || op === "<=";
                case 0:
                  return op === "=" || op === ">=" || op === "=<" || op === "<=";
                case 1:
                  return op === ">" || op === ">=";
                default:
                  return false;
              }
          }
        }(this.op, this.lvalue.eval(context), this.rvalue.eval(context));
        return this.negate ? !result : result;
      }
    });
    var UnicodeDescriptor = function(value) {
      this.value = value;
    };
    UnicodeDescriptor.prototype = Object.assign(new Node(), {
      type: "UnicodeDescriptor"
    });
    var Negative = function(node2) {
      this.value = node2;
    };
    Negative.prototype = Object.assign(new Node(), {
      type: "Negative",
      genCSS: function(context, output) {
        output.add("-");
        this.value.genCSS(context, output);
      },
      eval: function(context) {
        if (context.isMathOn()) {
          return new Operation("*", [new Dimension(-1), this.value]).eval(context);
        }
        return new Negative(this.value.eval(context));
      }
    });
    var Extend = function(selector, option, index2, currentFileInfo, visibilityInfo) {
      this.selector = selector;
      this.option = option;
      this.object_id = Extend.next_id++;
      this.parent_ids = [this.object_id];
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.copyVisibilityInfo(visibilityInfo);
      this.allowRoot = true;
      switch (option) {
        case "all":
          this.allowBefore = true;
          this.allowAfter = true;
          break;
        default:
          this.allowBefore = false;
          this.allowAfter = false;
          break;
      }
      this.setParent(this.selector, this);
    };
    Extend.prototype = Object.assign(new Node(), {
      type: "Extend",
      accept: function(visitor) {
        this.selector = visitor.visit(this.selector);
      },
      eval: function(context) {
        return new Extend(this.selector.eval(context), this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      },
      clone: function(context) {
        return new Extend(this.selector, this.option, this.getIndex(), this.fileInfo(), this.visibilityInfo());
      },
      findSelfSelectors: function(selectors) {
        var selfElements = [], i2, selectorElements;
        for (i2 = 0; i2 < selectors.length; i2++) {
          selectorElements = selectors[i2].elements;
          if (i2 > 0 && selectorElements.length && selectorElements[0].combinator.value === "") {
            selectorElements[0].combinator.value = " ";
          }
          selfElements = selfElements.concat(selectors[i2].elements);
        }
        this.selfSelectors = [new Selector(selfElements)];
        this.selfSelectors[0].copyVisibilityInfo(this.visibilityInfo());
      }
    });
    Extend.next_id = 0;
    var VariableCall = function(variable, index2, currentFileInfo) {
      this.variable = variable;
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.allowRoot = true;
    };
    VariableCall.prototype = Object.assign(new Node(), {
      type: "VariableCall",
      eval: function(context) {
        var rules2;
        var detachedRuleset = new Variable(this.variable, this.getIndex(), this.fileInfo()).eval(context);
        var error = new LessError({ message: "Could not evaluate variable call " + this.variable });
        if (!detachedRuleset.ruleset) {
          if (detachedRuleset.rules) {
            rules2 = detachedRuleset;
          } else if (Array.isArray(detachedRuleset)) {
            rules2 = new Ruleset("", detachedRuleset);
          } else if (Array.isArray(detachedRuleset.value)) {
            rules2 = new Ruleset("", detachedRuleset.value);
          } else {
            throw error;
          }
          detachedRuleset = new DetachedRuleset(rules2);
        }
        if (detachedRuleset.ruleset) {
          return detachedRuleset.callEval(context);
        }
        throw error;
      }
    });
    var NamespaceValue = function(ruleCall, lookups, index2, fileInfo) {
      this.value = ruleCall;
      this.lookups = lookups;
      this._index = index2;
      this._fileInfo = fileInfo;
    };
    NamespaceValue.prototype = Object.assign(new Node(), {
      type: "NamespaceValue",
      eval: function(context) {
        var i2, name2, rules2 = this.value.eval(context);
        for (i2 = 0; i2 < this.lookups.length; i2++) {
          name2 = this.lookups[i2];
          if (Array.isArray(rules2)) {
            rules2 = new Ruleset([new Selector()], rules2);
          }
          if (name2 === "") {
            rules2 = rules2.lastDeclaration();
          } else if (name2.charAt(0) === "@") {
            if (name2.charAt(1) === "@") {
              name2 = "@" + new Variable(name2.substr(1)).eval(context).value;
            }
            if (rules2.variables) {
              rules2 = rules2.variable(name2);
            }
            if (!rules2) {
              throw {
                type: "Name",
                message: "variable " + name2 + " not found",
                filename: this.fileInfo().filename,
                index: this.getIndex()
              };
            }
          } else {
            if (name2.substring(0, 2) === "$@") {
              name2 = "$" + new Variable(name2.substr(1)).eval(context).value;
            } else {
              name2 = name2.charAt(0) === "$" ? name2 : "$" + name2;
            }
            if (rules2.properties) {
              rules2 = rules2.property(name2);
            }
            if (!rules2) {
              throw {
                type: "Name",
                message: 'property "' + name2.substr(1) + '" not found',
                filename: this.fileInfo().filename,
                index: this.getIndex()
              };
            }
            rules2 = rules2[rules2.length - 1];
          }
          if (rules2.value) {
            rules2 = rules2.eval(context).value;
          }
          if (rules2.ruleset) {
            rules2 = rules2.ruleset.eval(context);
          }
        }
        return rules2;
      }
    });
    var Definition = function(name2, params, rules2, condition, variadic, frames, visibilityInfo) {
      this.name = name2 || "anonymous mixin";
      this.selectors = [new Selector([new Element2(null, name2, false, this._index, this._fileInfo)])];
      this.params = params;
      this.condition = condition;
      this.variadic = variadic;
      this.arity = params.length;
      this.rules = rules2;
      this._lookups = {};
      var optionalParameters = [];
      this.required = params.reduce(function(count, p2) {
        if (!p2.name || p2.name && !p2.value) {
          return count + 1;
        } else {
          optionalParameters.push(p2.name);
          return count;
        }
      }, 0);
      this.optionalParameters = optionalParameters;
      this.frames = frames;
      this.copyVisibilityInfo(visibilityInfo);
      this.allowRoot = true;
    };
    Definition.prototype = Object.assign(new Ruleset(), {
      type: "MixinDefinition",
      evalFirst: true,
      accept: function(visitor) {
        if (this.params && this.params.length) {
          this.params = visitor.visitArray(this.params);
        }
        this.rules = visitor.visitArray(this.rules);
        if (this.condition) {
          this.condition = visitor.visit(this.condition);
        }
      },
      evalParams: function(context, mixinEnv, args, evaldArguments) {
        var frame = new Ruleset(null, null);
        var varargs;
        var arg;
        var params = copyArray(this.params);
        var i2;
        var j2;
        var val;
        var name2;
        var isNamedFound;
        var argIndex;
        var argsLength = 0;
        if (mixinEnv.frames && mixinEnv.frames[0] && mixinEnv.frames[0].functionRegistry) {
          frame.functionRegistry = mixinEnv.frames[0].functionRegistry.inherit();
        }
        mixinEnv = new contexts.Eval(mixinEnv, [frame].concat(mixinEnv.frames));
        if (args) {
          args = copyArray(args);
          argsLength = args.length;
          for (i2 = 0; i2 < argsLength; i2++) {
            arg = args[i2];
            if (name2 = arg && arg.name) {
              isNamedFound = false;
              for (j2 = 0; j2 < params.length; j2++) {
                if (!evaldArguments[j2] && name2 === params[j2].name) {
                  evaldArguments[j2] = arg.value.eval(context);
                  frame.prependRule(new Declaration(name2, arg.value.eval(context)));
                  isNamedFound = true;
                  break;
                }
              }
              if (isNamedFound) {
                args.splice(i2, 1);
                i2--;
                continue;
              } else {
                throw { type: "Runtime", message: "Named argument for " + this.name + " " + args[i2].name + " not found" };
              }
            }
          }
        }
        argIndex = 0;
        for (i2 = 0; i2 < params.length; i2++) {
          if (evaldArguments[i2]) {
            continue;
          }
          arg = args && args[argIndex];
          if (name2 = params[i2].name) {
            if (params[i2].variadic) {
              varargs = [];
              for (j2 = argIndex; j2 < argsLength; j2++) {
                varargs.push(args[j2].value.eval(context));
              }
              frame.prependRule(new Declaration(name2, new Expression(varargs).eval(context)));
            } else {
              val = arg && arg.value;
              if (val) {
                if (Array.isArray(val)) {
                  val = new DetachedRuleset(new Ruleset("", val));
                } else {
                  val = val.eval(context);
                }
              } else if (params[i2].value) {
                val = params[i2].value.eval(mixinEnv);
                frame.resetCache();
              } else {
                throw { type: "Runtime", message: "wrong number of arguments for " + this.name + " (" + argsLength + " for " + this.arity + ")" };
              }
              frame.prependRule(new Declaration(name2, val));
              evaldArguments[i2] = val;
            }
          }
          if (params[i2].variadic && args) {
            for (j2 = argIndex; j2 < argsLength; j2++) {
              evaldArguments[j2] = args[j2].value.eval(context);
            }
          }
          argIndex++;
        }
        return frame;
      },
      makeImportant: function() {
        var rules2 = !this.rules ? this.rules : this.rules.map(function(r2) {
          if (r2.makeImportant) {
            return r2.makeImportant(true);
          } else {
            return r2;
          }
        });
        var result = new Definition(this.name, this.params, rules2, this.condition, this.variadic, this.frames);
        return result;
      },
      eval: function(context) {
        return new Definition(this.name, this.params, this.rules, this.condition, this.variadic, this.frames || copyArray(context.frames));
      },
      evalCall: function(context, args, important) {
        var _arguments = [];
        var mixinFrames = this.frames ? this.frames.concat(context.frames) : context.frames;
        var frame = this.evalParams(context, new contexts.Eval(context, mixinFrames), args, _arguments);
        var rules2;
        var ruleset2;
        frame.prependRule(new Declaration("@arguments", new Expression(_arguments).eval(context)));
        rules2 = copyArray(this.rules);
        ruleset2 = new Ruleset(null, rules2);
        ruleset2.originalRuleset = this;
        ruleset2 = ruleset2.eval(new contexts.Eval(context, [this, frame].concat(mixinFrames)));
        if (important) {
          ruleset2 = ruleset2.makeImportant();
        }
        return ruleset2;
      },
      matchCondition: function(args, context) {
        if (this.condition && !this.condition.eval(new contexts.Eval(context, [this.evalParams(context, new contexts.Eval(context, this.frames ? this.frames.concat(context.frames) : context.frames), args, [])].concat(this.frames || []).concat(context.frames)))) {
          return false;
        }
        return true;
      },
      matchArgs: function(args, context) {
        var allArgsCnt = args && args.length || 0;
        var len;
        var optionalParameters = this.optionalParameters;
        var requiredArgsCnt = !args ? 0 : args.reduce(function(count, p2) {
          if (optionalParameters.indexOf(p2.name) < 0) {
            return count + 1;
          } else {
            return count;
          }
        }, 0);
        if (!this.variadic) {
          if (requiredArgsCnt < this.required) {
            return false;
          }
          if (allArgsCnt > this.params.length) {
            return false;
          }
        } else {
          if (requiredArgsCnt < this.required - 1) {
            return false;
          }
        }
        len = Math.min(requiredArgsCnt, this.arity);
        for (var i2 = 0; i2 < len; i2++) {
          if (!this.params[i2].name && !this.params[i2].variadic) {
            if (args[i2].value.eval(context).toCSS() != this.params[i2].value.eval(context).toCSS()) {
              return false;
            }
          }
        }
        return true;
      }
    });
    var MixinCall = function(elements, args, index2, currentFileInfo, important) {
      this.selector = new Selector(elements);
      this.arguments = args || [];
      this._index = index2;
      this._fileInfo = currentFileInfo;
      this.important = important;
      this.allowRoot = true;
      this.setParent(this.selector, this);
    };
    MixinCall.prototype = Object.assign(new Node(), {
      type: "MixinCall",
      accept: function(visitor) {
        if (this.selector) {
          this.selector = visitor.visit(this.selector);
        }
        if (this.arguments.length) {
          this.arguments = visitor.visitArray(this.arguments);
        }
      },
      eval: function(context) {
        var mixins;
        var mixin;
        var mixinPath;
        var args = [];
        var arg;
        var argValue;
        var rules2 = [];
        var match = false;
        var i2;
        var m2;
        var f3;
        var isRecursive;
        var isOneFound;
        var candidates = [];
        var candidate;
        var conditionResult = [];
        var defaultResult;
        var defFalseEitherCase = -1;
        var defNone = 0;
        var defTrue = 1;
        var defFalse = 2;
        var count;
        var originalRuleset;
        var noArgumentsFilter;
        this.selector = this.selector.eval(context);
        function calcDefGroup(mixin2, mixinPath2) {
          var f4, p2, namespace;
          for (f4 = 0; f4 < 2; f4++) {
            conditionResult[f4] = true;
            defaultFunc.value(f4);
            for (p2 = 0; p2 < mixinPath2.length && conditionResult[f4]; p2++) {
              namespace = mixinPath2[p2];
              if (namespace.matchCondition) {
                conditionResult[f4] = conditionResult[f4] && namespace.matchCondition(null, context);
              }
            }
            if (mixin2.matchCondition) {
              conditionResult[f4] = conditionResult[f4] && mixin2.matchCondition(args, context);
            }
          }
          if (conditionResult[0] || conditionResult[1]) {
            if (conditionResult[0] != conditionResult[1]) {
              return conditionResult[1] ? defTrue : defFalse;
            }
            return defNone;
          }
          return defFalseEitherCase;
        }
        for (i2 = 0; i2 < this.arguments.length; i2++) {
          arg = this.arguments[i2];
          argValue = arg.value.eval(context);
          if (arg.expand && Array.isArray(argValue.value)) {
            argValue = argValue.value;
            for (m2 = 0; m2 < argValue.length; m2++) {
              args.push({ value: argValue[m2] });
            }
          } else {
            args.push({ name: arg.name, value: argValue });
          }
        }
        noArgumentsFilter = function(rule) {
          return rule.matchArgs(null, context);
        };
        for (i2 = 0; i2 < context.frames.length; i2++) {
          if ((mixins = context.frames[i2].find(this.selector, null, noArgumentsFilter)).length > 0) {
            isOneFound = true;
            for (m2 = 0; m2 < mixins.length; m2++) {
              mixin = mixins[m2].rule;
              mixinPath = mixins[m2].path;
              isRecursive = false;
              for (f3 = 0; f3 < context.frames.length; f3++) {
                if (!(mixin instanceof Definition) && mixin === (context.frames[f3].originalRuleset || context.frames[f3])) {
                  isRecursive = true;
                  break;
                }
              }
              if (isRecursive) {
                continue;
              }
              if (mixin.matchArgs(args, context)) {
                candidate = { mixin, group: calcDefGroup(mixin, mixinPath) };
                if (candidate.group !== defFalseEitherCase) {
                  candidates.push(candidate);
                }
                match = true;
              }
            }
            defaultFunc.reset();
            count = [0, 0, 0];
            for (m2 = 0; m2 < candidates.length; m2++) {
              count[candidates[m2].group]++;
            }
            if (count[defNone] > 0) {
              defaultResult = defFalse;
            } else {
              defaultResult = defTrue;
              if (count[defTrue] + count[defFalse] > 1) {
                throw {
                  type: "Runtime",
                  message: "Ambiguous use of `default()` found when matching for `" + this.format(args) + "`",
                  index: this.getIndex(),
                  filename: this.fileInfo().filename
                };
              }
            }
            for (m2 = 0; m2 < candidates.length; m2++) {
              candidate = candidates[m2].group;
              if (candidate === defNone || candidate === defaultResult) {
                try {
                  mixin = candidates[m2].mixin;
                  if (!(mixin instanceof Definition)) {
                    originalRuleset = mixin.originalRuleset || mixin;
                    mixin = new Definition("", [], mixin.rules, null, false, null, originalRuleset.visibilityInfo());
                    mixin.originalRuleset = originalRuleset;
                  }
                  var newRules = mixin.evalCall(context, args, this.important).rules;
                  this._setVisibilityToReplacement(newRules);
                  Array.prototype.push.apply(rules2, newRules);
                } catch (e2) {
                  throw { message: e2.message, index: this.getIndex(), filename: this.fileInfo().filename, stack: e2.stack };
                }
              }
            }
            if (match) {
              return rules2;
            }
          }
        }
        if (isOneFound) {
          throw {
            type: "Runtime",
            message: "No matching definition was found for `" + this.format(args) + "`",
            index: this.getIndex(),
            filename: this.fileInfo().filename
          };
        } else {
          throw {
            type: "Name",
            message: this.selector.toCSS().trim() + " is undefined",
            index: this.getIndex(),
            filename: this.fileInfo().filename
          };
        }
      },
      _setVisibilityToReplacement: function(replacement) {
        var i2, rule;
        if (this.blocksVisibility()) {
          for (i2 = 0; i2 < replacement.length; i2++) {
            rule = replacement[i2];
            rule.addVisibilityBlock();
          }
        }
      },
      format: function(args) {
        return this.selector.toCSS().trim() + "(" + (args ? args.map(function(a2) {
          var argValue = "";
          if (a2.name) {
            argValue += a2.name + ":";
          }
          if (a2.value.toCSS) {
            argValue += a2.value.toCSS();
          } else {
            argValue += "???";
          }
          return argValue;
        }).join(", ") : "") + ")";
      }
    });
    var tree = {
      Node,
      Color,
      AtRule,
      DetachedRuleset,
      Operation,
      Dimension,
      Unit,
      Keyword,
      Variable,
      Property,
      Ruleset,
      Element: Element2,
      Attribute,
      Combinator,
      Selector,
      Quoted,
      Expression,
      Declaration,
      Call,
      URL: URL2,
      Import,
      Comment,
      Anonymous,
      Value,
      JavaScript,
      Assignment,
      Condition,
      Paren,
      Media,
      UnicodeDescriptor,
      Negative,
      Extend,
      VariableCall,
      NamespaceValue,
      mixin: {
        Call: MixinCall,
        Definition
      }
    };
    var AbstractFileManager = function() {
      function AbstractFileManager2() {
      }
      AbstractFileManager2.prototype.getPath = function(filename) {
        var j2 = filename.lastIndexOf("?");
        if (j2 > 0) {
          filename = filename.slice(0, j2);
        }
        j2 = filename.lastIndexOf("/");
        if (j2 < 0) {
          j2 = filename.lastIndexOf("\\");
        }
        if (j2 < 0) {
          return "";
        }
        return filename.slice(0, j2 + 1);
      };
      AbstractFileManager2.prototype.tryAppendExtension = function(path2, ext) {
        return /(\.[a-z]*$)|([\?;].*)$/.test(path2) ? path2 : path2 + ext;
      };
      AbstractFileManager2.prototype.tryAppendLessExtension = function(path2) {
        return this.tryAppendExtension(path2, ".less");
      };
      AbstractFileManager2.prototype.supportsSync = function() {
        return false;
      };
      AbstractFileManager2.prototype.alwaysMakePathsAbsolute = function() {
        return false;
      };
      AbstractFileManager2.prototype.isPathAbsolute = function(filename) {
        return /^(?:[a-z-]+:|\/|\\|#)/i.test(filename);
      };
      AbstractFileManager2.prototype.join = function(basePath, laterPath) {
        if (!basePath) {
          return laterPath;
        }
        return basePath + laterPath;
      };
      AbstractFileManager2.prototype.pathDiff = function(url2, baseUrl) {
        var urlParts = this.extractUrlParts(url2);
        var baseUrlParts = this.extractUrlParts(baseUrl);
        var i2;
        var max;
        var urlDirectories;
        var baseUrlDirectories;
        var diff = "";
        if (urlParts.hostPart !== baseUrlParts.hostPart) {
          return "";
        }
        max = Math.max(baseUrlParts.directories.length, urlParts.directories.length);
        for (i2 = 0; i2 < max; i2++) {
          if (baseUrlParts.directories[i2] !== urlParts.directories[i2]) {
            break;
          }
        }
        baseUrlDirectories = baseUrlParts.directories.slice(i2);
        urlDirectories = urlParts.directories.slice(i2);
        for (i2 = 0; i2 < baseUrlDirectories.length - 1; i2++) {
          diff += "../";
        }
        for (i2 = 0; i2 < urlDirectories.length - 1; i2++) {
          diff += urlDirectories[i2] + "/";
        }
        return diff;
      };
      AbstractFileManager2.prototype.extractUrlParts = function(url2, baseUrl) {
        var urlPartsRegex = /^((?:[a-z-]+:)?\/{2}(?:[^\/\?#]*\/)|([\/\\]))?((?:[^\/\\\?#]*[\/\\])*)([^\/\\\?#]*)([#\?].*)?$/i;
        var urlParts = url2.match(urlPartsRegex);
        var returner = {};
        var rawDirectories = [];
        var directories = [];
        var i2;
        var baseUrlParts;
        if (!urlParts) {
          throw new Error("Could not parse sheet href - '" + url2 + "'");
        }
        if (baseUrl && (!urlParts[1] || urlParts[2])) {
          baseUrlParts = baseUrl.match(urlPartsRegex);
          if (!baseUrlParts) {
            throw new Error("Could not parse page url - '" + baseUrl + "'");
          }
          urlParts[1] = urlParts[1] || baseUrlParts[1] || "";
          if (!urlParts[2]) {
            urlParts[3] = baseUrlParts[3] + urlParts[3];
          }
        }
        if (urlParts[3]) {
          rawDirectories = urlParts[3].replace(/\\/g, "/").split("/");
          for (i2 = 0; i2 < rawDirectories.length; i2++) {
            if (rawDirectories[i2] === "..") {
              directories.pop();
            } else if (rawDirectories[i2] !== ".") {
              directories.push(rawDirectories[i2]);
            }
          }
        }
        returner.hostPart = urlParts[1];
        returner.directories = directories;
        returner.rawPath = (urlParts[1] || "") + rawDirectories.join("/");
        returner.path = (urlParts[1] || "") + directories.join("/");
        returner.filename = urlParts[4];
        returner.fileUrl = returner.path + (urlParts[4] || "");
        returner.url = returner.fileUrl + (urlParts[5] || "");
        return returner;
      };
      return AbstractFileManager2;
    }();
    var AbstractPluginLoader = function() {
      function AbstractPluginLoader2() {
        this.require = function() {
          return null;
        };
      }
      AbstractPluginLoader2.prototype.evalPlugin = function(contents, context, imports, pluginOptions, fileInfo) {
        var loader, registry, pluginObj, localModule, pluginManager, filename, result;
        pluginManager = context.pluginManager;
        if (fileInfo) {
          if (typeof fileInfo === "string") {
            filename = fileInfo;
          } else {
            filename = fileInfo.filename;
          }
        }
        var shortname = new this.less.FileManager().extractUrlParts(filename).filename;
        if (filename) {
          pluginObj = pluginManager.get(filename);
          if (pluginObj) {
            result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
            if (result) {
              return result;
            }
            try {
              if (pluginObj.use) {
                pluginObj.use.call(this.context, pluginObj);
              }
            } catch (e2) {
              e2.message = e2.message || "Error during @plugin call";
              return new LessError(e2, imports, filename);
            }
            return pluginObj;
          }
        }
        localModule = {
          exports: {},
          pluginManager,
          fileInfo
        };
        registry = functionRegistry.create();
        var registerPlugin = function(obj) {
          pluginObj = obj;
        };
        try {
          loader = new Function("module", "require", "registerPlugin", "functions", "tree", "less", "fileInfo", contents);
          loader(localModule, this.require(filename), registerPlugin, registry, this.less.tree, this.less, fileInfo);
        } catch (e2) {
          return new LessError(e2, imports, filename);
        }
        if (!pluginObj) {
          pluginObj = localModule.exports;
        }
        pluginObj = this.validatePlugin(pluginObj, filename, shortname);
        if (pluginObj instanceof LessError) {
          return pluginObj;
        }
        if (pluginObj) {
          pluginObj.imports = imports;
          pluginObj.filename = filename;
          if (!pluginObj.minVersion || this.compareVersion("3.0.0", pluginObj.minVersion) < 0) {
            result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
            if (result) {
              return result;
            }
          }
          pluginManager.addPlugin(pluginObj, fileInfo.filename, registry);
          pluginObj.functions = registry.getLocalFunctions();
          result = this.trySetOptions(pluginObj, filename, shortname, pluginOptions);
          if (result) {
            return result;
          }
          try {
            if (pluginObj.use) {
              pluginObj.use.call(this.context, pluginObj);
            }
          } catch (e2) {
            e2.message = e2.message || "Error during @plugin call";
            return new LessError(e2, imports, filename);
          }
        } else {
          return new LessError({ message: "Not a valid plugin" }, imports, filename);
        }
        return pluginObj;
      };
      AbstractPluginLoader2.prototype.trySetOptions = function(plugin, filename, name2, options2) {
        if (options2 && !plugin.setOptions) {
          return new LessError({
            message: "Options have been provided but the plugin " + name2 + " does not support any options."
          });
        }
        try {
          plugin.setOptions && plugin.setOptions(options2);
        } catch (e2) {
          return new LessError(e2);
        }
      };
      AbstractPluginLoader2.prototype.validatePlugin = function(plugin, filename, name2) {
        if (plugin) {
          if (typeof plugin === "function") {
            plugin = new plugin();
          }
          if (plugin.minVersion) {
            if (this.compareVersion(plugin.minVersion, this.less.version) < 0) {
              return new LessError({
                message: "Plugin " + name2 + " requires version " + this.versionToString(plugin.minVersion)
              });
            }
          }
          return plugin;
        }
        return null;
      };
      AbstractPluginLoader2.prototype.compareVersion = function(aVersion, bVersion) {
        if (typeof aVersion === "string") {
          aVersion = aVersion.match(/^(\d+)\.?(\d+)?\.?(\d+)?/);
          aVersion.shift();
        }
        for (var i2 = 0; i2 < aVersion.length; i2++) {
          if (aVersion[i2] !== bVersion[i2]) {
            return parseInt(aVersion[i2]) > parseInt(bVersion[i2]) ? -1 : 1;
          }
        }
        return 0;
      };
      AbstractPluginLoader2.prototype.versionToString = function(version3) {
        var versionString = "";
        for (var i2 = 0; i2 < version3.length; i2++) {
          versionString += (versionString ? "." : "") + version3[i2];
        }
        return versionString;
      };
      AbstractPluginLoader2.prototype.printUsage = function(plugins) {
        for (var i2 = 0; i2 < plugins.length; i2++) {
          var plugin = plugins[i2];
          if (plugin.printUsage) {
            plugin.printUsage();
          }
        }
      };
      return AbstractPluginLoader2;
    }();
    var _visitArgs = { visitDeeper: true };
    var _hasIndexed = false;
    function _noop(node2) {
      return node2;
    }
    function indexNodeTypes(parent, ticker) {
      var key2, child;
      for (key2 in parent) {
        child = parent[key2];
        switch (typeof child) {
          case "function":
            if (child.prototype && child.prototype.type) {
              child.prototype.typeIndex = ticker++;
            }
            break;
          case "object":
            ticker = indexNodeTypes(child, ticker);
            break;
        }
      }
      return ticker;
    }
    var Visitor = function() {
      function Visitor2(implementation) {
        this._implementation = implementation;
        this._visitInCache = {};
        this._visitOutCache = {};
        if (!_hasIndexed) {
          indexNodeTypes(tree, 1);
          _hasIndexed = true;
        }
      }
      Visitor2.prototype.visit = function(node2) {
        if (!node2) {
          return node2;
        }
        var nodeTypeIndex = node2.typeIndex;
        if (!nodeTypeIndex) {
          if (node2.value && node2.value.typeIndex) {
            this.visit(node2.value);
          }
          return node2;
        }
        var impl = this._implementation;
        var func = this._visitInCache[nodeTypeIndex];
        var funcOut = this._visitOutCache[nodeTypeIndex];
        var visitArgs = _visitArgs;
        var fnName;
        visitArgs.visitDeeper = true;
        if (!func) {
          fnName = "visit" + node2.type;
          func = impl[fnName] || _noop;
          funcOut = impl[fnName + "Out"] || _noop;
          this._visitInCache[nodeTypeIndex] = func;
          this._visitOutCache[nodeTypeIndex] = funcOut;
        }
        if (func !== _noop) {
          var newNode = func.call(impl, node2, visitArgs);
          if (node2 && impl.isReplacing) {
            node2 = newNode;
          }
        }
        if (visitArgs.visitDeeper && node2) {
          if (node2.length) {
            for (var i2 = 0, cnt = node2.length; i2 < cnt; i2++) {
              if (node2[i2].accept) {
                node2[i2].accept(this);
              }
            }
          } else if (node2.accept) {
            node2.accept(this);
          }
        }
        if (funcOut != _noop) {
          funcOut.call(impl, node2);
        }
        return node2;
      };
      Visitor2.prototype.visitArray = function(nodes, nonReplacing) {
        if (!nodes) {
          return nodes;
        }
        var cnt = nodes.length;
        var i2;
        if (nonReplacing || !this._implementation.isReplacing) {
          for (i2 = 0; i2 < cnt; i2++) {
            this.visit(nodes[i2]);
          }
          return nodes;
        }
        var out = [];
        for (i2 = 0; i2 < cnt; i2++) {
          var evald = this.visit(nodes[i2]);
          if (evald === void 0) {
            continue;
          }
          if (!evald.splice) {
            out.push(evald);
          } else if (evald.length) {
            this.flatten(evald, out);
          }
        }
        return out;
      };
      Visitor2.prototype.flatten = function(arr, out) {
        if (!out) {
          out = [];
        }
        var cnt, i2, item, nestedCnt, j2, nestedItem;
        for (i2 = 0, cnt = arr.length; i2 < cnt; i2++) {
          item = arr[i2];
          if (item === void 0) {
            continue;
          }
          if (!item.splice) {
            out.push(item);
            continue;
          }
          for (j2 = 0, nestedCnt = item.length; j2 < nestedCnt; j2++) {
            nestedItem = item[j2];
            if (nestedItem === void 0) {
              continue;
            }
            if (!nestedItem.splice) {
              out.push(nestedItem);
            } else if (nestedItem.length) {
              this.flatten(nestedItem, out);
            }
          }
        }
        return out;
      };
      return Visitor2;
    }();
    var ImportSequencer = function() {
      function ImportSequencer2(onSequencerEmpty) {
        this.imports = [];
        this.variableImports = [];
        this._onSequencerEmpty = onSequencerEmpty;
        this._currentDepth = 0;
      }
      ImportSequencer2.prototype.addImport = function(callback) {
        var importSequencer = this, importItem = {
          callback,
          args: null,
          isReady: false
        };
        this.imports.push(importItem);
        return function() {
          importItem.args = Array.prototype.slice.call(arguments, 0);
          importItem.isReady = true;
          importSequencer.tryRun();
        };
      };
      ImportSequencer2.prototype.addVariableImport = function(callback) {
        this.variableImports.push(callback);
      };
      ImportSequencer2.prototype.tryRun = function() {
        this._currentDepth++;
        try {
          while (true) {
            while (this.imports.length > 0) {
              var importItem = this.imports[0];
              if (!importItem.isReady) {
                return;
              }
              this.imports = this.imports.slice(1);
              importItem.callback.apply(null, importItem.args);
            }
            if (this.variableImports.length === 0) {
              break;
            }
            var variableImport = this.variableImports[0];
            this.variableImports = this.variableImports.slice(1);
            variableImport();
          }
        } finally {
          this._currentDepth--;
        }
        if (this._currentDepth === 0 && this._onSequencerEmpty) {
          this._onSequencerEmpty();
        }
      };
      return ImportSequencer2;
    }();
    var ImportVisitor = function(importer, finish) {
      this._visitor = new Visitor(this);
      this._importer = importer;
      this._finish = finish;
      this.context = new contexts.Eval();
      this.importCount = 0;
      this.onceFileDetectionMap = {};
      this.recursionDetector = {};
      this._sequencer = new ImportSequencer(this._onSequencerEmpty.bind(this));
    };
    ImportVisitor.prototype = {
      isReplacing: false,
      run: function(root3) {
        try {
          this._visitor.visit(root3);
        } catch (e2) {
          this.error = e2;
        }
        this.isFinished = true;
        this._sequencer.tryRun();
      },
      _onSequencerEmpty: function() {
        if (!this.isFinished) {
          return;
        }
        this._finish(this.error);
      },
      visitImport: function(importNode, visitArgs) {
        var inlineCSS = importNode.options.inline;
        if (!importNode.css || inlineCSS) {
          var context = new contexts.Eval(this.context, copyArray(this.context.frames));
          var importParent = context.frames[0];
          this.importCount++;
          if (importNode.isVariableImport()) {
            this._sequencer.addVariableImport(this.processImportNode.bind(this, importNode, context, importParent));
          } else {
            this.processImportNode(importNode, context, importParent);
          }
        }
        visitArgs.visitDeeper = false;
      },
      processImportNode: function(importNode, context, importParent) {
        var evaldImportNode;
        var inlineCSS = importNode.options.inline;
        try {
          evaldImportNode = importNode.evalForImport(context);
        } catch (e2) {
          if (!e2.filename) {
            e2.index = importNode.getIndex();
            e2.filename = importNode.fileInfo().filename;
          }
          importNode.css = true;
          importNode.error = e2;
        }
        if (evaldImportNode && (!evaldImportNode.css || inlineCSS)) {
          if (evaldImportNode.options.multiple) {
            context.importMultiple = true;
          }
          var tryAppendLessExtension = evaldImportNode.css === void 0;
          for (var i2 = 0; i2 < importParent.rules.length; i2++) {
            if (importParent.rules[i2] === importNode) {
              importParent.rules[i2] = evaldImportNode;
              break;
            }
          }
          var onImported = this.onImported.bind(this, evaldImportNode, context), sequencedOnImported = this._sequencer.addImport(onImported);
          this._importer.push(evaldImportNode.getPath(), tryAppendLessExtension, evaldImportNode.fileInfo(), evaldImportNode.options, sequencedOnImported);
        } else {
          this.importCount--;
          if (this.isFinished) {
            this._sequencer.tryRun();
          }
        }
      },
      onImported: function(importNode, context, e2, root3, importedAtRoot, fullPath) {
        if (e2) {
          if (!e2.filename) {
            e2.index = importNode.getIndex();
            e2.filename = importNode.fileInfo().filename;
          }
          this.error = e2;
        }
        var importVisitor = this, inlineCSS = importNode.options.inline, isPlugin = importNode.options.isPlugin, isOptional = importNode.options.optional, duplicateImport = importedAtRoot || fullPath in importVisitor.recursionDetector;
        if (!context.importMultiple) {
          if (duplicateImport) {
            importNode.skip = true;
          } else {
            importNode.skip = function() {
              if (fullPath in importVisitor.onceFileDetectionMap) {
                return true;
              }
              importVisitor.onceFileDetectionMap[fullPath] = true;
              return false;
            };
          }
        }
        if (!fullPath && isOptional) {
          importNode.skip = true;
        }
        if (root3) {
          importNode.root = root3;
          importNode.importedFilename = fullPath;
          if (!inlineCSS && !isPlugin && (context.importMultiple || !duplicateImport)) {
            importVisitor.recursionDetector[fullPath] = true;
            var oldContext = this.context;
            this.context = context;
            try {
              this._visitor.visit(root3);
            } catch (e3) {
              this.error = e3;
            }
            this.context = oldContext;
          }
        }
        importVisitor.importCount--;
        if (importVisitor.isFinished) {
          importVisitor._sequencer.tryRun();
        }
      },
      visitDeclaration: function(declNode, visitArgs) {
        if (declNode.value.type === "DetachedRuleset") {
          this.context.frames.unshift(declNode);
        } else {
          visitArgs.visitDeeper = false;
        }
      },
      visitDeclarationOut: function(declNode) {
        if (declNode.value.type === "DetachedRuleset") {
          this.context.frames.shift();
        }
      },
      visitAtRule: function(atRuleNode, visitArgs) {
        this.context.frames.unshift(atRuleNode);
      },
      visitAtRuleOut: function(atRuleNode) {
        this.context.frames.shift();
      },
      visitMixinDefinition: function(mixinDefinitionNode, visitArgs) {
        this.context.frames.unshift(mixinDefinitionNode);
      },
      visitMixinDefinitionOut: function(mixinDefinitionNode) {
        this.context.frames.shift();
      },
      visitRuleset: function(rulesetNode, visitArgs) {
        this.context.frames.unshift(rulesetNode);
      },
      visitRulesetOut: function(rulesetNode) {
        this.context.frames.shift();
      },
      visitMedia: function(mediaNode, visitArgs) {
        this.context.frames.unshift(mediaNode.rules[0]);
      },
      visitMediaOut: function(mediaNode) {
        this.context.frames.shift();
      }
    };
    var SetTreeVisibilityVisitor = function() {
      function SetTreeVisibilityVisitor2(visible) {
        this.visible = visible;
      }
      SetTreeVisibilityVisitor2.prototype.run = function(root3) {
        this.visit(root3);
      };
      SetTreeVisibilityVisitor2.prototype.visitArray = function(nodes) {
        if (!nodes) {
          return nodes;
        }
        var cnt = nodes.length;
        var i2;
        for (i2 = 0; i2 < cnt; i2++) {
          this.visit(nodes[i2]);
        }
        return nodes;
      };
      SetTreeVisibilityVisitor2.prototype.visit = function(node2) {
        if (!node2) {
          return node2;
        }
        if (node2.constructor === Array) {
          return this.visitArray(node2);
        }
        if (!node2.blocksVisibility || node2.blocksVisibility()) {
          return node2;
        }
        if (this.visible) {
          node2.ensureVisibility();
        } else {
          node2.ensureInvisibility();
        }
        node2.accept(this);
        return node2;
      };
      return SetTreeVisibilityVisitor2;
    }();
    var ExtendFinderVisitor = function() {
      function ExtendFinderVisitor2() {
        this._visitor = new Visitor(this);
        this.contexts = [];
        this.allExtendsStack = [[]];
      }
      ExtendFinderVisitor2.prototype.run = function(root3) {
        root3 = this._visitor.visit(root3);
        root3.allExtends = this.allExtendsStack[0];
        return root3;
      };
      ExtendFinderVisitor2.prototype.visitDeclaration = function(declNode, visitArgs) {
        visitArgs.visitDeeper = false;
      };
      ExtendFinderVisitor2.prototype.visitMixinDefinition = function(mixinDefinitionNode, visitArgs) {
        visitArgs.visitDeeper = false;
      };
      ExtendFinderVisitor2.prototype.visitRuleset = function(rulesetNode, visitArgs) {
        if (rulesetNode.root) {
          return;
        }
        var i2;
        var j2;
        var extend2;
        var allSelectorsExtendList = [];
        var extendList;
        var rules2 = rulesetNode.rules, ruleCnt = rules2 ? rules2.length : 0;
        for (i2 = 0; i2 < ruleCnt; i2++) {
          if (rulesetNode.rules[i2] instanceof tree.Extend) {
            allSelectorsExtendList.push(rules2[i2]);
            rulesetNode.extendOnEveryPath = true;
          }
        }
        var paths = rulesetNode.paths;
        for (i2 = 0; i2 < paths.length; i2++) {
          var selectorPath = paths[i2], selector = selectorPath[selectorPath.length - 1], selExtendList = selector.extendList;
          extendList = selExtendList ? copyArray(selExtendList).concat(allSelectorsExtendList) : allSelectorsExtendList;
          if (extendList) {
            extendList = extendList.map(function(allSelectorsExtend) {
              return allSelectorsExtend.clone();
            });
          }
          for (j2 = 0; j2 < extendList.length; j2++) {
            this.foundExtends = true;
            extend2 = extendList[j2];
            extend2.findSelfSelectors(selectorPath);
            extend2.ruleset = rulesetNode;
            if (j2 === 0) {
              extend2.firstExtendOnThisSelectorPath = true;
            }
            this.allExtendsStack[this.allExtendsStack.length - 1].push(extend2);
          }
        }
        this.contexts.push(rulesetNode.selectors);
      };
      ExtendFinderVisitor2.prototype.visitRulesetOut = function(rulesetNode) {
        if (!rulesetNode.root) {
          this.contexts.length = this.contexts.length - 1;
        }
      };
      ExtendFinderVisitor2.prototype.visitMedia = function(mediaNode, visitArgs) {
        mediaNode.allExtends = [];
        this.allExtendsStack.push(mediaNode.allExtends);
      };
      ExtendFinderVisitor2.prototype.visitMediaOut = function(mediaNode) {
        this.allExtendsStack.length = this.allExtendsStack.length - 1;
      };
      ExtendFinderVisitor2.prototype.visitAtRule = function(atRuleNode, visitArgs) {
        atRuleNode.allExtends = [];
        this.allExtendsStack.push(atRuleNode.allExtends);
      };
      ExtendFinderVisitor2.prototype.visitAtRuleOut = function(atRuleNode) {
        this.allExtendsStack.length = this.allExtendsStack.length - 1;
      };
      return ExtendFinderVisitor2;
    }();
    var ProcessExtendsVisitor = function() {
      function ProcessExtendsVisitor2() {
        this._visitor = new Visitor(this);
      }
      ProcessExtendsVisitor2.prototype.run = function(root3) {
        var extendFinder = new ExtendFinderVisitor();
        this.extendIndices = {};
        extendFinder.run(root3);
        if (!extendFinder.foundExtends) {
          return root3;
        }
        root3.allExtends = root3.allExtends.concat(this.doExtendChaining(root3.allExtends, root3.allExtends));
        this.allExtendsStack = [root3.allExtends];
        var newRoot = this._visitor.visit(root3);
        this.checkExtendsForNonMatched(root3.allExtends);
        return newRoot;
      };
      ProcessExtendsVisitor2.prototype.checkExtendsForNonMatched = function(extendList) {
        var indices = this.extendIndices;
        extendList.filter(function(extend2) {
          return !extend2.hasFoundMatches && extend2.parent_ids.length == 1;
        }).forEach(function(extend2) {
          var selector = "_unknown_";
          try {
            selector = extend2.selector.toCSS({});
          } catch (_2) {
          }
          if (!indices[extend2.index + " " + selector]) {
            indices[extend2.index + " " + selector] = true;
            logger$1.warn("extend '" + selector + "' has no matches");
          }
        });
      };
      ProcessExtendsVisitor2.prototype.doExtendChaining = function(extendsList, extendsListTarget, iterationCount) {
        var extendIndex;
        var targetExtendIndex;
        var matches;
        var extendsToAdd = [];
        var newSelector;
        var extendVisitor = this;
        var selectorPath;
        var extend2;
        var targetExtend;
        var newExtend;
        iterationCount = iterationCount || 0;
        for (extendIndex = 0; extendIndex < extendsList.length; extendIndex++) {
          for (targetExtendIndex = 0; targetExtendIndex < extendsListTarget.length; targetExtendIndex++) {
            extend2 = extendsList[extendIndex];
            targetExtend = extendsListTarget[targetExtendIndex];
            if (extend2.parent_ids.indexOf(targetExtend.object_id) >= 0) {
              continue;
            }
            selectorPath = [targetExtend.selfSelectors[0]];
            matches = extendVisitor.findMatch(extend2, selectorPath);
            if (matches.length) {
              extend2.hasFoundMatches = true;
              extend2.selfSelectors.forEach(function(selfSelector) {
                var info = targetExtend.visibilityInfo();
                newSelector = extendVisitor.extendSelector(matches, selectorPath, selfSelector, extend2.isVisible());
                newExtend = new tree.Extend(targetExtend.selector, targetExtend.option, 0, targetExtend.fileInfo(), info);
                newExtend.selfSelectors = newSelector;
                newSelector[newSelector.length - 1].extendList = [newExtend];
                extendsToAdd.push(newExtend);
                newExtend.ruleset = targetExtend.ruleset;
                newExtend.parent_ids = newExtend.parent_ids.concat(targetExtend.parent_ids, extend2.parent_ids);
                if (targetExtend.firstExtendOnThisSelectorPath) {
                  newExtend.firstExtendOnThisSelectorPath = true;
                  targetExtend.ruleset.paths.push(newSelector);
                }
              });
            }
          }
        }
        if (extendsToAdd.length) {
          this.extendChainCount++;
          if (iterationCount > 100) {
            var selectorOne = "{unable to calculate}";
            var selectorTwo = "{unable to calculate}";
            try {
              selectorOne = extendsToAdd[0].selfSelectors[0].toCSS();
              selectorTwo = extendsToAdd[0].selector.toCSS();
            } catch (e2) {
            }
            throw { message: "extend circular reference detected. One of the circular extends is currently:" + selectorOne + ":extend(" + selectorTwo + ")" };
          }
          return extendsToAdd.concat(extendVisitor.doExtendChaining(extendsToAdd, extendsListTarget, iterationCount + 1));
        } else {
          return extendsToAdd;
        }
      };
      ProcessExtendsVisitor2.prototype.visitDeclaration = function(ruleNode, visitArgs) {
        visitArgs.visitDeeper = false;
      };
      ProcessExtendsVisitor2.prototype.visitMixinDefinition = function(mixinDefinitionNode, visitArgs) {
        visitArgs.visitDeeper = false;
      };
      ProcessExtendsVisitor2.prototype.visitSelector = function(selectorNode, visitArgs) {
        visitArgs.visitDeeper = false;
      };
      ProcessExtendsVisitor2.prototype.visitRuleset = function(rulesetNode, visitArgs) {
        if (rulesetNode.root) {
          return;
        }
        var matches;
        var pathIndex;
        var extendIndex;
        var allExtends = this.allExtendsStack[this.allExtendsStack.length - 1];
        var selectorsToAdd = [];
        var extendVisitor = this;
        var selectorPath;
        for (extendIndex = 0; extendIndex < allExtends.length; extendIndex++) {
          for (pathIndex = 0; pathIndex < rulesetNode.paths.length; pathIndex++) {
            selectorPath = rulesetNode.paths[pathIndex];
            if (rulesetNode.extendOnEveryPath) {
              continue;
            }
            var extendList = selectorPath[selectorPath.length - 1].extendList;
            if (extendList && extendList.length) {
              continue;
            }
            matches = this.findMatch(allExtends[extendIndex], selectorPath);
            if (matches.length) {
              allExtends[extendIndex].hasFoundMatches = true;
              allExtends[extendIndex].selfSelectors.forEach(function(selfSelector) {
                var extendedSelectors;
                extendedSelectors = extendVisitor.extendSelector(matches, selectorPath, selfSelector, allExtends[extendIndex].isVisible());
                selectorsToAdd.push(extendedSelectors);
              });
            }
          }
        }
        rulesetNode.paths = rulesetNode.paths.concat(selectorsToAdd);
      };
      ProcessExtendsVisitor2.prototype.findMatch = function(extend2, haystackSelectorPath) {
        var haystackSelectorIndex;
        var hackstackSelector;
        var hackstackElementIndex;
        var haystackElement;
        var targetCombinator;
        var i2;
        var extendVisitor = this;
        var needleElements = extend2.selector.elements;
        var potentialMatches = [];
        var potentialMatch;
        var matches = [];
        for (haystackSelectorIndex = 0; haystackSelectorIndex < haystackSelectorPath.length; haystackSelectorIndex++) {
          hackstackSelector = haystackSelectorPath[haystackSelectorIndex];
          for (hackstackElementIndex = 0; hackstackElementIndex < hackstackSelector.elements.length; hackstackElementIndex++) {
            haystackElement = hackstackSelector.elements[hackstackElementIndex];
            if (extend2.allowBefore || haystackSelectorIndex === 0 && hackstackElementIndex === 0) {
              potentialMatches.push({
                pathIndex: haystackSelectorIndex,
                index: hackstackElementIndex,
                matched: 0,
                initialCombinator: haystackElement.combinator
              });
            }
            for (i2 = 0; i2 < potentialMatches.length; i2++) {
              potentialMatch = potentialMatches[i2];
              targetCombinator = haystackElement.combinator.value;
              if (targetCombinator === "" && hackstackElementIndex === 0) {
                targetCombinator = " ";
              }
              if (!extendVisitor.isElementValuesEqual(needleElements[potentialMatch.matched].value, haystackElement.value) || potentialMatch.matched > 0 && needleElements[potentialMatch.matched].combinator.value !== targetCombinator) {
                potentialMatch = null;
              } else {
                potentialMatch.matched++;
              }
              if (potentialMatch) {
                potentialMatch.finished = potentialMatch.matched === needleElements.length;
                if (potentialMatch.finished && (!extend2.allowAfter && (hackstackElementIndex + 1 < hackstackSelector.elements.length || haystackSelectorIndex + 1 < haystackSelectorPath.length))) {
                  potentialMatch = null;
                }
              }
              if (potentialMatch) {
                if (potentialMatch.finished) {
                  potentialMatch.length = needleElements.length;
                  potentialMatch.endPathIndex = haystackSelectorIndex;
                  potentialMatch.endPathElementIndex = hackstackElementIndex + 1;
                  potentialMatches.length = 0;
                  matches.push(potentialMatch);
                }
              } else {
                potentialMatches.splice(i2, 1);
                i2--;
              }
            }
          }
        }
        return matches;
      };
      ProcessExtendsVisitor2.prototype.isElementValuesEqual = function(elementValue1, elementValue2) {
        if (typeof elementValue1 === "string" || typeof elementValue2 === "string") {
          return elementValue1 === elementValue2;
        }
        if (elementValue1 instanceof tree.Attribute) {
          if (elementValue1.op !== elementValue2.op || elementValue1.key !== elementValue2.key) {
            return false;
          }
          if (!elementValue1.value || !elementValue2.value) {
            if (elementValue1.value || elementValue2.value) {
              return false;
            }
            return true;
          }
          elementValue1 = elementValue1.value.value || elementValue1.value;
          elementValue2 = elementValue2.value.value || elementValue2.value;
          return elementValue1 === elementValue2;
        }
        elementValue1 = elementValue1.value;
        elementValue2 = elementValue2.value;
        if (elementValue1 instanceof tree.Selector) {
          if (!(elementValue2 instanceof tree.Selector) || elementValue1.elements.length !== elementValue2.elements.length) {
            return false;
          }
          for (var i2 = 0; i2 < elementValue1.elements.length; i2++) {
            if (elementValue1.elements[i2].combinator.value !== elementValue2.elements[i2].combinator.value) {
              if (i2 !== 0 || (elementValue1.elements[i2].combinator.value || " ") !== (elementValue2.elements[i2].combinator.value || " ")) {
                return false;
              }
            }
            if (!this.isElementValuesEqual(elementValue1.elements[i2].value, elementValue2.elements[i2].value)) {
              return false;
            }
          }
          return true;
        }
        return false;
      };
      ProcessExtendsVisitor2.prototype.extendSelector = function(matches, selectorPath, replacementSelector, isVisible2) {
        var currentSelectorPathIndex = 0, currentSelectorPathElementIndex = 0, path2 = [], matchIndex, selector, firstElement, match, newElements;
        for (matchIndex = 0; matchIndex < matches.length; matchIndex++) {
          match = matches[matchIndex];
          selector = selectorPath[match.pathIndex];
          firstElement = new tree.Element(match.initialCombinator, replacementSelector.elements[0].value, replacementSelector.elements[0].isVariable, replacementSelector.elements[0].getIndex(), replacementSelector.elements[0].fileInfo());
          if (match.pathIndex > currentSelectorPathIndex && currentSelectorPathElementIndex > 0) {
            path2[path2.length - 1].elements = path2[path2.length - 1].elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
            currentSelectorPathElementIndex = 0;
            currentSelectorPathIndex++;
          }
          newElements = selector.elements.slice(currentSelectorPathElementIndex, match.index).concat([firstElement]).concat(replacementSelector.elements.slice(1));
          if (currentSelectorPathIndex === match.pathIndex && matchIndex > 0) {
            path2[path2.length - 1].elements = path2[path2.length - 1].elements.concat(newElements);
          } else {
            path2 = path2.concat(selectorPath.slice(currentSelectorPathIndex, match.pathIndex));
            path2.push(new tree.Selector(newElements));
          }
          currentSelectorPathIndex = match.endPathIndex;
          currentSelectorPathElementIndex = match.endPathElementIndex;
          if (currentSelectorPathElementIndex >= selectorPath[currentSelectorPathIndex].elements.length) {
            currentSelectorPathElementIndex = 0;
            currentSelectorPathIndex++;
          }
        }
        if (currentSelectorPathIndex < selectorPath.length && currentSelectorPathElementIndex > 0) {
          path2[path2.length - 1].elements = path2[path2.length - 1].elements.concat(selectorPath[currentSelectorPathIndex].elements.slice(currentSelectorPathElementIndex));
          currentSelectorPathIndex++;
        }
        path2 = path2.concat(selectorPath.slice(currentSelectorPathIndex, selectorPath.length));
        path2 = path2.map(function(currentValue) {
          var derived = currentValue.createDerived(currentValue.elements);
          if (isVisible2) {
            derived.ensureVisibility();
          } else {
            derived.ensureInvisibility();
          }
          return derived;
        });
        return path2;
      };
      ProcessExtendsVisitor2.prototype.visitMedia = function(mediaNode, visitArgs) {
        var newAllExtends = mediaNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, mediaNode.allExtends));
        this.allExtendsStack.push(newAllExtends);
      };
      ProcessExtendsVisitor2.prototype.visitMediaOut = function(mediaNode) {
        var lastIndex = this.allExtendsStack.length - 1;
        this.allExtendsStack.length = lastIndex;
      };
      ProcessExtendsVisitor2.prototype.visitAtRule = function(atRuleNode, visitArgs) {
        var newAllExtends = atRuleNode.allExtends.concat(this.allExtendsStack[this.allExtendsStack.length - 1]);
        newAllExtends = newAllExtends.concat(this.doExtendChaining(newAllExtends, atRuleNode.allExtends));
        this.allExtendsStack.push(newAllExtends);
      };
      ProcessExtendsVisitor2.prototype.visitAtRuleOut = function(atRuleNode) {
        var lastIndex = this.allExtendsStack.length - 1;
        this.allExtendsStack.length = lastIndex;
      };
      return ProcessExtendsVisitor2;
    }();
    var JoinSelectorVisitor = function() {
      function JoinSelectorVisitor2() {
        this.contexts = [[]];
        this._visitor = new Visitor(this);
      }
      JoinSelectorVisitor2.prototype.run = function(root3) {
        return this._visitor.visit(root3);
      };
      JoinSelectorVisitor2.prototype.visitDeclaration = function(declNode, visitArgs) {
        visitArgs.visitDeeper = false;
      };
      JoinSelectorVisitor2.prototype.visitMixinDefinition = function(mixinDefinitionNode, visitArgs) {
        visitArgs.visitDeeper = false;
      };
      JoinSelectorVisitor2.prototype.visitRuleset = function(rulesetNode, visitArgs) {
        var context = this.contexts[this.contexts.length - 1];
        var paths = [];
        var selectors;
        this.contexts.push(paths);
        if (!rulesetNode.root) {
          selectors = rulesetNode.selectors;
          if (selectors) {
            selectors = selectors.filter(function(selector) {
              return selector.getIsOutput();
            });
            rulesetNode.selectors = selectors.length ? selectors : selectors = null;
            if (selectors) {
              rulesetNode.joinSelectors(paths, context, selectors);
            }
          }
          if (!selectors) {
            rulesetNode.rules = null;
          }
          rulesetNode.paths = paths;
        }
      };
      JoinSelectorVisitor2.prototype.visitRulesetOut = function(rulesetNode) {
        this.contexts.length = this.contexts.length - 1;
      };
      JoinSelectorVisitor2.prototype.visitMedia = function(mediaNode, visitArgs) {
        var context = this.contexts[this.contexts.length - 1];
        mediaNode.rules[0].root = context.length === 0 || context[0].multiMedia;
      };
      JoinSelectorVisitor2.prototype.visitAtRule = function(atRuleNode, visitArgs) {
        var context = this.contexts[this.contexts.length - 1];
        if (atRuleNode.rules && atRuleNode.rules.length) {
          atRuleNode.rules[0].root = atRuleNode.isRooted || context.length === 0 || null;
        }
      };
      return JoinSelectorVisitor2;
    }();
    var CSSVisitorUtils = function() {
      function CSSVisitorUtils2(context) {
        this._visitor = new Visitor(this);
        this._context = context;
      }
      CSSVisitorUtils2.prototype.containsSilentNonBlockedChild = function(bodyRules) {
        var rule;
        if (!bodyRules) {
          return false;
        }
        for (var r2 = 0; r2 < bodyRules.length; r2++) {
          rule = bodyRules[r2];
          if (rule.isSilent && rule.isSilent(this._context) && !rule.blocksVisibility()) {
            return true;
          }
        }
        return false;
      };
      CSSVisitorUtils2.prototype.keepOnlyVisibleChilds = function(owner) {
        if (owner && owner.rules) {
          owner.rules = owner.rules.filter(function(thing) {
            return thing.isVisible();
          });
        }
      };
      CSSVisitorUtils2.prototype.isEmpty = function(owner) {
        return owner && owner.rules ? owner.rules.length === 0 : true;
      };
      CSSVisitorUtils2.prototype.hasVisibleSelector = function(rulesetNode) {
        return rulesetNode && rulesetNode.paths ? rulesetNode.paths.length > 0 : false;
      };
      CSSVisitorUtils2.prototype.resolveVisibility = function(node2, originalRules) {
        if (!node2.blocksVisibility()) {
          if (this.isEmpty(node2) && !this.containsSilentNonBlockedChild(originalRules)) {
            return;
          }
          return node2;
        }
        var compiledRulesBody = node2.rules[0];
        this.keepOnlyVisibleChilds(compiledRulesBody);
        if (this.isEmpty(compiledRulesBody)) {
          return;
        }
        node2.ensureVisibility();
        node2.removeVisibilityBlock();
        return node2;
      };
      CSSVisitorUtils2.prototype.isVisibleRuleset = function(rulesetNode) {
        if (rulesetNode.firstRoot) {
          return true;
        }
        if (this.isEmpty(rulesetNode)) {
          return false;
        }
        if (!rulesetNode.root && !this.hasVisibleSelector(rulesetNode)) {
          return false;
        }
        return true;
      };
      return CSSVisitorUtils2;
    }();
    var ToCSSVisitor = function(context) {
      this._visitor = new Visitor(this);
      this._context = context;
      this.utils = new CSSVisitorUtils(context);
    };
    ToCSSVisitor.prototype = {
      isReplacing: true,
      run: function(root3) {
        return this._visitor.visit(root3);
      },
      visitDeclaration: function(declNode, visitArgs) {
        if (declNode.blocksVisibility() || declNode.variable) {
          return;
        }
        return declNode;
      },
      visitMixinDefinition: function(mixinNode, visitArgs) {
        mixinNode.frames = [];
      },
      visitExtend: function(extendNode, visitArgs) {
      },
      visitComment: function(commentNode, visitArgs) {
        if (commentNode.blocksVisibility() || commentNode.isSilent(this._context)) {
          return;
        }
        return commentNode;
      },
      visitMedia: function(mediaNode, visitArgs) {
        var originalRules = mediaNode.rules[0].rules;
        mediaNode.accept(this._visitor);
        visitArgs.visitDeeper = false;
        return this.utils.resolveVisibility(mediaNode, originalRules);
      },
      visitImport: function(importNode, visitArgs) {
        if (importNode.blocksVisibility()) {
          return;
        }
        return importNode;
      },
      visitAtRule: function(atRuleNode, visitArgs) {
        if (atRuleNode.rules && atRuleNode.rules.length) {
          return this.visitAtRuleWithBody(atRuleNode, visitArgs);
        } else {
          return this.visitAtRuleWithoutBody(atRuleNode, visitArgs);
        }
      },
      visitAnonymous: function(anonymousNode, visitArgs) {
        if (!anonymousNode.blocksVisibility()) {
          anonymousNode.accept(this._visitor);
          return anonymousNode;
        }
      },
      visitAtRuleWithBody: function(atRuleNode, visitArgs) {
        function hasFakeRuleset(atRuleNode2) {
          var bodyRules = atRuleNode2.rules;
          return bodyRules.length === 1 && (!bodyRules[0].paths || bodyRules[0].paths.length === 0);
        }
        function getBodyRules(atRuleNode2) {
          var nodeRules = atRuleNode2.rules;
          if (hasFakeRuleset(atRuleNode2)) {
            return nodeRules[0].rules;
          }
          return nodeRules;
        }
        var originalRules = getBodyRules(atRuleNode);
        atRuleNode.accept(this._visitor);
        visitArgs.visitDeeper = false;
        if (!this.utils.isEmpty(atRuleNode)) {
          this._mergeRules(atRuleNode.rules[0].rules);
        }
        return this.utils.resolveVisibility(atRuleNode, originalRules);
      },
      visitAtRuleWithoutBody: function(atRuleNode, visitArgs) {
        if (atRuleNode.blocksVisibility()) {
          return;
        }
        if (atRuleNode.name === "@charset") {
          if (this.charset) {
            if (atRuleNode.debugInfo) {
              var comment2 = new tree.Comment("/* " + atRuleNode.toCSS(this._context).replace(/\n/g, "") + " */\n");
              comment2.debugInfo = atRuleNode.debugInfo;
              return this._visitor.visit(comment2);
            }
            return;
          }
          this.charset = true;
        }
        return atRuleNode;
      },
      checkValidNodes: function(rules2, isRoot) {
        if (!rules2) {
          return;
        }
        for (var i2 = 0; i2 < rules2.length; i2++) {
          var ruleNode = rules2[i2];
          if (isRoot && ruleNode instanceof tree.Declaration && !ruleNode.variable) {
            throw {
              message: "Properties must be inside selector blocks. They cannot be in the root",
              index: ruleNode.getIndex(),
              filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename
            };
          }
          if (ruleNode instanceof tree.Call) {
            throw {
              message: "Function '" + ruleNode.name + "' did not return a root node",
              index: ruleNode.getIndex(),
              filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename
            };
          }
          if (ruleNode.type && !ruleNode.allowRoot) {
            throw {
              message: ruleNode.type + " node returned by a function is not valid here",
              index: ruleNode.getIndex(),
              filename: ruleNode.fileInfo() && ruleNode.fileInfo().filename
            };
          }
        }
      },
      visitRuleset: function(rulesetNode, visitArgs) {
        var rule;
        var rulesets = [];
        this.checkValidNodes(rulesetNode.rules, rulesetNode.firstRoot);
        if (!rulesetNode.root) {
          this._compileRulesetPaths(rulesetNode);
          var nodeRules = rulesetNode.rules;
          var nodeRuleCnt = nodeRules ? nodeRules.length : 0;
          for (var i2 = 0; i2 < nodeRuleCnt; ) {
            rule = nodeRules[i2];
            if (rule && rule.rules) {
              rulesets.push(this._visitor.visit(rule));
              nodeRules.splice(i2, 1);
              nodeRuleCnt--;
              continue;
            }
            i2++;
          }
          if (nodeRuleCnt > 0) {
            rulesetNode.accept(this._visitor);
          } else {
            rulesetNode.rules = null;
          }
          visitArgs.visitDeeper = false;
        } else {
          rulesetNode.accept(this._visitor);
          visitArgs.visitDeeper = false;
        }
        if (rulesetNode.rules) {
          this._mergeRules(rulesetNode.rules);
          this._removeDuplicateRules(rulesetNode.rules);
        }
        if (this.utils.isVisibleRuleset(rulesetNode)) {
          rulesetNode.ensureVisibility();
          rulesets.splice(0, 0, rulesetNode);
        }
        if (rulesets.length === 1) {
          return rulesets[0];
        }
        return rulesets;
      },
      _compileRulesetPaths: function(rulesetNode) {
        if (rulesetNode.paths) {
          rulesetNode.paths = rulesetNode.paths.filter(function(p2) {
            var i2;
            if (p2[0].elements[0].combinator.value === " ") {
              p2[0].elements[0].combinator = new tree.Combinator("");
            }
            for (i2 = 0; i2 < p2.length; i2++) {
              if (p2[i2].isVisible() && p2[i2].getIsOutput()) {
                return true;
              }
            }
            return false;
          });
        }
      },
      _removeDuplicateRules: function(rules2) {
        if (!rules2) {
          return;
        }
        var ruleCache = {};
        var ruleList;
        var rule;
        var i2;
        for (i2 = rules2.length - 1; i2 >= 0; i2--) {
          rule = rules2[i2];
          if (rule instanceof tree.Declaration) {
            if (!ruleCache[rule.name]) {
              ruleCache[rule.name] = rule;
            } else {
              ruleList = ruleCache[rule.name];
              if (ruleList instanceof tree.Declaration) {
                ruleList = ruleCache[rule.name] = [ruleCache[rule.name].toCSS(this._context)];
              }
              var ruleCSS = rule.toCSS(this._context);
              if (ruleList.indexOf(ruleCSS) !== -1) {
                rules2.splice(i2, 1);
              } else {
                ruleList.push(ruleCSS);
              }
            }
          }
        }
      },
      _mergeRules: function(rules2) {
        if (!rules2) {
          return;
        }
        var groups = {};
        var groupsArr = [];
        for (var i2 = 0; i2 < rules2.length; i2++) {
          var rule = rules2[i2];
          if (rule.merge) {
            var key2 = rule.name;
            groups[key2] ? rules2.splice(i2--, 1) : groupsArr.push(groups[key2] = []);
            groups[key2].push(rule);
          }
        }
        groupsArr.forEach(function(group) {
          if (group.length > 0) {
            var result_1 = group[0];
            var space_1 = [];
            var comma_1 = [new tree.Expression(space_1)];
            group.forEach(function(rule2) {
              if (rule2.merge === "+" && space_1.length > 0) {
                comma_1.push(new tree.Expression(space_1 = []));
              }
              space_1.push(rule2.value);
              result_1.important = result_1.important || rule2.important;
            });
            result_1.value = new tree.Value(comma_1);
          }
        });
      }
    };
    var visitors = {
      Visitor,
      ImportVisitor,
      MarkVisibleSelectorsVisitor: SetTreeVisibilityVisitor,
      ExtendVisitor: ProcessExtendsVisitor,
      JoinSelectorVisitor,
      ToCSSVisitor
    };
    function chunker(input, fail) {
      var len = input.length;
      var level = 0;
      var parenLevel = 0;
      var lastOpening;
      var lastOpeningParen;
      var lastMultiComment;
      var lastMultiCommentEndBrace;
      var chunks = [];
      var emitFrom = 0;
      var chunkerCurrentIndex;
      var currentChunkStartIndex;
      var cc2;
      var cc22;
      var matched;
      function emitChunk(force) {
        var len2 = chunkerCurrentIndex - emitFrom;
        if (len2 < 512 && !force || !len2) {
          return;
        }
        chunks.push(input.slice(emitFrom, chunkerCurrentIndex + 1));
        emitFrom = chunkerCurrentIndex + 1;
      }
      for (chunkerCurrentIndex = 0; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
        cc2 = input.charCodeAt(chunkerCurrentIndex);
        if (cc2 >= 97 && cc2 <= 122 || cc2 < 34) {
          continue;
        }
        switch (cc2) {
          case 40:
            parenLevel++;
            lastOpeningParen = chunkerCurrentIndex;
            continue;
          case 41:
            if (--parenLevel < 0) {
              return fail("missing opening `(`", chunkerCurrentIndex);
            }
            continue;
          case 59:
            if (!parenLevel) {
              emitChunk();
            }
            continue;
          case 123:
            level++;
            lastOpening = chunkerCurrentIndex;
            continue;
          case 125:
            if (--level < 0) {
              return fail("missing opening `{`", chunkerCurrentIndex);
            }
            if (!level && !parenLevel) {
              emitChunk();
            }
            continue;
          case 92:
            if (chunkerCurrentIndex < len - 1) {
              chunkerCurrentIndex++;
              continue;
            }
            return fail("unescaped `\\`", chunkerCurrentIndex);
          case 34:
          case 39:
          case 96:
            matched = 0;
            currentChunkStartIndex = chunkerCurrentIndex;
            for (chunkerCurrentIndex = chunkerCurrentIndex + 1; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
              cc22 = input.charCodeAt(chunkerCurrentIndex);
              if (cc22 > 96) {
                continue;
              }
              if (cc22 == cc2) {
                matched = 1;
                break;
              }
              if (cc22 == 92) {
                if (chunkerCurrentIndex == len - 1) {
                  return fail("unescaped `\\`", chunkerCurrentIndex);
                }
                chunkerCurrentIndex++;
              }
            }
            if (matched) {
              continue;
            }
            return fail("unmatched `" + String.fromCharCode(cc2) + "`", currentChunkStartIndex);
          case 47:
            if (parenLevel || chunkerCurrentIndex == len - 1) {
              continue;
            }
            cc22 = input.charCodeAt(chunkerCurrentIndex + 1);
            if (cc22 == 47) {
              for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len; chunkerCurrentIndex++) {
                cc22 = input.charCodeAt(chunkerCurrentIndex);
                if (cc22 <= 13 && (cc22 == 10 || cc22 == 13)) {
                  break;
                }
              }
            } else if (cc22 == 42) {
              lastMultiComment = currentChunkStartIndex = chunkerCurrentIndex;
              for (chunkerCurrentIndex = chunkerCurrentIndex + 2; chunkerCurrentIndex < len - 1; chunkerCurrentIndex++) {
                cc22 = input.charCodeAt(chunkerCurrentIndex);
                if (cc22 == 125) {
                  lastMultiCommentEndBrace = chunkerCurrentIndex;
                }
                if (cc22 != 42) {
                  continue;
                }
                if (input.charCodeAt(chunkerCurrentIndex + 1) == 47) {
                  break;
                }
              }
              if (chunkerCurrentIndex == len - 1) {
                return fail("missing closing `*/`", currentChunkStartIndex);
              }
              chunkerCurrentIndex++;
            }
            continue;
          case 42:
            if (chunkerCurrentIndex < len - 1 && input.charCodeAt(chunkerCurrentIndex + 1) == 47) {
              return fail("unmatched `/*`", chunkerCurrentIndex);
            }
            continue;
        }
      }
      if (level !== 0) {
        if (lastMultiComment > lastOpening && lastMultiCommentEndBrace > lastMultiComment) {
          return fail("missing closing `}` or `*/`", lastOpening);
        } else {
          return fail("missing closing `}`", lastOpening);
        }
      } else if (parenLevel !== 0) {
        return fail("missing closing `)`", lastOpeningParen);
      }
      emitChunk(true);
      return chunks;
    }
    var getParserInput = function() {
      var input;
      var j2;
      var saveStack = [];
      var furthest;
      var furthestPossibleErrorMessage;
      var chunks;
      var current;
      var currentPos;
      var parserInput = {};
      var CHARCODE_SPACE = 32;
      var CHARCODE_TAB = 9;
      var CHARCODE_LF = 10;
      var CHARCODE_CR = 13;
      var CHARCODE_PLUS = 43;
      var CHARCODE_COMMA = 44;
      var CHARCODE_FORWARD_SLASH = 47;
      var CHARCODE_9 = 57;
      function skipWhitespace(length2) {
        var oldi = parserInput.i;
        var oldj = j2;
        var curr = parserInput.i - currentPos;
        var endIndex = parserInput.i + current.length - curr;
        var mem = parserInput.i += length2;
        var inp = input;
        var c2;
        var nextChar;
        var comment2;
        for (; parserInput.i < endIndex; parserInput.i++) {
          c2 = inp.charCodeAt(parserInput.i);
          if (parserInput.autoCommentAbsorb && c2 === CHARCODE_FORWARD_SLASH) {
            nextChar = inp.charAt(parserInput.i + 1);
            if (nextChar === "/") {
              comment2 = { index: parserInput.i, isLineComment: true };
              var nextNewLine = inp.indexOf("\n", parserInput.i + 2);
              if (nextNewLine < 0) {
                nextNewLine = endIndex;
              }
              parserInput.i = nextNewLine;
              comment2.text = inp.substr(comment2.index, parserInput.i - comment2.index);
              parserInput.commentStore.push(comment2);
              continue;
            } else if (nextChar === "*") {
              var nextStarSlash = inp.indexOf("*/", parserInput.i + 2);
              if (nextStarSlash >= 0) {
                comment2 = {
                  index: parserInput.i,
                  text: inp.substr(parserInput.i, nextStarSlash + 2 - parserInput.i),
                  isLineComment: false
                };
                parserInput.i += comment2.text.length - 1;
                parserInput.commentStore.push(comment2);
                continue;
              }
            }
            break;
          }
          if (c2 !== CHARCODE_SPACE && c2 !== CHARCODE_LF && c2 !== CHARCODE_TAB && c2 !== CHARCODE_CR) {
            break;
          }
        }
        current = current.slice(length2 + parserInput.i - mem + curr);
        currentPos = parserInput.i;
        if (!current.length) {
          if (j2 < chunks.length - 1) {
            current = chunks[++j2];
            skipWhitespace(0);
            return true;
          }
          parserInput.finished = true;
        }
        return oldi !== parserInput.i || oldj !== j2;
      }
      parserInput.save = function() {
        currentPos = parserInput.i;
        saveStack.push({ current, i: parserInput.i, j: j2 });
      };
      parserInput.restore = function(possibleErrorMessage) {
        if (parserInput.i > furthest || parserInput.i === furthest && possibleErrorMessage && !furthestPossibleErrorMessage) {
          furthest = parserInput.i;
          furthestPossibleErrorMessage = possibleErrorMessage;
        }
        var state = saveStack.pop();
        current = state.current;
        currentPos = parserInput.i = state.i;
        j2 = state.j;
      };
      parserInput.forget = function() {
        saveStack.pop();
      };
      parserInput.isWhitespace = function(offset2) {
        var pos = parserInput.i + (offset2 || 0);
        var code = input.charCodeAt(pos);
        return code === CHARCODE_SPACE || code === CHARCODE_CR || code === CHARCODE_TAB || code === CHARCODE_LF;
      };
      parserInput.$re = function(tok) {
        if (parserInput.i > currentPos) {
          current = current.slice(parserInput.i - currentPos);
          currentPos = parserInput.i;
        }
        var m2 = tok.exec(current);
        if (!m2) {
          return null;
        }
        skipWhitespace(m2[0].length);
        if (typeof m2 === "string") {
          return m2;
        }
        return m2.length === 1 ? m2[0] : m2;
      };
      parserInput.$char = function(tok) {
        if (input.charAt(parserInput.i) !== tok) {
          return null;
        }
        skipWhitespace(1);
        return tok;
      };
      parserInput.$str = function(tok) {
        var tokLength = tok.length;
        for (var i2 = 0; i2 < tokLength; i2++) {
          if (input.charAt(parserInput.i + i2) !== tok.charAt(i2)) {
            return null;
          }
        }
        skipWhitespace(tokLength);
        return tok;
      };
      parserInput.$quoted = function(loc) {
        var pos = loc || parserInput.i;
        var startChar = input.charAt(pos);
        if (startChar !== "'" && startChar !== '"') {
          return;
        }
        var length2 = input.length;
        var currentPosition = pos;
        for (var i2 = 1; i2 + currentPosition < length2; i2++) {
          var nextChar = input.charAt(i2 + currentPosition);
          switch (nextChar) {
            case "\\":
              i2++;
              continue;
            case "\r":
            case "\n":
              break;
            case startChar:
              var str = input.substr(currentPosition, i2 + 1);
              if (!loc && loc !== 0) {
                skipWhitespace(i2 + 1);
                return str;
              }
              return [startChar, str];
          }
        }
        return null;
      };
      parserInput.$parseUntil = function(tok) {
        var quote = "";
        var returnVal = null;
        var inComment = false;
        var blockDepth = 0;
        var blockStack = [];
        var parseGroups = [];
        var length2 = input.length;
        var startPos = parserInput.i;
        var lastPos = parserInput.i;
        var i2 = parserInput.i;
        var loop = true;
        var testChar;
        if (typeof tok === "string") {
          testChar = function(char2) {
            return char2 === tok;
          };
        } else {
          testChar = function(char2) {
            return tok.test(char2);
          };
        }
        do {
          var nextChar = input.charAt(i2);
          if (blockDepth === 0 && testChar(nextChar)) {
            returnVal = input.substr(lastPos, i2 - lastPos);
            if (returnVal) {
              parseGroups.push(returnVal);
            } else {
              parseGroups.push(" ");
            }
            returnVal = parseGroups;
            skipWhitespace(i2 - startPos);
            loop = false;
          } else {
            if (inComment) {
              if (nextChar === "*" && input.charAt(i2 + 1) === "/") {
                i2++;
                blockDepth--;
                inComment = false;
              }
              i2++;
              continue;
            }
            switch (nextChar) {
              case "\\":
                i2++;
                nextChar = input.charAt(i2);
                parseGroups.push(input.substr(lastPos, i2 - lastPos + 1));
                lastPos = i2 + 1;
                break;
              case "/":
                if (input.charAt(i2 + 1) === "*") {
                  i2++;
                  inComment = true;
                  blockDepth++;
                }
                break;
              case "'":
              case '"':
                quote = parserInput.$quoted(i2);
                if (quote) {
                  parseGroups.push(input.substr(lastPos, i2 - lastPos), quote);
                  i2 += quote[1].length - 1;
                  lastPos = i2 + 1;
                } else {
                  skipWhitespace(i2 - startPos);
                  returnVal = nextChar;
                  loop = false;
                }
                break;
              case "{":
                blockStack.push("}");
                blockDepth++;
                break;
              case "(":
                blockStack.push(")");
                blockDepth++;
                break;
              case "[":
                blockStack.push("]");
                blockDepth++;
                break;
              case "}":
              case ")":
              case "]":
                var expected = blockStack.pop();
                if (nextChar === expected) {
                  blockDepth--;
                } else {
                  skipWhitespace(i2 - startPos);
                  returnVal = expected;
                  loop = false;
                }
            }
            i2++;
            if (i2 > length2) {
              loop = false;
            }
          }
        } while (loop);
        return returnVal ? returnVal : null;
      };
      parserInput.autoCommentAbsorb = true;
      parserInput.commentStore = [];
      parserInput.finished = false;
      parserInput.peek = function(tok) {
        if (typeof tok === "string") {
          for (var i2 = 0; i2 < tok.length; i2++) {
            if (input.charAt(parserInput.i + i2) !== tok.charAt(i2)) {
              return false;
            }
          }
          return true;
        } else {
          return tok.test(current);
        }
      };
      parserInput.peekChar = function(tok) {
        return input.charAt(parserInput.i) === tok;
      };
      parserInput.currentChar = function() {
        return input.charAt(parserInput.i);
      };
      parserInput.prevChar = function() {
        return input.charAt(parserInput.i - 1);
      };
      parserInput.getInput = function() {
        return input;
      };
      parserInput.peekNotNumeric = function() {
        var c2 = input.charCodeAt(parserInput.i);
        return c2 > CHARCODE_9 || c2 < CHARCODE_PLUS || c2 === CHARCODE_FORWARD_SLASH || c2 === CHARCODE_COMMA;
      };
      parserInput.start = function(str, chunkInput, failFunction) {
        input = str;
        parserInput.i = j2 = currentPos = furthest = 0;
        if (chunkInput) {
          chunks = chunker(str, failFunction);
        } else {
          chunks = [str];
        }
        current = chunks[0];
        skipWhitespace(0);
      };
      parserInput.end = function() {
        var message2;
        var isFinished = parserInput.i >= input.length;
        if (parserInput.i < furthest) {
          message2 = furthestPossibleErrorMessage;
          parserInput.i = furthest;
        }
        return {
          isFinished,
          furthest: parserInput.i,
          furthestPossibleErrorMessage: message2,
          furthestReachedEnd: parserInput.i >= input.length - 1,
          furthestChar: input[parserInput.i]
        };
      };
      return parserInput;
    };
    var Parser = function Parser2(context, imports, fileInfo) {
      var parsers;
      var parserInput = getParserInput();
      function error(msg, type4) {
        throw new LessError({
          index: parserInput.i,
          filename: fileInfo.filename,
          type: type4 || "Syntax",
          message: msg
        }, imports);
      }
      function expect(arg, msg) {
        var result = arg instanceof Function ? arg.call(parsers) : parserInput.$re(arg);
        if (result) {
          return result;
        }
        error(msg || (typeof arg === "string" ? "expected '" + arg + "' got '" + parserInput.currentChar() + "'" : "unexpected token"));
      }
      function expectChar(arg, msg) {
        if (parserInput.$char(arg)) {
          return arg;
        }
        error(msg || "expected '" + arg + "' got '" + parserInput.currentChar() + "'");
      }
      function getDebugInfo(index2) {
        var filename = fileInfo.filename;
        return {
          lineNumber: getLocation(index2, parserInput.getInput()).line + 1,
          fileName: filename
        };
      }
      function parseNode(str, parseList, currentIndex, fileInfo2, callback) {
        var result;
        var returnNodes = [];
        var parser = parserInput;
        try {
          parser.start(str, false, function fail(msg, index2) {
            callback({
              message: msg,
              index: index2 + currentIndex
            });
          });
          for (var x2 = 0, p2 = void 0, i2 = void 0; p2 = parseList[x2]; x2++) {
            i2 = parser.i;
            result = parsers[p2]();
            if (result) {
              try {
                result._index = i2 + currentIndex;
                result._fileInfo = fileInfo2;
              } catch (e2) {
              }
              returnNodes.push(result);
            } else {
              returnNodes.push(null);
            }
          }
          var endInfo = parser.end();
          if (endInfo.isFinished) {
            callback(null, returnNodes);
          } else {
            callback(true, null);
          }
        } catch (e2) {
          throw new LessError({
            index: e2.index + currentIndex,
            message: e2.message
          }, imports, fileInfo2.filename);
        }
      }
      return {
        parserInput,
        imports,
        fileInfo,
        parseNode,
        parse: function(str, callback, additionalData) {
          var root3;
          var err = null;
          var globalVars;
          var modifyVars;
          var ignored;
          var preText = "";
          if (additionalData && additionalData.disablePluginRule) {
            parsers.plugin = function() {
              var dir = parserInput.$re(/^@plugin?\s+/);
              if (dir) {
                error("@plugin statements are not allowed when disablePluginRule is set to true");
              }
            };
          }
          globalVars = additionalData && additionalData.globalVars ? Parser2.serializeVars(additionalData.globalVars) + "\n" : "";
          modifyVars = additionalData && additionalData.modifyVars ? "\n" + Parser2.serializeVars(additionalData.modifyVars) : "";
          if (context.pluginManager) {
            var preProcessors = context.pluginManager.getPreProcessors();
            for (var i2 = 0; i2 < preProcessors.length; i2++) {
              str = preProcessors[i2].process(str, { context, imports, fileInfo });
            }
          }
          if (globalVars || additionalData && additionalData.banner) {
            preText = (additionalData && additionalData.banner ? additionalData.banner : "") + globalVars;
            ignored = imports.contentsIgnoredChars;
            ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
            ignored[fileInfo.filename] += preText.length;
          }
          str = str.replace(/\r\n?/g, "\n");
          str = preText + str.replace(/^\uFEFF/, "") + modifyVars;
          imports.contents[fileInfo.filename] = str;
          try {
            parserInput.start(str, context.chunkInput, function fail(msg, index2) {
              throw new LessError({
                index: index2,
                type: "Parse",
                message: msg,
                filename: fileInfo.filename
              }, imports);
            });
            tree.Node.prototype.parse = this;
            root3 = new tree.Ruleset(null, this.parsers.primary());
            tree.Node.prototype.rootNode = root3;
            root3.root = true;
            root3.firstRoot = true;
            root3.functionRegistry = functionRegistry.inherit();
          } catch (e2) {
            return callback(new LessError(e2, imports, fileInfo.filename));
          }
          var endInfo = parserInput.end();
          if (!endInfo.isFinished) {
            var message2 = endInfo.furthestPossibleErrorMessage;
            if (!message2) {
              message2 = "Unrecognised input";
              if (endInfo.furthestChar === "}") {
                message2 += ". Possibly missing opening '{'";
              } else if (endInfo.furthestChar === ")") {
                message2 += ". Possibly missing opening '('";
              } else if (endInfo.furthestReachedEnd) {
                message2 += ". Possibly missing something";
              }
            }
            err = new LessError({
              type: "Parse",
              message: message2,
              index: endInfo.furthest,
              filename: fileInfo.filename
            }, imports);
          }
          var finish = function(e2) {
            e2 = err || e2 || imports.error;
            if (e2) {
              if (!(e2 instanceof LessError)) {
                e2 = new LessError(e2, imports, fileInfo.filename);
              }
              return callback(e2);
            } else {
              return callback(null, root3);
            }
          };
          if (context.processImports !== false) {
            new visitors.ImportVisitor(imports, finish).run(root3);
          } else {
            return finish();
          }
        },
        parsers: parsers = {
          primary: function() {
            var mixin = this.mixin;
            var root3 = [];
            var node2;
            while (true) {
              while (true) {
                node2 = this.comment();
                if (!node2) {
                  break;
                }
                root3.push(node2);
              }
              if (parserInput.finished) {
                break;
              }
              if (parserInput.peek("}")) {
                break;
              }
              node2 = this.extendRule();
              if (node2) {
                root3 = root3.concat(node2);
                continue;
              }
              node2 = mixin.definition() || this.declaration() || mixin.call(false, false) || this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();
              if (node2) {
                root3.push(node2);
              } else {
                var foundSemiColon = false;
                while (parserInput.$char(";")) {
                  foundSemiColon = true;
                }
                if (!foundSemiColon) {
                  break;
                }
              }
            }
            return root3;
          },
          comment: function() {
            if (parserInput.commentStore.length) {
              var comment2 = parserInput.commentStore.shift();
              return new tree.Comment(comment2.text, comment2.isLineComment, comment2.index, fileInfo);
            }
          },
          entities: {
            mixinLookup: function() {
              return parsers.mixin.call(true, true);
            },
            quoted: function(forceEscaped) {
              var str;
              var index2 = parserInput.i;
              var isEscaped = false;
              parserInput.save();
              if (parserInput.$char("~")) {
                isEscaped = true;
              } else if (forceEscaped) {
                parserInput.restore();
                return;
              }
              str = parserInput.$quoted();
              if (!str) {
                parserInput.restore();
                return;
              }
              parserInput.forget();
              return new tree.Quoted(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index2, fileInfo);
            },
            keyword: function() {
              var k2 = parserInput.$char("%") || parserInput.$re(/^\[?(?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\]?/);
              if (k2) {
                return tree.Color.fromKeyword(k2) || new tree.Keyword(k2);
              }
            },
            call: function() {
              var name2;
              var args;
              var func;
              var index2 = parserInput.i;
              if (parserInput.peek(/^url\(/i)) {
                return;
              }
              parserInput.save();
              name2 = parserInput.$re(/^([\w-]+|%|~|progid:[\w\.]+)\(/);
              if (!name2) {
                parserInput.forget();
                return;
              }
              name2 = name2[1];
              func = this.customFuncCall(name2);
              if (func) {
                args = func.parse();
                if (args && func.stop) {
                  parserInput.forget();
                  return args;
                }
              }
              args = this.arguments(args);
              if (!parserInput.$char(")")) {
                parserInput.restore("Could not parse call arguments or missing ')'");
                return;
              }
              parserInput.forget();
              return new tree.Call(name2, args, index2, fileInfo);
            },
            customFuncCall: function(name2) {
              return {
                alpha: f3(parsers.ieAlpha, true),
                boolean: f3(condition),
                "if": f3(condition)
              }[name2.toLowerCase()];
              function f3(parse2, stop) {
                return {
                  parse: parse2,
                  stop
                };
              }
              function condition() {
                return [expect(parsers.condition, "expected condition")];
              }
            },
            arguments: function(prevArgs) {
              var argsComma = prevArgs || [];
              var argsSemiColon = [];
              var isSemiColonSeparated;
              var value;
              parserInput.save();
              while (true) {
                if (prevArgs) {
                  prevArgs = false;
                } else {
                  value = parsers.detachedRuleset() || this.assignment() || parsers.expression();
                  if (!value) {
                    break;
                  }
                  if (value.value && value.value.length == 1) {
                    value = value.value[0];
                  }
                  argsComma.push(value);
                }
                if (parserInput.$char(",")) {
                  continue;
                }
                if (parserInput.$char(";") || isSemiColonSeparated) {
                  isSemiColonSeparated = true;
                  value = argsComma.length < 1 ? argsComma[0] : new tree.Value(argsComma);
                  argsSemiColon.push(value);
                  argsComma = [];
                }
              }
              parserInput.forget();
              return isSemiColonSeparated ? argsSemiColon : argsComma;
            },
            literal: function() {
              return this.dimension() || this.color() || this.quoted() || this.unicodeDescriptor();
            },
            assignment: function() {
              var key2;
              var value;
              parserInput.save();
              key2 = parserInput.$re(/^\w+(?=\s?=)/i);
              if (!key2) {
                parserInput.restore();
                return;
              }
              if (!parserInput.$char("=")) {
                parserInput.restore();
                return;
              }
              value = parsers.entity();
              if (value) {
                parserInput.forget();
                return new tree.Assignment(key2, value);
              } else {
                parserInput.restore();
              }
            },
            url: function() {
              var value;
              var index2 = parserInput.i;
              parserInput.autoCommentAbsorb = false;
              if (!parserInput.$str("url(")) {
                parserInput.autoCommentAbsorb = true;
                return;
              }
              value = this.quoted() || this.variable() || this.property() || parserInput.$re(/^(?:(?:\\[\(\)'"])|[^\(\)'"])+/) || "";
              parserInput.autoCommentAbsorb = true;
              expectChar(")");
              return new tree.URL(value.value != null || value instanceof tree.Variable || value instanceof tree.Property ? value : new tree.Anonymous(value, index2), index2, fileInfo);
            },
            variable: function() {
              var ch2;
              var name2;
              var index2 = parserInput.i;
              parserInput.save();
              if (parserInput.currentChar() === "@" && (name2 = parserInput.$re(/^@@?[\w-]+/))) {
                ch2 = parserInput.currentChar();
                if (ch2 === "(" || ch2 === "[" && !parserInput.prevChar().match(/^\s/)) {
                  var result = parsers.variableCall(name2);
                  if (result) {
                    parserInput.forget();
                    return result;
                  }
                }
                parserInput.forget();
                return new tree.Variable(name2, index2, fileInfo);
              }
              parserInput.restore();
            },
            variableCurly: function() {
              var curly;
              var index2 = parserInput.i;
              if (parserInput.currentChar() === "@" && (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
                return new tree.Variable("@" + curly[1], index2, fileInfo);
              }
            },
            property: function() {
              var name2;
              var index2 = parserInput.i;
              if (parserInput.currentChar() === "$" && (name2 = parserInput.$re(/^\$[\w-]+/))) {
                return new tree.Property(name2, index2, fileInfo);
              }
            },
            propertyCurly: function() {
              var curly;
              var index2 = parserInput.i;
              if (parserInput.currentChar() === "$" && (curly = parserInput.$re(/^\$\{([\w-]+)\}/))) {
                return new tree.Property("$" + curly[1], index2, fileInfo);
              }
            },
            color: function() {
              var rgb;
              parserInput.save();
              if (parserInput.currentChar() === "#" && (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\w.#\[])?/))) {
                if (!rgb[2]) {
                  parserInput.forget();
                  return new tree.Color(rgb[1], void 0, rgb[0]);
                }
              }
              parserInput.restore();
            },
            colorKeyword: function() {
              parserInput.save();
              var autoCommentAbsorb = parserInput.autoCommentAbsorb;
              parserInput.autoCommentAbsorb = false;
              var k2 = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);
              parserInput.autoCommentAbsorb = autoCommentAbsorb;
              if (!k2) {
                parserInput.forget();
                return;
              }
              parserInput.restore();
              var color2 = tree.Color.fromKeyword(k2);
              if (color2) {
                parserInput.$str(k2);
                return color2;
              }
            },
            dimension: function() {
              if (parserInput.peekNotNumeric()) {
                return;
              }
              var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
              if (value) {
                return new tree.Dimension(value[1], value[2]);
              }
            },
            unicodeDescriptor: function() {
              var ud2;
              ud2 = parserInput.$re(/^U\+[0-9a-fA-F?]+(\-[0-9a-fA-F?]+)?/);
              if (ud2) {
                return new tree.UnicodeDescriptor(ud2[0]);
              }
            },
            javascript: function() {
              var js;
              var index2 = parserInput.i;
              parserInput.save();
              var escape2 = parserInput.$char("~");
              var jsQuote = parserInput.$char("`");
              if (!jsQuote) {
                parserInput.restore();
                return;
              }
              js = parserInput.$re(/^[^`]*`/);
              if (js) {
                parserInput.forget();
                return new tree.JavaScript(js.substr(0, js.length - 1), Boolean(escape2), index2, fileInfo);
              }
              parserInput.restore("invalid javascript definition");
            }
          },
          variable: function() {
            var name2;
            if (parserInput.currentChar() === "@" && (name2 = parserInput.$re(/^(@[\w-]+)\s*:/))) {
              return name2[1];
            }
          },
          variableCall: function(parsedName) {
            var lookups;
            var i2 = parserInput.i;
            var inValue = !!parsedName;
            var name2 = parsedName;
            parserInput.save();
            if (name2 || parserInput.currentChar() === "@" && (name2 = parserInput.$re(/^(@[\w-]+)(\(\s*\))?/))) {
              lookups = this.mixin.ruleLookups();
              if (!lookups && (inValue && parserInput.$str("()") !== "()" || name2[2] !== "()")) {
                parserInput.restore("Missing '[...]' lookup in variable call");
                return;
              }
              if (!inValue) {
                name2 = name2[1];
              }
              var call2 = new tree.VariableCall(name2, i2, fileInfo);
              if (!inValue && parsers.end()) {
                parserInput.forget();
                return call2;
              } else {
                parserInput.forget();
                return new tree.NamespaceValue(call2, lookups, i2, fileInfo);
              }
            }
            parserInput.restore();
          },
          extend: function(isRule) {
            var elements;
            var e2;
            var index2 = parserInput.i;
            var option;
            var extendList;
            var extend2;
            if (!parserInput.$str(isRule ? "&:extend(" : ":extend(")) {
              return;
            }
            do {
              option = null;
              elements = null;
              while (!(option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
                e2 = this.element();
                if (!e2) {
                  break;
                }
                if (elements) {
                  elements.push(e2);
                } else {
                  elements = [e2];
                }
              }
              option = option && option[1];
              if (!elements) {
                error("Missing target selector for :extend().");
              }
              extend2 = new tree.Extend(new tree.Selector(elements), option, index2, fileInfo);
              if (extendList) {
                extendList.push(extend2);
              } else {
                extendList = [extend2];
              }
            } while (parserInput.$char(","));
            expect(/^\)/);
            if (isRule) {
              expect(/^;/);
            }
            return extendList;
          },
          extendRule: function() {
            return this.extend(true);
          },
          mixin: {
            call: function(inValue, getLookup) {
              var s2 = parserInput.currentChar();
              var important = false;
              var lookups;
              var index2 = parserInput.i;
              var elements;
              var args;
              var hasParens;
              if (s2 !== "." && s2 !== "#") {
                return;
              }
              parserInput.save();
              elements = this.elements();
              if (elements) {
                if (parserInput.$char("(")) {
                  args = this.args(true).args;
                  expectChar(")");
                  hasParens = true;
                }
                if (getLookup !== false) {
                  lookups = this.ruleLookups();
                }
                if (getLookup === true && !lookups) {
                  parserInput.restore();
                  return;
                }
                if (inValue && !lookups && !hasParens) {
                  parserInput.restore();
                  return;
                }
                if (!inValue && parsers.important()) {
                  important = true;
                }
                if (inValue || parsers.end()) {
                  parserInput.forget();
                  var mixin = new tree.mixin.Call(elements, args, index2, fileInfo, !lookups && important);
                  if (lookups) {
                    return new tree.NamespaceValue(mixin, lookups);
                  } else {
                    return mixin;
                  }
                }
              }
              parserInput.restore();
            },
            elements: function() {
              var elements;
              var e2;
              var c2;
              var elem;
              var elemIndex;
              var re2 = /^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;
              while (true) {
                elemIndex = parserInput.i;
                e2 = parserInput.$re(re2);
                if (!e2) {
                  break;
                }
                elem = new tree.Element(c2, e2, false, elemIndex, fileInfo);
                if (elements) {
                  elements.push(elem);
                } else {
                  elements = [elem];
                }
                c2 = parserInput.$char(">");
              }
              return elements;
            },
            args: function(isCall) {
              var entities = parsers.entities;
              var returner = { args: null, variadic: false };
              var expressions = [];
              var argsSemiColon = [];
              var argsComma = [];
              var isSemiColonSeparated;
              var expressionContainsNamed;
              var name2;
              var nameLoop;
              var value;
              var arg;
              var expand;
              var hasSep = true;
              parserInput.save();
              while (true) {
                if (isCall) {
                  arg = parsers.detachedRuleset() || parsers.expression();
                } else {
                  parserInput.commentStore.length = 0;
                  if (parserInput.$str("...")) {
                    returner.variadic = true;
                    if (parserInput.$char(";") && !isSemiColonSeparated) {
                      isSemiColonSeparated = true;
                    }
                    (isSemiColonSeparated ? argsSemiColon : argsComma).push({ variadic: true });
                    break;
                  }
                  arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);
                }
                if (!arg || !hasSep) {
                  break;
                }
                nameLoop = null;
                if (arg.throwAwayComments) {
                  arg.throwAwayComments();
                }
                value = arg;
                var val = null;
                if (isCall) {
                  if (arg.value && arg.value.length == 1) {
                    val = arg.value[0];
                  }
                } else {
                  val = arg;
                }
                if (val && (val instanceof tree.Variable || val instanceof tree.Property)) {
                  if (parserInput.$char(":")) {
                    if (expressions.length > 0) {
                      if (isSemiColonSeparated) {
                        error("Cannot mix ; and , as delimiter types");
                      }
                      expressionContainsNamed = true;
                    }
                    value = parsers.detachedRuleset() || parsers.expression();
                    if (!value) {
                      if (isCall) {
                        error("could not understand value for named argument");
                      } else {
                        parserInput.restore();
                        returner.args = [];
                        return returner;
                      }
                    }
                    nameLoop = name2 = val.name;
                  } else if (parserInput.$str("...")) {
                    if (!isCall) {
                      returner.variadic = true;
                      if (parserInput.$char(";") && !isSemiColonSeparated) {
                        isSemiColonSeparated = true;
                      }
                      (isSemiColonSeparated ? argsSemiColon : argsComma).push({ name: arg.name, variadic: true });
                      break;
                    } else {
                      expand = true;
                    }
                  } else if (!isCall) {
                    name2 = nameLoop = val.name;
                    value = null;
                  }
                }
                if (value) {
                  expressions.push(value);
                }
                argsComma.push({ name: nameLoop, value, expand });
                if (parserInput.$char(",")) {
                  hasSep = true;
                  continue;
                }
                hasSep = parserInput.$char(";") === ";";
                if (hasSep || isSemiColonSeparated) {
                  if (expressionContainsNamed) {
                    error("Cannot mix ; and , as delimiter types");
                  }
                  isSemiColonSeparated = true;
                  if (expressions.length > 1) {
                    value = new tree.Value(expressions);
                  }
                  argsSemiColon.push({ name: name2, value, expand });
                  name2 = null;
                  expressions = [];
                  expressionContainsNamed = false;
                }
              }
              parserInput.forget();
              returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
              return returner;
            },
            definition: function() {
              var name2;
              var params = [];
              var match;
              var ruleset2;
              var cond;
              var variadic = false;
              if (parserInput.currentChar() !== "." && parserInput.currentChar() !== "#" || parserInput.peek(/^[^{]*\}/)) {
                return;
              }
              parserInput.save();
              match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
              if (match) {
                name2 = match[1];
                var argInfo = this.args(false);
                params = argInfo.args;
                variadic = argInfo.variadic;
                if (!parserInput.$char(")")) {
                  parserInput.restore("Missing closing ')'");
                  return;
                }
                parserInput.commentStore.length = 0;
                if (parserInput.$str("when")) {
                  cond = expect(parsers.conditions, "expected condition");
                }
                ruleset2 = parsers.block();
                if (ruleset2) {
                  parserInput.forget();
                  return new tree.mixin.Definition(name2, params, ruleset2, cond, variadic);
                } else {
                  parserInput.restore();
                }
              } else {
                parserInput.restore();
              }
            },
            ruleLookups: function() {
              var rule;
              var lookups = [];
              if (parserInput.currentChar() !== "[") {
                return;
              }
              while (true) {
                parserInput.save();
                rule = this.lookupValue();
                if (!rule && rule !== "") {
                  parserInput.restore();
                  break;
                }
                lookups.push(rule);
                parserInput.forget();
              }
              if (lookups.length > 0) {
                return lookups;
              }
            },
            lookupValue: function() {
              parserInput.save();
              if (!parserInput.$char("[")) {
                parserInput.restore();
                return;
              }
              var name2 = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);
              if (!parserInput.$char("]")) {
                parserInput.restore();
                return;
              }
              if (name2 || name2 === "") {
                parserInput.forget();
                return name2;
              }
              parserInput.restore();
            }
          },
          entity: function() {
            var entities = this.entities;
            return this.comment() || entities.literal() || entities.variable() || entities.url() || entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) || entities.javascript();
          },
          end: function() {
            return parserInput.$char(";") || parserInput.peek("}");
          },
          ieAlpha: function() {
            var value;
            if (!parserInput.$re(/^opacity=/i)) {
              return;
            }
            value = parserInput.$re(/^\d+/);
            if (!value) {
              value = expect(parsers.entities.variable, "Could not parse alpha");
              value = "@{" + value.name.slice(1) + "}";
            }
            expectChar(")");
            return new tree.Quoted("", "alpha(opacity=" + value + ")");
          },
          element: function() {
            var e2;
            var c2;
            var v2;
            var index2 = parserInput.i;
            c2 = this.combinator();
            e2 = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) || parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) || parserInput.$char("*") || parserInput.$char("&") || this.attribute() || parserInput.$re(/^\([^&()@]+\)/) || parserInput.$re(/^[\.#:](?=@)/) || this.entities.variableCurly();
            if (!e2) {
              parserInput.save();
              if (parserInput.$char("(")) {
                if ((v2 = this.selector(false)) && parserInput.$char(")")) {
                  e2 = new tree.Paren(v2);
                  parserInput.forget();
                } else {
                  parserInput.restore("Missing closing ')'");
                }
              } else {
                parserInput.forget();
              }
            }
            if (e2) {
              return new tree.Element(c2, e2, e2 instanceof tree.Variable, index2, fileInfo);
            }
          },
          combinator: function() {
            var c2 = parserInput.currentChar();
            if (c2 === "/") {
              parserInput.save();
              var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
              if (slashedCombinator) {
                parserInput.forget();
                return new tree.Combinator(slashedCombinator);
              }
              parserInput.restore();
            }
            if (c2 === ">" || c2 === "+" || c2 === "~" || c2 === "|" || c2 === "^") {
              parserInput.i++;
              if (c2 === "^" && parserInput.currentChar() === "^") {
                c2 = "^^";
                parserInput.i++;
              }
              while (parserInput.isWhitespace()) {
                parserInput.i++;
              }
              return new tree.Combinator(c2);
            } else if (parserInput.isWhitespace(-1)) {
              return new tree.Combinator(" ");
            } else {
              return new tree.Combinator(null);
            }
          },
          selector: function(isLess) {
            var index2 = parserInput.i;
            var elements;
            var extendList;
            var c2;
            var e2;
            var allExtends;
            var when;
            var condition;
            isLess = isLess !== false;
            while (isLess && (extendList = this.extend()) || isLess && (when = parserInput.$str("when")) || (e2 = this.element())) {
              if (when) {
                condition = expect(this.conditions, "expected condition");
              } else if (condition) {
                error("CSS guard can only be used at the end of selector");
              } else if (extendList) {
                if (allExtends) {
                  allExtends = allExtends.concat(extendList);
                } else {
                  allExtends = extendList;
                }
              } else {
                if (allExtends) {
                  error("Extend can only be used at the end of selector");
                }
                c2 = parserInput.currentChar();
                if (elements) {
                  elements.push(e2);
                } else {
                  elements = [e2];
                }
                e2 = null;
              }
              if (c2 === "{" || c2 === "}" || c2 === ";" || c2 === "," || c2 === ")") {
                break;
              }
            }
            if (elements) {
              return new tree.Selector(elements, allExtends, condition, index2, fileInfo);
            }
            if (allExtends) {
              error("Extend must be used to extend a selector, it cannot be used on its own");
            }
          },
          selectors: function() {
            var s2;
            var selectors;
            while (true) {
              s2 = this.selector();
              if (!s2) {
                break;
              }
              if (selectors) {
                selectors.push(s2);
              } else {
                selectors = [s2];
              }
              parserInput.commentStore.length = 0;
              if (s2.condition && selectors.length > 1) {
                error("Guards are only currently allowed on a single selector.");
              }
              if (!parserInput.$char(",")) {
                break;
              }
              if (s2.condition) {
                error("Guards are only currently allowed on a single selector.");
              }
              parserInput.commentStore.length = 0;
            }
            return selectors;
          },
          attribute: function() {
            if (!parserInput.$char("[")) {
              return;
            }
            var entities = this.entities;
            var key2;
            var val;
            var op;
            var cif;
            if (!(key2 = entities.variableCurly())) {
              key2 = expect(/^(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
            }
            op = parserInput.$re(/^[|~*$^]?=/);
            if (op) {
              val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
              if (val) {
                cif = parserInput.$re(/^[iIsS]/);
              }
            }
            expectChar("]");
            return new tree.Attribute(key2, op, val, cif);
          },
          block: function() {
            var content;
            if (parserInput.$char("{") && (content = this.primary()) && parserInput.$char("}")) {
              return content;
            }
          },
          blockRuleset: function() {
            var block = this.block();
            if (block) {
              block = new tree.Ruleset(null, block);
            }
            return block;
          },
          detachedRuleset: function() {
            var argInfo;
            var params;
            var variadic;
            parserInput.save();
            if (parserInput.$re(/^[.#]\(/)) {
              argInfo = this.mixin.args(false);
              params = argInfo.args;
              variadic = argInfo.variadic;
              if (!parserInput.$char(")")) {
                parserInput.restore();
                return;
              }
            }
            var blockRuleset = this.blockRuleset();
            if (blockRuleset) {
              parserInput.forget();
              if (params) {
                return new tree.mixin.Definition(null, params, blockRuleset, null, variadic);
              }
              return new tree.DetachedRuleset(blockRuleset);
            }
            parserInput.restore();
          },
          ruleset: function() {
            var selectors;
            var rules2;
            var debugInfo2;
            parserInput.save();
            if (context.dumpLineNumbers) {
              debugInfo2 = getDebugInfo(parserInput.i);
            }
            selectors = this.selectors();
            if (selectors && (rules2 = this.block())) {
              parserInput.forget();
              var ruleset2 = new tree.Ruleset(selectors, rules2, context.strictImports);
              if (context.dumpLineNumbers) {
                ruleset2.debugInfo = debugInfo2;
              }
              return ruleset2;
            } else {
              parserInput.restore();
            }
          },
          declaration: function() {
            var name2;
            var value;
            var index2 = parserInput.i;
            var hasDR;
            var c2 = parserInput.currentChar();
            var important;
            var merge4;
            var isVariable;
            if (c2 === "." || c2 === "#" || c2 === "&" || c2 === ":") {
              return;
            }
            parserInput.save();
            name2 = this.variable() || this.ruleProperty();
            if (name2) {
              isVariable = typeof name2 === "string";
              if (isVariable) {
                value = this.detachedRuleset();
                if (value) {
                  hasDR = true;
                }
              }
              parserInput.commentStore.length = 0;
              if (!value) {
                merge4 = !isVariable && name2.length > 1 && name2.pop().value;
                if (name2[0].value && name2[0].value.slice(0, 2) === "--") {
                  value = this.permissiveValue();
                } else {
                  value = this.anonymousValue();
                }
                if (value) {
                  parserInput.forget();
                  return new tree.Declaration(name2, value, false, merge4, index2, fileInfo);
                }
                if (!value) {
                  value = this.value();
                }
                if (value) {
                  important = this.important();
                } else if (isVariable) {
                  value = this.permissiveValue();
                }
              }
              if (value && (this.end() || hasDR)) {
                parserInput.forget();
                return new tree.Declaration(name2, value, important, merge4, index2, fileInfo);
              } else {
                parserInput.restore();
              }
            } else {
              parserInput.restore();
            }
          },
          anonymousValue: function() {
            var index2 = parserInput.i;
            var match = parserInput.$re(/^([^.#@\$+\/'"*`(;{}-]*);/);
            if (match) {
              return new tree.Anonymous(match[1], index2);
            }
          },
          permissiveValue: function(untilTokens) {
            var i2;
            var e2;
            var done;
            var value;
            var tok = untilTokens || ";";
            var index2 = parserInput.i;
            var result = [];
            function testCurrentChar() {
              var char2 = parserInput.currentChar();
              if (typeof tok === "string") {
                return char2 === tok;
              } else {
                return tok.test(char2);
              }
            }
            if (testCurrentChar()) {
              return;
            }
            value = [];
            do {
              e2 = this.comment();
              if (e2) {
                value.push(e2);
                continue;
              }
              e2 = this.entity();
              if (e2) {
                value.push(e2);
              }
            } while (e2);
            done = testCurrentChar();
            if (value.length > 0) {
              value = new tree.Expression(value);
              if (done) {
                return value;
              } else {
                result.push(value);
              }
              if (parserInput.prevChar() === " ") {
                result.push(new tree.Anonymous(" ", index2));
              }
            }
            parserInput.save();
            value = parserInput.$parseUntil(tok);
            if (value) {
              if (typeof value === "string") {
                error("Expected '" + value + "'", "Parse");
              }
              if (value.length === 1 && value[0] === " ") {
                parserInput.forget();
                return new tree.Anonymous("", index2);
              }
              var item = void 0;
              for (i2 = 0; i2 < value.length; i2++) {
                item = value[i2];
                if (Array.isArray(item)) {
                  result.push(new tree.Quoted(item[0], item[1], true, index2, fileInfo));
                } else {
                  if (i2 === value.length - 1) {
                    item = item.trim();
                  }
                  var quote = new tree.Quoted("'", item, true, index2, fileInfo);
                  quote.variableRegex = /@([\w-]+)/g;
                  quote.propRegex = /\$([\w-]+)/g;
                  result.push(quote);
                }
              }
              parserInput.forget();
              return new tree.Expression(result, true);
            }
            parserInput.restore();
          },
          "import": function() {
            var path2;
            var features;
            var index2 = parserInput.i;
            var dir = parserInput.$re(/^@import\s+/);
            if (dir) {
              var options2 = (dir ? this.importOptions() : null) || {};
              if (path2 = this.entities.quoted() || this.entities.url()) {
                features = this.mediaFeatures();
                if (!parserInput.$char(";")) {
                  parserInput.i = index2;
                  error("missing semi-colon or unrecognised media features on import");
                }
                features = features && new tree.Value(features);
                return new tree.Import(path2, features, options2, index2, fileInfo);
              } else {
                parserInput.i = index2;
                error("malformed import statement");
              }
            }
          },
          importOptions: function() {
            var o2;
            var options2 = {};
            var optionName;
            var value;
            if (!parserInput.$char("(")) {
              return null;
            }
            do {
              o2 = this.importOption();
              if (o2) {
                optionName = o2;
                value = true;
                switch (optionName) {
                  case "css":
                    optionName = "less";
                    value = false;
                    break;
                  case "once":
                    optionName = "multiple";
                    value = false;
                    break;
                }
                options2[optionName] = value;
                if (!parserInput.$char(",")) {
                  break;
                }
              }
            } while (o2);
            expectChar(")");
            return options2;
          },
          importOption: function() {
            var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
            if (opt) {
              return opt[1];
            }
          },
          mediaFeature: function() {
            var entities = this.entities;
            var nodes = [];
            var e2;
            var p2;
            parserInput.save();
            do {
              e2 = entities.keyword() || entities.variable() || entities.mixinLookup();
              if (e2) {
                nodes.push(e2);
              } else if (parserInput.$char("(")) {
                p2 = this.property();
                e2 = this.value();
                if (parserInput.$char(")")) {
                  if (p2 && e2) {
                    nodes.push(new tree.Paren(new tree.Declaration(p2, e2, null, null, parserInput.i, fileInfo, true)));
                  } else if (e2) {
                    nodes.push(new tree.Paren(e2));
                  } else {
                    error("badly formed media feature definition");
                  }
                } else {
                  error("Missing closing ')'", "Parse");
                }
              }
            } while (e2);
            parserInput.forget();
            if (nodes.length > 0) {
              return new tree.Expression(nodes);
            }
          },
          mediaFeatures: function() {
            var entities = this.entities;
            var features = [];
            var e2;
            do {
              e2 = this.mediaFeature();
              if (e2) {
                features.push(e2);
                if (!parserInput.$char(",")) {
                  break;
                }
              } else {
                e2 = entities.variable() || entities.mixinLookup();
                if (e2) {
                  features.push(e2);
                  if (!parserInput.$char(",")) {
                    break;
                  }
                }
              }
            } while (e2);
            return features.length > 0 ? features : null;
          },
          media: function() {
            var features;
            var rules2;
            var media;
            var debugInfo2;
            var index2 = parserInput.i;
            if (context.dumpLineNumbers) {
              debugInfo2 = getDebugInfo(index2);
            }
            parserInput.save();
            if (parserInput.$str("@media")) {
              features = this.mediaFeatures();
              rules2 = this.block();
              if (!rules2) {
                error("media definitions require block statements after any features");
              }
              parserInput.forget();
              media = new tree.Media(rules2, features, index2, fileInfo);
              if (context.dumpLineNumbers) {
                media.debugInfo = debugInfo2;
              }
              return media;
            }
            parserInput.restore();
          },
          plugin: function() {
            var path2;
            var args;
            var options2;
            var index2 = parserInput.i;
            var dir = parserInput.$re(/^@plugin\s+/);
            if (dir) {
              args = this.pluginArgs();
              if (args) {
                options2 = {
                  pluginArgs: args,
                  isPlugin: true
                };
              } else {
                options2 = { isPlugin: true };
              }
              if (path2 = this.entities.quoted() || this.entities.url()) {
                if (!parserInput.$char(";")) {
                  parserInput.i = index2;
                  error("missing semi-colon on @plugin");
                }
                return new tree.Import(path2, null, options2, index2, fileInfo);
              } else {
                parserInput.i = index2;
                error("malformed @plugin statement");
              }
            }
          },
          pluginArgs: function() {
            parserInput.save();
            if (!parserInput.$char("(")) {
              parserInput.restore();
              return null;
            }
            var args = parserInput.$re(/^\s*([^\);]+)\)\s*/);
            if (args[1]) {
              parserInput.forget();
              return args[1].trim();
            } else {
              parserInput.restore();
              return null;
            }
          },
          atrule: function() {
            var index2 = parserInput.i;
            var name2;
            var value;
            var rules2;
            var nonVendorSpecificName;
            var hasIdentifier;
            var hasExpression;
            var hasUnknown;
            var hasBlock = true;
            var isRooted = true;
            if (parserInput.currentChar() !== "@") {
              return;
            }
            value = this["import"]() || this.plugin() || this.media();
            if (value) {
              return value;
            }
            parserInput.save();
            name2 = parserInput.$re(/^@[a-z-]+/);
            if (!name2) {
              return;
            }
            nonVendorSpecificName = name2;
            if (name2.charAt(1) == "-" && name2.indexOf("-", 2) > 0) {
              nonVendorSpecificName = "@" + name2.slice(name2.indexOf("-", 2) + 1);
            }
            switch (nonVendorSpecificName) {
              case "@charset":
                hasIdentifier = true;
                hasBlock = false;
                break;
              case "@namespace":
                hasExpression = true;
                hasBlock = false;
                break;
              case "@keyframes":
              case "@counter-style":
                hasIdentifier = true;
                break;
              case "@document":
              case "@supports":
                hasUnknown = true;
                isRooted = false;
                break;
              default:
                hasUnknown = true;
                break;
            }
            parserInput.commentStore.length = 0;
            if (hasIdentifier) {
              value = this.entity();
              if (!value) {
                error("expected " + name2 + " identifier");
              }
            } else if (hasExpression) {
              value = this.expression();
              if (!value) {
                error("expected " + name2 + " expression");
              }
            } else if (hasUnknown) {
              value = this.permissiveValue(/^[{;]/);
              hasBlock = parserInput.currentChar() === "{";
              if (!value) {
                if (!hasBlock && parserInput.currentChar() !== ";") {
                  error(name2 + " rule is missing block or ending semi-colon");
                }
              } else if (!value.value) {
                value = null;
              }
            }
            if (hasBlock) {
              rules2 = this.blockRuleset();
            }
            if (rules2 || !hasBlock && value && parserInput.$char(";")) {
              parserInput.forget();
              return new tree.AtRule(name2, value, rules2, index2, fileInfo, context.dumpLineNumbers ? getDebugInfo(index2) : null, isRooted);
            }
            parserInput.restore("at-rule options not recognised");
          },
          value: function() {
            var e2;
            var expressions = [];
            var index2 = parserInput.i;
            do {
              e2 = this.expression();
              if (e2) {
                expressions.push(e2);
                if (!parserInput.$char(",")) {
                  break;
                }
              }
            } while (e2);
            if (expressions.length > 0) {
              return new tree.Value(expressions, index2);
            }
          },
          important: function() {
            if (parserInput.currentChar() === "!") {
              return parserInput.$re(/^! *important/);
            }
          },
          sub: function() {
            var a2;
            var e2;
            parserInput.save();
            if (parserInput.$char("(")) {
              a2 = this.addition();
              if (a2 && parserInput.$char(")")) {
                parserInput.forget();
                e2 = new tree.Expression([a2]);
                e2.parens = true;
                return e2;
              }
              parserInput.restore("Expected ')'");
              return;
            }
            parserInput.restore();
          },
          multiplication: function() {
            var m2;
            var a2;
            var op;
            var operation;
            var isSpaced;
            m2 = this.operand();
            if (m2) {
              isSpaced = parserInput.isWhitespace(-1);
              while (true) {
                if (parserInput.peek(/^\/[*\/]/)) {
                  break;
                }
                parserInput.save();
                op = parserInput.$char("/") || parserInput.$char("*") || parserInput.$str("./");
                if (!op) {
                  parserInput.forget();
                  break;
                }
                a2 = this.operand();
                if (!a2) {
                  parserInput.restore();
                  break;
                }
                parserInput.forget();
                m2.parensInOp = true;
                a2.parensInOp = true;
                operation = new tree.Operation(op, [operation || m2, a2], isSpaced);
                isSpaced = parserInput.isWhitespace(-1);
              }
              return operation || m2;
            }
          },
          addition: function() {
            var m2;
            var a2;
            var op;
            var operation;
            var isSpaced;
            m2 = this.multiplication();
            if (m2) {
              isSpaced = parserInput.isWhitespace(-1);
              while (true) {
                op = parserInput.$re(/^[-+]\s+/) || !isSpaced && (parserInput.$char("+") || parserInput.$char("-"));
                if (!op) {
                  break;
                }
                a2 = this.multiplication();
                if (!a2) {
                  break;
                }
                m2.parensInOp = true;
                a2.parensInOp = true;
                operation = new tree.Operation(op, [operation || m2, a2], isSpaced);
                isSpaced = parserInput.isWhitespace(-1);
              }
              return operation || m2;
            }
          },
          conditions: function() {
            var a2;
            var b2;
            var index2 = parserInput.i;
            var condition;
            a2 = this.condition(true);
            if (a2) {
              while (true) {
                if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(",")) {
                  break;
                }
                b2 = this.condition(true);
                if (!b2) {
                  break;
                }
                condition = new tree.Condition("or", condition || a2, b2, index2);
              }
              return condition || a2;
            }
          },
          condition: function(needsParens) {
            var result;
            var logical;
            var next2;
            function or() {
              return parserInput.$str("or");
            }
            result = this.conditionAnd(needsParens);
            if (!result) {
              return;
            }
            logical = or();
            if (logical) {
              next2 = this.condition(needsParens);
              if (next2) {
                result = new tree.Condition(logical, result, next2);
              } else {
                return;
              }
            }
            return result;
          },
          conditionAnd: function(needsParens) {
            var result;
            var logical;
            var next2;
            var self2 = this;
            function insideCondition() {
              var cond = self2.negatedCondition(needsParens) || self2.parenthesisCondition(needsParens);
              if (!cond && !needsParens) {
                return self2.atomicCondition(needsParens);
              }
              return cond;
            }
            function and() {
              return parserInput.$str("and");
            }
            result = insideCondition();
            if (!result) {
              return;
            }
            logical = and();
            if (logical) {
              next2 = this.conditionAnd(needsParens);
              if (next2) {
                result = new tree.Condition(logical, result, next2);
              } else {
                return;
              }
            }
            return result;
          },
          negatedCondition: function(needsParens) {
            if (parserInput.$str("not")) {
              var result = this.parenthesisCondition(needsParens);
              if (result) {
                result.negate = !result.negate;
              }
              return result;
            }
          },
          parenthesisCondition: function(needsParens) {
            function tryConditionFollowedByParenthesis(me2) {
              var body2;
              parserInput.save();
              body2 = me2.condition(needsParens);
              if (!body2) {
                parserInput.restore();
                return;
              }
              if (!parserInput.$char(")")) {
                parserInput.restore();
                return;
              }
              parserInput.forget();
              return body2;
            }
            var body;
            parserInput.save();
            if (!parserInput.$str("(")) {
              parserInput.restore();
              return;
            }
            body = tryConditionFollowedByParenthesis(this);
            if (body) {
              parserInput.forget();
              return body;
            }
            body = this.atomicCondition(needsParens);
            if (!body) {
              parserInput.restore();
              return;
            }
            if (!parserInput.$char(")")) {
              parserInput.restore("expected ')' got '" + parserInput.currentChar() + "'");
              return;
            }
            parserInput.forget();
            return body;
          },
          atomicCondition: function(needsParens) {
            var entities = this.entities;
            var index2 = parserInput.i;
            var a2;
            var b2;
            var c2;
            var op;
            function cond() {
              return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();
            }
            cond = cond.bind(this);
            a2 = cond();
            if (a2) {
              if (parserInput.$char(">")) {
                if (parserInput.$char("=")) {
                  op = ">=";
                } else {
                  op = ">";
                }
              } else if (parserInput.$char("<")) {
                if (parserInput.$char("=")) {
                  op = "<=";
                } else {
                  op = "<";
                }
              } else if (parserInput.$char("=")) {
                if (parserInput.$char(">")) {
                  op = "=>";
                } else if (parserInput.$char("<")) {
                  op = "=<";
                } else {
                  op = "=";
                }
              }
              if (op) {
                b2 = cond();
                if (b2) {
                  c2 = new tree.Condition(op, a2, b2, index2, false);
                } else {
                  error("expected expression");
                }
              } else {
                c2 = new tree.Condition("=", a2, new tree.Keyword("true"), index2, false);
              }
              return c2;
            }
          },
          operand: function() {
            var entities = this.entities;
            var negate;
            if (parserInput.peek(/^-[@\$\(]/)) {
              negate = parserInput.$char("-");
            }
            var o2 = this.sub() || entities.dimension() || entities.color() || entities.variable() || entities.property() || entities.call() || entities.quoted(true) || entities.colorKeyword() || entities.mixinLookup();
            if (negate) {
              o2.parensInOp = true;
              o2 = new tree.Negative(o2);
            }
            return o2;
          },
          expression: function() {
            var entities = [];
            var e2;
            var delim;
            var index2 = parserInput.i;
            do {
              e2 = this.comment();
              if (e2) {
                entities.push(e2);
                continue;
              }
              e2 = this.addition() || this.entity();
              if (e2 instanceof tree.Comment) {
                e2 = null;
              }
              if (e2) {
                entities.push(e2);
                if (!parserInput.peek(/^\/[\/*]/)) {
                  delim = parserInput.$char("/");
                  if (delim) {
                    entities.push(new tree.Anonymous(delim, index2));
                  }
                }
              }
            } while (e2);
            if (entities.length > 0) {
              return new tree.Expression(entities);
            }
          },
          property: function() {
            var name2 = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
            if (name2) {
              return name2[1];
            }
          },
          ruleProperty: function() {
            var name2 = [];
            var index2 = [];
            var s2;
            var k2;
            parserInput.save();
            var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
            if (simpleProperty) {
              name2 = [new tree.Keyword(simpleProperty[1])];
              parserInput.forget();
              return name2;
            }
            function match(re2) {
              var i2 = parserInput.i;
              var chunk = parserInput.$re(re2);
              if (chunk) {
                index2.push(i2);
                return name2.push(chunk[1]);
              }
            }
            match(/^(\*?)/);
            while (true) {
              if (!match(/^((?:[\w-]+)|(?:[@\$]\{[\w-]+\}))/)) {
                break;
              }
            }
            if (name2.length > 1 && match(/^((?:\+_|\+)?)\s*:/)) {
              parserInput.forget();
              if (name2[0] === "") {
                name2.shift();
                index2.shift();
              }
              for (k2 = 0; k2 < name2.length; k2++) {
                s2 = name2[k2];
                name2[k2] = s2.charAt(0) !== "@" && s2.charAt(0) !== "$" ? new tree.Keyword(s2) : s2.charAt(0) === "@" ? new tree.Variable("@" + s2.slice(2, -1), index2[k2], fileInfo) : new tree.Property("$" + s2.slice(2, -1), index2[k2], fileInfo);
              }
              return name2;
            }
            parserInput.restore();
          }
        }
      };
    };
    Parser.serializeVars = function(vars) {
      var s2 = "";
      for (var name_1 in vars) {
        if (Object.hasOwnProperty.call(vars, name_1)) {
          var value = vars[name_1];
          s2 += (name_1[0] === "@" ? "" : "@") + name_1 + ": " + value + (String(value).slice(-1) === ";" ? "" : ";");
        }
      }
      return s2;
    };
    function boolean(condition) {
      return condition ? Keyword.True : Keyword.False;
    }
    function If2(context, condition, trueValue, falseValue) {
      return condition.eval(context) ? trueValue.eval(context) : falseValue ? falseValue.eval(context) : new Anonymous();
    }
    If2.evalArgs = false;
    function isdefined(context, variable) {
      try {
        variable.eval(context);
        return Keyword.True;
      } catch (e2) {
        return Keyword.False;
      }
    }
    isdefined.evalArgs = false;
    var boolean$1 = { isdefined, boolean, "if": If2 };
    var colorFunctions;
    function clamp2(val) {
      return Math.min(1, Math.max(0, val));
    }
    function hsla(origColor, hsl) {
      var color2 = colorFunctions.hsla(hsl.h, hsl.s, hsl.l, hsl.a);
      if (color2) {
        if (origColor.value && /^(rgb|hsl)/.test(origColor.value)) {
          color2.value = origColor.value;
        } else {
          color2.value = "rgb";
        }
        return color2;
      }
    }
    function toHSL(color2) {
      if (color2.toHSL) {
        return color2.toHSL();
      } else {
        throw new Error("Argument cannot be evaluated to a color");
      }
    }
    function toHSV(color2) {
      if (color2.toHSV) {
        return color2.toHSV();
      } else {
        throw new Error("Argument cannot be evaluated to a color");
      }
    }
    function number$1(n2) {
      if (n2 instanceof Dimension) {
        return parseFloat(n2.unit.is("%") ? n2.value / 100 : n2.value);
      } else if (typeof n2 === "number") {
        return n2;
      } else {
        throw {
          type: "Argument",
          message: "color functions take numbers as parameters"
        };
      }
    }
    function scaled(n2, size) {
      if (n2 instanceof Dimension && n2.unit.is("%")) {
        return parseFloat(n2.value * size / 100);
      } else {
        return number$1(n2);
      }
    }
    colorFunctions = {
      rgb: function(r2, g2, b2) {
        var a2 = 1;
        if (r2 instanceof Expression) {
          var val = r2.value;
          r2 = val[0];
          g2 = val[1];
          b2 = val[2];
          if (b2 instanceof Operation) {
            var op = b2;
            b2 = op.operands[0];
            a2 = op.operands[1];
          }
        }
        var color2 = colorFunctions.rgba(r2, g2, b2, a2);
        if (color2) {
          color2.value = "rgb";
          return color2;
        }
      },
      rgba: function(r2, g2, b2, a2) {
        try {
          if (r2 instanceof Color) {
            if (g2) {
              a2 = number$1(g2);
            } else {
              a2 = r2.alpha;
            }
            return new Color(r2.rgb, a2, "rgba");
          }
          var rgb = [r2, g2, b2].map(function(c2) {
            return scaled(c2, 255);
          });
          a2 = number$1(a2);
          return new Color(rgb, a2, "rgba");
        } catch (e2) {
        }
      },
      hsl: function(h2, s2, l2) {
        var a2 = 1;
        if (h2 instanceof Expression) {
          var val = h2.value;
          h2 = val[0];
          s2 = val[1];
          l2 = val[2];
          if (l2 instanceof Operation) {
            var op = l2;
            l2 = op.operands[0];
            a2 = op.operands[1];
          }
        }
        var color2 = colorFunctions.hsla(h2, s2, l2, a2);
        if (color2) {
          color2.value = "hsl";
          return color2;
        }
      },
      hsla: function(h2, s2, l2, a2) {
        try {
          let hue2 = function(h3) {
            h3 = h3 < 0 ? h3 + 1 : h3 > 1 ? h3 - 1 : h3;
            if (h3 * 6 < 1) {
              return m1_1 + (m2_1 - m1_1) * h3 * 6;
            } else if (h3 * 2 < 1) {
              return m2_1;
            } else if (h3 * 3 < 2) {
              return m1_1 + (m2_1 - m1_1) * (2 / 3 - h3) * 6;
            } else {
              return m1_1;
            }
          };
          var hue = hue2;
          if (h2 instanceof Color) {
            if (s2) {
              a2 = number$1(s2);
            } else {
              a2 = h2.alpha;
            }
            return new Color(h2.rgb, a2, "hsla");
          }
          var m1_1;
          var m2_1;
          h2 = number$1(h2) % 360 / 360;
          s2 = clamp2(number$1(s2));
          l2 = clamp2(number$1(l2));
          a2 = clamp2(number$1(a2));
          m2_1 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
          m1_1 = l2 * 2 - m2_1;
          var rgb = [
            hue2(h2 + 1 / 3) * 255,
            hue2(h2) * 255,
            hue2(h2 - 1 / 3) * 255
          ];
          a2 = number$1(a2);
          return new Color(rgb, a2, "hsla");
        } catch (e2) {
        }
      },
      hsv: function(h2, s2, v2) {
        return colorFunctions.hsva(h2, s2, v2, 1);
      },
      hsva: function(h2, s2, v2, a2) {
        h2 = number$1(h2) % 360 / 360 * 360;
        s2 = number$1(s2);
        v2 = number$1(v2);
        a2 = number$1(a2);
        var i2;
        var f3;
        i2 = Math.floor(h2 / 60 % 6);
        f3 = h2 / 60 - i2;
        var vs = [
          v2,
          v2 * (1 - s2),
          v2 * (1 - f3 * s2),
          v2 * (1 - (1 - f3) * s2)
        ];
        var perm = [
          [0, 3, 1],
          [2, 0, 1],
          [1, 0, 3],
          [1, 2, 0],
          [3, 1, 0],
          [0, 1, 2]
        ];
        return colorFunctions.rgba(vs[perm[i2][0]] * 255, vs[perm[i2][1]] * 255, vs[perm[i2][2]] * 255, a2);
      },
      hue: function(color2) {
        return new Dimension(toHSL(color2).h);
      },
      saturation: function(color2) {
        return new Dimension(toHSL(color2).s * 100, "%");
      },
      lightness: function(color2) {
        return new Dimension(toHSL(color2).l * 100, "%");
      },
      hsvhue: function(color2) {
        return new Dimension(toHSV(color2).h);
      },
      hsvsaturation: function(color2) {
        return new Dimension(toHSV(color2).s * 100, "%");
      },
      hsvvalue: function(color2) {
        return new Dimension(toHSV(color2).v * 100, "%");
      },
      red: function(color2) {
        return new Dimension(color2.rgb[0]);
      },
      green: function(color2) {
        return new Dimension(color2.rgb[1]);
      },
      blue: function(color2) {
        return new Dimension(color2.rgb[2]);
      },
      alpha: function(color2) {
        return new Dimension(toHSL(color2).a);
      },
      luma: function(color2) {
        return new Dimension(color2.luma() * color2.alpha * 100, "%");
      },
      luminance: function(color2) {
        var luminance = 0.2126 * color2.rgb[0] / 255 + 0.7152 * color2.rgb[1] / 255 + 0.0722 * color2.rgb[2] / 255;
        return new Dimension(luminance * color2.alpha * 100, "%");
      },
      saturate: function(color2, amount, method4) {
        if (!color2.rgb) {
          return null;
        }
        var hsl = toHSL(color2);
        if (typeof method4 !== "undefined" && method4.value === "relative") {
          hsl.s += hsl.s * amount.value / 100;
        } else {
          hsl.s += amount.value / 100;
        }
        hsl.s = clamp2(hsl.s);
        return hsla(color2, hsl);
      },
      desaturate: function(color2, amount, method4) {
        var hsl = toHSL(color2);
        if (typeof method4 !== "undefined" && method4.value === "relative") {
          hsl.s -= hsl.s * amount.value / 100;
        } else {
          hsl.s -= amount.value / 100;
        }
        hsl.s = clamp2(hsl.s);
        return hsla(color2, hsl);
      },
      lighten: function(color2, amount, method4) {
        var hsl = toHSL(color2);
        if (typeof method4 !== "undefined" && method4.value === "relative") {
          hsl.l += hsl.l * amount.value / 100;
        } else {
          hsl.l += amount.value / 100;
        }
        hsl.l = clamp2(hsl.l);
        return hsla(color2, hsl);
      },
      darken: function(color2, amount, method4) {
        var hsl = toHSL(color2);
        if (typeof method4 !== "undefined" && method4.value === "relative") {
          hsl.l -= hsl.l * amount.value / 100;
        } else {
          hsl.l -= amount.value / 100;
        }
        hsl.l = clamp2(hsl.l);
        return hsla(color2, hsl);
      },
      fadein: function(color2, amount, method4) {
        var hsl = toHSL(color2);
        if (typeof method4 !== "undefined" && method4.value === "relative") {
          hsl.a += hsl.a * amount.value / 100;
        } else {
          hsl.a += amount.value / 100;
        }
        hsl.a = clamp2(hsl.a);
        return hsla(color2, hsl);
      },
      fadeout: function(color2, amount, method4) {
        var hsl = toHSL(color2);
        if (typeof method4 !== "undefined" && method4.value === "relative") {
          hsl.a -= hsl.a * amount.value / 100;
        } else {
          hsl.a -= amount.value / 100;
        }
        hsl.a = clamp2(hsl.a);
        return hsla(color2, hsl);
      },
      fade: function(color2, amount) {
        var hsl = toHSL(color2);
        hsl.a = amount.value / 100;
        hsl.a = clamp2(hsl.a);
        return hsla(color2, hsl);
      },
      spin: function(color2, amount) {
        var hsl = toHSL(color2);
        var hue = (hsl.h + amount.value) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return hsla(color2, hsl);
      },
      mix: function(color1, color2, weight) {
        if (!weight) {
          weight = new Dimension(50);
        }
        var p2 = weight.value / 100;
        var w2 = p2 * 2 - 1;
        var a2 = toHSL(color1).a - toHSL(color2).a;
        var w1 = ((w2 * a2 == -1 ? w2 : (w2 + a2) / (1 + w2 * a2)) + 1) / 2;
        var w22 = 1 - w1;
        var rgb = [
          color1.rgb[0] * w1 + color2.rgb[0] * w22,
          color1.rgb[1] * w1 + color2.rgb[1] * w22,
          color1.rgb[2] * w1 + color2.rgb[2] * w22
        ];
        var alpha = color1.alpha * p2 + color2.alpha * (1 - p2);
        return new Color(rgb, alpha);
      },
      greyscale: function(color2) {
        return colorFunctions.desaturate(color2, new Dimension(100));
      },
      contrast: function(color2, dark, light, threshold) {
        if (!color2.rgb) {
          return null;
        }
        if (typeof light === "undefined") {
          light = colorFunctions.rgba(255, 255, 255, 1);
        }
        if (typeof dark === "undefined") {
          dark = colorFunctions.rgba(0, 0, 0, 1);
        }
        if (dark.luma() > light.luma()) {
          var t2 = light;
          light = dark;
          dark = t2;
        }
        if (typeof threshold === "undefined") {
          threshold = 0.43;
        } else {
          threshold = number$1(threshold);
        }
        if (color2.luma() < threshold) {
          return light;
        } else {
          return dark;
        }
      },
      argb: function(color2) {
        return new Anonymous(color2.toARGB());
      },
      color: function(c2) {
        if (c2 instanceof Quoted && /^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})$/i.test(c2.value)) {
          var val = c2.value.slice(1);
          return new Color(val, void 0, "#" + val);
        }
        if (c2 instanceof Color || (c2 = Color.fromKeyword(c2.value))) {
          c2.value = void 0;
          return c2;
        }
        throw {
          type: "Argument",
          message: "argument must be a color keyword or 3|4|6|8 digit hex e.g. #FFF"
        };
      },
      tint: function(color2, amount) {
        return colorFunctions.mix(colorFunctions.rgb(255, 255, 255), color2, amount);
      },
      shade: function(color2, amount) {
        return colorFunctions.mix(colorFunctions.rgb(0, 0, 0), color2, amount);
      }
    };
    var color = colorFunctions;
    function colorBlend(mode, color1, color2) {
      var ab2 = color1.alpha;
      var cb2;
      var as = color2.alpha;
      var cs;
      var ar;
      var cr;
      var r2 = [];
      ar = as + ab2 * (1 - as);
      for (var i2 = 0; i2 < 3; i2++) {
        cb2 = color1.rgb[i2] / 255;
        cs = color2.rgb[i2] / 255;
        cr = mode(cb2, cs);
        if (ar) {
          cr = (as * cs + ab2 * (cb2 - as * (cb2 + cs - cr))) / ar;
        }
        r2[i2] = cr * 255;
      }
      return new Color(r2, ar);
    }
    var colorBlendModeFunctions = {
      multiply: function(cb2, cs) {
        return cb2 * cs;
      },
      screen: function(cb2, cs) {
        return cb2 + cs - cb2 * cs;
      },
      overlay: function(cb2, cs) {
        cb2 *= 2;
        return cb2 <= 1 ? colorBlendModeFunctions.multiply(cb2, cs) : colorBlendModeFunctions.screen(cb2 - 1, cs);
      },
      softlight: function(cb2, cs) {
        var d2 = 1;
        var e2 = cb2;
        if (cs > 0.5) {
          e2 = 1;
          d2 = cb2 > 0.25 ? Math.sqrt(cb2) : ((16 * cb2 - 12) * cb2 + 4) * cb2;
        }
        return cb2 - (1 - 2 * cs) * e2 * (d2 - cb2);
      },
      hardlight: function(cb2, cs) {
        return colorBlendModeFunctions.overlay(cs, cb2);
      },
      difference: function(cb2, cs) {
        return Math.abs(cb2 - cs);
      },
      exclusion: function(cb2, cs) {
        return cb2 + cs - 2 * cb2 * cs;
      },
      average: function(cb2, cs) {
        return (cb2 + cs) / 2;
      },
      negation: function(cb2, cs) {
        return 1 - Math.abs(cb2 + cs - 1);
      }
    };
    for (var f$12 in colorBlendModeFunctions) {
      if (colorBlendModeFunctions.hasOwnProperty(f$12)) {
        colorBlend[f$12] = colorBlend.bind(null, colorBlendModeFunctions[f$12]);
      }
    }
    var dataUri = function(environment) {
      var fallback = function(functionThis, node2) {
        return new URL2(node2, functionThis.index, functionThis.currentFileInfo).eval(functionThis.context);
      };
      return { "data-uri": function(mimetypeNode, filePathNode) {
        if (!filePathNode) {
          filePathNode = mimetypeNode;
          mimetypeNode = null;
        }
        var mimetype = mimetypeNode && mimetypeNode.value;
        var filePath = filePathNode.value;
        var currentFileInfo = this.currentFileInfo;
        var currentDirectory = currentFileInfo.rewriteUrls ? currentFileInfo.currentDirectory : currentFileInfo.entryPath;
        var fragmentStart = filePath.indexOf("#");
        var fragment = "";
        if (fragmentStart !== -1) {
          fragment = filePath.slice(fragmentStart);
          filePath = filePath.slice(0, fragmentStart);
        }
        var context = clone2(this.context);
        context.rawBuffer = true;
        var fileManager = environment.getFileManager(filePath, currentDirectory, context, environment, true);
        if (!fileManager) {
          return fallback(this, filePathNode);
        }
        var useBase64 = false;
        if (!mimetypeNode) {
          mimetype = environment.mimeLookup(filePath);
          if (mimetype === "image/svg+xml") {
            useBase64 = false;
          } else {
            var charset = environment.charsetLookup(mimetype);
            useBase64 = ["US-ASCII", "UTF-8"].indexOf(charset) < 0;
          }
          if (useBase64) {
            mimetype += ";base64";
          }
        } else {
          useBase64 = /;base64$/.test(mimetype);
        }
        var fileSync = fileManager.loadFileSync(filePath, currentDirectory, context, environment);
        if (!fileSync.contents) {
          logger$1.warn("Skipped data-uri embedding of " + filePath + " because file not found");
          return fallback(this, filePathNode || mimetypeNode);
        }
        var buf = fileSync.contents;
        if (useBase64 && !environment.encodeBase64) {
          return fallback(this, filePathNode);
        }
        buf = useBase64 ? environment.encodeBase64(buf) : encodeURIComponent(buf);
        var uri = "data:" + mimetype + "," + buf + fragment;
        return new URL2(new Quoted('"' + uri + '"', uri, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
      } };
    };
    var getItemsFromNode = function(node2) {
      var items = Array.isArray(node2.value) ? node2.value : Array(node2);
      return items;
    };
    var list = {
      _SELF: function(n2) {
        return n2;
      },
      "~": function() {
        var expr = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          expr[_i] = arguments[_i];
        }
        if (expr.length === 1) {
          return expr[0];
        }
        return new Value(expr);
      },
      extract: function(values, index2) {
        index2 = index2.value - 1;
        return getItemsFromNode(values)[index2];
      },
      length: function(values) {
        return new Dimension(getItemsFromNode(values).length);
      },
      range: function(start, end, step) {
        var from2;
        var to;
        var stepValue = 1;
        var list2 = [];
        if (end) {
          to = end;
          from2 = start.value;
          if (step) {
            stepValue = step.value;
          }
        } else {
          from2 = 1;
          to = start;
        }
        for (var i2 = from2; i2 <= to.value; i2 += stepValue) {
          list2.push(new Dimension(i2, to.unit));
        }
        return new Expression(list2);
      },
      each: function(list2, rs) {
        var _this = this;
        var rules2 = [];
        var newRules;
        var iterator;
        var tryEval = function(val) {
          if (val instanceof Node) {
            return val.eval(_this.context);
          }
          return val;
        };
        if (list2.value && !(list2 instanceof Quoted)) {
          if (Array.isArray(list2.value)) {
            iterator = list2.value.map(tryEval);
          } else {
            iterator = [tryEval(list2.value)];
          }
        } else if (list2.ruleset) {
          iterator = tryEval(list2.ruleset).rules;
        } else if (list2.rules) {
          iterator = list2.rules.map(tryEval);
        } else if (Array.isArray(list2)) {
          iterator = list2.map(tryEval);
        } else {
          iterator = [tryEval(list2)];
        }
        var valueName = "@value";
        var keyName = "@key";
        var indexName = "@index";
        if (rs.params) {
          valueName = rs.params[0] && rs.params[0].name;
          keyName = rs.params[1] && rs.params[1].name;
          indexName = rs.params[2] && rs.params[2].name;
          rs = rs.rules;
        } else {
          rs = rs.ruleset;
        }
        for (var i2 = 0; i2 < iterator.length; i2++) {
          var key2 = void 0;
          var value = void 0;
          var item = iterator[i2];
          if (item instanceof Declaration) {
            key2 = typeof item.name === "string" ? item.name : item.name[0].value;
            value = item.value;
          } else {
            key2 = new Dimension(i2 + 1);
            value = item;
          }
          if (item instanceof Comment) {
            continue;
          }
          newRules = rs.rules.slice(0);
          if (valueName) {
            newRules.push(new Declaration(valueName, value, false, false, this.index, this.currentFileInfo));
          }
          if (indexName) {
            newRules.push(new Declaration(indexName, new Dimension(i2 + 1), false, false, this.index, this.currentFileInfo));
          }
          if (keyName) {
            newRules.push(new Declaration(keyName, key2, false, false, this.index, this.currentFileInfo));
          }
          rules2.push(new Ruleset([new Selector([new Element2("", "&")])], newRules, rs.strictImports, rs.visibilityInfo()));
        }
        return new Ruleset([new Selector([new Element2("", "&")])], rules2, rs.strictImports, rs.visibilityInfo()).eval(this.context);
      }
    };
    var MathHelper = function(fn2, unit, n2) {
      if (!(n2 instanceof Dimension)) {
        throw { type: "Argument", message: "argument must be a number" };
      }
      if (unit == null) {
        unit = n2.unit;
      } else {
        n2 = n2.unify();
      }
      return new Dimension(fn2(parseFloat(n2.value)), unit);
    };
    var mathFunctions = {
      ceil: null,
      floor: null,
      sqrt: null,
      abs: null,
      tan: "",
      sin: "",
      cos: "",
      atan: "rad",
      asin: "rad",
      acos: "rad"
    };
    for (var f2 in mathFunctions) {
      if (mathFunctions.hasOwnProperty(f2)) {
        mathFunctions[f2] = MathHelper.bind(null, Math[f2], mathFunctions[f2]);
      }
    }
    mathFunctions.round = function(n2, f3) {
      var fraction = typeof f3 === "undefined" ? 0 : f3.value;
      return MathHelper(function(num) {
        return num.toFixed(fraction);
      }, null, n2);
    };
    var minMax = function(isMin, args) {
      args = Array.prototype.slice.call(args);
      switch (args.length) {
        case 0:
          throw { type: "Argument", message: "one or more arguments required" };
      }
      var i2;
      var j2;
      var current;
      var currentUnified;
      var referenceUnified;
      var unit;
      var unitStatic;
      var unitClone;
      var order = [];
      var values = {};
      for (i2 = 0; i2 < args.length; i2++) {
        current = args[i2];
        if (!(current instanceof Dimension)) {
          if (Array.isArray(args[i2].value)) {
            Array.prototype.push.apply(args, Array.prototype.slice.call(args[i2].value));
          }
          continue;
        }
        currentUnified = current.unit.toString() === "" && unitClone !== void 0 ? new Dimension(current.value, unitClone).unify() : current.unify();
        unit = currentUnified.unit.toString() === "" && unitStatic !== void 0 ? unitStatic : currentUnified.unit.toString();
        unitStatic = unit !== "" && unitStatic === void 0 || unit !== "" && order[0].unify().unit.toString() === "" ? unit : unitStatic;
        unitClone = unit !== "" && unitClone === void 0 ? current.unit.toString() : unitClone;
        j2 = values[""] !== void 0 && unit !== "" && unit === unitStatic ? values[""] : values[unit];
        if (j2 === void 0) {
          if (unitStatic !== void 0 && unit !== unitStatic) {
            throw { type: "Argument", message: "incompatible types" };
          }
          values[unit] = order.length;
          order.push(current);
          continue;
        }
        referenceUnified = order[j2].unit.toString() === "" && unitClone !== void 0 ? new Dimension(order[j2].value, unitClone).unify() : order[j2].unify();
        if (isMin && currentUnified.value < referenceUnified.value || !isMin && currentUnified.value > referenceUnified.value) {
          order[j2] = current;
        }
      }
      if (order.length == 1) {
        return order[0];
      }
      args = order.map(function(a2) {
        return a2.toCSS(this.context);
      }).join(this.context.compress ? "," : ", ");
      return new Anonymous((isMin ? "min" : "max") + "(" + args + ")");
    };
    var number4 = {
      min: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        try {
          return minMax(true, args);
        } catch (e2) {
        }
      },
      max: function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        try {
          return minMax(false, args);
        } catch (e2) {
        }
      },
      convert: function(val, unit) {
        return val.convertTo(unit.value);
      },
      pi: function() {
        return new Dimension(Math.PI);
      },
      mod: function(a2, b2) {
        return new Dimension(a2.value % b2.value, a2.unit);
      },
      pow: function(x2, y2) {
        if (typeof x2 === "number" && typeof y2 === "number") {
          x2 = new Dimension(x2);
          y2 = new Dimension(y2);
        } else if (!(x2 instanceof Dimension) || !(y2 instanceof Dimension)) {
          throw { type: "Argument", message: "arguments must be numbers" };
        }
        return new Dimension(Math.pow(x2.value, y2.value), x2.unit);
      },
      percentage: function(n2) {
        var result = MathHelper(function(num) {
          return num * 100;
        }, "%", n2);
        return result;
      }
    };
    var string3 = {
      e: function(str) {
        return new Quoted('"', str instanceof JavaScript ? str.evaluated : str.value, true);
      },
      escape: function(str) {
        return new Anonymous(encodeURI(str.value).replace(/=/g, "%3D").replace(/:/g, "%3A").replace(/#/g, "%23").replace(/;/g, "%3B").replace(/\(/g, "%28").replace(/\)/g, "%29"));
      },
      replace: function(string4, pattern4, replacement, flags) {
        var result = string4.value;
        replacement = replacement.type === "Quoted" ? replacement.value : replacement.toCSS();
        result = result.replace(new RegExp(pattern4.value, flags ? flags.value : ""), replacement);
        return new Quoted(string4.quote || "", result, string4.escaped);
      },
      "%": function(string4) {
        var args = Array.prototype.slice.call(arguments, 1);
        var result = string4.value;
        var _loop_1 = function(i3) {
          result = result.replace(/%[sda]/i, function(token2) {
            var value = args[i3].type === "Quoted" && token2.match(/s/i) ? args[i3].value : args[i3].toCSS();
            return token2.match(/[A-Z]$/) ? encodeURIComponent(value) : value;
          });
        };
        for (var i2 = 0; i2 < args.length; i2++) {
          _loop_1(i2);
        }
        result = result.replace(/%%/g, "%");
        return new Quoted(string4.quote || "", result, string4.escaped);
      }
    };
    var svg = function(environment) {
      return { "svg-gradient": function(direction) {
        var stops;
        var gradientDirectionSvg;
        var gradientType = "linear";
        var rectangleDimension = 'x="0" y="0" width="1" height="1"';
        var renderEnv = { compress: false };
        var returner;
        var directionValue = direction.toCSS(renderEnv);
        var i2;
        var color2;
        var position2;
        var positionValue;
        var alpha;
        function throwArgumentDescriptor() {
          throw {
            type: "Argument",
            message: "svg-gradient expects direction, start_color [start_position], [color position,]..., end_color [end_position] or direction, color list"
          };
        }
        if (arguments.length == 2) {
          if (arguments[1].value.length < 2) {
            throwArgumentDescriptor();
          }
          stops = arguments[1].value;
        } else if (arguments.length < 3) {
          throwArgumentDescriptor();
        } else {
          stops = Array.prototype.slice.call(arguments, 1);
        }
        switch (directionValue) {
          case "to bottom":
            gradientDirectionSvg = 'x1="0%" y1="0%" x2="0%" y2="100%"';
            break;
          case "to right":
            gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="0%"';
            break;
          case "to bottom right":
            gradientDirectionSvg = 'x1="0%" y1="0%" x2="100%" y2="100%"';
            break;
          case "to top right":
            gradientDirectionSvg = 'x1="0%" y1="100%" x2="100%" y2="0%"';
            break;
          case "ellipse":
          case "ellipse at center":
            gradientType = "radial";
            gradientDirectionSvg = 'cx="50%" cy="50%" r="75%"';
            rectangleDimension = 'x="-50" y="-50" width="101" height="101"';
            break;
          default:
            throw { type: "Argument", message: "svg-gradient direction must be 'to bottom', 'to right', 'to bottom right', 'to top right' or 'ellipse at center'" };
        }
        returner = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"><' + gradientType + 'Gradient id="g" ' + gradientDirectionSvg + ">";
        for (i2 = 0; i2 < stops.length; i2 += 1) {
          if (stops[i2] instanceof Expression) {
            color2 = stops[i2].value[0];
            position2 = stops[i2].value[1];
          } else {
            color2 = stops[i2];
            position2 = void 0;
          }
          if (!(color2 instanceof Color) || !((i2 === 0 || i2 + 1 === stops.length) && position2 === void 0) && !(position2 instanceof Dimension)) {
            throwArgumentDescriptor();
          }
          positionValue = position2 ? position2.toCSS(renderEnv) : i2 === 0 ? "0%" : "100%";
          alpha = color2.alpha;
          returner += '<stop offset="' + positionValue + '" stop-color="' + color2.toRGB() + '"' + (alpha < 1 ? ' stop-opacity="' + alpha + '"' : "") + "/>";
        }
        returner += "</" + gradientType + "Gradient><rect " + rectangleDimension + ' fill="url(#g)" /></svg>';
        returner = encodeURIComponent(returner);
        returner = "data:image/svg+xml," + returner;
        return new URL2(new Quoted("'" + returner + "'", returner, false, this.index, this.currentFileInfo), this.index, this.currentFileInfo);
      } };
    };
    var isa = function(n2, Type) {
      return n2 instanceof Type ? Keyword.True : Keyword.False;
    };
    var isunit = function(n2, unit) {
      if (unit === void 0) {
        throw { type: "Argument", message: "missing the required second argument to isunit." };
      }
      unit = typeof unit.value === "string" ? unit.value : unit;
      if (typeof unit !== "string") {
        throw { type: "Argument", message: "Second argument to isunit should be a unit or a string." };
      }
      return n2 instanceof Dimension && n2.unit.is(unit) ? Keyword.True : Keyword.False;
    };
    var types2 = {
      isruleset: function(n2) {
        return isa(n2, DetachedRuleset);
      },
      iscolor: function(n2) {
        return isa(n2, Color);
      },
      isnumber: function(n2) {
        return isa(n2, Dimension);
      },
      isstring: function(n2) {
        return isa(n2, Quoted);
      },
      iskeyword: function(n2) {
        return isa(n2, Keyword);
      },
      isurl: function(n2) {
        return isa(n2, URL2);
      },
      ispixel: function(n2) {
        return isunit(n2, "px");
      },
      ispercentage: function(n2) {
        return isunit(n2, "%");
      },
      isem: function(n2) {
        return isunit(n2, "em");
      },
      isunit,
      unit: function(val, unit) {
        if (!(val instanceof Dimension)) {
          throw {
            type: "Argument",
            message: "the first argument to unit must be a number" + (val instanceof Operation ? ". Have you forgotten parenthesis?" : "")
          };
        }
        if (unit) {
          if (unit instanceof Keyword) {
            unit = unit.value;
          } else {
            unit = unit.toCSS();
          }
        } else {
          unit = "";
        }
        return new Dimension(val.value, unit);
      },
      "get-unit": function(n2) {
        return new Anonymous(n2.unit);
      }
    };
    var functions = function(environment) {
      var functions2 = { functionRegistry, functionCaller };
      functionRegistry.addMultiple(boolean$1);
      functionRegistry.add("default", defaultFunc.eval.bind(defaultFunc));
      functionRegistry.addMultiple(color);
      functionRegistry.addMultiple(colorBlend);
      functionRegistry.addMultiple(dataUri(environment));
      functionRegistry.addMultiple(list);
      functionRegistry.addMultiple(mathFunctions);
      functionRegistry.addMultiple(number4);
      functionRegistry.addMultiple(string3);
      functionRegistry.addMultiple(svg());
      functionRegistry.addMultiple(types2);
      return functions2;
    };
    function transformTree(root3, options2) {
      options2 = options2 || {};
      var evaldRoot;
      var variables = options2.variables;
      var evalEnv = new contexts.Eval(options2);
      if (typeof variables === "object" && !Array.isArray(variables)) {
        variables = Object.keys(variables).map(function(k2) {
          var value = variables[k2];
          if (!(value instanceof tree.Value)) {
            if (!(value instanceof tree.Expression)) {
              value = new tree.Expression([value]);
            }
            value = new tree.Value([value]);
          }
          return new tree.Declaration("@" + k2, value, false, null, 0);
        });
        evalEnv.frames = [new tree.Ruleset(null, variables)];
      }
      var visitors$1 = [
        new visitors.JoinSelectorVisitor(),
        new visitors.MarkVisibleSelectorsVisitor(true),
        new visitors.ExtendVisitor(),
        new visitors.ToCSSVisitor({ compress: Boolean(options2.compress) })
      ];
      var preEvalVisitors = [];
      var v2;
      var visitorIterator;
      if (options2.pluginManager) {
        visitorIterator = options2.pluginManager.visitor();
        for (var i2 = 0; i2 < 2; i2++) {
          visitorIterator.first();
          while (v2 = visitorIterator.get()) {
            if (v2.isPreEvalVisitor) {
              if (i2 === 0 || preEvalVisitors.indexOf(v2) === -1) {
                preEvalVisitors.push(v2);
                v2.run(root3);
              }
            } else {
              if (i2 === 0 || visitors$1.indexOf(v2) === -1) {
                if (v2.isPreVisitor) {
                  visitors$1.unshift(v2);
                } else {
                  visitors$1.push(v2);
                }
              }
            }
          }
        }
      }
      evaldRoot = root3.eval(evalEnv);
      for (var i2 = 0; i2 < visitors$1.length; i2++) {
        visitors$1[i2].run(evaldRoot);
      }
      if (options2.pluginManager) {
        visitorIterator.first();
        while (v2 = visitorIterator.get()) {
          if (visitors$1.indexOf(v2) === -1 && preEvalVisitors.indexOf(v2) === -1) {
            v2.run(evaldRoot);
          }
        }
      }
      return evaldRoot;
    }
    var PluginManager = function() {
      function PluginManager2(less3) {
        this.less = less3;
        this.visitors = [];
        this.preProcessors = [];
        this.postProcessors = [];
        this.installedPlugins = [];
        this.fileManagers = [];
        this.iterator = -1;
        this.pluginCache = {};
        this.Loader = new less3.PluginLoader(less3);
      }
      PluginManager2.prototype.addPlugins = function(plugins) {
        if (plugins) {
          for (var i2 = 0; i2 < plugins.length; i2++) {
            this.addPlugin(plugins[i2]);
          }
        }
      };
      PluginManager2.prototype.addPlugin = function(plugin, filename, functionRegistry2) {
        this.installedPlugins.push(plugin);
        if (filename) {
          this.pluginCache[filename] = plugin;
        }
        if (plugin.install) {
          plugin.install(this.less, this, functionRegistry2 || this.less.functions.functionRegistry);
        }
      };
      PluginManager2.prototype.get = function(filename) {
        return this.pluginCache[filename];
      };
      PluginManager2.prototype.addVisitor = function(visitor) {
        this.visitors.push(visitor);
      };
      PluginManager2.prototype.addPreProcessor = function(preProcessor, priority) {
        var indexToInsertAt;
        for (indexToInsertAt = 0; indexToInsertAt < this.preProcessors.length; indexToInsertAt++) {
          if (this.preProcessors[indexToInsertAt].priority >= priority) {
            break;
          }
        }
        this.preProcessors.splice(indexToInsertAt, 0, { preProcessor, priority });
      };
      PluginManager2.prototype.addPostProcessor = function(postProcessor, priority) {
        var indexToInsertAt;
        for (indexToInsertAt = 0; indexToInsertAt < this.postProcessors.length; indexToInsertAt++) {
          if (this.postProcessors[indexToInsertAt].priority >= priority) {
            break;
          }
        }
        this.postProcessors.splice(indexToInsertAt, 0, { postProcessor, priority });
      };
      PluginManager2.prototype.addFileManager = function(manager) {
        this.fileManagers.push(manager);
      };
      PluginManager2.prototype.getPreProcessors = function() {
        var preProcessors = [];
        for (var i2 = 0; i2 < this.preProcessors.length; i2++) {
          preProcessors.push(this.preProcessors[i2].preProcessor);
        }
        return preProcessors;
      };
      PluginManager2.prototype.getPostProcessors = function() {
        var postProcessors = [];
        for (var i2 = 0; i2 < this.postProcessors.length; i2++) {
          postProcessors.push(this.postProcessors[i2].postProcessor);
        }
        return postProcessors;
      };
      PluginManager2.prototype.getVisitors = function() {
        return this.visitors;
      };
      PluginManager2.prototype.visitor = function() {
        var self2 = this;
        return {
          first: function() {
            self2.iterator = -1;
            return self2.visitors[self2.iterator];
          },
          get: function() {
            self2.iterator += 1;
            return self2.visitors[self2.iterator];
          }
        };
      };
      PluginManager2.prototype.getFileManagers = function() {
        return this.fileManagers;
      };
      return PluginManager2;
    }();
    var pm;
    var PluginManagerFactory = function(less3, newFactory) {
      if (newFactory || !pm) {
        pm = new PluginManager(less3);
      }
      return pm;
    };
    function SourceMapOutput(environment) {
      var SourceMapOutput2 = function() {
        function SourceMapOutput3(options2) {
          this._css = [];
          this._rootNode = options2.rootNode;
          this._contentsMap = options2.contentsMap;
          this._contentsIgnoredCharsMap = options2.contentsIgnoredCharsMap;
          if (options2.sourceMapFilename) {
            this._sourceMapFilename = options2.sourceMapFilename.replace(/\\/g, "/");
          }
          this._outputFilename = options2.outputFilename;
          this.sourceMapURL = options2.sourceMapURL;
          if (options2.sourceMapBasepath) {
            this._sourceMapBasepath = options2.sourceMapBasepath.replace(/\\/g, "/");
          }
          if (options2.sourceMapRootpath) {
            this._sourceMapRootpath = options2.sourceMapRootpath.replace(/\\/g, "/");
            if (this._sourceMapRootpath.charAt(this._sourceMapRootpath.length - 1) !== "/") {
              this._sourceMapRootpath += "/";
            }
          } else {
            this._sourceMapRootpath = "";
          }
          this._outputSourceFiles = options2.outputSourceFiles;
          this._sourceMapGeneratorConstructor = environment.getSourceMapGenerator();
          this._lineNumber = 0;
          this._column = 0;
        }
        SourceMapOutput3.prototype.removeBasepath = function(path2) {
          if (this._sourceMapBasepath && path2.indexOf(this._sourceMapBasepath) === 0) {
            path2 = path2.substring(this._sourceMapBasepath.length);
            if (path2.charAt(0) === "\\" || path2.charAt(0) === "/") {
              path2 = path2.substring(1);
            }
          }
          return path2;
        };
        SourceMapOutput3.prototype.normalizeFilename = function(filename) {
          filename = filename.replace(/\\/g, "/");
          filename = this.removeBasepath(filename);
          return (this._sourceMapRootpath || "") + filename;
        };
        SourceMapOutput3.prototype.add = function(chunk, fileInfo, index2, mapLines) {
          if (!chunk) {
            return;
          }
          var lines, sourceLines, columns, sourceColumns, i2;
          if (fileInfo && fileInfo.filename) {
            var inputSource = this._contentsMap[fileInfo.filename];
            if (this._contentsIgnoredCharsMap[fileInfo.filename]) {
              index2 -= this._contentsIgnoredCharsMap[fileInfo.filename];
              if (index2 < 0) {
                index2 = 0;
              }
              inputSource = inputSource.slice(this._contentsIgnoredCharsMap[fileInfo.filename]);
            }
            if (inputSource === void 0) {
              this._css.push(chunk);
              return;
            }
            inputSource = inputSource.substring(0, index2);
            sourceLines = inputSource.split("\n");
            sourceColumns = sourceLines[sourceLines.length - 1];
          }
          lines = chunk.split("\n");
          columns = lines[lines.length - 1];
          if (fileInfo && fileInfo.filename) {
            if (!mapLines) {
              this._sourceMapGenerator.addMapping({
                generated: { line: this._lineNumber + 1, column: this._column },
                original: { line: sourceLines.length, column: sourceColumns.length },
                source: this.normalizeFilename(fileInfo.filename)
              });
            } else {
              for (i2 = 0; i2 < lines.length; i2++) {
                this._sourceMapGenerator.addMapping({
                  generated: { line: this._lineNumber + i2 + 1, column: i2 === 0 ? this._column : 0 },
                  original: { line: sourceLines.length + i2, column: i2 === 0 ? sourceColumns.length : 0 },
                  source: this.normalizeFilename(fileInfo.filename)
                });
              }
            }
          }
          if (lines.length === 1) {
            this._column += columns.length;
          } else {
            this._lineNumber += lines.length - 1;
            this._column = columns.length;
          }
          this._css.push(chunk);
        };
        SourceMapOutput3.prototype.isEmpty = function() {
          return this._css.length === 0;
        };
        SourceMapOutput3.prototype.toCSS = function(context) {
          this._sourceMapGenerator = new this._sourceMapGeneratorConstructor({ file: this._outputFilename, sourceRoot: null });
          if (this._outputSourceFiles) {
            for (var filename in this._contentsMap) {
              if (this._contentsMap.hasOwnProperty(filename)) {
                var source = this._contentsMap[filename];
                if (this._contentsIgnoredCharsMap[filename]) {
                  source = source.slice(this._contentsIgnoredCharsMap[filename]);
                }
                this._sourceMapGenerator.setSourceContent(this.normalizeFilename(filename), source);
              }
            }
          }
          this._rootNode.genCSS(context, this);
          if (this._css.length > 0) {
            var sourceMapURL = void 0;
            var sourceMapContent = JSON.stringify(this._sourceMapGenerator.toJSON());
            if (this.sourceMapURL) {
              sourceMapURL = this.sourceMapURL;
            } else if (this._sourceMapFilename) {
              sourceMapURL = this._sourceMapFilename;
            }
            this.sourceMapURL = sourceMapURL;
            this.sourceMap = sourceMapContent;
          }
          return this._css.join("");
        };
        return SourceMapOutput3;
      }();
      return SourceMapOutput2;
    }
    function SourceMapBuilder(SourceMapOutput2, environment) {
      var SourceMapBuilder2 = function() {
        function SourceMapBuilder3(options2) {
          this.options = options2;
        }
        SourceMapBuilder3.prototype.toCSS = function(rootNode, options2, imports) {
          var sourceMapOutput = new SourceMapOutput2({
            contentsIgnoredCharsMap: imports.contentsIgnoredChars,
            rootNode,
            contentsMap: imports.contents,
            sourceMapFilename: this.options.sourceMapFilename,
            sourceMapURL: this.options.sourceMapURL,
            outputFilename: this.options.sourceMapOutputFilename,
            sourceMapBasepath: this.options.sourceMapBasepath,
            sourceMapRootpath: this.options.sourceMapRootpath,
            outputSourceFiles: this.options.outputSourceFiles,
            sourceMapGenerator: this.options.sourceMapGenerator,
            sourceMapFileInline: this.options.sourceMapFileInline,
            disableSourcemapAnnotation: this.options.disableSourcemapAnnotation
          });
          var css3 = sourceMapOutput.toCSS(options2);
          this.sourceMap = sourceMapOutput.sourceMap;
          this.sourceMapURL = sourceMapOutput.sourceMapURL;
          if (this.options.sourceMapInputFilename) {
            this.sourceMapInputFilename = sourceMapOutput.normalizeFilename(this.options.sourceMapInputFilename);
          }
          if (this.options.sourceMapBasepath !== void 0 && this.sourceMapURL !== void 0) {
            this.sourceMapURL = sourceMapOutput.removeBasepath(this.sourceMapURL);
          }
          return css3 + this.getCSSAppendage();
        };
        SourceMapBuilder3.prototype.getCSSAppendage = function() {
          var sourceMapURL = this.sourceMapURL;
          if (this.options.sourceMapFileInline) {
            if (this.sourceMap === void 0) {
              return "";
            }
            sourceMapURL = "data:application/json;base64," + environment.encodeBase64(this.sourceMap);
          }
          if (this.options.disableSourcemapAnnotation) {
            return "";
          }
          if (sourceMapURL) {
            return "/*# sourceMappingURL=" + sourceMapURL + " */";
          }
          return "";
        };
        SourceMapBuilder3.prototype.getExternalSourceMap = function() {
          return this.sourceMap;
        };
        SourceMapBuilder3.prototype.setExternalSourceMap = function(sourceMap) {
          this.sourceMap = sourceMap;
        };
        SourceMapBuilder3.prototype.isInline = function() {
          return this.options.sourceMapFileInline;
        };
        SourceMapBuilder3.prototype.getSourceMapURL = function() {
          return this.sourceMapURL;
        };
        SourceMapBuilder3.prototype.getOutputFilename = function() {
          return this.options.sourceMapOutputFilename;
        };
        SourceMapBuilder3.prototype.getInputFilename = function() {
          return this.sourceMapInputFilename;
        };
        return SourceMapBuilder3;
      }();
      return SourceMapBuilder2;
    }
    function ParseTree(SourceMapBuilder2) {
      var ParseTree2 = function() {
        function ParseTree3(root3, imports) {
          this.root = root3;
          this.imports = imports;
        }
        ParseTree3.prototype.toCSS = function(options2) {
          var evaldRoot;
          var result = {};
          var sourceMapBuilder;
          try {
            evaldRoot = transformTree(this.root, options2);
          } catch (e2) {
            throw new LessError(e2, this.imports);
          }
          try {
            var compress = Boolean(options2.compress);
            if (compress) {
              logger$1.warn("The compress option has been deprecated. We recommend you use a dedicated css minifier, for instance see less-plugin-clean-css.");
            }
            var toCSSOptions = {
              compress,
              dumpLineNumbers: options2.dumpLineNumbers,
              strictUnits: Boolean(options2.strictUnits),
              numPrecision: 8
            };
            if (options2.sourceMap) {
              sourceMapBuilder = new SourceMapBuilder2(options2.sourceMap);
              result.css = sourceMapBuilder.toCSS(evaldRoot, toCSSOptions, this.imports);
            } else {
              result.css = evaldRoot.toCSS(toCSSOptions);
            }
          } catch (e2) {
            throw new LessError(e2, this.imports);
          }
          if (options2.pluginManager) {
            var postProcessors = options2.pluginManager.getPostProcessors();
            for (var i2 = 0; i2 < postProcessors.length; i2++) {
              result.css = postProcessors[i2].process(result.css, { sourceMap: sourceMapBuilder, options: options2, imports: this.imports });
            }
          }
          if (options2.sourceMap) {
            result.map = sourceMapBuilder.getExternalSourceMap();
          }
          result.imports = [];
          for (var file in this.imports.files) {
            if (this.imports.files.hasOwnProperty(file) && file !== this.imports.rootFilename) {
              result.imports.push(file);
            }
          }
          return result;
        };
        return ParseTree3;
      }();
      return ParseTree2;
    }
    function ImportManager(environment) {
      var ImportManager2 = function() {
        function ImportManager3(less3, context, rootFileInfo) {
          this.less = less3;
          this.rootFilename = rootFileInfo.filename;
          this.paths = context.paths || [];
          this.contents = {};
          this.contentsIgnoredChars = {};
          this.mime = context.mime;
          this.error = null;
          this.context = context;
          this.queue = [];
          this.files = {};
        }
        ImportManager3.prototype.push = function(path2, tryAppendExtension, currentFileInfo, importOptions, callback) {
          var importManager = this, pluginLoader = this.context.pluginManager.Loader;
          this.queue.push(path2);
          var fileParsedFunc = function(e2, root3, fullPath) {
            importManager.queue.splice(importManager.queue.indexOf(path2), 1);
            var importedEqualsRoot = fullPath === importManager.rootFilename;
            if (importOptions.optional && e2) {
              callback(null, { rules: [] }, false, null);
              logger$1.info("The file " + fullPath + " was skipped because it was not found and the import was marked optional.");
            } else {
              if (!importManager.files[fullPath] && !importOptions.inline) {
                importManager.files[fullPath] = { root: root3, options: importOptions };
              }
              if (e2 && !importManager.error) {
                importManager.error = e2;
              }
              callback(e2, root3, importedEqualsRoot, fullPath);
            }
          };
          var newFileInfo = {
            rewriteUrls: this.context.rewriteUrls,
            entryPath: currentFileInfo.entryPath,
            rootpath: currentFileInfo.rootpath,
            rootFilename: currentFileInfo.rootFilename
          };
          var fileManager = environment.getFileManager(path2, currentFileInfo.currentDirectory, this.context, environment);
          if (!fileManager) {
            fileParsedFunc({ message: "Could not find a file-manager for " + path2 });
            return;
          }
          var loadFileCallback = function(loadedFile2) {
            var plugin;
            var resolvedFilename = loadedFile2.filename;
            var contents = loadedFile2.contents.replace(/^\uFEFF/, "");
            newFileInfo.currentDirectory = fileManager.getPath(resolvedFilename);
            if (newFileInfo.rewriteUrls) {
              newFileInfo.rootpath = fileManager.join(importManager.context.rootpath || "", fileManager.pathDiff(newFileInfo.currentDirectory, newFileInfo.entryPath));
              if (!fileManager.isPathAbsolute(newFileInfo.rootpath) && fileManager.alwaysMakePathsAbsolute()) {
                newFileInfo.rootpath = fileManager.join(newFileInfo.entryPath, newFileInfo.rootpath);
              }
            }
            newFileInfo.filename = resolvedFilename;
            var newEnv = new contexts.Parse(importManager.context);
            newEnv.processImports = false;
            importManager.contents[resolvedFilename] = contents;
            if (currentFileInfo.reference || importOptions.reference) {
              newFileInfo.reference = true;
            }
            if (importOptions.isPlugin) {
              plugin = pluginLoader.evalPlugin(contents, newEnv, importManager, importOptions.pluginArgs, newFileInfo);
              if (plugin instanceof LessError) {
                fileParsedFunc(plugin, null, resolvedFilename);
              } else {
                fileParsedFunc(null, plugin, resolvedFilename);
              }
            } else if (importOptions.inline) {
              fileParsedFunc(null, contents, resolvedFilename);
            } else {
              if (importManager.files[resolvedFilename] && !importManager.files[resolvedFilename].options.multiple && !importOptions.multiple) {
                fileParsedFunc(null, importManager.files[resolvedFilename].root, resolvedFilename);
              } else {
                new Parser(newEnv, importManager, newFileInfo).parse(contents, function(e2, root3) {
                  fileParsedFunc(e2, root3, resolvedFilename);
                });
              }
            }
          };
          var loadedFile;
          var promise2;
          var context = clone2(this.context);
          if (tryAppendExtension) {
            context.ext = importOptions.isPlugin ? ".js" : ".less";
          }
          if (importOptions.isPlugin) {
            context.mime = "application/javascript";
            if (context.syncImport) {
              loadedFile = pluginLoader.loadPluginSync(path2, currentFileInfo.currentDirectory, context, environment, fileManager);
            } else {
              promise2 = pluginLoader.loadPlugin(path2, currentFileInfo.currentDirectory, context, environment, fileManager);
            }
          } else {
            if (context.syncImport) {
              loadedFile = fileManager.loadFileSync(path2, currentFileInfo.currentDirectory, context, environment);
            } else {
              promise2 = fileManager.loadFile(path2, currentFileInfo.currentDirectory, context, environment, function(err, loadedFile2) {
                if (err) {
                  fileParsedFunc(err);
                } else {
                  loadFileCallback(loadedFile2);
                }
              });
            }
          }
          if (loadedFile) {
            if (!loadedFile.filename) {
              fileParsedFunc(loadedFile);
            } else {
              loadFileCallback(loadedFile);
            }
          } else if (promise2) {
            promise2.then(loadFileCallback, fileParsedFunc);
          }
        };
        return ImportManager3;
      }();
      return ImportManager2;
    }
    function Parse(environment, ParseTree2, ImportManager2) {
      var parse2 = function(input, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = copyOptions(this.options, {});
        } else {
          options2 = copyOptions(this.options, options2 || {});
        }
        if (!callback) {
          var self_1 = this;
          return new Promise(function(resolve, reject) {
            parse2.call(self_1, input, options2, function(err, output) {
              if (err) {
                reject(err);
              } else {
                resolve(output);
              }
            });
          });
        } else {
          var context_1;
          var rootFileInfo = void 0;
          var pluginManager_1 = new PluginManagerFactory(this, !options2.reUsePluginManager);
          options2.pluginManager = pluginManager_1;
          context_1 = new contexts.Parse(options2);
          if (options2.rootFileInfo) {
            rootFileInfo = options2.rootFileInfo;
          } else {
            var filename = options2.filename || "input";
            var entryPath = filename.replace(/[^\/\\]*$/, "");
            rootFileInfo = {
              filename,
              rewriteUrls: context_1.rewriteUrls,
              rootpath: context_1.rootpath || "",
              currentDirectory: entryPath,
              entryPath,
              rootFilename: filename
            };
            if (rootFileInfo.rootpath && rootFileInfo.rootpath.slice(-1) !== "/") {
              rootFileInfo.rootpath += "/";
            }
          }
          var imports_1 = new ImportManager2(this, context_1, rootFileInfo);
          this.importManager = imports_1;
          if (options2.plugins) {
            options2.plugins.forEach(function(plugin) {
              var evalResult, contents;
              if (plugin.fileContent) {
                contents = plugin.fileContent.replace(/^\uFEFF/, "");
                evalResult = pluginManager_1.Loader.evalPlugin(contents, context_1, imports_1, plugin.options, plugin.filename);
                if (evalResult instanceof LessError) {
                  return callback(evalResult);
                }
              } else {
                pluginManager_1.addPlugin(plugin);
              }
            });
          }
          new Parser(context_1, imports_1, rootFileInfo).parse(input, function(e2, root3) {
            if (e2) {
              return callback(e2);
            }
            callback(null, root3, imports_1, options2);
          }, options2);
        }
      };
      return parse2;
    }
    function Render(environment, ParseTree2, ImportManager2) {
      var render2 = function(input, options2, callback) {
        if (typeof options2 === "function") {
          callback = options2;
          options2 = copyOptions(this.options, {});
        } else {
          options2 = copyOptions(this.options, options2 || {});
        }
        if (!callback) {
          var self_1 = this;
          return new Promise(function(resolve, reject) {
            render2.call(self_1, input, options2, function(err, output) {
              if (err) {
                reject(err);
              } else {
                resolve(output);
              }
            });
          });
        } else {
          this.parse(input, options2, function(err, root3, imports, options3) {
            if (err) {
              return callback(err);
            }
            var result;
            try {
              var parseTree = new ParseTree2(root3, imports);
              result = parseTree.toCSS(options3);
            } catch (err2) {
              return callback(err2);
            }
            callback(null, result);
          });
        }
      };
      return render2;
    }
    var version2 = "4.1.3";
    function parseNodeVersion(version3) {
      var match = version3.match(/^v(\d{1,2})\.(\d{1,2})\.(\d{1,2})(?:-([0-9A-Za-z-.]+))?(?:\+([0-9A-Za-z-.]+))?$/);
      if (!match) {
        throw new Error("Unable to parse: " + version3);
      }
      var res = {
        major: parseInt(match[1], 10),
        minor: parseInt(match[2], 10),
        patch: parseInt(match[3], 10),
        pre: match[4] || "",
        build: match[5] || ""
      };
      return res;
    }
    var parseNodeVersion_1 = parseNodeVersion;
    function lessRoot(environment, fileManagers) {
      var sourceMapOutput, sourceMapBuilder, parseTree, importManager;
      environment = new Environment(environment, fileManagers);
      sourceMapOutput = SourceMapOutput(environment);
      sourceMapBuilder = SourceMapBuilder(sourceMapOutput, environment);
      parseTree = ParseTree(sourceMapBuilder);
      importManager = ImportManager(environment);
      var render2 = Render(environment, parseTree);
      var parse2 = Parse(environment, parseTree, importManager);
      var v2 = parseNodeVersion_1("v" + version2);
      var initial = {
        version: [v2.major, v2.minor, v2.patch],
        data,
        tree,
        Environment,
        AbstractFileManager,
        AbstractPluginLoader,
        environment,
        visitors,
        Parser,
        functions: functions(environment),
        contexts,
        SourceMapOutput: sourceMapOutput,
        SourceMapBuilder: sourceMapBuilder,
        ParseTree: parseTree,
        ImportManager: importManager,
        render: render2,
        parse: parse2,
        LessError,
        transformTree,
        utils: utils2,
        PluginManager: PluginManagerFactory,
        logger: logger$1
      };
      var ctor = function(t3) {
        return function() {
          var obj = Object.create(t3.prototype);
          t3.apply(obj, Array.prototype.slice.call(arguments, 0));
          return obj;
        };
      };
      var t2;
      var api = Object.create(initial);
      for (var n2 in initial.tree) {
        t2 = initial.tree[n2];
        if (typeof t2 === "function") {
          api[n2.toLowerCase()] = ctor(t2);
        } else {
          api[n2] = /* @__PURE__ */ Object.create(null);
          for (var o2 in t2) {
            api[n2][o2.toLowerCase()] = ctor(t2[o2]);
          }
        }
      }
      initial.parse = initial.parse.bind(api);
      initial.render = initial.render.bind(api);
      return api;
    }
    var options$1;
    var logger2;
    var fileCache = {};
    var FileManager = function() {
    };
    FileManager.prototype = Object.assign(new AbstractFileManager(), {
      alwaysMakePathsAbsolute: function() {
        return true;
      },
      join: function(basePath, laterPath) {
        if (!basePath) {
          return laterPath;
        }
        return this.extractUrlParts(laterPath, basePath).path;
      },
      doXHR: function(url2, type4, callback, errback) {
        var xhr = new XMLHttpRequest();
        var async = options$1.isFileProtocol ? options$1.fileAsync : true;
        if (typeof xhr.overrideMimeType === "function") {
          xhr.overrideMimeType("text/css");
        }
        logger2.debug("XHR: Getting '" + url2 + "'");
        xhr.open("GET", url2, async);
        xhr.setRequestHeader("Accept", type4 || "text/x-less, text/css; q=0.9, */*; q=0.5");
        xhr.send(null);
        function handleResponse(xhr2, callback2, errback2) {
          if (xhr2.status >= 200 && xhr2.status < 300) {
            callback2(xhr2.responseText, xhr2.getResponseHeader("Last-Modified"));
          } else if (typeof errback2 === "function") {
            errback2(xhr2.status, url2);
          }
        }
        if (options$1.isFileProtocol && !options$1.fileAsync) {
          if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300) {
            callback(xhr.responseText);
          } else {
            errback(xhr.status, url2);
          }
        } else if (async) {
          xhr.onreadystatechange = function() {
            if (xhr.readyState == 4) {
              handleResponse(xhr, callback, errback);
            }
          };
        } else {
          handleResponse(xhr, callback, errback);
        }
      },
      supports: function() {
        return true;
      },
      clearFileCache: function() {
        fileCache = {};
      },
      loadFile: function(filename, currentDirectory, options2, environment) {
        if (currentDirectory && !this.isPathAbsolute(filename)) {
          filename = currentDirectory + filename;
        }
        filename = options2.ext ? this.tryAppendExtension(filename, options2.ext) : filename;
        options2 = options2 || {};
        var hrefParts = this.extractUrlParts(filename, window.location.href);
        var href = hrefParts.url;
        var self2 = this;
        return new Promise(function(resolve, reject) {
          if (options2.useFileCache && fileCache[href]) {
            try {
              var lessText = fileCache[href];
              return resolve({ contents: lessText, filename: href, webInfo: { lastModified: new Date() } });
            } catch (e2) {
              return reject({ filename: href, message: "Error loading file " + href + " error was " + e2.message });
            }
          }
          self2.doXHR(href, options2.mime, function doXHRCallback(data2, lastModified) {
            fileCache[href] = data2;
            resolve({ contents: data2, filename: href, webInfo: { lastModified } });
          }, function doXHRError(status, url2) {
            reject({ type: "File", message: "'" + url2 + "' wasn't found (" + status + ")", href });
          });
        });
      }
    });
    var FM = function(opts, log) {
      options$1 = opts;
      logger2 = log;
      return FileManager;
    };
    var PluginLoader = function(less3) {
      this.less = less3;
    };
    PluginLoader.prototype = Object.assign(new AbstractPluginLoader(), {
      loadPlugin: function(filename, basePath, context, environment, fileManager) {
        return new Promise(function(fulfill, reject) {
          fileManager.loadFile(filename, basePath, context, environment).then(fulfill).catch(reject);
        });
      }
    });
    var LogListener = function(less3, options2) {
      var logLevel_debug = 4;
      var logLevel_info = 3;
      var logLevel_warn = 2;
      var logLevel_error = 1;
      options2.logLevel = typeof options2.logLevel !== "undefined" ? options2.logLevel : options2.env === "development" ? logLevel_info : logLevel_error;
      if (!options2.loggers) {
        options2.loggers = [{
          debug: function(msg) {
            if (options2.logLevel >= logLevel_debug) {
              console.log(msg);
            }
          },
          info: function(msg) {
            if (options2.logLevel >= logLevel_info) {
              console.log(msg);
            }
          },
          warn: function(msg) {
            if (options2.logLevel >= logLevel_warn) {
              console.warn(msg);
            }
          },
          error: function(msg) {
            if (options2.logLevel >= logLevel_error) {
              console.error(msg);
            }
          }
        }];
      }
      for (var i2 = 0; i2 < options2.loggers.length; i2++) {
        less3.logger.addListener(options2.loggers[i2]);
      }
    };
    var ErrorReporting = function(window2, less3, options2) {
      function errorHTML(e2, rootHref) {
        var id2 = "less-error-message:" + extractId(rootHref || "");
        var template = '<li><label>{line}</label><pre class="{class}">{content}</pre></li>';
        var elem = window2.document.createElement("div");
        var timer;
        var content;
        var errors = [];
        var filename = e2.filename || rootHref;
        var filenameNoPath = filename.match(/([^\/]+(\?.*)?)$/)[1];
        elem.id = id2;
        elem.className = "less-error-message";
        content = "<h3>" + (e2.type || "Syntax") + "Error: " + (e2.message || "There is an error in your .less file") + ('</h3><p>in <a href="' + filename + '">' + filenameNoPath + "</a> ");
        var errorline = function(e3, i2, classname) {
          if (e3.extract[i2] !== void 0) {
            errors.push(template.replace(/\{line\}/, (parseInt(e3.line, 10) || 0) + (i2 - 1)).replace(/\{class\}/, classname).replace(/\{content\}/, e3.extract[i2]));
          }
        };
        if (e2.line) {
          errorline(e2, 0, "");
          errorline(e2, 1, "line");
          errorline(e2, 2, "");
          content += "on line " + e2.line + ", column " + (e2.column + 1) + ":</p><ul>" + errors.join("") + "</ul>";
        }
        if (e2.stack && (e2.extract || options2.logLevel >= 4)) {
          content += "<br/>Stack Trace</br />" + e2.stack.split("\n").slice(1).join("<br/>");
        }
        elem.innerHTML = content;
        browser2.createCSS(window2.document, [
          ".less-error-message ul, .less-error-message li {",
          "list-style-type: none;",
          "margin-right: 15px;",
          "padding: 4px 0;",
          "margin: 0;",
          "}",
          ".less-error-message label {",
          "font-size: 12px;",
          "margin-right: 15px;",
          "padding: 4px 0;",
          "color: #cc7777;",
          "}",
          ".less-error-message pre {",
          "color: #dd6666;",
          "padding: 4px 0;",
          "margin: 0;",
          "display: inline-block;",
          "}",
          ".less-error-message pre.line {",
          "color: #ff0000;",
          "}",
          ".less-error-message h3 {",
          "font-size: 20px;",
          "font-weight: bold;",
          "padding: 15px 0 5px 0;",
          "margin: 0;",
          "}",
          ".less-error-message a {",
          "color: #10a",
          "}",
          ".less-error-message .error {",
          "color: red;",
          "font-weight: bold;",
          "padding-bottom: 2px;",
          "border-bottom: 1px dashed red;",
          "}"
        ].join("\n"), { title: "error-message" });
        elem.style.cssText = [
          "font-family: Arial, sans-serif",
          "border: 1px solid #e00",
          "background-color: #eee",
          "border-radius: 5px",
          "-webkit-border-radius: 5px",
          "-moz-border-radius: 5px",
          "color: #e00",
          "padding: 15px",
          "margin-bottom: 15px"
        ].join(";");
        if (options2.env === "development") {
          timer = setInterval(function() {
            var document2 = window2.document;
            var body = document2.body;
            if (body) {
              if (document2.getElementById(id2)) {
                body.replaceChild(elem, document2.getElementById(id2));
              } else {
                body.insertBefore(elem, body.firstChild);
              }
              clearInterval(timer);
            }
          }, 10);
        }
      }
      function removeErrorHTML(path2) {
        var node2 = window2.document.getElementById("less-error-message:" + extractId(path2));
        if (node2) {
          node2.parentNode.removeChild(node2);
        }
      }
      function removeError(path2) {
        if (!options2.errorReporting || options2.errorReporting === "html") {
          removeErrorHTML(path2);
        } else if (options2.errorReporting === "console")
          ;
        else if (typeof options2.errorReporting === "function") {
          options2.errorReporting("remove", path2);
        }
      }
      function errorConsole(e2, rootHref) {
        var template = "{line} {content}";
        var filename = e2.filename || rootHref;
        var errors = [];
        var content = (e2.type || "Syntax") + "Error: " + (e2.message || "There is an error in your .less file") + " in " + filename;
        var errorline = function(e3, i2, classname) {
          if (e3.extract[i2] !== void 0) {
            errors.push(template.replace(/\{line\}/, (parseInt(e3.line, 10) || 0) + (i2 - 1)).replace(/\{class\}/, classname).replace(/\{content\}/, e3.extract[i2]));
          }
        };
        if (e2.line) {
          errorline(e2, 0, "");
          errorline(e2, 1, "line");
          errorline(e2, 2, "");
          content += " on line " + e2.line + ", column " + (e2.column + 1) + ":\n" + errors.join("\n");
        }
        if (e2.stack && (e2.extract || options2.logLevel >= 4)) {
          content += "\nStack Trace\n" + e2.stack;
        }
        less3.logger.error(content);
      }
      function error(e2, rootHref) {
        if (!options2.errorReporting || options2.errorReporting === "html") {
          errorHTML(e2, rootHref);
        } else if (options2.errorReporting === "console") {
          errorConsole(e2, rootHref);
        } else if (typeof options2.errorReporting === "function") {
          options2.errorReporting("add", e2, rootHref);
        }
      }
      return {
        add: error,
        remove: removeError
      };
    };
    var Cache = function(window2, options2, logger3) {
      var cache = null;
      if (options2.env !== "development") {
        try {
          cache = typeof window2.localStorage === "undefined" ? null : window2.localStorage;
        } catch (_2) {
        }
      }
      return {
        setCSS: function(path2, lastModified, modifyVars, styles) {
          if (cache) {
            logger3.info("saving " + path2 + " to cache.");
            try {
              cache.setItem(path2, styles);
              cache.setItem(path2 + ":timestamp", lastModified);
              if (modifyVars) {
                cache.setItem(path2 + ":vars", JSON.stringify(modifyVars));
              }
            } catch (e2) {
              logger3.error('failed to save "' + path2 + '" to local storage for caching.');
            }
          }
        },
        getCSS: function(path2, webInfo, modifyVars) {
          var css3 = cache && cache.getItem(path2);
          var timestamp = cache && cache.getItem(path2 + ":timestamp");
          var vars = cache && cache.getItem(path2 + ":vars");
          modifyVars = modifyVars || {};
          vars = vars || "{}";
          if (timestamp && webInfo.lastModified && new Date(webInfo.lastModified).valueOf() === new Date(timestamp).valueOf() && JSON.stringify(modifyVars) === vars) {
            return css3;
          }
        }
      };
    };
    var ImageSize = function() {
      function imageSize() {
        throw {
          type: "Runtime",
          message: "Image size functions are not supported in browser version of less"
        };
      }
      var imageFunctions = {
        "image-size": function(filePathNode) {
          imageSize();
          return -1;
        },
        "image-width": function(filePathNode) {
          imageSize();
          return -1;
        },
        "image-height": function(filePathNode) {
          imageSize();
          return -1;
        }
      };
      functionRegistry.addMultiple(imageFunctions);
    };
    var root2 = function(window2, options2) {
      var document2 = window2.document;
      var less3 = lessRoot();
      less3.options = options2;
      var environment = less3.environment;
      var FileManager2 = FM(options2, less3.logger);
      var fileManager = new FileManager2();
      environment.addFileManager(fileManager);
      less3.FileManager = FileManager2;
      less3.PluginLoader = PluginLoader;
      LogListener(less3, options2);
      var errors = ErrorReporting(window2, less3, options2);
      var cache = less3.cache = options2.cache || Cache(window2, options2, less3.logger);
      ImageSize(less3.environment);
      if (options2.functions) {
        less3.functions.functionRegistry.addMultiple(options2.functions);
      }
      var typePattern = /^text\/(x-)?less$/;
      function clone3(obj) {
        var cloned = {};
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            cloned[prop] = obj[prop];
          }
        }
        return cloned;
      }
      function bind2(func, thisArg) {
        var curryArgs = Array.prototype.slice.call(arguments, 2);
        return function() {
          var args = curryArgs.concat(Array.prototype.slice.call(arguments, 0));
          return func.apply(thisArg, args);
        };
      }
      function loadStyles(modifyVars) {
        var styles = document2.getElementsByTagName("style");
        var style3;
        for (var i2 = 0; i2 < styles.length; i2++) {
          style3 = styles[i2];
          if (style3.type.match(typePattern)) {
            var instanceOptions = clone3(options2);
            instanceOptions.modifyVars = modifyVars;
            var lessText = style3.innerHTML || "";
            instanceOptions.filename = document2.location.href.replace(/#.*$/, "");
            less3.render(lessText, instanceOptions, bind2(function(style4, e2, result) {
              if (e2) {
                errors.add(e2, "inline");
              } else {
                style4.type = "text/css";
                if (style4.styleSheet) {
                  style4.styleSheet.cssText = result.css;
                } else {
                  style4.innerHTML = result.css;
                }
              }
            }, null, style3));
          }
        }
      }
      function loadStyleSheet(sheet, callback, reload, remaining, modifyVars) {
        var instanceOptions = clone3(options2);
        addDataAttr(instanceOptions, sheet);
        instanceOptions.mime = sheet.type;
        if (modifyVars) {
          instanceOptions.modifyVars = modifyVars;
        }
        function loadInitialFileCallback(loadedFile) {
          var data2 = loadedFile.contents;
          var path2 = loadedFile.filename;
          var webInfo = loadedFile.webInfo;
          var newFileInfo = {
            currentDirectory: fileManager.getPath(path2),
            filename: path2,
            rootFilename: path2,
            rewriteUrls: instanceOptions.rewriteUrls
          };
          newFileInfo.entryPath = newFileInfo.currentDirectory;
          newFileInfo.rootpath = instanceOptions.rootpath || newFileInfo.currentDirectory;
          if (webInfo) {
            webInfo.remaining = remaining;
            var css3 = cache.getCSS(path2, webInfo, instanceOptions.modifyVars);
            if (!reload && css3) {
              webInfo.local = true;
              callback(null, css3, data2, sheet, webInfo, path2);
              return;
            }
          }
          errors.remove(path2);
          instanceOptions.rootFileInfo = newFileInfo;
          less3.render(data2, instanceOptions, function(e2, result) {
            if (e2) {
              e2.href = path2;
              callback(e2);
            } else {
              cache.setCSS(sheet.href, webInfo.lastModified, instanceOptions.modifyVars, result.css);
              callback(null, result.css, data2, sheet, webInfo, path2);
            }
          });
        }
        fileManager.loadFile(sheet.href, null, instanceOptions, environment).then(function(loadedFile) {
          loadInitialFileCallback(loadedFile);
        }).catch(function(err) {
          console.log(err);
          callback(err);
        });
      }
      function loadStyleSheets(callback, reload, modifyVars) {
        for (var i2 = 0; i2 < less3.sheets.length; i2++) {
          loadStyleSheet(less3.sheets[i2], callback, reload, less3.sheets.length - (i2 + 1), modifyVars);
        }
      }
      function initRunningMode() {
        if (less3.env === "development") {
          less3.watchTimer = setInterval(function() {
            if (less3.watchMode) {
              fileManager.clearFileCache();
              loadStyleSheets(function(e2, css3, _2, sheet, webInfo) {
                if (e2) {
                  errors.add(e2, e2.href || sheet.href);
                } else if (css3) {
                  browser2.createCSS(window2.document, css3, sheet);
                }
              });
            }
          }, options2.poll);
        }
      }
      less3.watch = function() {
        if (!less3.watchMode) {
          less3.env = "development";
          initRunningMode();
        }
        this.watchMode = true;
        return true;
      };
      less3.unwatch = function() {
        clearInterval(less3.watchTimer);
        this.watchMode = false;
        return false;
      };
      less3.registerStylesheetsImmediately = function() {
        var links = document2.getElementsByTagName("link");
        less3.sheets = [];
        for (var i2 = 0; i2 < links.length; i2++) {
          if (links[i2].rel === "stylesheet/less" || links[i2].rel.match(/stylesheet/) && links[i2].type.match(typePattern)) {
            less3.sheets.push(links[i2]);
          }
        }
      };
      less3.registerStylesheets = function() {
        return new Promise(function(resolve, reject) {
          less3.registerStylesheetsImmediately();
          resolve();
        });
      };
      less3.modifyVars = function(record) {
        return less3.refresh(true, record, false);
      };
      less3.refresh = function(reload, modifyVars, clearFileCache) {
        if ((reload || clearFileCache) && clearFileCache !== false) {
          fileManager.clearFileCache();
        }
        return new Promise(function(resolve, reject) {
          var startTime;
          var endTime;
          var totalMilliseconds;
          var remainingSheets;
          startTime = endTime = new Date();
          remainingSheets = less3.sheets.length;
          if (remainingSheets === 0) {
            endTime = new Date();
            totalMilliseconds = endTime - startTime;
            less3.logger.info("Less has finished and no sheets were loaded.");
            resolve({
              startTime,
              endTime,
              totalMilliseconds,
              sheets: less3.sheets.length
            });
          } else {
            loadStyleSheets(function(e2, css3, _2, sheet, webInfo) {
              if (e2) {
                errors.add(e2, e2.href || sheet.href);
                reject(e2);
                return;
              }
              if (webInfo.local) {
                less3.logger.info("Loading " + sheet.href + " from cache.");
              } else {
                less3.logger.info("Rendered " + sheet.href + " successfully.");
              }
              browser2.createCSS(window2.document, css3, sheet);
              less3.logger.info("CSS for " + sheet.href + " generated in " + (new Date() - endTime) + "ms");
              remainingSheets--;
              if (remainingSheets === 0) {
                totalMilliseconds = new Date() - startTime;
                less3.logger.info("Less has finished. CSS generated in " + totalMilliseconds + "ms");
                resolve({
                  startTime,
                  endTime,
                  totalMilliseconds,
                  sheets: less3.sheets.length
                });
              }
              endTime = new Date();
            }, reload, modifyVars);
          }
          loadStyles(modifyVars);
        });
      };
      less3.refreshStyles = loadStyles;
      return less3;
    };
    var options = defaultOptions();
    if (window.less) {
      for (var key in window.less) {
        if (window.less.hasOwnProperty(key)) {
          options[key] = window.less[key];
        }
      }
    }
    addDefaultOptions(window, options);
    options.plugins = options.plugins || [];
    if (window.LESS_PLUGINS) {
      options.plugins = options.plugins.concat(window.LESS_PLUGINS);
    }
    var less2 = root2(window, options);
    window.less = less2;
    var css2;
    var head;
    var style2;
    function resolveOrReject(data2) {
      if (data2.filename) {
        console.warn(data2);
      }
      if (!options.async) {
        head.removeChild(style2);
      }
    }
    if (options.onReady) {
      if (/!watch/.test(window.location.hash)) {
        less2.watch();
      }
      if (!options.async) {
        css2 = "body { display: none !important }";
        head = document.head || document.getElementsByTagName("head")[0];
        style2 = document.createElement("style");
        style2.type = "text/css";
        if (style2.styleSheet) {
          style2.styleSheet.cssText = css2;
        } else {
          style2.appendChild(document.createTextNode(css2));
        }
        head.appendChild(style2);
      }
      less2.registerStylesheetsImmediately();
      less2.pageLoadFinished = less2.refresh(less2.env === "development").then(resolveOrReject, resolveOrReject);
    }
    return less2;
  });
})(less);
const {
  Title: Title$3,
  Text: Text$2
} = Typography$1;
const product = {
  code: "",
  title: "Riporta Pinot Grigio",
  description: "Vino Blanco",
  unitPrice: 650,
  quantity: 1
};
const ProductView = ({
  code,
  onAddToCart
}) => {
  const {
    colorSuccess,
    colorSuccessBg
  } = useTheme();
  const {
    title,
    description,
    unitPrice,
    onInputChange,
    quantity,
    formState
  } = useForm(product);
  const {
    counter,
    increment,
    decrement,
    reset,
    refresh: refresh2
  } = useCounter(1);
  const contentStyle = {
    height: "160px",
    color: "#fff",
    lineHeight: "160px",
    textAlign: "center",
    background: "#364d79"
  };
  const onIncrement = () => {
    increment();
    onInputChange({
      target: {
        name: "quantity",
        value: counter + 1
      }
    });
  };
  const onDecrement = () => {
    if (counter - 1 === 0)
      return;
    decrement();
    onInputChange({
      target: {
        name: "quantity",
        value: counter - 1
      }
    });
  };
  const onQuantityChange = ({
    target
  }) => {
    refresh2(target.value);
    onInputChange({
      target
    });
  };
  react.exports.useEffect(() => {
    reset();
    onInputChange({
      target: {
        name: "quantity",
        value: 1
      }
    });
  }, [code]);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsxs(Carousel$1, {
      autoplay: true,
      autoplaySpeed: "25",
      dotPosition: "left",
      children: [/* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsx("h3", {
          style: contentStyle,
          children: "1"
        })
      }), /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsx("h3", {
          style: contentStyle,
          children: "2"
        })
      }), /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsx("h3", {
          style: contentStyle,
          children: "3"
        })
      }), /* @__PURE__ */ jsx("div", {
        children: /* @__PURE__ */ jsx("h3", {
          style: contentStyle,
          children: "4"
        })
      })]
    }), /* @__PURE__ */ jsxs(Row$1, {
      align: "middle",
      children: [/* @__PURE__ */ jsxs(Col$1, {
        xs: {
          span: 18
        },
        children: [/* @__PURE__ */ jsx(Title$3, {
          style: {
            margin: 0
          },
          level: 4,
          children: title
        }), /* @__PURE__ */ jsx(Text$2, {
          strong: true,
          type: "secondary",
          children: description
        })]
      }), /* @__PURE__ */ jsx(Col$1, {
        xs: {
          span: 6
        },
        children: /* @__PURE__ */ jsxs(Title$3, {
          style: {
            margin: 0
          },
          level: 5,
          strong: true,
          children: ["$", unitPrice]
        })
      })]
    }), /* @__PURE__ */ jsxs(Row$1, {
      align: "middle",
      justify: "center",
      children: [/* @__PURE__ */ jsx(Col$1, {
        style: {
          marginTop: "1em"
        },
        xs: {
          push: 4,
          span: 18
        },
        children: /* @__PURE__ */ jsxs(Row$1, {
          gutter: [{
            xs: 12
          }, 0],
          justify: {
            xs: "center"
          },
          align: {
            xs: "middle"
          },
          children: [/* @__PURE__ */ jsx(Col$1, {
            children: /* @__PURE__ */ jsx(Button$1, {
              ghost: true,
              type: "primary",
              danger: true,
              icon: /* @__PURE__ */ jsx(MinusOutlined$1, {}),
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
              },
              htmlType: "button",
              onClick: () => onDecrement()
            })
          }), /* @__PURE__ */ jsx(Col$1, {
            xs: {
              span: 6
            },
            children: /* @__PURE__ */ jsx(Input$1, {
              value: quantity,
              style: {
                textAlign: "center"
              },
              onChange: onQuantityChange,
              name: "quantity"
            })
          }), /* @__PURE__ */ jsx(Col$1, {
            flex: 2,
            children: /* @__PURE__ */ jsx(Button$1, {
              icon: /* @__PURE__ */ jsx(PlusOutlined$1, {}),
              ghost: true,
              style: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                color: colorSuccess,
                borderColor: colorSuccess
              },
              htmlType: "button",
              onClick: () => onIncrement()
            })
          })]
        })
      }), /* @__PURE__ */ jsx(Col$1, {
        style: {
          marginTop: "1em"
        },
        xs: {
          span: 24
        },
        children: /* @__PURE__ */ jsx(Button$1, {
          type: "primary",
          block: true,
          size: "large",
          htmlType: "button",
          onClick: () => onAddToCart(formState),
          children: "Agregar al carrito"
        })
      })]
    })]
  });
};
const {
  Title: Title$2,
  Text: Text$1
} = Typography$1;
const HomePage = () => {
  useTheme();
  const [open2, setOpen] = react.exports.useState(false);
  const [productCode, setProductCode] = react.exports.useState(null);
  const showDrawer = () => {
    setOpen(true);
  };
  const [placement, setPlacement] = react.exports.useState("bottom");
  const [cart, setCart] = react.exports.useState([]);
  const addToCart = (product2) => {
    setCart([...cart, product2]);
    onClose();
  };
  const onClose = () => {
    setOpen(false);
    setProductCode(null);
  };
  const onChangeProductCode = ({
    target
  }) => {
    setProductCode(target.value);
    if (target.value.length == 0)
      return;
    showDrawer();
  };
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsxs(
      Row$1,
      {
        align: "top",
        justify: "start",
        style: {
          display: "flex",
          height: "100%"
        },
        children: [/* @__PURE__ */ jsx(Col$1, {
          xs: {
            span: 24
          },
          children: /* @__PURE__ */ jsxs(Row$1, {
            children: [/* @__PURE__ */ jsx(Col$1, {
              xs: {
                span: 24
              },
              children: /* @__PURE__ */ jsx(Card$1, {
                className: "site-card-border-less-wrapper",
                title: "Carrito",
                bordered: true,
                style: {
                  width: "100%"
                },
                children: /* @__PURE__ */ jsx(Row$1, {
                  gutter: [0, {
                    xs: 25
                  }],
                  children: cart.map((item) => /* @__PURE__ */ jsx(Col$1, {
                    xs: {
                      span: 24
                    },
                    children: /* @__PURE__ */ jsx(ProductInfo, {
                      ...item
                    }, item.code)
                  }))
                })
              })
            }), /* @__PURE__ */ jsx(Col$1, {
              xs: {
                span: 12,
                offset: 2
              },
              children: /* @__PURE__ */ jsx(Text$1, {
                type: "secondary",
                children: "Subtotal"
              })
            }), /* @__PURE__ */ jsx(Col$1, {
              xs: {
                offset: 4,
                span: 6
              },
              children: /* @__PURE__ */ jsxs(Text$1, {
                type: "secondary",
                children: ["$", cart.reduce((a2, v2) => a2 = a2 + v2.unitPrice, 0)]
              })
            }), /* @__PURE__ */ jsx(Divider$1, {}), /* @__PURE__ */ jsx(Col$1, {
              xs: {
                span: 12,
                offset: 2
              },
              children: /* @__PURE__ */ jsx(Text$1, {
                strong: true,
                children: "Subtotal"
              })
            }), /* @__PURE__ */ jsx(Col$1, {
              xs: {
                offset: 4,
                span: 6
              },
              children: /* @__PURE__ */ jsxs(Text$1, {
                strong: true,
                children: ["$", cart.reduce((a2, v2) => a2 = a2 + v2.unitPrice, 0)]
              })
            })]
          })
        }), /* @__PURE__ */ jsx(Col$1, {
          xs: {
            span: 24
          },
          style: {
            alignSelf: "flex-end"
          },
          children: /* @__PURE__ */ jsx(Input$1, {
            size: "large",
            onChange: onChangeProductCode,
            placeholder: "Escanee el producto",
            value: productCode
          })
        })]
      }
    ), /* @__PURE__ */ jsx(Drawer2, {
      placement,
      closable: false,
      onClose,
      open: open2,
      \u0192: true,
      height: "45%",
      size: "default",
      children: /* @__PURE__ */ jsx(ProductView, {
        code: productCode,
        onAddToCart: addToCart
      })
    }, placement)]
  });
};
const {
  Title: Title$1,
  Text
} = Typography$1;
const UserInfo = () => {
  const {
    displayName,
    username,
    startLogout
  } = useAuthStore();
  const onLogout2 = () => {
    startLogout();
  };
  const items = [{
    key: "1",
    label: /* @__PURE__ */ jsx(NavLink, {
      to: "profile",
      children: /* @__PURE__ */ jsxs(Space$1, {
        children: [/* @__PURE__ */ jsx(UserOutlined$1, {}), /* @__PURE__ */ jsx(Text, {
          children: "Mi Perfil"
        })]
      })
    })
  }, {
    key: "2",
    label: /* @__PURE__ */ jsxs(Space$1, {
      onClick: onLogout2,
      children: [/* @__PURE__ */ jsx(LogoutOutlined$1, {}), /* @__PURE__ */ jsx(Text, {
        children: "Cerrar sesion"
      })]
    })
  }];
  return /* @__PURE__ */ jsxs(Row$1, {
    justify: {
      xs: "center",
      lg: "center"
    },
    align: {
      xs: "middle",
      lg: "middle"
    },
    children: [/* @__PURE__ */ jsx(Col$1, {
      xs: {
        span: 12
      },
      lg: {
        offset: 10,
        span: 11
      },
      style: {
        marginTop: ".8em",
        textAlign: "end"
      },
      children: /* @__PURE__ */ jsx(Title$1, {
        style: {
          color: "white"
        },
        level: 5,
        children: displayName != null ? displayName : username
      })
    }), /* @__PURE__ */ jsx(Col$1, {
      xs: {
        span: 12
      },
      lg: {
        offset: 1,
        span: 2
      },
      children: /* @__PURE__ */ jsx(Dropdown$1, {
        menu: {
          items
        },
        placement: "bottom",
        children: /* @__PURE__ */ jsx("a", {
          className: "text-decoration-none",
          onClick: (e2) => e2.preventDefault(),
          children: /* @__PURE__ */ jsx(Avatar$1, {
            size: {
              xs: 35
            },
            icon: /* @__PURE__ */ jsx(UserOutlined$1, {
              style: {
                fontSize: "22.5px"
              }
            })
          })
        })
      })
    })]
  });
};
const {
  Header: Header$1
} = Layout$1;
const {
  Title
} = Typography$1;
const NavBar = () => {
  const {
    colorPrimary,
    colorInfoBg,
    colorInfo
  } = useTheme();
  useNavigate();
  return /* @__PURE__ */ jsx(Header$1, {
    style: {
      padding: 0,
      background: colorInfo,
      marginBottom: "5px",
      width: "100%",
      backgroundColor: colorInfoBg,
      color: "white"
    },
    children: /* @__PURE__ */ jsxs(Row$1, {
      style: {
        width: "100%"
      },
      justify: {
        xs: "center",
        lg: "center"
      },
      align: {
        xs: "middle",
        lg: "middle"
      },
      children: [/* @__PURE__ */ jsx(Col$1, {
        xs: {
          offset: 2,
          span: 15
        },
        lg: {
          offset: 0,
          span: 2
        },
        children: /* @__PURE__ */ jsx(Space$1, {
          direction: "horizontal",
          children: /* @__PURE__ */ jsx("img", {
            style: {
              marginRight: "auto"
            },
            height: 50,
            width: 100,
            alt: "Logo",
            src: ""
          })
        })
      }), /* @__PURE__ */ jsx(Col$1, {
        xs: {
          span: 0,
          offset: 0
        },
        lg: {
          offset: 5,
          span: 6
        },
        children: /* @__PURE__ */ jsx(Title, {
          level: 4,
          style: {
            color: "white",
            display: "flex",
            justifyContent: "center",
            margin: 0
          },
          children: "App Title"
        })
      }), /* @__PURE__ */ jsx(Col$1, {
        xs: {
          offset: 0,
          span: 7
        },
        lg: {
          offset: 0,
          span: 9
        },
        children: /* @__PURE__ */ jsx(UserInfo, {})
      })]
    })
  });
};
const {
  Sider
} = Layout$1;
const SideBar = () => {
  useSelector((state) => state.auth);
  const {
    colorPrimary,
    colorPrimaryBg,
    colorInfo,
    colorInfoBg,
    colorPrimaryText,
    colorMenuBg
  } = useTheme();
  const menuItems = [createNavMenuItem(1, /* @__PURE__ */ jsx("span", {
    style: {
      color: "white"
    },
    children: "Home"
  }), /* @__PURE__ */ jsx(HomeOutlined$1, {
    style: {
      color: "white"
    }
  }), "/"), buildMenuItem(5, /* @__PURE__ */ jsx("span", {
    style: {
      color: "white"
    },
    children: "Dropdown"
  }), /* @__PURE__ */ jsx(FormOutlined$1, {
    style: {
      color: "white"
    }
  }), null, [createNavMenuItem(6, /* @__PURE__ */ jsx("span", {
    style: {
      color: "white"
    },
    children: "Option 1"
  }), /* @__PURE__ */ jsx(DollarCircleOutlined$1, {
    style: {
      color: "white"
    }
  }), "application/credit")])];
  return /* @__PURE__ */ jsx(
    Sider,
    {
      breakpoint: "lg",
      collapsedWidth: "0",
      collapsible: true,
      zeroWidthTriggerStyle: {
        top: "15px",
        backgroundColor: colorMenuBg
      },
      onBreakpoint: (broken) => {
      },
      onCollapse: (collapsed, type4) => {
      },
      children: /* @__PURE__ */ jsx(Menu$1, {
        theme: "dark",
        mode: "inline",
        defaultSelectedKeys: ["1"],
        items: menuItems,
        style: {
          height: "100%",
          borderRight: 0,
          backgroundColor: colorInfoBg
        }
      })
    }
  );
};
const {
  Content,
  Footer,
  Header
} = Layout$1;
const AppLayout = ({
  children,
  appName
}) => {
  useNavigate();
  useTheme();
  return /* @__PURE__ */ jsx(Fragment, {
    children: /* @__PURE__ */ jsxs(Layout$1, {
      hasSider: true,
      children: [/* @__PURE__ */ jsx(SideBar, {}), /* @__PURE__ */ jsxs(Content, {
        className: "content",
        style: {
          height: "100vh"
        },
        children: [/* @__PURE__ */ jsx(NavBar, {}), /* @__PURE__ */ jsx(Row$1, {
          gutter: [{
            xs: 0
          }, {
            xs: 30,
            lg: 0
          }],
          justify: {
            xs: "center"
          },
          style: {
            height: "100%"
          },
          children: /* @__PURE__ */ jsx(Col$1, {
            xs: {
              span: 24
            },
            lg: {
              span: 24
            },
            style: {
              margin: 0,
              paddingLeft: "0.5em",
              paddingRight: "0.5em",
              width: "100%"
            },
            children
          })
        })]
      })]
    })
  });
};
const AppRoutes = () => {
  return /* @__PURE__ */ jsx(AppLayout, {
    appName: "Self Services App",
    style: {
      height: "100% !important"
    },
    children: /* @__PURE__ */ jsxs(Routes, {
      children: [/* @__PURE__ */ jsx(Route, {
        path: "/",
        element: /* @__PURE__ */ jsx(HomePage, {})
      }), /* @__PURE__ */ jsx(Route, {
        path: "/*",
        element: /* @__PURE__ */ jsx(Navigate, {
          to: "/"
        })
      })]
    })
  });
};
const AppRouter = () => {
  const {
    status
  } = useCheckAuth();
  const {
    BackTop: BackTop2
  } = FloatButton$1;
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(Spin$1, {
      size: "small",
      spinning: status === "checking",
      children: /* @__PURE__ */ jsxs(Routes, {
        children: [status === "authenticated" ? /* @__PURE__ */ jsx(Route, {
          path: "/*",
          element: /* @__PURE__ */ jsx(AppRoutes, {})
        }) : /* @__PURE__ */ jsx(Route, {
          path: "/auth/*",
          element: /* @__PURE__ */ jsx(AuthRoutes, {})
        }), /* @__PURE__ */ jsx(Route, {
          path: "/*",
          element: /* @__PURE__ */ jsx(Navigate, {
            to: "/auth/login"
          })
        })]
      })
    }), /* @__PURE__ */ jsx(BackTop2, {})]
  });
};
var relativeTime$1 = { exports: {} };
(function(module, exports) {
  !function(r2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    return function(r2, e2, t2) {
      r2 = r2 || {};
      var n2 = e2.prototype, o2 = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" };
      function i2(r3, e3, t3, o3) {
        return n2.fromToBase(r3, e3, t3, o3);
      }
      t2.en.relativeTime = o2, n2.fromToBase = function(e3, n3, i3, d3, u2) {
        for (var f2, a2, s2, l2 = i3.$locale().relativeTime || o2, h2 = r2.thresholds || [{ l: "s", r: 44, d: "second" }, { l: "m", r: 89 }, { l: "mm", r: 44, d: "minute" }, { l: "h", r: 89 }, { l: "hh", r: 21, d: "hour" }, { l: "d", r: 35 }, { l: "dd", r: 25, d: "day" }, { l: "M", r: 45 }, { l: "MM", r: 10, d: "month" }, { l: "y", r: 17 }, { l: "yy", d: "year" }], m2 = h2.length, c2 = 0; c2 < m2; c2 += 1) {
          var y2 = h2[c2];
          y2.d && (f2 = d3 ? t2(e3).diff(i3, y2.d, true) : i3.diff(e3, y2.d, true));
          var p2 = (r2.rounding || Math.round)(Math.abs(f2));
          if (s2 = f2 > 0, p2 <= y2.r || !y2.r) {
            p2 <= 1 && c2 > 0 && (y2 = h2[c2 - 1]);
            var v2 = l2[y2.l];
            u2 && (p2 = u2("" + p2)), a2 = "string" == typeof v2 ? v2.replace("%d", p2) : v2(p2, n3, y2.l, s2);
            break;
          }
        }
        if (n3)
          return a2;
        var M2 = s2 ? l2.future : l2.past;
        return "function" == typeof M2 ? M2(a2) : M2.replace("%s", a2);
      }, n2.to = function(r3, e3) {
        return i2(r3, e3, this, true);
      }, n2.from = function(r3, e3) {
        return i2(r3, e3, this);
      };
      var d2 = function(r3) {
        return r3.$u ? t2.utc() : t2();
      };
      n2.toNow = function(r3) {
        return this.to(d2(this), r3);
      }, n2.fromNow = function(r3) {
        return this.from(d2(this), r3);
      };
    };
  });
})(relativeTime$1);
const relativeTime = relativeTime$1.exports;
var localizedFormat$1 = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(commonjsGlobal, function() {
    var e2 = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(t2, o2, n2) {
      var r2 = o2.prototype, i2 = r2.format;
      n2.en.formats = e2, r2.format = function(t3) {
        void 0 === t3 && (t3 = "YYYY-MM-DDTHH:mm:ssZ");
        var o3 = this.$locale().formats, n3 = function(t4, o4) {
          return t4.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t5, n4, r3) {
            var i3 = r3 && r3.toUpperCase();
            return n4 || o4[r3] || e2[r3] || o4[i3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e3, t6, o5) {
              return t6 || o5.slice(1);
            });
          });
        }(t3, void 0 === o3 ? {} : o3);
        return i2.call(this, n3);
      };
    };
  });
})(localizedFormat$1);
const localizedFormat = localizedFormat$1.exports;
var es_ES$6 = { exports: {} };
var es_ES$5 = {};
var interopRequireDefault = { exports: {} };
(function(module) {
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  module.exports = _interopRequireDefault2, module.exports.__esModule = true, module.exports["default"] = module.exports;
})(interopRequireDefault);
var es_ES$4 = {};
Object.defineProperty(es_ES$4, "__esModule", {
  value: true
});
es_ES$4.default = void 0;
var _default$5 = {
  items_per_page: "/ p\xE1gina",
  jump_to: "Ir a",
  jump_to_confirm: "confirmar",
  page: "P\xE1gina",
  prev_page: "P\xE1gina anterior",
  next_page: "P\xE1gina siguiente",
  prev_5: "5 p\xE1ginas previas",
  next_5: "5 p\xE1ginas siguientes",
  prev_3: "3 p\xE1ginas previas",
  next_3: "3 p\xE1ginas siguientes",
  page_size: "tama\xF1o de p\xE1gina"
};
es_ES$4.default = _default$5;
var es_ES$3 = {};
var es_ES$2 = {};
var es_ES$1 = {};
Object.defineProperty(es_ES$1, "__esModule", {
  value: true
});
es_ES$1.default = void 0;
var locale$2 = {
  locale: "es_ES",
  today: "Hoy",
  now: "Ahora",
  backToToday: "Volver a hoy",
  ok: "Aceptar",
  clear: "Limpiar",
  month: "Mes",
  year: "A\xF1o",
  timeSelect: "Seleccionar hora",
  dateSelect: "Seleccionar fecha",
  monthSelect: "Elegir un mes",
  yearSelect: "Elegir un a\xF1o",
  decadeSelect: "Elegir una d\xE9cada",
  yearFormat: "YYYY",
  dateFormat: "D/M/YYYY",
  dayFormat: "D",
  dateTimeFormat: "D/M/YYYY HH:mm:ss",
  monthBeforeYear: true,
  previousMonth: "Mes anterior (PageUp)",
  nextMonth: "Mes siguiente (PageDown)",
  previousYear: "A\xF1o anterior (Control + left)",
  nextYear: "A\xF1o siguiente (Control + right)",
  previousDecade: "D\xE9cada anterior",
  nextDecade: "D\xE9cada siguiente",
  previousCentury: "Siglo anterior",
  nextCentury: "Siglo siguiente"
};
var _default$4 = locale$2;
es_ES$1.default = _default$4;
var es_ES = {};
Object.defineProperty(es_ES, "__esModule", {
  value: true
});
es_ES.default = void 0;
const locale$1 = {
  placeholder: "Seleccionar hora"
};
var _default$3 = locale$1;
es_ES.default = _default$3;
var _interopRequireDefault$2 = interopRequireDefault.exports.default;
Object.defineProperty(es_ES$2, "__esModule", {
  value: true
});
es_ES$2.default = void 0;
var _es_ES$2 = _interopRequireDefault$2(es_ES$1);
var _es_ES2$1 = _interopRequireDefault$2(es_ES);
const locale = {
  lang: Object.assign({
    placeholder: "Seleccionar fecha",
    rangePlaceholder: ["Fecha inicial", "Fecha final"]
  }, _es_ES$2.default),
  timePickerLocale: Object.assign({}, _es_ES2$1.default)
};
var _default$2 = locale;
es_ES$2.default = _default$2;
var _interopRequireDefault$1 = interopRequireDefault.exports.default;
Object.defineProperty(es_ES$3, "__esModule", {
  value: true
});
es_ES$3.default = void 0;
var _es_ES$1 = _interopRequireDefault$1(es_ES$2);
var _default$1 = _es_ES$1.default;
es_ES$3.default = _default$1;
var _interopRequireDefault = interopRequireDefault.exports.default;
Object.defineProperty(es_ES$5, "__esModule", {
  value: true
});
es_ES$5.default = void 0;
var _es_ES = _interopRequireDefault(es_ES$4);
var _es_ES2 = _interopRequireDefault(es_ES$3);
var _es_ES3 = _interopRequireDefault(es_ES$2);
var _es_ES4 = _interopRequireDefault(es_ES);
const typeTemplate = "${label} no es un ${type} v\xE1lido";
const localeValues = {
  locale: "es",
  Pagination: _es_ES.default,
  DatePicker: _es_ES3.default,
  TimePicker: _es_ES4.default,
  Calendar: _es_ES2.default,
  global: {
    placeholder: "Seleccione"
  },
  Table: {
    filterTitle: "Filtrar men\xFA",
    filterConfirm: "Aceptar",
    filterReset: "Reiniciar",
    filterEmptyText: "Sin filtros",
    filterCheckall: "Seleccionar todo",
    filterSearchPlaceholder: "Buscar en filtros",
    emptyText: "Sin datos",
    selectAll: "Seleccionar todo",
    selectInvert: "Invertir selecci\xF3n",
    selectNone: "Vac\xEDe todo",
    selectionAll: "Seleccionar todos los datos",
    sortTitle: "Ordenar",
    expand: "Expandir fila",
    collapse: "Colapsar fila",
    triggerDesc: "Click para ordenar en orden descendente",
    triggerAsc: "Click para ordenar en orden ascendente",
    cancelSort: "Click para cancelar ordenamiento"
  },
  Modal: {
    okText: "Aceptar",
    cancelText: "Cancelar",
    justOkText: "Aceptar"
  },
  Popconfirm: {
    okText: "Aceptar",
    cancelText: "Cancelar"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Buscar aqu\xED",
    itemUnit: "elemento",
    itemsUnit: "elementos",
    remove: "Eliminar",
    selectCurrent: "Seleccionar p\xE1gina actual",
    removeCurrent: "Remover p\xE1gina actual",
    selectAll: "Seleccionar todos los datos",
    removeAll: "Eliminar todos los datos",
    selectInvert: "Invertir p\xE1gina actual"
  },
  Upload: {
    uploading: "Subiendo...",
    removeFile: "Eliminar archivo",
    uploadError: "Error al subir el archivo",
    previewFile: "Vista previa",
    downloadFile: "Descargar archivo"
  },
  Empty: {
    description: "No hay datos"
  },
  Icon: {
    icon: "\xEDcono"
  },
  Text: {
    edit: "Editar",
    copy: "Copiar",
    copied: "Copiado",
    expand: "Expandir"
  },
  PageHeader: {
    back: "Volver"
  },
  Form: {
    optional: "(opcional)",
    defaultValidateMessages: {
      default: "Error de validaci\xF3n del campo ${label}",
      required: "Por favor ingresar ${label}",
      enum: "${label} debe ser uno de [${enum}]",
      whitespace: "${label} no puede ser un car\xE1cter en blanco",
      date: {
        format: "El formato de fecha de ${label} es inv\xE1lido",
        parse: "${label} no se puede convertir a una fecha",
        invalid: "${label} es una fecha inv\xE1lida"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label} debe tener ${len} caracteres",
        min: "${label} debe tener al menos ${min} caracteres",
        max: "${label} debe tener hasta ${max} caracteres",
        range: "${label} debe tener entre ${min}-${max} caracteres"
      },
      number: {
        len: "${label} debe ser igual a ${len}",
        min: "${label} valor m\xEDnimo es ${min}",
        max: "${label} valor m\xE1ximo es ${max}",
        range: "${label} debe estar entre ${min}-${max}"
      },
      array: {
        len: "Debe ser ${len} ${label}",
        min: "Al menos ${min} ${label}",
        max: "A lo mucho ${max} ${label}",
        range: "El monto de ${label} debe estar entre ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} no coincide con el patr\xF3n ${pattern}"
      }
    }
  },
  Image: {
    preview: "Previsualizaci\xF3n"
  }
};
var _default = localeValues;
es_ES$5.default = _default;
(function(module) {
  module.exports = es_ES$5;
})(es_ES$6);
const esES = /* @__PURE__ */ getDefaultExportFromCjs(es_ES$6.exports);
dayjs.locale(dateLocalizer);
dayjs.extend(relativeTime);
dayjs.extend(localizedFormat);
const AppTheme = ({
  children
}) => {
  return /* @__PURE__ */ jsx(ConfigProvider$1, {
    locale: esES,
    theme: customTheme,
    children
  });
};
const customTheme = {
  token: {
    colorPrimary: "#2274a5",
    colorWarning: "#e59500",
    colorInfo: "#001529",
    colorInfoBg: "#001529",
    colorMenuBg: "#dc0d15",
    borderRadius: 9,
    wireframe: true
  }
};
const ReactToastify = "";
const DemoApp = () => {
  return /* @__PURE__ */ jsx(FeedBackProvider, {
    children: /* @__PURE__ */ jsxs(AppTheme, {
      children: [/* @__PURE__ */ jsx(k, {
        autoClose: 3e3,
        hideProgressBar: true,
        newestOnTop: false,
        closeOnClick: true,
        rtl: false,
        pauseOnFocusLoss: false,
        draggable: true,
        pauseOnHover: false
      }), /* @__PURE__ */ jsx(FirebaseNotification, {}), /* @__PURE__ */ jsx(AppRouter, {})]
    })
  });
};
const style = "";
const index = "";
client.createRoot(document.getElementById("root")).render(/* @__PURE__ */ jsx(React.StrictMode, {
  children: /* @__PURE__ */ jsx(Provider$1, {
    store,
    children: /* @__PURE__ */ jsx(BrowserRouter, {
      children: /* @__PURE__ */ jsx(DemoApp, {})
    })
  })
}));
